[
  {
    "function_name": "try_release_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5568-5608",
    "snippet": "int try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 5607
        },
        "resolved": true,
        "details": {
          "function_name": "try_release_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5568-5608",
          "snippet": "int try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 5603
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_TREE_REF",
            "&eb->bflags"
          ],
          "line": 5602
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_under_io",
          "args": [
            "eb"
          ],
          "line": 5591
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_under_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4535-4540",
          "snippet": "int extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 5591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 5590
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!eb"
          ],
          "line": 5583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 5577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}"
  },
  {
    "function_name": "memmove_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5521-5566",
    "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_pages",
          "args": [
            "dst->pages[dst_i]",
            "dst->pages[src_i]",
            "dst_off_in_page - cur + 1",
            "src_off_in_page - cur + 1",
            "cur"
          ],
          "line": 5558
        },
        "resolved": true,
        "details": {
          "function_name": "copy_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5455-5475",
          "snippet": "static void copy_pages(struct page *dst_page, struct page *src_page,\n\t\t       unsigned long dst_off, unsigned long src_off,\n\t\t       unsigned long len)\n{\n\tchar *dst_kaddr = page_address(dst_page);\n\tchar *src_kaddr;\n\tint must_memmove = 0;\n\n\tif (dst_page != src_page) {\n\t\tsrc_kaddr = page_address(src_page);\n\t} else {\n\t\tsrc_kaddr = dst_kaddr;\n\t\tif (areas_overlap(src_off, dst_off, len))\n\t\t\tmust_memmove = 1;\n\t}\n\n\tif (must_memmove)\n\t\tmemmove(dst_kaddr + dst_off, src_kaddr + src_off, len);\n\telse\n\t\tmemcpy(dst_kaddr + dst_off, src_kaddr + src_off, len);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void copy_pages(struct page *dst_page, struct page *src_page,\n\t\t       unsigned long dst_off, unsigned long src_off,\n\t\t       unsigned long len)\n{\n\tchar *dst_kaddr = page_address(dst_page);\n\tchar *src_kaddr;\n\tint must_memmove = 0;\n\n\tif (dst_page != src_page) {\n\t\tsrc_kaddr = page_address(src_page);\n\t} else {\n\t\tsrc_kaddr = dst_kaddr;\n\t\tif (areas_overlap(src_off, dst_off, len))\n\t\t\tmust_memmove = 1;\n\t}\n\n\tif (must_memmove)\n\t\tmemmove(dst_kaddr + dst_off, src_kaddr + src_off, len);\n\telse\n\t\tmemcpy(dst_kaddr + dst_off, src_kaddr + src_off, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "cur",
            "dst_off_in_page + 1"
          ],
          "line": 5557
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "len",
            "src_off_in_page + 1"
          ],
          "line": 5556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy_extent_buffer",
          "args": [
            "dst",
            "dst_offset",
            "src_offset",
            "len"
          ],
          "line": 5544
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5477-5519",
          "snippet": "void memcpy_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\n\twhile (len > 0) {\n\t\tdst_off_in_page = (start_offset + dst_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tdst_i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_offset) >> PAGE_CACHE_SHIFT;\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE -\n\t\t\t\t\t       src_off_in_page));\n\t\tcur = min_t(unsigned long, cur,\n\t\t\t(unsigned long)(PAGE_CACHE_SIZE - dst_off_in_page));\n\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page, src_off_in_page, cur);\n\n\t\tsrc_offset += cur;\n\t\tdst_offset += cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memcpy_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\n\twhile (len > 0) {\n\t\tdst_off_in_page = (start_offset + dst_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tdst_i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_offset) >> PAGE_CACHE_SHIFT;\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE -\n\t\t\t\t\t       src_off_in_page));\n\t\tcur = min_t(unsigned long, cur,\n\t\t\t(unsigned long)(PAGE_CACHE_SIZE - dst_off_in_page));\n\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page, src_off_in_page, cur);\n\n\t\tsrc_offset += cur;\n\t\tdst_offset += cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 5541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\"",
            "dst_offset",
            "len",
            "dst->len"
          ],
          "line": 5539
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 5536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
  },
  {
    "function_name": "memcpy_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5477-5519",
    "snippet": "void memcpy_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\n\twhile (len > 0) {\n\t\tdst_off_in_page = (start_offset + dst_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tdst_i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_offset) >> PAGE_CACHE_SHIFT;\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE -\n\t\t\t\t\t       src_off_in_page));\n\t\tcur = min_t(unsigned long, cur,\n\t\t\t(unsigned long)(PAGE_CACHE_SIZE - dst_off_in_page));\n\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page, src_off_in_page, cur);\n\n\t\tsrc_offset += cur;\n\t\tdst_offset += cur;\n\t\tlen -= cur;\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_pages",
          "args": [
            "dst->pages[dst_i]",
            "dst->pages[src_i]",
            "dst_off_in_page",
            "src_off_in_page",
            "cur"
          ],
          "line": 5512
        },
        "resolved": true,
        "details": {
          "function_name": "copy_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5455-5475",
          "snippet": "static void copy_pages(struct page *dst_page, struct page *src_page,\n\t\t       unsigned long dst_off, unsigned long src_off,\n\t\t       unsigned long len)\n{\n\tchar *dst_kaddr = page_address(dst_page);\n\tchar *src_kaddr;\n\tint must_memmove = 0;\n\n\tif (dst_page != src_page) {\n\t\tsrc_kaddr = page_address(src_page);\n\t} else {\n\t\tsrc_kaddr = dst_kaddr;\n\t\tif (areas_overlap(src_off, dst_off, len))\n\t\t\tmust_memmove = 1;\n\t}\n\n\tif (must_memmove)\n\t\tmemmove(dst_kaddr + dst_off, src_kaddr + src_off, len);\n\telse\n\t\tmemcpy(dst_kaddr + dst_off, src_kaddr + src_off, len);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void copy_pages(struct page *dst_page, struct page *src_page,\n\t\t       unsigned long dst_off, unsigned long src_off,\n\t\t       unsigned long len)\n{\n\tchar *dst_kaddr = page_address(dst_page);\n\tchar *src_kaddr;\n\tint must_memmove = 0;\n\n\tif (dst_page != src_page) {\n\t\tsrc_kaddr = page_address(src_page);\n\t} else {\n\t\tsrc_kaddr = dst_kaddr;\n\t\tif (areas_overlap(src_off, dst_off, len))\n\t\t\tmust_memmove = 1;\n\t}\n\n\tif (must_memmove)\n\t\tmemmove(dst_kaddr + dst_off, src_kaddr + src_off, len);\n\telse\n\t\tmemcpy(dst_kaddr + dst_off, src_kaddr + src_off, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "cur",
            "(unsigned long)(PAGE_CACHE_SIZE - dst_off_in_page)"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "(unsigned long)(PAGE_CACHE_SIZE -\n\t\t\t\t\t       src_off_in_page)"
          ],
          "line": 5507
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 5495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\"",
            "dst_offset",
            "len",
            "dst->len"
          ],
          "line": 5493
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 5490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memcpy_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\n\twhile (len > 0) {\n\t\tdst_off_in_page = (start_offset + dst_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tdst_i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_offset) >> PAGE_CACHE_SHIFT;\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE -\n\t\t\t\t\t       src_off_in_page));\n\t\tcur = min_t(unsigned long, cur,\n\t\t\t(unsigned long)(PAGE_CACHE_SIZE - dst_off_in_page));\n\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page, src_off_in_page, cur);\n\n\t\tsrc_offset += cur;\n\t\tdst_offset += cur;\n\t\tlen -= cur;\n\t}\n}"
  },
  {
    "function_name": "copy_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5455-5475",
    "snippet": "static void copy_pages(struct page *dst_page, struct page *src_page,\n\t\t       unsigned long dst_off, unsigned long src_off,\n\t\t       unsigned long len)\n{\n\tchar *dst_kaddr = page_address(dst_page);\n\tchar *src_kaddr;\n\tint must_memmove = 0;\n\n\tif (dst_page != src_page) {\n\t\tsrc_kaddr = page_address(src_page);\n\t} else {\n\t\tsrc_kaddr = dst_kaddr;\n\t\tif (areas_overlap(src_off, dst_off, len))\n\t\t\tmust_memmove = 1;\n\t}\n\n\tif (must_memmove)\n\t\tmemmove(dst_kaddr + dst_off, src_kaddr + src_off, len);\n\telse\n\t\tmemcpy(dst_kaddr + dst_off, src_kaddr + src_off, len);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_kaddr + dst_off",
            "src_kaddr + src_off",
            "len"
          ],
          "line": 5474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dst_kaddr + dst_off",
            "src_kaddr + src_off",
            "len"
          ],
          "line": 5472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "areas_overlap",
          "args": [
            "src_off",
            "dst_off",
            "len"
          ],
          "line": 5467
        },
        "resolved": true,
        "details": {
          "function_name": "areas_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5449-5453",
          "snippet": "static inline bool areas_overlap(unsigned long src, unsigned long dst, unsigned long len)\n{\n\tunsigned long distance = (src > dst) ? src - dst : dst - src;\n\treturn distance < len;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool areas_overlap(unsigned long src, unsigned long dst, unsigned long len)\n{\n\tunsigned long distance = (src > dst) ? src - dst : dst - src;\n\treturn distance < len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "src_page"
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "dst_page"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void copy_pages(struct page *dst_page, struct page *src_page,\n\t\t       unsigned long dst_off, unsigned long src_off,\n\t\t       unsigned long len)\n{\n\tchar *dst_kaddr = page_address(dst_page);\n\tchar *src_kaddr;\n\tint must_memmove = 0;\n\n\tif (dst_page != src_page) {\n\t\tsrc_kaddr = page_address(src_page);\n\t} else {\n\t\tsrc_kaddr = dst_kaddr;\n\t\tif (areas_overlap(src_off, dst_off, len))\n\t\t\tmust_memmove = 1;\n\t}\n\n\tif (must_memmove)\n\t\tmemmove(dst_kaddr + dst_off, src_kaddr + src_off, len);\n\telse\n\t\tmemcpy(dst_kaddr + dst_off, src_kaddr + src_off, len);\n}"
  },
  {
    "function_name": "areas_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5449-5453",
    "snippet": "static inline bool areas_overlap(unsigned long src, unsigned long dst, unsigned long len)\n{\n\tunsigned long distance = (src > dst) ? src - dst : dst - src;\n\treturn distance < len;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool areas_overlap(unsigned long src, unsigned long dst, unsigned long len)\n{\n\tunsigned long distance = (src > dst) ? src - dst : dst - src;\n\treturn distance < len;\n}"
  },
  {
    "function_name": "copy_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5416-5447",
    "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "src",
            "kaddr + offset",
            "src_offset",
            "cur"
          ],
          "line": 5440
        },
        "resolved": true,
        "details": {
          "function_name": "read_extent_buffer_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5245-5280",
          "snippet": "int read_extent_buffer_to_user(struct extent_buffer *eb, void __user *dstv,\n\t\t\tunsigned long start,\n\t\t\tunsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar __user *dst = (char __user *)dstv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\t\tkaddr = page_address(page);\n\t\tif (copy_to_user(dst, kaddr + offset, cur)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint read_extent_buffer_to_user(struct extent_buffer *eb, void __user *dstv,\n\t\t\tunsigned long start,\n\t\t\tunsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar __user *dst = (char __user *)dstv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\t\tkaddr = page_address(page);\n\t\tif (copy_to_user(dst, kaddr + offset, cur)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 5439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "(unsigned long)(PAGE_CACHE_SIZE - offset)"
          ],
          "line": 5437
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "src->len != dst_len"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "memset_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5387-5414",
    "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + offset",
            "c",
            "cur"
          ],
          "line": 5408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 5407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 5406
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start + len > eb->start + eb->len"
          ],
          "line": 5398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start > eb->len"
          ],
          "line": 5397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "write_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5356-5385",
    "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr + offset",
            "src",
            "cur"
          ],
          "line": 5378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 5377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 5376
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 5374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 5374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start + len > eb->start + eb->len"
          ],
          "line": 5368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start > eb->len"
          ],
          "line": 5367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "memcmp_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5320-5354",
    "snippet": "int memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ptr",
            "kaddr + offset",
            "cur"
          ],
          "line": 5344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 5343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "(PAGE_CACHE_SIZE - offset)"
          ],
          "line": 5341
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start + len > eb->start + eb->len"
          ],
          "line": 5334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start > eb->len"
          ],
          "line": 5333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "map_private_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5282-5318",
    "snippet": "int map_private_extent_buffer(struct extent_buffer *eb, unsigned long start,\n\t\t\t       unsigned long min_len, char **map,\n\t\t\t       unsigned long *map_start,\n\t\t\t       unsigned long *map_len)\n{\n\tsize_t offset = start & (PAGE_CACHE_SIZE - 1);\n\tchar *kaddr;\n\tstruct page *p;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tunsigned long end_i = (start_offset + start + min_len - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tif (i != end_i)\n\t\treturn -EINVAL;\n\n\tif (i == 0) {\n\t\toffset = start_offset;\n\t\t*map_start = 0;\n\t} else {\n\t\toffset = 0;\n\t\t*map_start = ((u64)i << PAGE_CACHE_SHIFT) - start_offset;\n\t}\n\n\tif (start + min_len > eb->len) {\n\t\tWARN(1, KERN_ERR \"btrfs bad mapping eb start %llu len %lu, \"\n\t\t       \"wanted %lu %lu\\n\",\n\t\t       eb->start, eb->len, start, min_len);\n\t\treturn -EINVAL;\n\t}\n\n\tp = eb->pages[i];\n\tkaddr = page_address(p);\n\t*map = kaddr + offset;\n\t*map_len = PAGE_CACHE_SIZE - offset;\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p"
          ],
          "line": 5314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"btrfs bad mapping eb start %llu len %lu, \"\n\t\t       \"wanted %lu %lu\\n\"",
            "eb->start",
            "eb->len",
            "start",
            "min_len"
          ],
          "line": 5307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint map_private_extent_buffer(struct extent_buffer *eb, unsigned long start,\n\t\t\t       unsigned long min_len, char **map,\n\t\t\t       unsigned long *map_start,\n\t\t\t       unsigned long *map_len)\n{\n\tsize_t offset = start & (PAGE_CACHE_SIZE - 1);\n\tchar *kaddr;\n\tstruct page *p;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tunsigned long end_i = (start_offset + start + min_len - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tif (i != end_i)\n\t\treturn -EINVAL;\n\n\tif (i == 0) {\n\t\toffset = start_offset;\n\t\t*map_start = 0;\n\t} else {\n\t\toffset = 0;\n\t\t*map_start = ((u64)i << PAGE_CACHE_SHIFT) - start_offset;\n\t}\n\n\tif (start + min_len > eb->len) {\n\t\tWARN(1, KERN_ERR \"btrfs bad mapping eb start %llu len %lu, \"\n\t\t       \"wanted %lu %lu\\n\",\n\t\t       eb->start, eb->len, start, min_len);\n\t\treturn -EINVAL;\n\t}\n\n\tp = eb->pages[i];\n\tkaddr = page_address(p);\n\t*map = kaddr + offset;\n\t*map_len = PAGE_CACHE_SIZE - offset;\n\treturn 0;\n}"
  },
  {
    "function_name": "read_extent_buffer_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5245-5280",
    "snippet": "int read_extent_buffer_to_user(struct extent_buffer *eb, void __user *dstv,\n\t\t\tunsigned long start,\n\t\t\tunsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar __user *dst = (char __user *)dstv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\t\tkaddr = page_address(page);\n\t\tif (copy_to_user(dst, kaddr + offset, cur)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "dst",
            "kaddr + offset",
            "cur"
          ],
          "line": 5268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 5267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "(PAGE_CACHE_SIZE - offset)"
          ],
          "line": 5266
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start + len > eb->start + eb->len"
          ],
          "line": 5259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start > eb->len"
          ],
          "line": 5258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint read_extent_buffer_to_user(struct extent_buffer *eb, void __user *dstv,\n\t\t\tunsigned long start,\n\t\t\tunsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar __user *dst = (char __user *)dstv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\t\tkaddr = page_address(page);\n\t\tif (copy_to_user(dst, kaddr + offset, cur)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "read_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5214-5243",
    "snippet": "void read_extent_buffer(struct extent_buffer *eb, void *dstv,\n\t\t\tunsigned long start,\n\t\t\tunsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\t\tkaddr = page_address(page);\n\t\tmemcpy(dst, kaddr + offset, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "kaddr + offset",
            "cur"
          ],
          "line": 5236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 5235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "(PAGE_CACHE_SIZE - offset)"
          ],
          "line": 5234
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start + len > eb->start + eb->len"
          ],
          "line": 5227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start > eb->len"
          ],
          "line": 5226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid read_extent_buffer(struct extent_buffer *eb, void *dstv,\n\t\t\tunsigned long start,\n\t\t\tunsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *dst = (char *)dstv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\t\tkaddr = page_address(page);\n\t\tmemcpy(dst, kaddr + offset, cur);\n\n\t\tdst += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
  },
  {
    "function_name": "read_extent_buffer_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5118-5212",
    "snippet": "int read_extent_buffer_pages(struct extent_io_tree *tree,\n\t\t\t     struct extent_buffer *eb, u64 start, int wait,\n\t\t\t     get_extent_t *get_extent, int mirror_num)\n{\n\tunsigned long i;\n\tunsigned long start_i;\n\tstruct page *page;\n\tint err;\n\tint ret = 0;\n\tint locked_pages = 0;\n\tint all_uptodate = 1;\n\tunsigned long num_pages;\n\tunsigned long num_reads = 0;\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\n\tif (test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags))\n\t\treturn 0;\n\n\tif (start) {\n\t\tWARN_ON(start < eb->start);\n\t\tstart_i = (start >> PAGE_CACHE_SHIFT) -\n\t\t\t(eb->start >> PAGE_CACHE_SHIFT);\n\t} else {\n\t\tstart_i = 0;\n\t}\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (wait == WAIT_NONE) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto unlock_exit;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\t\tlocked_pages++;\n\t\tif (!PageUptodate(page)) {\n\t\t\tnum_reads++;\n\t\t\tall_uptodate = 0;\n\t\t}\n\t}\n\tif (all_uptodate) {\n\t\tif (start_i == 0)\n\t\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\t\tgoto unlock_exit;\n\t}\n\n\tclear_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = 0;\n\tatomic_set(&eb->io_pages, num_reads);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageUptodate(page)) {\n\t\t\tClearPageError(page);\n\t\t\terr = __extent_read_full_page(tree, page,\n\t\t\t\t\t\t      get_extent, &bio,\n\t\t\t\t\t\t      mirror_num, &bio_flags,\n\t\t\t\t\t\t      READ | REQ_META);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\terr = submit_one_bio(READ | REQ_META, bio, mirror_num,\n\t\t\t\t     bio_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ret || wait != WAIT_COMPLETE)\n\t\treturn ret;\n\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\nunlock_exit:\n\ti = start_i;\n\twhile (locked_pages > 0) {\n\t\tpage = eb->pages[i];\n\t\ti++;\n\t\tunlock_page(page);\n\t\tlocked_pages--;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 5208
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 5197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_locked",
          "args": [
            "page"
          ],
          "line": 5196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_one_bio",
          "args": [
            "READ | REQ_META",
            "bio",
            "mirror_num",
            "bio_flags"
          ],
          "line": 5185
        },
        "resolved": true,
        "details": {
          "function_name": "submit_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2749-2774",
          "snippet": "static int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__extent_read_full_page",
          "args": [
            "tree",
            "page",
            "get_extent",
            "&bio",
            "mirror_num",
            "&bio_flags",
            "READ | REQ_META"
          ],
          "line": 5173
        },
        "resolved": true,
        "details": {
          "function_name": "__extent_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3148-3173",
          "snippet": "static int __extent_read_full_page(struct extent_io_tree *tree,\n\t\t\t\t   struct page *page,\n\t\t\t\t   get_extent_t *get_extent,\n\t\t\t\t   struct bio **bio, int mirror_num,\n\t\t\t\t   unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_extent(inode, start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tret = __do_readpage(tree, page, get_extent, NULL, bio, mirror_num,\n\t\t\t    bio_flags, rw);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __extent_read_full_page(struct extent_io_tree *tree,\n\t\t\t\t   struct page *page,\n\t\t\t\t   get_extent_t *get_extent,\n\t\t\t\t   struct bio **bio, int mirror_num,\n\t\t\t\t   unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_extent(inode, start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tret = __do_readpage(tree, page, get_extent, NULL, bio, mirror_num,\n\t\t\t    bio_flags, rw);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 5172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 5171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->io_pages",
            "num_reads"
          ],
          "line": 5168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXTENT_BUFFER_READ_ERR",
            "&eb->bflags"
          ],
          "line": 5166
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_UPTODATE",
            "&eb->bflags"
          ],
          "line": 5162
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 5155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 5149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 5145
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start < eb->start"
          ],
          "line": 5138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_UPTODATE",
            "&eb->bflags"
          ],
          "line": 5134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint read_extent_buffer_pages(struct extent_io_tree *tree,\n\t\t\t     struct extent_buffer *eb, u64 start, int wait,\n\t\t\t     get_extent_t *get_extent, int mirror_num)\n{\n\tunsigned long i;\n\tunsigned long start_i;\n\tstruct page *page;\n\tint err;\n\tint ret = 0;\n\tint locked_pages = 0;\n\tint all_uptodate = 1;\n\tunsigned long num_pages;\n\tunsigned long num_reads = 0;\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\n\tif (test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags))\n\t\treturn 0;\n\n\tif (start) {\n\t\tWARN_ON(start < eb->start);\n\t\tstart_i = (start >> PAGE_CACHE_SHIFT) -\n\t\t\t(eb->start >> PAGE_CACHE_SHIFT);\n\t} else {\n\t\tstart_i = 0;\n\t}\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (wait == WAIT_NONE) {\n\t\t\tif (!trylock_page(page))\n\t\t\t\tgoto unlock_exit;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\t\tlocked_pages++;\n\t\tif (!PageUptodate(page)) {\n\t\t\tnum_reads++;\n\t\t\tall_uptodate = 0;\n\t\t}\n\t}\n\tif (all_uptodate) {\n\t\tif (start_i == 0)\n\t\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\t\tgoto unlock_exit;\n\t}\n\n\tclear_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);\n\teb->read_mirror = 0;\n\tatomic_set(&eb->io_pages, num_reads);\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageUptodate(page)) {\n\t\t\tClearPageError(page);\n\t\t\terr = __extent_read_full_page(tree, page,\n\t\t\t\t\t\t      get_extent, &bio,\n\t\t\t\t\t\t      mirror_num, &bio_flags,\n\t\t\t\t\t\t      READ | REQ_META);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\terr = submit_one_bio(READ | REQ_META, bio, mirror_num,\n\t\t\t\t     bio_flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ret || wait != WAIT_COMPLETE)\n\t\treturn ret;\n\n\tfor (i = start_i; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\twait_on_page_locked(page);\n\t\tif (!PageUptodate(page))\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n\nunlock_exit:\n\ti = start_i;\n\twhile (locked_pages > 0) {\n\t\tpage = eb->pages[i];\n\t\ti++;\n\t\tunlock_page(page);\n\t\tlocked_pages--;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "extent_buffer_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5113-5116",
    "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_UPTODATE",
            "&eb->bflags"
          ],
          "line": 5115
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
  },
  {
    "function_name": "set_extent_buffer_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5098-5111",
    "snippet": "int set_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tSetPageUptodate(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 5108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 5105
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_UPTODATE",
            "&eb->bflags"
          ],
          "line": 5104
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tSetPageUptodate(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_extent_buffer_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5082-5096",
    "snippet": "int clear_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tclear_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (page)\n\t\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 5093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 5089
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXTENT_BUFFER_UPTODATE",
            "&eb->bflags"
          ],
          "line": 5088
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint clear_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tclear_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (page)\n\t\t\tClearPageUptodate(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_extent_buffer_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5063-5080",
    "snippet": "int set_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tint was_dirty = 0;\n\n\tcheck_buffer_tree_ref(eb);\n\n\twas_dirty = test_and_set_bit(EXTENT_BUFFER_DIRTY, &eb->bflags);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n\tWARN_ON(!test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags));\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tset_page_dirty(eb->pages[i]);\n\treturn was_dirty;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "eb->pages[i]"
          ],
          "line": 5078
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9538-9541",
          "snippet": "static int btrfs_set_page_dirty(struct page *page)\n{\n\treturn __set_page_dirty_nobuffers(page);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_set_page_dirty(struct page *page)\n{\n\treturn __set_page_dirty_nobuffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)"
          ],
          "line": 5075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_TREE_REF",
            "&eb->bflags"
          ],
          "line": 5075
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->refs) == 0"
          ],
          "line": 5074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 5074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 5073
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "EXTENT_BUFFER_DIRTY",
            "&eb->bflags"
          ],
          "line": 5071
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_buffer_tree_ref",
          "args": [
            "eb"
          ],
          "line": 5069
        },
        "resolved": true,
        "details": {
          "function_name": "check_buffer_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4712-4743",
          "snippet": "static void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tint was_dirty = 0;\n\n\tcheck_buffer_tree_ref(eb);\n\n\twas_dirty = test_and_set_bit(EXTENT_BUFFER_DIRTY, &eb->bflags);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n\tWARN_ON(!test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags));\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tset_page_dirty(eb->pages[i]);\n\treturn was_dirty;\n}"
  },
  {
    "function_name": "clear_extent_buffer_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5033-5061",
    "snippet": "void clear_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tstruct page *page;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageDirty(page))\n\t\t\tcontinue;\n\n\t\tlock_page(page);\n\t\tWARN_ON(!PagePrivate(page));\n\n\t\tclear_page_dirty_for_io(page);\n\t\tspin_lock_irq(&page->mapping->tree_lock);\n\t\tif (!PageDirty(page)) {\n\t\t\tradix_tree_tag_clear(&page->mapping->page_tree,\n\t\t\t\t\t\tpage_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\t}\n\t\tspin_unlock_irq(&page->mapping->tree_lock);\n\t\tClearPageError(page);\n\t\tunlock_page(page);\n\t}\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->refs) == 0"
          ],
          "line": 5060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 5060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 5058
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 5057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&page->mapping->tree_lock"
          ],
          "line": 5056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_tag_clear",
          "args": [
            "&page->mapping->page_tree",
            "page_index(page)",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 5052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_index",
          "args": [
            "page"
          ],
          "line": 5053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 5051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&page->mapping->tree_lock"
          ],
          "line": 5050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 5049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PagePrivate(page)"
          ],
          "line": 5047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 5047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 5043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid clear_extent_buffer_dirty(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tunsigned long num_pages;\n\tstruct page *page;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tif (!PageDirty(page))\n\t\t\tcontinue;\n\n\t\tlock_page(page);\n\t\tWARN_ON(!PagePrivate(page));\n\n\t\tclear_page_dirty_for_io(page);\n\t\tspin_lock_irq(&page->mapping->tree_lock);\n\t\tif (!PageDirty(page)) {\n\t\t\tradix_tree_tag_clear(&page->mapping->page_tree,\n\t\t\t\t\t\tpage_index(page),\n\t\t\t\t\t\tPAGECACHE_TAG_DIRTY);\n\t\t}\n\t\tspin_unlock_irq(&page->mapping->tree_lock);\n\t\tClearPageError(page);\n\t\tunlock_page(page);\n\t}\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n}"
  },
  {
    "function_name": "free_extent_buffer_stale",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "5019-5031",
    "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 5030
        },
        "resolved": true,
        "details": {
          "function_name": "try_release_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5568-5608",
          "snippet": "int try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->refs"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_TREE_REF",
            "&eb->bflags"
          ],
          "line": 5028
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_under_io",
          "args": [
            "eb"
          ],
          "line": 5027
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_under_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4535-4540",
          "snippet": "int extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 5027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_STALE",
            "&eb->bflags"
          ],
          "line": 5025
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 5024
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
  },
  {
    "function_name": "free_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4985-5017",
    "snippet": "void free_extent_buffer(struct extent_buffer *eb)\n{\n\tint refs;\n\tint old;\n\tif (!eb)\n\t\treturn;\n\n\twhile (1) {\n\t\trefs = atomic_read(&eb->refs);\n\t\tif (refs <= 3)\n\t\t\tbreak;\n\t\told = atomic_cmpxchg(&eb->refs, refs, refs - 1);\n\t\tif (old == refs)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) == 2 &&\n\t    test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\n\tif (atomic_read(&eb->refs) == 2 &&\n\t    test_bit(EXTENT_BUFFER_STALE, &eb->bflags) &&\n\t    !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\n\t/*\n\t * I know this is terrible, but it's temporary until we stop tracking\n\t * the uptodate bits and such for the extent buffers.\n\t */\n\trelease_extent_buffer(eb);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "try_release_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5568-5608",
          "snippet": "int try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint try_release_extent_buffer(struct page *page)\n{\n\tstruct extent_buffer *eb;\n\n\t/*\n\t * We need to make sure noboody is attaching this page to an eb right\n\t * now.\n\t */\n\tspin_lock(&page->mapping->private_lock);\n\tif (!PagePrivate(page)) {\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 1;\n\t}\n\n\teb = (struct extent_buffer *)page->private;\n\tBUG_ON(!eb);\n\n\t/*\n\t * This is a little awful but should be ok, we need to make sure that\n\t * the eb doesn't disappear out from under us while we're looking at\n\t * this page.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) != 1 || extent_buffer_under_io(eb)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\tspin_unlock(&page->mapping->private_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&page->mapping->private_lock);\n\n\t/*\n\t * If tree ref isn't set then we know the ref on this eb is a real ref,\n\t * so just return, this page will likely be freed soon anyway.\n\t */\n\tif (!test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags)) {\n\t\tspin_unlock(&eb->refs_lock);\n\t\treturn 0;\n\t}\n\n\treturn release_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->refs"
          ],
          "line": 5010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_TREE_REF",
            "&eb->bflags"
          ],
          "line": 5009
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_under_io",
          "args": [
            "eb"
          ],
          "line": 5008
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_under_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4535-4540",
          "snippet": "int extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_STALE",
            "&eb->bflags"
          ],
          "line": 5007
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 5006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&eb->refs"
          ],
          "line": 5004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 5001
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&eb->refs",
            "refs",
            "refs - 1"
          ],
          "line": 4996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nvoid free_extent_buffer(struct extent_buffer *eb)\n{\n\tint refs;\n\tint old;\n\tif (!eb)\n\t\treturn;\n\n\twhile (1) {\n\t\trefs = atomic_read(&eb->refs);\n\t\tif (refs <= 3)\n\t\t\tbreak;\n\t\told = atomic_cmpxchg(&eb->refs, refs, refs - 1);\n\t\tif (old == refs)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&eb->refs_lock);\n\tif (atomic_read(&eb->refs) == 2 &&\n\t    test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\n\tif (atomic_read(&eb->refs) == 2 &&\n\t    test_bit(EXTENT_BUFFER_STALE, &eb->bflags) &&\n\t    !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\n\t/*\n\t * I know this is terrible, but it's temporary until we stop tracking\n\t * the uptodate bits and such for the extent buffers.\n\t */\n\trelease_extent_buffer(eb);\n}"
  },
  {
    "function_name": "release_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4952-4983",
    "snippet": "static int release_extent_buffer(struct extent_buffer *eb)\n{\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n\tif (atomic_dec_and_test(&eb->refs)) {\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags)) {\n\t\t\tstruct btrfs_fs_info *fs_info = eb->fs_info;\n\n\t\t\tspin_unlock(&eb->refs_lock);\n\n\t\t\tspin_lock(&fs_info->buffer_lock);\n\t\t\tradix_tree_delete(&fs_info->buffer_radix,\n\t\t\t\t\t  eb->start >> PAGE_CACHE_SHIFT);\n\t\t\tspin_unlock(&fs_info->buffer_lock);\n\t\t} else {\n\t\t\tspin_unlock(&eb->refs_lock);\n\t\t}\n\n\t\t/* Should be safe to release our pages at this point */\n\t\tbtrfs_release_extent_buffer_page(eb);\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags))) {\n\t\t\t__free_extent_buffer(eb);\n\t\t\treturn 1;\n\t\t}\n#endif\n\t\tcall_rcu(&eb->rcu_head, btrfs_release_extent_buffer_rcu);\n\t\treturn 1;\n\t}\n\tspin_unlock(&eb->refs_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 4980
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&eb->rcu_head",
            "btrfs_release_extent_buffer_rcu"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 4973
        },
        "resolved": true,
        "details": {
          "function_name": "__free_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4529-4533",
          "snippet": "static void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags)"
          ],
          "line": 4972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_DUMMY",
            "&eb->bflags"
          ],
          "line": 4972
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_extent_buffer_page",
          "args": [
            "eb"
          ],
          "line": 4970
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_extent_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4545-4591",
          "snippet": "static void btrfs_release_extent_buffer_page(struct extent_buffer *eb)\n{\n\tunsigned long index;\n\tstruct page *page;\n\tint mapped = !test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\tBUG_ON(extent_buffer_under_io(eb));\n\n\tindex = num_extent_pages(eb->start, eb->len);\n\tif (index == 0)\n\t\treturn;\n\n\tdo {\n\t\tindex--;\n\t\tpage = eb->pages[index];\n\t\tif (page && mapped) {\n\t\t\tspin_lock(&page->mapping->private_lock);\n\t\t\t/*\n\t\t\t * We do this since we'll remove the pages after we've\n\t\t\t * removed the eb from the radix tree, so we could race\n\t\t\t * and have this page now attached to the new eb.  So\n\t\t\t * only clear page_private if it's still connected to\n\t\t\t * this eb.\n\t\t\t */\n\t\t\tif (PagePrivate(page) &&\n\t\t\t    page->private == (unsigned long)eb) {\n\t\t\t\tBUG_ON(test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n\t\t\t\tBUG_ON(PageDirty(page));\n\t\t\t\tBUG_ON(PageWriteback(page));\n\t\t\t\t/*\n\t\t\t\t * We need to make sure we haven't be attached\n\t\t\t\t * to a new eb.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\t/* One for the page private */\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\tspin_unlock(&page->mapping->private_lock);\n\n\t\t}\n\t\tif (page) {\n\t\t\t/* One for when we alloced the page */\n\t\t\tpage_cache_release(page);\n\t\t}\n\t} while (index != 0);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void btrfs_release_extent_buffer_page(struct extent_buffer *eb)\n{\n\tunsigned long index;\n\tstruct page *page;\n\tint mapped = !test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\tBUG_ON(extent_buffer_under_io(eb));\n\n\tindex = num_extent_pages(eb->start, eb->len);\n\tif (index == 0)\n\t\treturn;\n\n\tdo {\n\t\tindex--;\n\t\tpage = eb->pages[index];\n\t\tif (page && mapped) {\n\t\t\tspin_lock(&page->mapping->private_lock);\n\t\t\t/*\n\t\t\t * We do this since we'll remove the pages after we've\n\t\t\t * removed the eb from the radix tree, so we could race\n\t\t\t * and have this page now attached to the new eb.  So\n\t\t\t * only clear page_private if it's still connected to\n\t\t\t * this eb.\n\t\t\t */\n\t\t\tif (PagePrivate(page) &&\n\t\t\t    page->private == (unsigned long)eb) {\n\t\t\t\tBUG_ON(test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n\t\t\t\tBUG_ON(PageDirty(page));\n\t\t\t\tBUG_ON(PageWriteback(page));\n\t\t\t\t/*\n\t\t\t\t * We need to make sure we haven't be attached\n\t\t\t\t * to a new eb.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\t/* One for the page private */\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\tspin_unlock(&page->mapping->private_lock);\n\n\t\t}\n\t\tif (page) {\n\t\t\t/* One for when we alloced the page */\n\t\t\tpage_cache_release(page);\n\t\t}\n\t} while (index != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&fs_info->buffer_radix",
            "eb->start >> PAGE_CACHE_SHIFT"
          ],
          "line": 4962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 4961
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_IN_TREE",
            "&eb->bflags"
          ],
          "line": 4956
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&eb->refs"
          ],
          "line": 4955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_read(&eb->refs) == 0"
          ],
          "line": 4954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 4954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int release_extent_buffer(struct extent_buffer *eb)\n{\n\tWARN_ON(atomic_read(&eb->refs) == 0);\n\tif (atomic_dec_and_test(&eb->refs)) {\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags)) {\n\t\t\tstruct btrfs_fs_info *fs_info = eb->fs_info;\n\n\t\t\tspin_unlock(&eb->refs_lock);\n\n\t\t\tspin_lock(&fs_info->buffer_lock);\n\t\t\tradix_tree_delete(&fs_info->buffer_radix,\n\t\t\t\t\t  eb->start >> PAGE_CACHE_SHIFT);\n\t\t\tspin_unlock(&fs_info->buffer_lock);\n\t\t} else {\n\t\t\tspin_unlock(&eb->refs_lock);\n\t\t}\n\n\t\t/* Should be safe to release our pages at this point */\n\t\tbtrfs_release_extent_buffer_page(eb);\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags))) {\n\t\t\t__free_extent_buffer(eb);\n\t\t\treturn 1;\n\t\t}\n#endif\n\t\tcall_rcu(&eb->rcu_head, btrfs_release_extent_buffer_rcu);\n\t\treturn 1;\n\t}\n\tspin_unlock(&eb->refs_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_release_extent_buffer_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4943-4949",
    "snippet": "static inline void btrfs_release_extent_buffer_rcu(struct rcu_head *head)\n{\n\tstruct extent_buffer *eb =\n\t\t\tcontainer_of(head, struct extent_buffer, rcu_head);\n\n\t__free_extent_buffer(eb);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 4948
        },
        "resolved": true,
        "details": {
          "function_name": "__free_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4529-4533",
          "snippet": "static void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structextent_buffer",
            "rcu_head"
          ],
          "line": 4946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline void btrfs_release_extent_buffer_rcu(struct rcu_head *head)\n{\n\tstruct extent_buffer *eb =\n\t\t\tcontainer_of(head, struct extent_buffer, rcu_head);\n\n\t__free_extent_buffer(eb);\n}"
  },
  {
    "function_name": "alloc_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4826-4941",
    "snippet": "struct extent_buffer *alloc_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 start)\n{\n\tunsigned long len = fs_info->tree_root->nodesize;\n\tunsigned long num_pages = num_extent_pages(start, len);\n\tunsigned long i;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *exists = NULL;\n\tstruct page *p;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tint uptodate = 1;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++, index++) {\n\t\tp = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!p)\n\t\t\tgoto free_eb;\n\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (PagePrivate(p)) {\n\t\t\t/*\n\t\t\t * We could have already allocated an eb for this page\n\t\t\t * and attached one so lets see if we can get a ref on\n\t\t\t * the existing eb, and if we can we know it's good and\n\t\t\t * we can just return that one, else we know we can just\n\t\t\t * overwrite page->private.\n\t\t\t */\n\t\t\texists = (struct extent_buffer *)p->private;\n\t\t\tif (atomic_inc_not_zero(&exists->refs)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tunlock_page(p);\n\t\t\t\tpage_cache_release(p);\n\t\t\t\tmark_extent_buffer_accessed(exists, p);\n\t\t\t\tgoto free_eb;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do this so attach doesn't complain and we need to\n\t\t\t * drop the ref the old guy had.\n\t\t\t */\n\t\t\tClearPagePrivate(p);\n\t\t\tWARN_ON(PageDirty(p));\n\t\t\tpage_cache_release(p);\n\t\t}\n\t\tattach_extent_buffer_page(eb, p);\n\t\tspin_unlock(&mapping->private_lock);\n\t\tWARN_ON(PageDirty(p));\n\t\teb->pages[i] = p;\n\t\tif (!PageUptodate(p))\n\t\t\tuptodate = 0;\n\n\t\t/*\n\t\t * see below about how we avoid a nasty race with release page\n\t\t * and why we unlock later\n\t\t */\n\t}\n\tif (uptodate)\n\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\t/* add one reference for the tree */\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * there is a race where release page may have\n\t * tried to find this extent buffer in the radix\n\t * but failed.  It will tell the VM it is safe to\n\t * reclaim the, and it will clear the page private bit.\n\t * We must make sure to set the page private bit properly\n\t * after the extent buffer is in the radix tree so\n\t * it doesn't get lost\n\t */\n\tSetPageChecked(eb->pages[0]);\n\tfor (i = 1; i < num_pages; i++) {\n\t\tp = eb->pages[i];\n\t\tClearPageChecked(p);\n\t\tunlock_page(p);\n\t}\n\tunlock_page(eb->pages[0]);\n\treturn eb;\n\nfree_eb:\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (eb->pages[i])\n\t\t\tunlock_page(eb->pages[i]);\n\t}\n\n\tWARN_ON(!atomic_dec_and_test(&eb->refs));\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 4939
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_extent_buffer_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4943-4949",
          "snippet": "static inline void btrfs_release_extent_buffer_rcu(struct rcu_head *head)\n{\n\tstruct extent_buffer *eb =\n\t\t\tcontainer_of(head, struct extent_buffer, rcu_head);\n\n\t__free_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline void btrfs_release_extent_buffer_rcu(struct rcu_head *head)\n{\n\tstruct extent_buffer *eb =\n\t\t\tcontainer_of(head, struct extent_buffer, rcu_head);\n\n\t__free_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!atomic_dec_and_test(&eb->refs)"
          ],
          "line": 4938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&eb->refs"
          ],
          "line": 4938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "eb->pages[i]"
          ],
          "line": 4935
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageChecked",
          "args": [
            "p"
          ],
          "line": 4926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "eb->pages[0]"
          ],
          "line": 4923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_IN_TREE",
            "&eb->bflags"
          ],
          "line": 4912
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_buffer_tree_ref",
          "args": [
            "eb"
          ],
          "line": 4911
        },
        "resolved": true,
        "details": {
          "function_name": "check_buffer_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4712-4743",
          "snippet": "static void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_extent_buffer",
          "args": [
            "fs_info",
            "start"
          ],
          "line": 4904
        },
        "resolved": true,
        "details": {
          "function_name": "find_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4761-4777",
          "snippet": "struct extent_buffer *find_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start)\n{\n\tstruct extent_buffer *eb;\n\n\trcu_read_lock();\n\teb = radix_tree_lookup(&fs_info->buffer_radix,\n\t\t\t       start >> PAGE_CACHE_SHIFT);\n\tif (eb && atomic_inc_not_zero(&eb->refs)) {\n\t\trcu_read_unlock();\n\t\tmark_extent_buffer_accessed(eb, NULL);\n\t\treturn eb;\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *find_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start)\n{\n\tstruct extent_buffer *eb;\n\n\trcu_read_lock();\n\teb = radix_tree_lookup(&fs_info->buffer_radix,\n\t\t\t       start >> PAGE_CACHE_SHIFT);\n\tif (eb && atomic_inc_not_zero(&eb->refs)) {\n\t\trcu_read_unlock();\n\t\tmark_extent_buffer_accessed(eb, NULL);\n\t\treturn eb;\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 4902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 4901
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&fs_info->buffer_radix",
            "start >> PAGE_CACHE_SHIFT",
            "eb"
          ],
          "line": 4899
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 4898
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS & ~__GFP_HIGHMEM"
          ],
          "line": 4894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "p"
          ],
          "line": 4883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageDirty(p)"
          ],
          "line": 4881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "p"
          ],
          "line": 4881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_extent_buffer_page",
          "args": [
            "eb",
            "p"
          ],
          "line": 4879
        },
        "resolved": true,
        "details": {
          "function_name": "attach_extent_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2850-2860",
          "snippet": "static void attach_extent_buffer_page(struct extent_buffer *eb,\n\t\t\t\t      struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long)eb);\n\t} else {\n\t\tWARN_ON(page->private != (unsigned long)eb);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void attach_extent_buffer_page(struct extent_buffer *eb,\n\t\t\t\t      struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long)eb);\n\t} else {\n\t\tWARN_ON(page->private != (unsigned long)eb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "p"
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageDirty(p)"
          ],
          "line": 4876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "p"
          ],
          "line": 4876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "p"
          ],
          "line": 4875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_extent_buffer_accessed",
          "args": [
            "exists",
            "p"
          ],
          "line": 4867
        },
        "resolved": true,
        "details": {
          "function_name": "mark_extent_buffer_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4745-4759",
          "snippet": "static void mark_extent_buffer_accessed(struct extent_buffer *eb,\n\t\tstruct page *accessed)\n{\n\tunsigned long num_pages, i;\n\n\tcheck_buffer_tree_ref(eb);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (p != accessed)\n\t\t\tmark_page_accessed(p);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void mark_extent_buffer_accessed(struct extent_buffer *eb,\n\t\tstruct page *accessed)\n{\n\tunsigned long num_pages, i;\n\n\tcheck_buffer_tree_ref(eb);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (p != accessed)\n\t\t\tmark_page_accessed(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "p"
          ],
          "line": 4866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&exists->refs"
          ],
          "line": 4863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "p"
          ],
          "line": 4854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_extent_buffer",
          "args": [
            "fs_info",
            "start",
            "len"
          ],
          "line": 4844
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4602-4640",
          "snippet": "static struct extent_buffer *\n__alloc_extent_buffer(struct btrfs_fs_info *fs_info, u64 start,\n\t\t      unsigned long len)\n{\n\tstruct extent_buffer *eb = NULL;\n\n\teb = kmem_cache_zalloc(extent_buffer_cache, GFP_NOFS);\n\tif (eb == NULL)\n\t\treturn NULL;\n\teb->start = start;\n\teb->len = len;\n\teb->fs_info = fs_info;\n\teb->bflags = 0;\n\trwlock_init(&eb->lock);\n\tatomic_set(&eb->write_locks, 0);\n\tatomic_set(&eb->read_locks, 0);\n\tatomic_set(&eb->blocking_readers, 0);\n\tatomic_set(&eb->blocking_writers, 0);\n\tatomic_set(&eb->spinning_readers, 0);\n\tatomic_set(&eb->spinning_writers, 0);\n\teb->lock_nested = 0;\n\tinit_waitqueue_head(&eb->write_lock_wq);\n\tinit_waitqueue_head(&eb->read_lock_wq);\n\n\tbtrfs_leak_debug_add(&eb->leak_list, &buffers);\n\n\tspin_lock_init(&eb->refs_lock);\n\tatomic_set(&eb->refs, 1);\n\tatomic_set(&eb->io_pages, 0);\n\n\t/*\n\t * Sanity checks, currently the maximum is 64k covered by 16x 4k pages\n\t */\n\tBUILD_BUG_ON(BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE);\n\tBUG_ON(len > MAX_INLINE_EXTENT_BUFFER_SIZE);\n\n\treturn eb;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic struct extent_buffer *\n__alloc_extent_buffer(struct btrfs_fs_info *fs_info, u64 start,\n\t\t      unsigned long len)\n{\n\tstruct extent_buffer *eb = NULL;\n\n\teb = kmem_cache_zalloc(extent_buffer_cache, GFP_NOFS);\n\tif (eb == NULL)\n\t\treturn NULL;\n\teb->start = start;\n\teb->len = len;\n\teb->fs_info = fs_info;\n\teb->bflags = 0;\n\trwlock_init(&eb->lock);\n\tatomic_set(&eb->write_locks, 0);\n\tatomic_set(&eb->read_locks, 0);\n\tatomic_set(&eb->blocking_readers, 0);\n\tatomic_set(&eb->blocking_writers, 0);\n\tatomic_set(&eb->spinning_readers, 0);\n\tatomic_set(&eb->spinning_writers, 0);\n\teb->lock_nested = 0;\n\tinit_waitqueue_head(&eb->write_lock_wq);\n\tinit_waitqueue_head(&eb->read_lock_wq);\n\n\tbtrfs_leak_debug_add(&eb->leak_list, &buffers);\n\n\tspin_lock_init(&eb->refs_lock);\n\tatomic_set(&eb->refs, 1);\n\tatomic_set(&eb->io_pages, 0);\n\n\t/*\n\t * Sanity checks, currently the maximum is 64k covered by 16x 4k pages\n\t */\n\tBUILD_BUG_ON(BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE);\n\tBUG_ON(len > MAX_INLINE_EXTENT_BUFFER_SIZE);\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "start",
            "len"
          ],
          "line": 4830
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 start)\n{\n\tunsigned long len = fs_info->tree_root->nodesize;\n\tunsigned long num_pages = num_extent_pages(start, len);\n\tunsigned long i;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *exists = NULL;\n\tstruct page *p;\n\tstruct address_space *mapping = fs_info->btree_inode->i_mapping;\n\tint uptodate = 1;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++, index++) {\n\t\tp = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (!p)\n\t\t\tgoto free_eb;\n\n\t\tspin_lock(&mapping->private_lock);\n\t\tif (PagePrivate(p)) {\n\t\t\t/*\n\t\t\t * We could have already allocated an eb for this page\n\t\t\t * and attached one so lets see if we can get a ref on\n\t\t\t * the existing eb, and if we can we know it's good and\n\t\t\t * we can just return that one, else we know we can just\n\t\t\t * overwrite page->private.\n\t\t\t */\n\t\t\texists = (struct extent_buffer *)p->private;\n\t\t\tif (atomic_inc_not_zero(&exists->refs)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tunlock_page(p);\n\t\t\t\tpage_cache_release(p);\n\t\t\t\tmark_extent_buffer_accessed(exists, p);\n\t\t\t\tgoto free_eb;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Do this so attach doesn't complain and we need to\n\t\t\t * drop the ref the old guy had.\n\t\t\t */\n\t\t\tClearPagePrivate(p);\n\t\t\tWARN_ON(PageDirty(p));\n\t\t\tpage_cache_release(p);\n\t\t}\n\t\tattach_extent_buffer_page(eb, p);\n\t\tspin_unlock(&mapping->private_lock);\n\t\tWARN_ON(PageDirty(p));\n\t\teb->pages[i] = p;\n\t\tif (!PageUptodate(p))\n\t\t\tuptodate = 0;\n\n\t\t/*\n\t\t * see below about how we avoid a nasty race with release page\n\t\t * and why we unlock later\n\t\t */\n\t}\n\tif (uptodate)\n\t\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\t/* add one reference for the tree */\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * there is a race where release page may have\n\t * tried to find this extent buffer in the radix\n\t * but failed.  It will tell the VM it is safe to\n\t * reclaim the, and it will clear the page private bit.\n\t * We must make sure to set the page private bit properly\n\t * after the extent buffer is in the radix tree so\n\t * it doesn't get lost\n\t */\n\tSetPageChecked(eb->pages[0]);\n\tfor (i = 1; i < num_pages; i++) {\n\t\tp = eb->pages[i];\n\t\tClearPageChecked(p);\n\t\tunlock_page(p);\n\t}\n\tunlock_page(eb->pages[0]);\n\treturn eb;\n\nfree_eb:\n\tfor (i = 0; i < num_pages; i++) {\n\t\tif (eb->pages[i])\n\t\t\tunlock_page(eb->pages[i]);\n\t}\n\n\tWARN_ON(!atomic_dec_and_test(&eb->refs));\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}"
  },
  {
    "function_name": "alloc_test_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4780-4823",
    "snippet": "struct extent_buffer *alloc_test_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 start)\n{\n\tstruct extent_buffer *eb, *exists = NULL;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\teb = alloc_dummy_extent_buffer(fs_info, start);\n\tif (!eb)\n\t\treturn NULL;\n\teb->fs_info = fs_info;\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * We will free dummy extent buffer's if they come into\n\t * free_extent_buffer with a ref count of 2, but if we are using this we\n\t * want the buffers to stay in memory until we're done with them, so\n\t * bump the ref count again.\n\t */\n\tatomic_inc(&eb->refs);\n\treturn eb;\nfree_eb:\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 4821
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_extent_buffer_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4943-4949",
          "snippet": "static inline void btrfs_release_extent_buffer_rcu(struct rcu_head *head)\n{\n\tstruct extent_buffer *eb =\n\t\t\tcontainer_of(head, struct extent_buffer, rcu_head);\n\n\t__free_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline void btrfs_release_extent_buffer_rcu(struct rcu_head *head)\n{\n\tstruct extent_buffer *eb =\n\t\t\tcontainer_of(head, struct extent_buffer, rcu_head);\n\n\t__free_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->refs"
          ],
          "line": 4818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_IN_TREE",
            "&eb->bflags"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_buffer_tree_ref",
          "args": [
            "eb"
          ],
          "line": 4809
        },
        "resolved": true,
        "details": {
          "function_name": "check_buffer_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4712-4743",
          "snippet": "static void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_extent_buffer",
          "args": [
            "fs_info",
            "start"
          ],
          "line": 4803
        },
        "resolved": true,
        "details": {
          "function_name": "find_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4761-4777",
          "snippet": "struct extent_buffer *find_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start)\n{\n\tstruct extent_buffer *eb;\n\n\trcu_read_lock();\n\teb = radix_tree_lookup(&fs_info->buffer_radix,\n\t\t\t       start >> PAGE_CACHE_SHIFT);\n\tif (eb && atomic_inc_not_zero(&eb->refs)) {\n\t\trcu_read_unlock();\n\t\tmark_extent_buffer_accessed(eb, NULL);\n\t\treturn eb;\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *find_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start)\n{\n\tstruct extent_buffer *eb;\n\n\trcu_read_lock();\n\teb = radix_tree_lookup(&fs_info->buffer_radix,\n\t\t\t       start >> PAGE_CACHE_SHIFT);\n\tif (eb && atomic_inc_not_zero(&eb->refs)) {\n\t\trcu_read_unlock();\n\t\tmark_extent_buffer_accessed(eb, NULL);\n\t\treturn eb;\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload_end",
          "args": [],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 4800
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&fs_info->buffer_radix",
            "start >> PAGE_CACHE_SHIFT",
            "eb"
          ],
          "line": 4798
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->buffer_lock"
          ],
          "line": 4797
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_preload",
          "args": [
            "GFP_NOFS & ~__GFP_HIGHMEM"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_dummy_extent_buffer",
          "args": [
            "fs_info",
            "start"
          ],
          "line": 4789
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_dummy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4672-4710",
          "snippet": "struct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_test_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t       u64 start)\n{\n\tstruct extent_buffer *eb, *exists = NULL;\n\tint ret;\n\n\teb = find_extent_buffer(fs_info, start);\n\tif (eb)\n\t\treturn eb;\n\teb = alloc_dummy_extent_buffer(fs_info, start);\n\tif (!eb)\n\t\treturn NULL;\n\teb->fs_info = fs_info;\nagain:\n\tret = radix_tree_preload(GFP_NOFS & ~__GFP_HIGHMEM);\n\tif (ret)\n\t\tgoto free_eb;\n\tspin_lock(&fs_info->buffer_lock);\n\tret = radix_tree_insert(&fs_info->buffer_radix,\n\t\t\t\tstart >> PAGE_CACHE_SHIFT, eb);\n\tspin_unlock(&fs_info->buffer_lock);\n\tradix_tree_preload_end();\n\tif (ret == -EEXIST) {\n\t\texists = find_extent_buffer(fs_info, start);\n\t\tif (exists)\n\t\t\tgoto free_eb;\n\t\telse\n\t\t\tgoto again;\n\t}\n\tcheck_buffer_tree_ref(eb);\n\tset_bit(EXTENT_BUFFER_IN_TREE, &eb->bflags);\n\n\t/*\n\t * We will free dummy extent buffer's if they come into\n\t * free_extent_buffer with a ref count of 2, but if we are using this we\n\t * want the buffers to stay in memory until we're done with them, so\n\t * bump the ref count again.\n\t */\n\tatomic_inc(&eb->refs);\n\treturn eb;\nfree_eb:\n\tbtrfs_release_extent_buffer(eb);\n\treturn exists;\n}"
  },
  {
    "function_name": "find_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4761-4777",
    "snippet": "struct extent_buffer *find_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start)\n{\n\tstruct extent_buffer *eb;\n\n\trcu_read_lock();\n\teb = radix_tree_lookup(&fs_info->buffer_radix,\n\t\t\t       start >> PAGE_CACHE_SHIFT);\n\tif (eb && atomic_inc_not_zero(&eb->refs)) {\n\t\trcu_read_unlock();\n\t\tmark_extent_buffer_accessed(eb, NULL);\n\t\treturn eb;\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_extent_buffer_accessed",
          "args": [
            "eb",
            "NULL"
          ],
          "line": 4771
        },
        "resolved": true,
        "details": {
          "function_name": "mark_extent_buffer_accessed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4745-4759",
          "snippet": "static void mark_extent_buffer_accessed(struct extent_buffer *eb,\n\t\tstruct page *accessed)\n{\n\tunsigned long num_pages, i;\n\n\tcheck_buffer_tree_ref(eb);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (p != accessed)\n\t\t\tmark_page_accessed(p);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void mark_extent_buffer_accessed(struct extent_buffer *eb,\n\t\tstruct page *accessed)\n{\n\tunsigned long num_pages, i;\n\n\tcheck_buffer_tree_ref(eb);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (p != accessed)\n\t\t\tmark_page_accessed(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&eb->refs"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&fs_info->buffer_radix",
            "start >> PAGE_CACHE_SHIFT"
          ],
          "line": 4767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 4766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *find_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t u64 start)\n{\n\tstruct extent_buffer *eb;\n\n\trcu_read_lock();\n\teb = radix_tree_lookup(&fs_info->buffer_radix,\n\t\t\t       start >> PAGE_CACHE_SHIFT);\n\tif (eb && atomic_inc_not_zero(&eb->refs)) {\n\t\trcu_read_unlock();\n\t\tmark_extent_buffer_accessed(eb, NULL);\n\t\treturn eb;\n\t}\n\trcu_read_unlock();\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "mark_extent_buffer_accessed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4745-4759",
    "snippet": "static void mark_extent_buffer_accessed(struct extent_buffer *eb,\n\t\tstruct page *accessed)\n{\n\tunsigned long num_pages, i;\n\n\tcheck_buffer_tree_ref(eb);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (p != accessed)\n\t\t\tmark_page_accessed(p);\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "p"
          ],
          "line": 4757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 4752
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_buffer_tree_ref",
          "args": [
            "eb"
          ],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "check_buffer_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4712-4743",
          "snippet": "static void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void mark_extent_buffer_accessed(struct extent_buffer *eb,\n\t\tstruct page *accessed)\n{\n\tunsigned long num_pages, i;\n\n\tcheck_buffer_tree_ref(eb);\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (p != accessed)\n\t\t\tmark_page_accessed(p);\n\t}\n}"
  },
  {
    "function_name": "check_buffer_tree_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4712-4743",
    "snippet": "static void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 4742
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->refs"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "EXTENT_BUFFER_TREE_REF",
            "&eb->bflags"
          ],
          "line": 4740
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_TREE_REF",
            "&eb->bflags"
          ],
          "line": 4736
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void check_buffer_tree_ref(struct extent_buffer *eb)\n{\n\tint refs;\n\t/* the ref bit is tricky.  We have to make sure it is set\n\t * if we have the buffer dirty.   Otherwise the\n\t * code to free a buffer can end up dropping a dirty\n\t * page\n\t *\n\t * Once the ref bit is set, it won't go away while the\n\t * buffer is dirty or in writeback, and it also won't\n\t * go away while we have the reference count on the\n\t * eb bumped.\n\t *\n\t * We can't just set the ref bit without bumping the\n\t * ref on the eb because free_extent_buffer might\n\t * see the ref bit and try to clear it.  If this happens\n\t * free_extent_buffer might end up dropping our original\n\t * ref by mistake and freeing the page before we are able\n\t * to add one more ref.\n\t *\n\t * So bump the ref count first, then set the bit.  If someone\n\t * beat us to it, drop the ref we added.\n\t */\n\trefs = atomic_read(&eb->refs);\n\tif (refs >= 2 && test_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tif (!test_and_set_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_inc(&eb->refs);\n\tspin_unlock(&eb->refs_lock);\n}"
  },
  {
    "function_name": "alloc_dummy_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4672-4710",
    "snippet": "struct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 4708
        },
        "resolved": true,
        "details": {
          "function_name": "__free_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4529-4533",
          "snippet": "static void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "eb->pages[i - 1]"
          ],
          "line": 4707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_DUMMY",
            "&eb->bflags"
          ],
          "line": 4702
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "eb",
            "0"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 4700
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5098-5111",
          "snippet": "int set_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tSetPageUptodate(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\tunsigned long i;\n\tstruct page *page;\n\tunsigned long num_pages;\n\n\tset_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tpage = eb->pages[i];\n\t\tSetPageUptodate(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 4696
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_extent_buffer",
          "args": [
            "fs_info",
            "start",
            "len"
          ],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4602-4640",
          "snippet": "static struct extent_buffer *\n__alloc_extent_buffer(struct btrfs_fs_info *fs_info, u64 start,\n\t\t      unsigned long len)\n{\n\tstruct extent_buffer *eb = NULL;\n\n\teb = kmem_cache_zalloc(extent_buffer_cache, GFP_NOFS);\n\tif (eb == NULL)\n\t\treturn NULL;\n\teb->start = start;\n\teb->len = len;\n\teb->fs_info = fs_info;\n\teb->bflags = 0;\n\trwlock_init(&eb->lock);\n\tatomic_set(&eb->write_locks, 0);\n\tatomic_set(&eb->read_locks, 0);\n\tatomic_set(&eb->blocking_readers, 0);\n\tatomic_set(&eb->blocking_writers, 0);\n\tatomic_set(&eb->spinning_readers, 0);\n\tatomic_set(&eb->spinning_writers, 0);\n\teb->lock_nested = 0;\n\tinit_waitqueue_head(&eb->write_lock_wq);\n\tinit_waitqueue_head(&eb->read_lock_wq);\n\n\tbtrfs_leak_debug_add(&eb->leak_list, &buffers);\n\n\tspin_lock_init(&eb->refs_lock);\n\tatomic_set(&eb->refs, 1);\n\tatomic_set(&eb->io_pages, 0);\n\n\t/*\n\t * Sanity checks, currently the maximum is 64k covered by 16x 4k pages\n\t */\n\tBUILD_BUG_ON(BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE);\n\tBUG_ON(len > MAX_INLINE_EXTENT_BUFFER_SIZE);\n\n\treturn eb;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic struct extent_buffer *\n__alloc_extent_buffer(struct btrfs_fs_info *fs_info, u64 start,\n\t\t      unsigned long len)\n{\n\tstruct extent_buffer *eb = NULL;\n\n\teb = kmem_cache_zalloc(extent_buffer_cache, GFP_NOFS);\n\tif (eb == NULL)\n\t\treturn NULL;\n\teb->start = start;\n\teb->len = len;\n\teb->fs_info = fs_info;\n\teb->bflags = 0;\n\trwlock_init(&eb->lock);\n\tatomic_set(&eb->write_locks, 0);\n\tatomic_set(&eb->read_locks, 0);\n\tatomic_set(&eb->blocking_readers, 0);\n\tatomic_set(&eb->blocking_writers, 0);\n\tatomic_set(&eb->spinning_readers, 0);\n\tatomic_set(&eb->spinning_writers, 0);\n\teb->lock_nested = 0;\n\tinit_waitqueue_head(&eb->write_lock_wq);\n\tinit_waitqueue_head(&eb->read_lock_wq);\n\n\tbtrfs_leak_debug_add(&eb->leak_list, &buffers);\n\n\tspin_lock_init(&eb->refs_lock);\n\tatomic_set(&eb->refs, 1);\n\tatomic_set(&eb->io_pages, 0);\n\n\t/*\n\t * Sanity checks, currently the maximum is 64k covered by 16x 4k pages\n\t */\n\tBUILD_BUG_ON(BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE);\n\tBUG_ON(len > MAX_INLINE_EXTENT_BUFFER_SIZE);\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "0",
            "len"
          ],
          "line": 4689
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}"
  },
  {
    "function_name": "btrfs_clone_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4642-4670",
    "snippet": "struct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_DUMMY",
            "&new->bflags"
          ],
          "line": 4667
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "new",
            "src",
            "0",
            "0",
            "src->len"
          ],
          "line": 4665
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "p"
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "PageDirty(p)"
          ],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "p"
          ],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "attach_extent_buffer_page",
          "args": [
            "new",
            "p"
          ],
          "line": 4659
        },
        "resolved": true,
        "details": {
          "function_name": "attach_extent_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2850-2860",
          "snippet": "static void attach_extent_buffer_page(struct extent_buffer *eb,\n\t\t\t\t      struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long)eb);\n\t} else {\n\t\tWARN_ON(page->private != (unsigned long)eb);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void attach_extent_buffer_page(struct extent_buffer *eb,\n\t\t\t\t      struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long)eb);\n\t} else {\n\t\tWARN_ON(page->private != (unsigned long)eb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_extent_buffer",
          "args": [
            "new"
          ],
          "line": 4656
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_extent_buffer_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4943-4949",
          "snippet": "static inline void btrfs_release_extent_buffer_rcu(struct rcu_head *head)\n{\n\tstruct extent_buffer *eb =\n\t\t\tcontainer_of(head, struct extent_buffer, rcu_head);\n\n\t__free_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline void btrfs_release_extent_buffer_rcu(struct rcu_head *head)\n{\n\tstruct extent_buffer *eb =\n\t\t\tcontainer_of(head, struct extent_buffer, rcu_head);\n\n\t__free_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 4654
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__alloc_extent_buffer",
          "args": [
            "src->fs_info",
            "src->start",
            "src->len"
          ],
          "line": 4649
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4602-4640",
          "snippet": "static struct extent_buffer *\n__alloc_extent_buffer(struct btrfs_fs_info *fs_info, u64 start,\n\t\t      unsigned long len)\n{\n\tstruct extent_buffer *eb = NULL;\n\n\teb = kmem_cache_zalloc(extent_buffer_cache, GFP_NOFS);\n\tif (eb == NULL)\n\t\treturn NULL;\n\teb->start = start;\n\teb->len = len;\n\teb->fs_info = fs_info;\n\teb->bflags = 0;\n\trwlock_init(&eb->lock);\n\tatomic_set(&eb->write_locks, 0);\n\tatomic_set(&eb->read_locks, 0);\n\tatomic_set(&eb->blocking_readers, 0);\n\tatomic_set(&eb->blocking_writers, 0);\n\tatomic_set(&eb->spinning_readers, 0);\n\tatomic_set(&eb->spinning_writers, 0);\n\teb->lock_nested = 0;\n\tinit_waitqueue_head(&eb->write_lock_wq);\n\tinit_waitqueue_head(&eb->read_lock_wq);\n\n\tbtrfs_leak_debug_add(&eb->leak_list, &buffers);\n\n\tspin_lock_init(&eb->refs_lock);\n\tatomic_set(&eb->refs, 1);\n\tatomic_set(&eb->io_pages, 0);\n\n\t/*\n\t * Sanity checks, currently the maximum is 64k covered by 16x 4k pages\n\t */\n\tBUILD_BUG_ON(BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE);\n\tBUG_ON(len > MAX_INLINE_EXTENT_BUFFER_SIZE);\n\n\treturn eb;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic struct extent_buffer *\n__alloc_extent_buffer(struct btrfs_fs_info *fs_info, u64 start,\n\t\t      unsigned long len)\n{\n\tstruct extent_buffer *eb = NULL;\n\n\teb = kmem_cache_zalloc(extent_buffer_cache, GFP_NOFS);\n\tif (eb == NULL)\n\t\treturn NULL;\n\teb->start = start;\n\teb->len = len;\n\teb->fs_info = fs_info;\n\teb->bflags = 0;\n\trwlock_init(&eb->lock);\n\tatomic_set(&eb->write_locks, 0);\n\tatomic_set(&eb->read_locks, 0);\n\tatomic_set(&eb->blocking_readers, 0);\n\tatomic_set(&eb->blocking_writers, 0);\n\tatomic_set(&eb->spinning_readers, 0);\n\tatomic_set(&eb->spinning_writers, 0);\n\teb->lock_nested = 0;\n\tinit_waitqueue_head(&eb->write_lock_wq);\n\tinit_waitqueue_head(&eb->read_lock_wq);\n\n\tbtrfs_leak_debug_add(&eb->leak_list, &buffers);\n\n\tspin_lock_init(&eb->refs_lock);\n\tatomic_set(&eb->refs, 1);\n\tatomic_set(&eb->io_pages, 0);\n\n\t/*\n\t * Sanity checks, currently the maximum is 64k covered by 16x 4k pages\n\t */\n\tBUILD_BUG_ON(BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE);\n\tBUG_ON(len > MAX_INLINE_EXTENT_BUFFER_SIZE);\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "src->start",
            "src->len"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}"
  },
  {
    "function_name": "__alloc_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4602-4640",
    "snippet": "static struct extent_buffer *\n__alloc_extent_buffer(struct btrfs_fs_info *fs_info, u64 start,\n\t\t      unsigned long len)\n{\n\tstruct extent_buffer *eb = NULL;\n\n\teb = kmem_cache_zalloc(extent_buffer_cache, GFP_NOFS);\n\tif (eb == NULL)\n\t\treturn NULL;\n\teb->start = start;\n\teb->len = len;\n\teb->fs_info = fs_info;\n\teb->bflags = 0;\n\trwlock_init(&eb->lock);\n\tatomic_set(&eb->write_locks, 0);\n\tatomic_set(&eb->read_locks, 0);\n\tatomic_set(&eb->blocking_readers, 0);\n\tatomic_set(&eb->blocking_writers, 0);\n\tatomic_set(&eb->spinning_readers, 0);\n\tatomic_set(&eb->spinning_writers, 0);\n\teb->lock_nested = 0;\n\tinit_waitqueue_head(&eb->write_lock_wq);\n\tinit_waitqueue_head(&eb->read_lock_wq);\n\n\tbtrfs_leak_debug_add(&eb->leak_list, &buffers);\n\n\tspin_lock_init(&eb->refs_lock);\n\tatomic_set(&eb->refs, 1);\n\tatomic_set(&eb->io_pages, 0);\n\n\t/*\n\t * Sanity checks, currently the maximum is 64k covered by 16x 4k pages\n\t */\n\tBUILD_BUG_ON(BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE);\n\tBUG_ON(len > MAX_INLINE_EXTENT_BUFFER_SIZE);\n\n\treturn eb;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_buffer_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len > MAX_INLINE_EXTENT_BUFFER_SIZE"
          ],
          "line": 4637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE"
          ],
          "line": 4635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->io_pages",
            "0"
          ],
          "line": 4630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->refs",
            "1"
          ],
          "line": 4629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 4628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leak_debug_add",
          "args": [
            "&eb->leak_list",
            "&buffers"
          ],
          "line": 4626
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leak_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "39-47",
          "snippet": "static inline\nvoid btrfs_leak_debug_add(struct list_head *new, struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_add(new, head);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline\nvoid btrfs_leak_debug_add(struct list_head *new, struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_add(new, head);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&eb->read_lock_wq"
          ],
          "line": 4624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&eb->write_lock_wq"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->spinning_writers",
            "0"
          ],
          "line": 4621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->spinning_readers",
            "0"
          ],
          "line": 4620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->blocking_writers",
            "0"
          ],
          "line": 4619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->blocking_readers",
            "0"
          ],
          "line": 4618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->read_locks",
            "0"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->write_locks",
            "0"
          ],
          "line": 4616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&eb->lock"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "extent_buffer_cache",
            "GFP_NOFS"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic struct extent_buffer *\n__alloc_extent_buffer(struct btrfs_fs_info *fs_info, u64 start,\n\t\t      unsigned long len)\n{\n\tstruct extent_buffer *eb = NULL;\n\n\teb = kmem_cache_zalloc(extent_buffer_cache, GFP_NOFS);\n\tif (eb == NULL)\n\t\treturn NULL;\n\teb->start = start;\n\teb->len = len;\n\teb->fs_info = fs_info;\n\teb->bflags = 0;\n\trwlock_init(&eb->lock);\n\tatomic_set(&eb->write_locks, 0);\n\tatomic_set(&eb->read_locks, 0);\n\tatomic_set(&eb->blocking_readers, 0);\n\tatomic_set(&eb->blocking_writers, 0);\n\tatomic_set(&eb->spinning_readers, 0);\n\tatomic_set(&eb->spinning_writers, 0);\n\teb->lock_nested = 0;\n\tinit_waitqueue_head(&eb->write_lock_wq);\n\tinit_waitqueue_head(&eb->read_lock_wq);\n\n\tbtrfs_leak_debug_add(&eb->leak_list, &buffers);\n\n\tspin_lock_init(&eb->refs_lock);\n\tatomic_set(&eb->refs, 1);\n\tatomic_set(&eb->io_pages, 0);\n\n\t/*\n\t * Sanity checks, currently the maximum is 64k covered by 16x 4k pages\n\t */\n\tBUILD_BUG_ON(BTRFS_MAX_METADATA_BLOCKSIZE\n\t\t> MAX_INLINE_EXTENT_BUFFER_SIZE);\n\tBUG_ON(len > MAX_INLINE_EXTENT_BUFFER_SIZE);\n\n\treturn eb;\n}"
  },
  {
    "function_name": "btrfs_release_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4596-4600",
    "snippet": "static inline void btrfs_release_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_release_extent_buffer_page(eb);\n\t__free_extent_buffer(eb);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 4599
        },
        "resolved": true,
        "details": {
          "function_name": "__free_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4529-4533",
          "snippet": "static void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_extent_buffer_page",
          "args": [
            "eb"
          ],
          "line": 4598
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_extent_buffer_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4545-4591",
          "snippet": "static void btrfs_release_extent_buffer_page(struct extent_buffer *eb)\n{\n\tunsigned long index;\n\tstruct page *page;\n\tint mapped = !test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\tBUG_ON(extent_buffer_under_io(eb));\n\n\tindex = num_extent_pages(eb->start, eb->len);\n\tif (index == 0)\n\t\treturn;\n\n\tdo {\n\t\tindex--;\n\t\tpage = eb->pages[index];\n\t\tif (page && mapped) {\n\t\t\tspin_lock(&page->mapping->private_lock);\n\t\t\t/*\n\t\t\t * We do this since we'll remove the pages after we've\n\t\t\t * removed the eb from the radix tree, so we could race\n\t\t\t * and have this page now attached to the new eb.  So\n\t\t\t * only clear page_private if it's still connected to\n\t\t\t * this eb.\n\t\t\t */\n\t\t\tif (PagePrivate(page) &&\n\t\t\t    page->private == (unsigned long)eb) {\n\t\t\t\tBUG_ON(test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n\t\t\t\tBUG_ON(PageDirty(page));\n\t\t\t\tBUG_ON(PageWriteback(page));\n\t\t\t\t/*\n\t\t\t\t * We need to make sure we haven't be attached\n\t\t\t\t * to a new eb.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\t/* One for the page private */\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\tspin_unlock(&page->mapping->private_lock);\n\n\t\t}\n\t\tif (page) {\n\t\t\t/* One for when we alloced the page */\n\t\t\tpage_cache_release(page);\n\t\t}\n\t} while (index != 0);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void btrfs_release_extent_buffer_page(struct extent_buffer *eb)\n{\n\tunsigned long index;\n\tstruct page *page;\n\tint mapped = !test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\tBUG_ON(extent_buffer_under_io(eb));\n\n\tindex = num_extent_pages(eb->start, eb->len);\n\tif (index == 0)\n\t\treturn;\n\n\tdo {\n\t\tindex--;\n\t\tpage = eb->pages[index];\n\t\tif (page && mapped) {\n\t\t\tspin_lock(&page->mapping->private_lock);\n\t\t\t/*\n\t\t\t * We do this since we'll remove the pages after we've\n\t\t\t * removed the eb from the radix tree, so we could race\n\t\t\t * and have this page now attached to the new eb.  So\n\t\t\t * only clear page_private if it's still connected to\n\t\t\t * this eb.\n\t\t\t */\n\t\t\tif (PagePrivate(page) &&\n\t\t\t    page->private == (unsigned long)eb) {\n\t\t\t\tBUG_ON(test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n\t\t\t\tBUG_ON(PageDirty(page));\n\t\t\t\tBUG_ON(PageWriteback(page));\n\t\t\t\t/*\n\t\t\t\t * We need to make sure we haven't be attached\n\t\t\t\t * to a new eb.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\t/* One for the page private */\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\tspin_unlock(&page->mapping->private_lock);\n\n\t\t}\n\t\tif (page) {\n\t\t\t/* One for when we alloced the page */\n\t\t\tpage_cache_release(page);\n\t\t}\n\t} while (index != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline void btrfs_release_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_release_extent_buffer_page(eb);\n\t__free_extent_buffer(eb);\n}"
  },
  {
    "function_name": "btrfs_release_extent_buffer_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4545-4591",
    "snippet": "static void btrfs_release_extent_buffer_page(struct extent_buffer *eb)\n{\n\tunsigned long index;\n\tstruct page *page;\n\tint mapped = !test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\tBUG_ON(extent_buffer_under_io(eb));\n\n\tindex = num_extent_pages(eb->start, eb->len);\n\tif (index == 0)\n\t\treturn;\n\n\tdo {\n\t\tindex--;\n\t\tpage = eb->pages[index];\n\t\tif (page && mapped) {\n\t\t\tspin_lock(&page->mapping->private_lock);\n\t\t\t/*\n\t\t\t * We do this since we'll remove the pages after we've\n\t\t\t * removed the eb from the radix tree, so we could race\n\t\t\t * and have this page now attached to the new eb.  So\n\t\t\t * only clear page_private if it's still connected to\n\t\t\t * this eb.\n\t\t\t */\n\t\t\tif (PagePrivate(page) &&\n\t\t\t    page->private == (unsigned long)eb) {\n\t\t\t\tBUG_ON(test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n\t\t\t\tBUG_ON(PageDirty(page));\n\t\t\t\tBUG_ON(PageWriteback(page));\n\t\t\t\t/*\n\t\t\t\t * We need to make sure we haven't be attached\n\t\t\t\t * to a new eb.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\t/* One for the page private */\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\tspin_unlock(&page->mapping->private_lock);\n\n\t\t}\n\t\tif (page) {\n\t\t\t/* One for when we alloced the page */\n\t\t\tpage_cache_release(page);\n\t\t}\n\t} while (index != 0);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 4579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 4578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 4573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 4573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageDirty(page)"
          ],
          "line": 4572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 4572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)"
          ],
          "line": 4571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_DIRTY",
            "&eb->bflags"
          ],
          "line": 4571
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 4569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&page->mapping->private_lock"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "extent_buffer_under_io(eb)"
          ],
          "line": 4551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_under_io",
          "args": [
            "eb"
          ],
          "line": 4551
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_under_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4535-4540",
          "snippet": "int extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void btrfs_release_extent_buffer_page(struct extent_buffer *eb)\n{\n\tunsigned long index;\n\tstruct page *page;\n\tint mapped = !test_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\tBUG_ON(extent_buffer_under_io(eb));\n\n\tindex = num_extent_pages(eb->start, eb->len);\n\tif (index == 0)\n\t\treturn;\n\n\tdo {\n\t\tindex--;\n\t\tpage = eb->pages[index];\n\t\tif (page && mapped) {\n\t\t\tspin_lock(&page->mapping->private_lock);\n\t\t\t/*\n\t\t\t * We do this since we'll remove the pages after we've\n\t\t\t * removed the eb from the radix tree, so we could race\n\t\t\t * and have this page now attached to the new eb.  So\n\t\t\t * only clear page_private if it's still connected to\n\t\t\t * this eb.\n\t\t\t */\n\t\t\tif (PagePrivate(page) &&\n\t\t\t    page->private == (unsigned long)eb) {\n\t\t\t\tBUG_ON(test_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n\t\t\t\tBUG_ON(PageDirty(page));\n\t\t\t\tBUG_ON(PageWriteback(page));\n\t\t\t\t/*\n\t\t\t\t * We need to make sure we haven't be attached\n\t\t\t\t * to a new eb.\n\t\t\t\t */\n\t\t\t\tClearPagePrivate(page);\n\t\t\t\tset_page_private(page, 0);\n\t\t\t\t/* One for the page private */\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t\tspin_unlock(&page->mapping->private_lock);\n\n\t\t}\n\t\tif (page) {\n\t\t\t/* One for when we alloced the page */\n\t\t\tpage_cache_release(page);\n\t\t}\n\t} while (index != 0);\n}"
  },
  {
    "function_name": "extent_buffer_under_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4535-4540",
    "snippet": "int extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_DIRTY",
            "&eb->bflags"
          ],
          "line": 4539
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->io_pages"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_under_io(struct extent_buffer *eb)\n{\n\treturn (atomic_read(&eb->io_pages) ||\n\t\ttest_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags) ||\n\t\ttest_bit(EXTENT_BUFFER_DIRTY, &eb->bflags));\n}"
  },
  {
    "function_name": "__free_extent_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4529-4533",
    "snippet": "static void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_buffer_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "extent_buffer_cache",
            "eb"
          ],
          "line": 4532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leak_debug_del",
          "args": [
            "&eb->leak_list"
          ],
          "line": 4531
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leak_debug_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "49-57",
          "snippet": "static inline\nvoid btrfs_leak_debug_del(struct list_head *entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_del(entry);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline\nvoid btrfs_leak_debug_del(struct list_head *entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_del(entry);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic void __free_extent_buffer(struct extent_buffer *eb)\n{\n\tbtrfs_leak_debug_del(&eb->leak_list);\n\tkmem_cache_free(extent_buffer_cache, eb);\n}"
  },
  {
    "function_name": "extent_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4340-4527",
    "snippet": "int extent_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t__u64 start, __u64 len, get_extent_t *get_extent)\n{\n\tint ret = 0;\n\tu64 off = start;\n\tu64 max = start + len;\n\tu32 flags = 0;\n\tu32 found_type;\n\tu64 last;\n\tu64 last_for_get_extent = 0;\n\tu64 disko = 0;\n\tu64 isize = i_size_read(inode);\n\tstruct btrfs_key found_key;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint end = 0;\n\tu64 em_start = 0;\n\tu64 em_len = 0;\n\tu64 em_end = 0;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tstart = round_down(start, BTRFS_I(inode)->root->sectorsize);\n\tlen = round_up(max, BTRFS_I(inode)->root->sectorsize) - start;\n\n\t/*\n\t * lookup the last file extent.  We're not using i_size here\n\t * because there might be preallocation past i_size\n\t */\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(inode), -1,\n\t\t\t\t       0);\n\tif (ret < 0) {\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tWARN_ON(!ret);\n\tpath->slots[0]--;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, path->slots[0]);\n\tfound_type = found_key.type;\n\n\t/* No extents, but there might be delalloc bits */\n\tif (found_key.objectid != btrfs_ino(inode) ||\n\t    found_type != BTRFS_EXTENT_DATA_KEY) {\n\t\t/* have to trust i_size as the end */\n\t\tlast = (u64)-1;\n\t\tlast_for_get_extent = isize;\n\t} else {\n\t\t/*\n\t\t * remember the start of the last extent.  There are a\n\t\t * bunch of different factors that go into the length of the\n\t\t * extent, so its much less complex to remember where it started\n\t\t */\n\t\tlast = found_key.offset;\n\t\tlast_for_get_extent = last + 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * we might have some extents allocated but more delalloc past those\n\t * extents.  so, we trust isize unless the start of the last extent is\n\t * beyond isize\n\t */\n\tif (last < isize) {\n\t\tlast = (u64)-1;\n\t\tlast_for_get_extent = isize;\n\t}\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, start, start + len - 1, 0,\n\t\t\t &cached_state);\n\n\tem = get_extent_skip_holes(inode, start, last_for_get_extent,\n\t\t\t\t   get_extent);\n\tif (!em)\n\t\tgoto out;\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out;\n\t}\n\n\twhile (!end) {\n\t\tu64 offset_in_extent = 0;\n\n\t\t/* break if the extent we found is outside the range */\n\t\tif (em->start >= max || extent_map_end(em) < off)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * get_extent may return an extent that starts before our\n\t\t * requested range.  We have to make sure the ranges\n\t\t * we return to fiemap always move forward and don't\n\t\t * overlap, so adjust the offsets here\n\t\t */\n\t\tem_start = max(em->start, off);\n\n\t\t/*\n\t\t * record the offset from the start of the extent\n\t\t * for adjusting the disk offset below.  Only do this if the\n\t\t * extent isn't compressed since our in ram offset may be past\n\t\t * what we have actually allocated on disk.\n\t\t */\n\t\tif (!test_bit(EXTENT_FLAG_COMPRESSED, &em->flags))\n\t\t\toffset_in_extent = em_start - em->start;\n\t\tem_end = extent_map_end(em);\n\t\tem_len = em_end - em_start;\n\t\tdisko = 0;\n\t\tflags = 0;\n\n\t\t/*\n\t\t * bump off for our next call to get_extent\n\t\t */\n\t\toff = extent_map_end(em);\n\t\tif (off >= max)\n\t\t\tend = 1;\n\n\t\tif (em->block_start == EXTENT_MAP_LAST_BYTE) {\n\t\t\tend = 1;\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\t\t} else if (em->block_start == EXTENT_MAP_INLINE) {\n\t\t\tflags |= (FIEMAP_EXTENT_DATA_INLINE |\n\t\t\t\t  FIEMAP_EXTENT_NOT_ALIGNED);\n\t\t} else if (em->block_start == EXTENT_MAP_DELALLOC) {\n\t\t\tflags |= (FIEMAP_EXTENT_DELALLOC |\n\t\t\t\t  FIEMAP_EXTENT_UNKNOWN);\n\t\t} else if (fieinfo->fi_extents_max) {\n\t\t\tu64 bytenr = em->block_start -\n\t\t\t\t(em->start - em->orig_start);\n\n\t\t\tdisko = em->block_start + offset_in_extent;\n\n\t\t\t/*\n\t\t\t * As btrfs supports shared space, this information\n\t\t\t * can be exported to userspace tools via\n\t\t\t * flag FIEMAP_EXTENT_SHARED.  If fi_extents_max == 0\n\t\t\t * then we're just getting a count and we can skip the\n\t\t\t * lookup stuff.\n\t\t\t */\n\t\t\tret = btrfs_check_shared(NULL, root->fs_info,\n\t\t\t\t\t\t root->objectid,\n\t\t\t\t\t\t btrfs_ino(inode), bytenr);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_free;\n\t\t\tif (ret)\n\t\t\t\tflags |= FIEMAP_EXTENT_SHARED;\n\t\t\tret = 0;\n\t\t}\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags))\n\t\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tif ((em_start >= last) || em_len == (u64)-1 ||\n\t\t   (last == (u64)-1 && isize <= em_end)) {\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\t\t\tend = 1;\n\t\t}\n\n\t\t/* now scan forward to see if this is really the last extent. */\n\t\tem = get_extent_skip_holes(inode, off, last_for_get_extent,\n\t\t\t\t\t   get_extent);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!em) {\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\t\t\tend = 1;\n\t\t}\n\t\tret = fiemap_fill_next_extent(fieinfo, em_start, disko,\n\t\t\t\t\t      em_len, flags);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\nout_free:\n\tfree_extent_map(em);\nout:\n\tbtrfs_free_path(path);\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, start, start + len - 1,\n\t\t\t     &cached_state, GFP_NOFS);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start",
            "start + len - 1",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 4524
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4524
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4523
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4521
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fieinfo",
            "em_start",
            "disko",
            "em_len",
            "flags"
          ],
          "line": 4515
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "85-121",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "em"
          ],
          "line": 4508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 4507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_extent_skip_holes",
          "args": [
            "inode",
            "off",
            "last_for_get_extent",
            "get_extent"
          ],
          "line": 4505
        },
        "resolved": true,
        "details": {
          "function_name": "get_extent_skip_holes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4304-4338",
          "snippet": "static struct extent_map *get_extent_skip_holes(struct inode *inode,\n\t\t\t\t\t\tu64 offset,\n\t\t\t\t\t\tu64 last,\n\t\t\t\t\t\tget_extent_t *get_extent)\n{\n\tu64 sectorsize = BTRFS_I(inode)->root->sectorsize;\n\tstruct extent_map *em;\n\tu64 len;\n\n\tif (offset >= last)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tlen = last - offset;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tlen = ALIGN(len, sectorsize);\n\t\tem = get_extent(inode, NULL, 0, offset, len, 0);\n\t\tif (IS_ERR_OR_NULL(em))\n\t\t\treturn em;\n\n\t\t/* if this isn't a hole return it */\n\t\tif (!test_bit(EXTENT_FLAG_VACANCY, &em->flags) &&\n\t\t    em->block_start != EXTENT_MAP_HOLE) {\n\t\t\treturn em;\n\t\t}\n\n\t\t/* this is a hole, advance to the next extent */\n\t\toffset = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (offset >= last)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_map *get_extent_skip_holes(struct inode *inode,\n\t\t\t\t\t\tu64 offset,\n\t\t\t\t\t\tu64 last,\n\t\t\t\t\t\tget_extent_t *get_extent)\n{\n\tu64 sectorsize = BTRFS_I(inode)->root->sectorsize;\n\tstruct extent_map *em;\n\tu64 len;\n\n\tif (offset >= last)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tlen = last - offset;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tlen = ALIGN(len, sectorsize);\n\t\tem = get_extent(inode, NULL, 0, offset, len, 0);\n\t\tif (IS_ERR_OR_NULL(em))\n\t\t\treturn em;\n\n\t\t/* if this isn't a hole return it */\n\t\tif (!test_bit(EXTENT_FLAG_VACANCY, &em->flags) &&\n\t\t    em->block_start != EXTENT_MAP_HOLE) {\n\t\t\treturn em;\n\t\t}\n\n\t\t/* this is a hole, advance to the next extent */\n\t\toffset = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (offset >= last)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_COMPRESSED",
            "&em->flags"
          ],
          "line": 4493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_check_shared",
          "args": [
            "NULL",
            "root->fs_info",
            "root->objectid",
            "btrfs_ino(inode)",
            "bytenr"
          ],
          "line": 4484
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1201-1247",
          "snippet": "int btrfs_check_shared(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info, u64 root_objectid,\n\t\t       u64 inum, u64 bytenr)\n{\n\tstruct ulist *tmp = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *node;\n\tstruct seq_list elem = {};\n\tint ret = 0;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\troots = ulist_alloc(GFP_NOFS);\n\tif (!tmp || !roots) {\n\t\tulist_free(tmp);\n\t\tulist_free(roots);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (trans)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\telse\n\t\tdown_read(&fs_info->commit_root_sem);\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr, elem.seq, tmp,\n\t\t\t\t\troots, NULL, root_objectid, inum);\n\t\tif (ret == BACKREF_FOUND_SHARED) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tbreak;\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\tif (trans)\n\t\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\telse\n\t\tup_read(&fs_info->commit_root_sem);\n\tulist_free(tmp);\n\tulist_free(roots);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [
            "#define BACKREF_FOUND_SHARED 6"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\n#define BACKREF_FOUND_SHARED 6\n\nint btrfs_check_shared(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info, u64 root_objectid,\n\t\t       u64 inum, u64 bytenr)\n{\n\tstruct ulist *tmp = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *node;\n\tstruct seq_list elem = {};\n\tint ret = 0;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\troots = ulist_alloc(GFP_NOFS);\n\tif (!tmp || !roots) {\n\t\tulist_free(tmp);\n\t\tulist_free(roots);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (trans)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\telse\n\t\tdown_read(&fs_info->commit_root_sem);\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr, elem.seq, tmp,\n\t\t\t\t\troots, NULL, root_objectid, inum);\n\t\tif (ret == BACKREF_FOUND_SHARED) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tbreak;\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\tif (trans)\n\t\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\telse\n\t\tup_read(&fs_info->commit_root_sem);\n\tulist_free(tmp);\n\tulist_free(roots);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 4486
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 4458
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "em->start",
            "off"
          ],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "em"
          ],
          "line": 4423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "em"
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start",
            "start + len - 1",
            "0",
            "&cached_state"
          ],
          "line": 4415
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 4403
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 4385
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ret"
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_file_extent",
          "args": [
            "NULL",
            "root",
            "path",
            "btrfs_ino(inode)",
            "-1",
            "0"
          ],
          "line": 4377
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_file_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "139-154",
          "snippet": "int btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "max",
            "BTRFS_I(inode)->root->sectorsize"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "start",
            "BTRFS_I(inode)->root->sectorsize"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4365
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint extent_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n\t\t__u64 start, __u64 len, get_extent_t *get_extent)\n{\n\tint ret = 0;\n\tu64 off = start;\n\tu64 max = start + len;\n\tu32 flags = 0;\n\tu32 found_type;\n\tu64 last;\n\tu64 last_for_get_extent = 0;\n\tu64 disko = 0;\n\tu64 isize = i_size_read(inode);\n\tstruct btrfs_key found_key;\n\tstruct extent_map *em = NULL;\n\tstruct extent_state *cached_state = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint end = 0;\n\tu64 em_start = 0;\n\tu64 em_len = 0;\n\tu64 em_end = 0;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->leave_spinning = 1;\n\n\tstart = round_down(start, BTRFS_I(inode)->root->sectorsize);\n\tlen = round_up(max, BTRFS_I(inode)->root->sectorsize) - start;\n\n\t/*\n\t * lookup the last file extent.  We're not using i_size here\n\t * because there might be preallocation past i_size\n\t */\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(inode), -1,\n\t\t\t\t       0);\n\tif (ret < 0) {\n\t\tbtrfs_free_path(path);\n\t\treturn ret;\n\t}\n\tWARN_ON(!ret);\n\tpath->slots[0]--;\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found_key, path->slots[0]);\n\tfound_type = found_key.type;\n\n\t/* No extents, but there might be delalloc bits */\n\tif (found_key.objectid != btrfs_ino(inode) ||\n\t    found_type != BTRFS_EXTENT_DATA_KEY) {\n\t\t/* have to trust i_size as the end */\n\t\tlast = (u64)-1;\n\t\tlast_for_get_extent = isize;\n\t} else {\n\t\t/*\n\t\t * remember the start of the last extent.  There are a\n\t\t * bunch of different factors that go into the length of the\n\t\t * extent, so its much less complex to remember where it started\n\t\t */\n\t\tlast = found_key.offset;\n\t\tlast_for_get_extent = last + 1;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * we might have some extents allocated but more delalloc past those\n\t * extents.  so, we trust isize unless the start of the last extent is\n\t * beyond isize\n\t */\n\tif (last < isize) {\n\t\tlast = (u64)-1;\n\t\tlast_for_get_extent = isize;\n\t}\n\n\tlock_extent_bits(&BTRFS_I(inode)->io_tree, start, start + len - 1, 0,\n\t\t\t &cached_state);\n\n\tem = get_extent_skip_holes(inode, start, last_for_get_extent,\n\t\t\t\t   get_extent);\n\tif (!em)\n\t\tgoto out;\n\tif (IS_ERR(em)) {\n\t\tret = PTR_ERR(em);\n\t\tgoto out;\n\t}\n\n\twhile (!end) {\n\t\tu64 offset_in_extent = 0;\n\n\t\t/* break if the extent we found is outside the range */\n\t\tif (em->start >= max || extent_map_end(em) < off)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * get_extent may return an extent that starts before our\n\t\t * requested range.  We have to make sure the ranges\n\t\t * we return to fiemap always move forward and don't\n\t\t * overlap, so adjust the offsets here\n\t\t */\n\t\tem_start = max(em->start, off);\n\n\t\t/*\n\t\t * record the offset from the start of the extent\n\t\t * for adjusting the disk offset below.  Only do this if the\n\t\t * extent isn't compressed since our in ram offset may be past\n\t\t * what we have actually allocated on disk.\n\t\t */\n\t\tif (!test_bit(EXTENT_FLAG_COMPRESSED, &em->flags))\n\t\t\toffset_in_extent = em_start - em->start;\n\t\tem_end = extent_map_end(em);\n\t\tem_len = em_end - em_start;\n\t\tdisko = 0;\n\t\tflags = 0;\n\n\t\t/*\n\t\t * bump off for our next call to get_extent\n\t\t */\n\t\toff = extent_map_end(em);\n\t\tif (off >= max)\n\t\t\tend = 1;\n\n\t\tif (em->block_start == EXTENT_MAP_LAST_BYTE) {\n\t\t\tend = 1;\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\t\t} else if (em->block_start == EXTENT_MAP_INLINE) {\n\t\t\tflags |= (FIEMAP_EXTENT_DATA_INLINE |\n\t\t\t\t  FIEMAP_EXTENT_NOT_ALIGNED);\n\t\t} else if (em->block_start == EXTENT_MAP_DELALLOC) {\n\t\t\tflags |= (FIEMAP_EXTENT_DELALLOC |\n\t\t\t\t  FIEMAP_EXTENT_UNKNOWN);\n\t\t} else if (fieinfo->fi_extents_max) {\n\t\t\tu64 bytenr = em->block_start -\n\t\t\t\t(em->start - em->orig_start);\n\n\t\t\tdisko = em->block_start + offset_in_extent;\n\n\t\t\t/*\n\t\t\t * As btrfs supports shared space, this information\n\t\t\t * can be exported to userspace tools via\n\t\t\t * flag FIEMAP_EXTENT_SHARED.  If fi_extents_max == 0\n\t\t\t * then we're just getting a count and we can skip the\n\t\t\t * lookup stuff.\n\t\t\t */\n\t\t\tret = btrfs_check_shared(NULL, root->fs_info,\n\t\t\t\t\t\t root->objectid,\n\t\t\t\t\t\t btrfs_ino(inode), bytenr);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_free;\n\t\t\tif (ret)\n\t\t\t\tflags |= FIEMAP_EXTENT_SHARED;\n\t\t\tret = 0;\n\t\t}\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags))\n\t\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\t\tif ((em_start >= last) || em_len == (u64)-1 ||\n\t\t   (last == (u64)-1 && isize <= em_end)) {\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\t\t\tend = 1;\n\t\t}\n\n\t\t/* now scan forward to see if this is really the last extent. */\n\t\tem = get_extent_skip_holes(inode, off, last_for_get_extent,\n\t\t\t\t\t   get_extent);\n\t\tif (IS_ERR(em)) {\n\t\t\tret = PTR_ERR(em);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!em) {\n\t\t\tflags |= FIEMAP_EXTENT_LAST;\n\t\t\tend = 1;\n\t\t}\n\t\tret = fiemap_fill_next_extent(fieinfo, em_start, disko,\n\t\t\t\t\t      em_len, flags);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\nout_free:\n\tfree_extent_map(em);\nout:\n\tbtrfs_free_path(path);\n\tunlock_extent_cached(&BTRFS_I(inode)->io_tree, start, start + len - 1,\n\t\t\t     &cached_state, GFP_NOFS);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_extent_skip_holes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4304-4338",
    "snippet": "static struct extent_map *get_extent_skip_holes(struct inode *inode,\n\t\t\t\t\t\tu64 offset,\n\t\t\t\t\t\tu64 last,\n\t\t\t\t\t\tget_extent_t *get_extent)\n{\n\tu64 sectorsize = BTRFS_I(inode)->root->sectorsize;\n\tstruct extent_map *em;\n\tu64 len;\n\n\tif (offset >= last)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tlen = last - offset;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tlen = ALIGN(len, sectorsize);\n\t\tem = get_extent(inode, NULL, 0, offset, len, 0);\n\t\tif (IS_ERR_OR_NULL(em))\n\t\t\treturn em;\n\n\t\t/* if this isn't a hole return it */\n\t\tif (!test_bit(EXTENT_FLAG_VACANCY, &em->flags) &&\n\t\t    em->block_start != EXTENT_MAP_HOLE) {\n\t\t\treturn em;\n\t\t}\n\n\t\t/* this is a hole, advance to the next extent */\n\t\toffset = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (offset >= last)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4333
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 4332
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_VACANCY",
            "&em->flags"
          ],
          "line": 4326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "em"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_extent",
          "args": [
            "inode",
            "NULL",
            "0",
            "offset",
            "len",
            "0"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "len",
            "sectorsize"
          ],
          "line": 4320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4309
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_map *get_extent_skip_holes(struct inode *inode,\n\t\t\t\t\t\tu64 offset,\n\t\t\t\t\t\tu64 last,\n\t\t\t\t\t\tget_extent_t *get_extent)\n{\n\tu64 sectorsize = BTRFS_I(inode)->root->sectorsize;\n\tstruct extent_map *em;\n\tu64 len;\n\n\tif (offset >= last)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tlen = last - offset;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tlen = ALIGN(len, sectorsize);\n\t\tem = get_extent(inode, NULL, 0, offset, len, 0);\n\t\tif (IS_ERR_OR_NULL(em))\n\t\t\treturn em;\n\n\t\t/* if this isn't a hole return it */\n\t\tif (!test_bit(EXTENT_FLAG_VACANCY, &em->flags) &&\n\t\t    em->block_start != EXTENT_MAP_HOLE) {\n\t\t\treturn em;\n\t\t}\n\n\t\t/* this is a hole, advance to the next extent */\n\t\toffset = extent_map_end(em);\n\t\tfree_extent_map(em);\n\t\tif (offset >= last)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "try_release_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4257-4298",
    "snippet": "int try_release_extent_mapping(struct extent_map_tree *map,\n\t\t\t       struct extent_io_tree *tree, struct page *page,\n\t\t\t       gfp_t mask)\n{\n\tstruct extent_map *em;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\n\tif ((mask & __GFP_WAIT) &&\n\t    page->mapping->host->i_size > 16 * 1024 * 1024) {\n\t\tu64 len;\n\t\twhile (start <= end) {\n\t\t\tlen = end - start + 1;\n\t\t\twrite_lock(&map->lock);\n\t\t\tem = lookup_extent_mapping(map, start, len);\n\t\t\tif (!em) {\n\t\t\t\twrite_unlock(&map->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (test_bit(EXTENT_FLAG_PINNED, &em->flags) ||\n\t\t\t    em->start != start) {\n\t\t\t\twrite_unlock(&map->lock);\n\t\t\t\tfree_extent_map(em);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!test_range_bit(tree, em->start,\n\t\t\t\t\t    extent_map_end(em) - 1,\n\t\t\t\t\t    EXTENT_LOCKED | EXTENT_WRITEBACK,\n\t\t\t\t\t    0, NULL)) {\n\t\t\t\tremove_extent_mapping(map, em);\n\t\t\t\t/* once for the rb tree */\n\t\t\t\tfree_extent_map(em);\n\t\t\t}\n\t\t\tstart = extent_map_end(em);\n\t\t\twrite_unlock(&map->lock);\n\n\t\t\t/* once for us */\n\t\t\tfree_extent_map(em);\n\t\t}\n\t}\n\treturn try_release_extent_state(map, tree, page, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_release_extent_state",
          "args": [
            "map",
            "tree",
            "page",
            "mask"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "try_release_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4219-4250",
          "snippet": "static int try_release_extent_state(struct extent_map_tree *map,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *page, gfp_t mask)\n{\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret = 1;\n\n\tif (test_range_bit(tree, start, end,\n\t\t\t   EXTENT_IOBITS, 0, NULL))\n\t\tret = 0;\n\telse {\n\t\tif ((mask & GFP_NOFS) == GFP_NOFS)\n\t\t\tmask = GFP_NOFS;\n\t\t/*\n\t\t * at this point we can safely clear everything except the\n\t\t * locked bit and the nodatasum bit\n\t\t */\n\t\tret = clear_extent_bit(tree, start, end,\n\t\t\t\t ~(EXTENT_LOCKED | EXTENT_NODATASUM),\n\t\t\t\t 0, 0, NULL, mask);\n\n\t\t/* if clear_extent_bit failed for enomem reasons,\n\t\t * we can't allow the release to continue.\n\t\t */\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = 1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int try_release_extent_state(struct extent_map_tree *map,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *page, gfp_t mask)\n{\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret = 1;\n\n\tif (test_range_bit(tree, start, end,\n\t\t\t   EXTENT_IOBITS, 0, NULL))\n\t\tret = 0;\n\telse {\n\t\tif ((mask & GFP_NOFS) == GFP_NOFS)\n\t\t\tmask = GFP_NOFS;\n\t\t/*\n\t\t * at this point we can safely clear everything except the\n\t\t * locked bit and the nodatasum bit\n\t\t */\n\t\tret = clear_extent_bit(tree, start, end,\n\t\t\t\t ~(EXTENT_LOCKED | EXTENT_NODATASUM),\n\t\t\t\t 0, 0, NULL, mask);\n\n\t\t/* if clear_extent_bit failed for enomem reasons,\n\t\t * we can't allow the release to continue.\n\t\t */\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = 1;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&map->lock"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 4290
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_extent_mapping",
          "args": [
            "map",
            "em"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "remove_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "430-440",
          "snippet": "int remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint remove_extent_mapping(struct extent_map_tree *tree, struct extent_map *em)\n{\n\tint ret = 0;\n\n\tWARN_ON(test_bit(EXTENT_FLAG_PINNED, &em->flags));\n\trb_erase(&em->rb_node, &tree->map);\n\tif (!test_bit(EXTENT_FLAG_LOGGING, &em->flags))\n\t\tlist_del_init(&em->list);\n\tRB_CLEAR_NODE(&em->rb_node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_range_bit",
          "args": [
            "tree",
            "em->start",
            "extent_map_end(em) - 1",
            "EXTENT_LOCKED | EXTENT_WRITEBACK",
            "0",
            "NULL"
          ],
          "line": 4282
        },
        "resolved": true,
        "details": {
          "function_name": "test_range_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1931-1979",
          "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_PINNED",
            "&em->flags"
          ],
          "line": 4276
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "map",
            "start",
            "len"
          ],
          "line": 4271
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&map->lock"
          ],
          "line": 4270
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 4262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint try_release_extent_mapping(struct extent_map_tree *map,\n\t\t\t       struct extent_io_tree *tree, struct page *page,\n\t\t\t       gfp_t mask)\n{\n\tstruct extent_map *em;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\n\tif ((mask & __GFP_WAIT) &&\n\t    page->mapping->host->i_size > 16 * 1024 * 1024) {\n\t\tu64 len;\n\t\twhile (start <= end) {\n\t\t\tlen = end - start + 1;\n\t\t\twrite_lock(&map->lock);\n\t\t\tem = lookup_extent_mapping(map, start, len);\n\t\t\tif (!em) {\n\t\t\t\twrite_unlock(&map->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (test_bit(EXTENT_FLAG_PINNED, &em->flags) ||\n\t\t\t    em->start != start) {\n\t\t\t\twrite_unlock(&map->lock);\n\t\t\t\tfree_extent_map(em);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!test_range_bit(tree, em->start,\n\t\t\t\t\t    extent_map_end(em) - 1,\n\t\t\t\t\t    EXTENT_LOCKED | EXTENT_WRITEBACK,\n\t\t\t\t\t    0, NULL)) {\n\t\t\t\tremove_extent_mapping(map, em);\n\t\t\t\t/* once for the rb tree */\n\t\t\t\tfree_extent_map(em);\n\t\t\t}\n\t\t\tstart = extent_map_end(em);\n\t\t\twrite_unlock(&map->lock);\n\n\t\t\t/* once for us */\n\t\t\tfree_extent_map(em);\n\t\t}\n\t}\n\treturn try_release_extent_state(map, tree, page, mask);\n}"
  },
  {
    "function_name": "try_release_extent_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4219-4250",
    "snippet": "static int try_release_extent_state(struct extent_map_tree *map,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *page, gfp_t mask)\n{\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret = 1;\n\n\tif (test_range_bit(tree, start, end,\n\t\t\t   EXTENT_IOBITS, 0, NULL))\n\t\tret = 0;\n\telse {\n\t\tif ((mask & GFP_NOFS) == GFP_NOFS)\n\t\t\tmask = GFP_NOFS;\n\t\t/*\n\t\t * at this point we can safely clear everything except the\n\t\t * locked bit and the nodatasum bit\n\t\t */\n\t\tret = clear_extent_bit(tree, start, end,\n\t\t\t\t ~(EXTENT_LOCKED | EXTENT_NODATASUM),\n\t\t\t\t 0, 0, NULL, mask);\n\n\t\t/* if clear_extent_bit failed for enomem reasons,\n\t\t * we can't allow the release to continue.\n\t\t */\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = 1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "~(EXTENT_LOCKED | EXTENT_NODATASUM)",
            "0",
            "0",
            "NULL",
            "mask"
          ],
          "line": 4237
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_range_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_IOBITS",
            "0",
            "NULL"
          ],
          "line": 4227
        },
        "resolved": true,
        "details": {
          "function_name": "test_range_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1931-1979",
          "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int try_release_extent_state(struct extent_map_tree *map,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *page, gfp_t mask)\n{\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret = 1;\n\n\tif (test_range_bit(tree, start, end,\n\t\t\t   EXTENT_IOBITS, 0, NULL))\n\t\tret = 0;\n\telse {\n\t\tif ((mask & GFP_NOFS) == GFP_NOFS)\n\t\t\tmask = GFP_NOFS;\n\t\t/*\n\t\t * at this point we can safely clear everything except the\n\t\t * locked bit and the nodatasum bit\n\t\t */\n\t\tret = clear_extent_bit(tree, start, end,\n\t\t\t\t ~(EXTENT_LOCKED | EXTENT_NODATASUM),\n\t\t\t\t 0, 0, NULL, mask);\n\n\t\t/* if clear_extent_bit failed for enomem reasons,\n\t\t * we can't allow the release to continue.\n\t\t */\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "extent_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4193-4212",
    "snippet": "int extent_invalidatepage(struct extent_io_tree *tree,\n\t\t\t  struct page *page, unsigned long offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tsize_t blocksize = page->mapping->host->i_sb->s_blocksize;\n\n\tstart += ALIGN(offset, blocksize);\n\tif (start > end)\n\t\treturn 0;\n\n\tlock_extent_bits(tree, start, end, 0, &cached_state);\n\twait_on_page_writeback(page);\n\tclear_extent_bit(tree, start, end,\n\t\t\t EXTENT_LOCKED | EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t EXTENT_DO_ACCOUNTING,\n\t\t\t 1, 1, &cached_state, GFP_NOFS);\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_LOCKED | EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t EXTENT_DO_ACCOUNTING",
            "1",
            "1",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "tree",
            "start",
            "end",
            "0",
            "&cached_state"
          ],
          "line": 4205
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "offset",
            "blocksize"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_invalidatepage(struct extent_io_tree *tree,\n\t\t\t  struct page *page, unsigned long offset)\n{\n\tstruct extent_state *cached_state = NULL;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tsize_t blocksize = page->mapping->host->i_sb->s_blocksize;\n\n\tstart += ALIGN(offset, blocksize);\n\tif (start > end)\n\t\treturn 0;\n\n\tlock_extent_bits(tree, start, end, 0, &cached_state);\n\twait_on_page_writeback(page);\n\tclear_extent_bit(tree, start, end,\n\t\t\t EXTENT_LOCKED | EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t EXTENT_DO_ACCOUNTING,\n\t\t\t 1, 1, &cached_state, GFP_NOFS);\n\treturn 0;\n}"
  },
  {
    "function_name": "extent_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4144-4186",
    "snippet": "int extent_readpages(struct extent_io_tree *tree,\n\t\t     struct address_space *mapping,\n\t\t     struct list_head *pages, unsigned nr_pages,\n\t\t     get_extent_t get_extent)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tunsigned long bio_flags = 0;\n\tstruct page *pagepool[16];\n\tstruct page *page;\n\tstruct extent_map *em_cached = NULL;\n\tint nr = 0;\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tpage = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_NOFS)) {\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpagepool[nr++] = page;\n\t\tif (nr < ARRAY_SIZE(pagepool))\n\t\t\tcontinue;\n\t\t__extent_readpages(tree, pagepool, nr, get_extent, &em_cached,\n\t\t\t\t   &bio, 0, &bio_flags, READ);\n\t\tnr = 0;\n\t}\n\tif (nr)\n\t\t__extent_readpages(tree, pagepool, nr, get_extent, &em_cached,\n\t\t\t\t   &bio, 0, &bio_flags, READ);\n\n\tif (em_cached)\n\t\tfree_extent_map(em_cached);\n\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\treturn submit_one_bio(READ, bio, 0, bio_flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_one_bio",
          "args": [
            "READ",
            "bio",
            "0",
            "bio_flags"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "submit_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2749-2774",
          "snippet": "static int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(pages)"
          ],
          "line": 4182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "pages"
          ],
          "line": 4182
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em_cached"
          ],
          "line": 4180
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__extent_readpages",
          "args": [
            "tree",
            "pagepool",
            "nr",
            "get_extent",
            "&em_cached",
            "&bio",
            "0",
            "&bio_flags",
            "READ"
          ],
          "line": 4176
        },
        "resolved": true,
        "details": {
          "function_name": "__extent_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3108-3146",
          "snippet": "static void __extent_readpages(struct extent_io_tree *tree,\n\t\t\t       struct page *pages[],\n\t\t\t       int nr_pages, get_extent_t *get_extent,\n\t\t\t       struct extent_map **em_cached,\n\t\t\t       struct bio **bio, int mirror_num,\n\t\t\t       unsigned long *bio_flags, int rw)\n{\n\tu64 start = 0;\n\tu64 end = 0;\n\tu64 page_start;\n\tint index;\n\tint first_index = 0;\n\n\tfor (index = 0; index < nr_pages; index++) {\n\t\tpage_start = page_offset(pages[index]);\n\t\tif (!end) {\n\t\t\tstart = page_start;\n\t\t\tend = start + PAGE_CACHE_SIZE - 1;\n\t\t\tfirst_index = index;\n\t\t} else if (end + 1 == page_start) {\n\t\t\tend += PAGE_CACHE_SIZE;\n\t\t} else {\n\t\t\t__do_contiguous_readpages(tree, &pages[first_index],\n\t\t\t\t\t\t  index - first_index, start,\n\t\t\t\t\t\t  end, get_extent, em_cached,\n\t\t\t\t\t\t  bio, mirror_num, bio_flags,\n\t\t\t\t\t\t  rw);\n\t\t\tstart = page_start;\n\t\t\tend = start + PAGE_CACHE_SIZE - 1;\n\t\t\tfirst_index = index;\n\t\t}\n\t}\n\n\tif (end)\n\t\t__do_contiguous_readpages(tree, &pages[first_index],\n\t\t\t\t\t  index - first_index, start,\n\t\t\t\t\t  end, get_extent, em_cached, bio,\n\t\t\t\t\t  mirror_num, bio_flags, rw);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void __extent_readpages(struct extent_io_tree *tree,\n\t\t\t       struct page *pages[],\n\t\t\t       int nr_pages, get_extent_t *get_extent,\n\t\t\t       struct extent_map **em_cached,\n\t\t\t       struct bio **bio, int mirror_num,\n\t\t\t       unsigned long *bio_flags, int rw)\n{\n\tu64 start = 0;\n\tu64 end = 0;\n\tu64 page_start;\n\tint index;\n\tint first_index = 0;\n\n\tfor (index = 0; index < nr_pages; index++) {\n\t\tpage_start = page_offset(pages[index]);\n\t\tif (!end) {\n\t\t\tstart = page_start;\n\t\t\tend = start + PAGE_CACHE_SIZE - 1;\n\t\t\tfirst_index = index;\n\t\t} else if (end + 1 == page_start) {\n\t\t\tend += PAGE_CACHE_SIZE;\n\t\t} else {\n\t\t\t__do_contiguous_readpages(tree, &pages[first_index],\n\t\t\t\t\t\t  index - first_index, start,\n\t\t\t\t\t\t  end, get_extent, em_cached,\n\t\t\t\t\t\t  bio, mirror_num, bio_flags,\n\t\t\t\t\t\t  rw);\n\t\t\tstart = page_start;\n\t\t\tend = start + PAGE_CACHE_SIZE - 1;\n\t\t\tfirst_index = index;\n\t\t}\n\t}\n\n\tif (end)\n\t\t__do_contiguous_readpages(tree, &pages[first_index],\n\t\t\t\t\t  index - first_index, start,\n\t\t\t\t\t  end, get_extent, em_cached, bio,\n\t\t\t\t\t  mirror_num, bio_flags, rw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pagepool"
          ],
          "line": 4169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "page->index",
            "GFP_NOFS"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&page->lru"
          ],
          "line": 4161
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefetchw",
          "args": [
            "&page->flags"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pages->prev",
            "structpage",
            "lru"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_readpages(struct extent_io_tree *tree,\n\t\t     struct address_space *mapping,\n\t\t     struct list_head *pages, unsigned nr_pages,\n\t\t     get_extent_t get_extent)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tunsigned long bio_flags = 0;\n\tstruct page *pagepool[16];\n\tstruct page *page;\n\tstruct extent_map *em_cached = NULL;\n\tint nr = 0;\n\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tpage = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_NOFS)) {\n\t\t\tpage_cache_release(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpagepool[nr++] = page;\n\t\tif (nr < ARRAY_SIZE(pagepool))\n\t\t\tcontinue;\n\t\t__extent_readpages(tree, pagepool, nr, get_extent, &em_cached,\n\t\t\t\t   &bio, 0, &bio_flags, READ);\n\t\tnr = 0;\n\t}\n\tif (nr)\n\t\t__extent_readpages(tree, pagepool, nr, get_extent, &em_cached,\n\t\t\t\t   &bio, 0, &bio_flags, READ);\n\n\tif (em_cached)\n\t\tfree_extent_map(em_cached);\n\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\treturn submit_one_bio(READ, bio, 0, bio_flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "extent_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4122-4142",
    "snippet": "int extent_writepages(struct extent_io_tree *tree,\n\t\t      struct address_space *mapping,\n\t\t      get_extent_t *get_extent,\n\t\t      struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.get_extent = get_extent,\n\t\t.extent_locked = 0,\n\t\t.sync_io = wbc->sync_mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\n\tret = extent_write_cache_pages(tree, mapping, wbc,\n\t\t\t\t       __extent_writepage, &epd,\n\t\t\t\t       flush_write_bio);\n\tflush_epd_write_bio(&epd);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_epd_write_bio",
          "args": [
            "&epd"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "flush_epd_write_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4037-4050",
          "snippet": "static void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_write_cache_pages",
          "args": [
            "tree",
            "mapping",
            "wbc",
            "__extent_writepage",
            "&epd",
            "flush_write_bio"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "extent_write_cache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3915-4035",
          "snippet": "static int extent_write_cache_pages(struct extent_io_tree *tree,\n\t\t\t     struct address_space *mapping,\n\t\t\t     struct writeback_control *wbc,\n\t\t\t     writepage_t writepage, void *data,\n\t\t\t     void (*flush_fn)(void *))\n{\n\tstruct inode *inode = mapping->host;\n\tint ret = 0;\n\tint done = 0;\n\tint err = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tint scanned = 0;\n\tint tag;\n\n\t/*\n\t * We have to hold onto the inode so that ordered extents can do their\n\t * work when the IO finishes.  The alternative to this is failing to add\n\t * an ordered extent if the igrab() fails there and that is a huge pain\n\t * to deal with, so instead just hold onto the inode throughout the\n\t * writepages operation.  If it fails here we are freeing up the inode\n\t * anyway and we'd rather not waste our time writing out stuff that is\n\t * going to be truncated anyway.\n\t */\n\tif (!igrab(inode))\n\t\treturn 0;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point we hold neither mapping->tree_lock nor\n\t\t\t * lock on the page itself: the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or even\n\t\t\t * swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping\n\t\t\t */\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tflush_fn(data);\n\t\t\t\tlock_page(page);\n\t\t\t}\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdone = 1;\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tflush_fn(data);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t}\n\n\t\t\tif (PageWriteback(page) ||\n\t\t\t    !clear_page_dirty_for_io(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = (*writepage)(page, wbc, data);\n\n\t\t\tif (unlikely(ret == AOP_WRITEPAGE_ACTIVATE)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tif (!err && ret < 0)\n\t\t\t\terr = ret;\n\n\t\t\t/*\n\t\t\t * the filesystem may choose to bump up nr_to_write.\n\t\t\t * We have to make sure to honor the new nr_to_write\n\t\t\t * at any time\n\t\t\t */\n\t\t\tnr_to_write_done = wbc->nr_to_write <= 0;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (!scanned && !done && !err) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = 1;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\tbtrfs_add_delayed_iput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void flush_write_bio(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstatic int extent_write_cache_pages(struct extent_io_tree *tree,\n\t\t\t     struct address_space *mapping,\n\t\t\t     struct writeback_control *wbc,\n\t\t\t     writepage_t writepage, void *data,\n\t\t\t     void (*flush_fn)(void *))\n{\n\tstruct inode *inode = mapping->host;\n\tint ret = 0;\n\tint done = 0;\n\tint err = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tint scanned = 0;\n\tint tag;\n\n\t/*\n\t * We have to hold onto the inode so that ordered extents can do their\n\t * work when the IO finishes.  The alternative to this is failing to add\n\t * an ordered extent if the igrab() fails there and that is a huge pain\n\t * to deal with, so instead just hold onto the inode throughout the\n\t * writepages operation.  If it fails here we are freeing up the inode\n\t * anyway and we'd rather not waste our time writing out stuff that is\n\t * going to be truncated anyway.\n\t */\n\tif (!igrab(inode))\n\t\treturn 0;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point we hold neither mapping->tree_lock nor\n\t\t\t * lock on the page itself: the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or even\n\t\t\t * swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping\n\t\t\t */\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tflush_fn(data);\n\t\t\t\tlock_page(page);\n\t\t\t}\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdone = 1;\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tflush_fn(data);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t}\n\n\t\t\tif (PageWriteback(page) ||\n\t\t\t    !clear_page_dirty_for_io(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = (*writepage)(page, wbc, data);\n\n\t\t\tif (unlikely(ret == AOP_WRITEPAGE_ACTIVATE)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tif (!err && ret < 0)\n\t\t\t\terr = ret;\n\n\t\t\t/*\n\t\t\t * the filesystem may choose to bump up nr_to_write.\n\t\t\t * We have to make sure to honor the new nr_to_write\n\t\t\t * at any time\n\t\t\t */\n\t\t\tnr_to_write_done = wbc->nr_to_write <= 0;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (!scanned && !done && !err) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = 1;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\tbtrfs_add_delayed_iput(inode);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_writepages(struct extent_io_tree *tree,\n\t\t      struct address_space *mapping,\n\t\t      get_extent_t *get_extent,\n\t\t      struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.get_extent = get_extent,\n\t\t.extent_locked = 0,\n\t\t.sync_io = wbc->sync_mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\n\tret = extent_write_cache_pages(tree, mapping, wbc,\n\t\t\t\t       __extent_writepage, &epd,\n\t\t\t\t       flush_write_bio);\n\tflush_epd_write_bio(&epd);\n\treturn ret;\n}"
  },
  {
    "function_name": "extent_write_locked_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4078-4120",
    "snippet": "int extent_write_locked_range(struct extent_io_tree *tree, struct inode *inode,\n\t\t\t      u64 start, u64 end, get_extent_t *get_extent,\n\t\t\t      int mode)\n{\n\tint ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tunsigned long nr_pages = (end - start + PAGE_CACHE_SIZE) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.get_extent = get_extent,\n\t\t.extent_locked = 1,\n\t\t.sync_io = mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\tstruct writeback_control wbc_writepages = {\n\t\t.sync_mode\t= mode,\n\t\t.nr_to_write\t= nr_pages * 2,\n\t\t.range_start\t= start,\n\t\t.range_end\t= end + 1,\n\t};\n\n\twhile (start <= end) {\n\t\tpage = find_get_page(mapping, start >> PAGE_CACHE_SHIFT);\n\t\tif (clear_page_dirty_for_io(page))\n\t\t\tret = __extent_writepage(page, &wbc_writepages, &epd);\n\t\telse {\n\t\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t\t start + PAGE_CACHE_SIZE - 1,\n\t\t\t\t\t\t NULL, 1);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t\tstart += PAGE_CACHE_SIZE;\n\t}\n\n\tflush_epd_write_bio(&epd);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_epd_write_bio",
          "args": [
            "&epd"
          ],
          "line": 4118
        },
        "resolved": true,
        "details": {
          "function_name": "flush_epd_write_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4037-4050",
          "snippet": "static void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree->ops->writepage_end_io_hook",
          "args": [
            "page",
            "start",
            "start + PAGE_CACHE_SIZE - 1",
            "NULL",
            "1"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__extent_writepage",
          "args": [
            "page",
            "&wbc_writepages",
            "&epd"
          ],
          "line": 4106
        },
        "resolved": true,
        "details": {
          "function_name": "__extent_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3474-3548",
          "snippet": "static int __extent_writepage(struct page *page, struct writeback_control *wbc,\n\t\t\t      void *data)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_page_data *epd = data;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\tint nr = 0;\n\tsize_t pg_offset = 0;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned long end_index = i_size >> PAGE_CACHE_SHIFT;\n\tint write_flags;\n\tunsigned long nr_written = 0;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\twrite_flags = WRITE_SYNC;\n\telse\n\t\twrite_flags = WRITE;\n\n\ttrace___extent_writepage(page, inode, wbc);\n\n\tWARN_ON(!PageLocked(page));\n\n\tClearPageError(page);\n\n\tpg_offset = i_size & (PAGE_CACHE_SIZE - 1);\n\tif (page->index > end_index ||\n\t   (page->index == end_index && !pg_offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (page->index == end_index) {\n\t\tchar *userpage;\n\n\t\tuserpage = kmap_atomic(page);\n\t\tmemset(userpage + pg_offset, 0,\n\t\t       PAGE_CACHE_SIZE - pg_offset);\n\t\tkunmap_atomic(userpage);\n\t\tflush_dcache_page(page);\n\t}\n\n\tpg_offset = 0;\n\n\tset_page_extent_mapped(page);\n\n\tret = writepage_delalloc(inode, page, wbc, epd, start, &nr_written);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\tif (ret)\n\t\tgoto done;\n\n\tret = __extent_writepage_io(inode, page, wbc, epd,\n\t\t\t\t    i_size, nr_written, write_flags, &nr);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\ndone:\n\tif (nr == 0) {\n\t\t/* make sure the mapping tag for page dirty gets cleared */\n\t\tset_page_writeback(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (PageError(page)) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tend_extent_writepage(page, ret, start, page_end);\n\t}\n\tunlock_page(page);\n\treturn ret;\n\ndone_unlocked:\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void flush_write_bio(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstatic int __extent_writepage(struct page *page, struct writeback_control *wbc,\n\t\t\t      void *data)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_page_data *epd = data;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\tint nr = 0;\n\tsize_t pg_offset = 0;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned long end_index = i_size >> PAGE_CACHE_SHIFT;\n\tint write_flags;\n\tunsigned long nr_written = 0;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\twrite_flags = WRITE_SYNC;\n\telse\n\t\twrite_flags = WRITE;\n\n\ttrace___extent_writepage(page, inode, wbc);\n\n\tWARN_ON(!PageLocked(page));\n\n\tClearPageError(page);\n\n\tpg_offset = i_size & (PAGE_CACHE_SIZE - 1);\n\tif (page->index > end_index ||\n\t   (page->index == end_index && !pg_offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (page->index == end_index) {\n\t\tchar *userpage;\n\n\t\tuserpage = kmap_atomic(page);\n\t\tmemset(userpage + pg_offset, 0,\n\t\t       PAGE_CACHE_SIZE - pg_offset);\n\t\tkunmap_atomic(userpage);\n\t\tflush_dcache_page(page);\n\t}\n\n\tpg_offset = 0;\n\n\tset_page_extent_mapped(page);\n\n\tret = writepage_delalloc(inode, page, wbc, epd, start, &nr_written);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\tif (ret)\n\t\tgoto done;\n\n\tret = __extent_writepage_io(inode, page, wbc, epd,\n\t\t\t\t    i_size, nr_written, write_flags, &nr);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\ndone:\n\tif (nr == 0) {\n\t\t/* make sure the mapping tag for page dirty gets cleared */\n\t\tset_page_writeback(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (PageError(page)) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tend_extent_writepage(page, ret, start, page_end);\n\t}\n\tunlock_page(page);\n\treturn ret;\n\ndone_unlocked:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "start >> PAGE_CACHE_SHIFT"
          ],
          "line": 4104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_write_locked_range(struct extent_io_tree *tree, struct inode *inode,\n\t\t\t      u64 start, u64 end, get_extent_t *get_extent,\n\t\t\t      int mode)\n{\n\tint ret = 0;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tunsigned long nr_pages = (end - start + PAGE_CACHE_SIZE) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.get_extent = get_extent,\n\t\t.extent_locked = 1,\n\t\t.sync_io = mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\tstruct writeback_control wbc_writepages = {\n\t\t.sync_mode\t= mode,\n\t\t.nr_to_write\t= nr_pages * 2,\n\t\t.range_start\t= start,\n\t\t.range_end\t= end + 1,\n\t};\n\n\twhile (start <= end) {\n\t\tpage = find_get_page(mapping, start >> PAGE_CACHE_SHIFT);\n\t\tif (clear_page_dirty_for_io(page))\n\t\t\tret = __extent_writepage(page, &wbc_writepages, &epd);\n\t\telse {\n\t\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t\t start + PAGE_CACHE_SIZE - 1,\n\t\t\t\t\t\t NULL, 1);\n\t\t\tunlock_page(page);\n\t\t}\n\t\tpage_cache_release(page);\n\t\tstart += PAGE_CACHE_SIZE;\n\t}\n\n\tflush_epd_write_bio(&epd);\n\treturn ret;\n}"
  },
  {
    "function_name": "extent_write_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4058-4076",
    "snippet": "int extent_write_full_page(struct extent_io_tree *tree, struct page *page,\n\t\t\t  get_extent_t *get_extent,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret;\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.get_extent = get_extent,\n\t\t.extent_locked = 0,\n\t\t.sync_io = wbc->sync_mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\n\tret = __extent_writepage(page, wbc, &epd);\n\n\tflush_epd_write_bio(&epd);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_epd_write_bio",
          "args": [
            "&epd"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "flush_epd_write_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4037-4050",
          "snippet": "static void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__extent_writepage",
          "args": [
            "page",
            "wbc",
            "&epd"
          ],
          "line": 4072
        },
        "resolved": true,
        "details": {
          "function_name": "__extent_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3474-3548",
          "snippet": "static int __extent_writepage(struct page *page, struct writeback_control *wbc,\n\t\t\t      void *data)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_page_data *epd = data;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\tint nr = 0;\n\tsize_t pg_offset = 0;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned long end_index = i_size >> PAGE_CACHE_SHIFT;\n\tint write_flags;\n\tunsigned long nr_written = 0;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\twrite_flags = WRITE_SYNC;\n\telse\n\t\twrite_flags = WRITE;\n\n\ttrace___extent_writepage(page, inode, wbc);\n\n\tWARN_ON(!PageLocked(page));\n\n\tClearPageError(page);\n\n\tpg_offset = i_size & (PAGE_CACHE_SIZE - 1);\n\tif (page->index > end_index ||\n\t   (page->index == end_index && !pg_offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (page->index == end_index) {\n\t\tchar *userpage;\n\n\t\tuserpage = kmap_atomic(page);\n\t\tmemset(userpage + pg_offset, 0,\n\t\t       PAGE_CACHE_SIZE - pg_offset);\n\t\tkunmap_atomic(userpage);\n\t\tflush_dcache_page(page);\n\t}\n\n\tpg_offset = 0;\n\n\tset_page_extent_mapped(page);\n\n\tret = writepage_delalloc(inode, page, wbc, epd, start, &nr_written);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\tif (ret)\n\t\tgoto done;\n\n\tret = __extent_writepage_io(inode, page, wbc, epd,\n\t\t\t\t    i_size, nr_written, write_flags, &nr);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\ndone:\n\tif (nr == 0) {\n\t\t/* make sure the mapping tag for page dirty gets cleared */\n\t\tset_page_writeback(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (PageError(page)) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tend_extent_writepage(page, ret, start, page_end);\n\t}\n\tunlock_page(page);\n\treturn ret;\n\ndone_unlocked:\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void flush_write_bio(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstatic int __extent_writepage(struct page *page, struct writeback_control *wbc,\n\t\t\t      void *data)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_page_data *epd = data;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\tint nr = 0;\n\tsize_t pg_offset = 0;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned long end_index = i_size >> PAGE_CACHE_SHIFT;\n\tint write_flags;\n\tunsigned long nr_written = 0;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\twrite_flags = WRITE_SYNC;\n\telse\n\t\twrite_flags = WRITE;\n\n\ttrace___extent_writepage(page, inode, wbc);\n\n\tWARN_ON(!PageLocked(page));\n\n\tClearPageError(page);\n\n\tpg_offset = i_size & (PAGE_CACHE_SIZE - 1);\n\tif (page->index > end_index ||\n\t   (page->index == end_index && !pg_offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (page->index == end_index) {\n\t\tchar *userpage;\n\n\t\tuserpage = kmap_atomic(page);\n\t\tmemset(userpage + pg_offset, 0,\n\t\t       PAGE_CACHE_SIZE - pg_offset);\n\t\tkunmap_atomic(userpage);\n\t\tflush_dcache_page(page);\n\t}\n\n\tpg_offset = 0;\n\n\tset_page_extent_mapped(page);\n\n\tret = writepage_delalloc(inode, page, wbc, epd, start, &nr_written);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\tif (ret)\n\t\tgoto done;\n\n\tret = __extent_writepage_io(inode, page, wbc, epd,\n\t\t\t\t    i_size, nr_written, write_flags, &nr);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\ndone:\n\tif (nr == 0) {\n\t\t/* make sure the mapping tag for page dirty gets cleared */\n\t\tset_page_writeback(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (PageError(page)) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tend_extent_writepage(page, ret, start, page_end);\n\t}\n\tunlock_page(page);\n\treturn ret;\n\ndone_unlocked:\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_write_full_page(struct extent_io_tree *tree, struct page *page,\n\t\t\t  get_extent_t *get_extent,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret;\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.get_extent = get_extent,\n\t\t.extent_locked = 0,\n\t\t.sync_io = wbc->sync_mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\n\tret = __extent_writepage(page, wbc, &epd);\n\n\tflush_epd_write_bio(&epd);\n\treturn ret;\n}"
  },
  {
    "function_name": "flush_write_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4052-4056",
    "snippet": "static noinline void flush_write_bio(void *data)\n{\n\tstruct extent_page_data *epd = data;\n\tflush_epd_write_bio(epd);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline void flush_write_bio(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_epd_write_bio",
          "args": [
            "epd"
          ],
          "line": 4055
        },
        "resolved": true,
        "details": {
          "function_name": "flush_epd_write_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4037-4050",
          "snippet": "static void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstatic noinline void flush_write_bio(void *data)\n{\n\tstruct extent_page_data *epd = data;\n\tflush_epd_write_bio(epd);\n}"
  },
  {
    "function_name": "flush_epd_write_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "4037-4050",
    "snippet": "static void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 4047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_one_bio",
          "args": [
            "rw",
            "epd->bio",
            "0",
            "epd->bio_flags"
          ],
          "line": 4046
        },
        "resolved": true,
        "details": {
          "function_name": "submit_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2749-2774",
          "snippet": "static int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void flush_epd_write_bio(struct extent_page_data *epd)\n{\n\tif (epd->bio) {\n\t\tint rw = WRITE;\n\t\tint ret;\n\n\t\tif (epd->sync_io)\n\t\t\trw = WRITE_SYNC;\n\n\t\tret = submit_one_bio(rw, epd->bio, 0, epd->bio_flags);\n\t\tBUG_ON(ret < 0); /* -ENOMEM */\n\t\tepd->bio = NULL;\n\t}\n}"
  },
  {
    "function_name": "extent_write_cache_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3915-4035",
    "snippet": "static int extent_write_cache_pages(struct extent_io_tree *tree,\n\t\t\t     struct address_space *mapping,\n\t\t\t     struct writeback_control *wbc,\n\t\t\t     writepage_t writepage, void *data,\n\t\t\t     void (*flush_fn)(void *))\n{\n\tstruct inode *inode = mapping->host;\n\tint ret = 0;\n\tint done = 0;\n\tint err = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tint scanned = 0;\n\tint tag;\n\n\t/*\n\t * We have to hold onto the inode so that ordered extents can do their\n\t * work when the IO finishes.  The alternative to this is failing to add\n\t * an ordered extent if the igrab() fails there and that is a huge pain\n\t * to deal with, so instead just hold onto the inode throughout the\n\t * writepages operation.  If it fails here we are freeing up the inode\n\t * anyway and we'd rather not waste our time writing out stuff that is\n\t * going to be truncated anyway.\n\t */\n\tif (!igrab(inode))\n\t\treturn 0;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point we hold neither mapping->tree_lock nor\n\t\t\t * lock on the page itself: the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or even\n\t\t\t * swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping\n\t\t\t */\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tflush_fn(data);\n\t\t\t\tlock_page(page);\n\t\t\t}\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdone = 1;\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tflush_fn(data);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t}\n\n\t\t\tif (PageWriteback(page) ||\n\t\t\t    !clear_page_dirty_for_io(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = (*writepage)(page, wbc, data);\n\n\t\t\tif (unlikely(ret == AOP_WRITEPAGE_ACTIVATE)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tif (!err && ret < 0)\n\t\t\t\terr = ret;\n\n\t\t\t/*\n\t\t\t * the filesystem may choose to bump up nr_to_write.\n\t\t\t * We have to make sure to honor the new nr_to_write\n\t\t\t * at any time\n\t\t\t */\n\t\t\tnr_to_write_done = wbc->nr_to_write <= 0;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (!scanned && !done && !err) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = 1;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\tbtrfs_add_delayed_iput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline void flush_write_bio(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_add_delayed_iput",
          "args": [
            "inode"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_delayed_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3084-3098",
          "snippet": "void btrfs_add_delayed_iput(struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct delayed_iput *delayed;\n\n\tif (atomic_add_unless(&inode->i_count, -1, 1))\n\t\treturn;\n\n\tdelayed = kmalloc(sizeof(*delayed), GFP_NOFS | __GFP_NOFAIL);\n\tdelayed->inode = inode;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_add_tail(&delayed->list, &fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_add_delayed_iput(struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct delayed_iput *delayed;\n\n\tif (atomic_add_unless(&inode->i_count, -1, 1))\n\t\treturn;\n\n\tdelayed = kmalloc(sizeof(*delayed), GFP_NOFS | __GFP_NOFAIL);\n\tdelayed->inode = inode;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_add_tail(&delayed->list, &fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 4008
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == AOP_WRITEPAGE_ACTIVATE"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "page",
            "wbc",
            "data"
          ],
          "line": 4005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 4000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 3996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fn",
          "args": [
            "data"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fn",
          "args": [
            "data"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "page"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "tag",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE-1"
          ],
          "line": 3963
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag_pages_for_writeback",
          "args": [
            "mapping",
            "index",
            "end"
          ],
          "line": 3960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstatic int extent_write_cache_pages(struct extent_io_tree *tree,\n\t\t\t     struct address_space *mapping,\n\t\t\t     struct writeback_control *wbc,\n\t\t\t     writepage_t writepage, void *data,\n\t\t\t     void (*flush_fn)(void *))\n{\n\tstruct inode *inode = mapping->host;\n\tint ret = 0;\n\tint done = 0;\n\tint err = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tint scanned = 0;\n\tint tag;\n\n\t/*\n\t * We have to hold onto the inode so that ordered extents can do their\n\t * work when the IO finishes.  The alternative to this is failing to add\n\t * an ordered extent if the igrab() fails there and that is a huge pain\n\t * to deal with, so instead just hold onto the inode throughout the\n\t * writepages operation.  If it fails here we are freeing up the inode\n\t * anyway and we'd rather not waste our time writing out stuff that is\n\t * going to be truncated anyway.\n\t */\n\tif (!igrab(inode))\n\t\treturn 0;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point we hold neither mapping->tree_lock nor\n\t\t\t * lock on the page itself: the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or even\n\t\t\t * swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping\n\t\t\t */\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tflush_fn(data);\n\t\t\t\tlock_page(page);\n\t\t\t}\n\n\t\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdone = 1;\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (wbc->sync_mode != WB_SYNC_NONE) {\n\t\t\t\tif (PageWriteback(page))\n\t\t\t\t\tflush_fn(data);\n\t\t\t\twait_on_page_writeback(page);\n\t\t\t}\n\n\t\t\tif (PageWriteback(page) ||\n\t\t\t    !clear_page_dirty_for_io(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = (*writepage)(page, wbc, data);\n\n\t\t\tif (unlikely(ret == AOP_WRITEPAGE_ACTIVATE)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tif (!err && ret < 0)\n\t\t\t\terr = ret;\n\n\t\t\t/*\n\t\t\t * the filesystem may choose to bump up nr_to_write.\n\t\t\t * We have to make sure to honor the new nr_to_write\n\t\t\t * at any time\n\t\t\t */\n\t\t\tnr_to_write_done = wbc->nr_to_write <= 0;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (!scanned && !done && !err) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = 1;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\tbtrfs_add_delayed_iput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "btree_write_cache_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3778-3898",
    "snippet": "int btree_write_cache_pages(struct address_space *mapping,\n\t\t\t\t   struct writeback_control *wbc)\n{\n\tstruct extent_io_tree *tree = &BTRFS_I(mapping->host)->io_tree;\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(mapping->host)->root->fs_info;\n\tstruct extent_buffer *eb, *prev_eb = NULL;\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.extent_locked = 0,\n\t\t.sync_io = wbc->sync_mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\tint ret = 0;\n\tint done = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tint scanned = 0;\n\tint tag;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (!PagePrivate(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_lock(&mapping->private_lock);\n\t\t\tif (!PagePrivate(page)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\teb = (struct extent_buffer *)page->private;\n\n\t\t\t/*\n\t\t\t * Shouldn't happen and normally this would be a BUG_ON\n\t\t\t * but no sense in crashing the users box for something\n\t\t\t * we can survive anyway.\n\t\t\t */\n\t\t\tif (WARN_ON(!eb)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (eb == prev_eb) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = atomic_inc_not_zero(&eb->refs);\n\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\n\t\t\tprev_eb = eb;\n\t\t\tret = lock_extent_buffer_for_io(eb, fs_info, &epd);\n\t\t\tif (!ret) {\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = write_one_eb(eb, fs_info, wbc, &epd);\n\t\t\tif (ret) {\n\t\t\t\tdone = 1;\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree_extent_buffer(eb);\n\n\t\t\t/*\n\t\t\t * the filesystem may choose to bump up nr_to_write.\n\t\t\t * We have to make sure to honor the new nr_to_write\n\t\t\t * at any time\n\t\t\t */\n\t\t\tnr_to_write_done = wbc->nr_to_write <= 0;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (!scanned && !done) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = 1;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\tflush_write_bio(&epd);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_write_bio",
          "args": [
            "&epd"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "flush_write_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4052-4056",
          "snippet": "static noinline void flush_write_bio(void *data)\n{\n\tstruct extent_page_data *epd = data;\n\tflush_epd_write_bio(epd);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void flush_write_bio(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstatic noinline void flush_write_bio(void *data)\n{\n\tstruct extent_page_data *epd = data;\n\tflush_epd_write_bio(epd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_release",
          "args": [
            "&pvec"
          ],
          "line": 3884
        },
        "resolved": true,
        "details": {
          "function_name": "huge_pagevec_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hugetlbfs/inode.c",
          "lines": "84-92",
          "snippet": "static void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/migrate.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/slab.h>",
            "#include <linux/mman.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>\t\t/* remove ASAP */",
            "#include <asm/current.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/migrate.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/dnotify.h>\n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <linux/parser.h>\n#include <linux/pagevec.h>\n#include <linux/hugetlb.h>\n#include <linux/backing-dev.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\t\t/* remove ASAP */\n#include <asm/current.h>\n#include <linux/thread_info.h>\n#include <linux/module.h>\n\nstatic void huge_pagevec_release(struct pagevec *pvec)\n{\n\tint i;\n\n\tfor (i = 0; i < pagevec_count(pvec); ++i)\n\t\tput_page(pvec->pages[i]);\n\n\tpagevec_reinit(pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 3875
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_eb",
          "args": [
            "eb",
            "fs_info",
            "wbc",
            "&epd"
          ],
          "line": 3869
        },
        "resolved": true,
        "details": {
          "function_name": "write_one_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3725-3776",
          "snippet": "static noinline_for_stack int write_one_eb(struct extent_buffer *eb,\n\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tstruct extent_page_data *epd)\n{\n\tstruct block_device *bdev = fs_info->fs_devices->latest_bdev;\n\tstruct extent_io_tree *tree = &BTRFS_I(fs_info->btree_inode)->io_tree;\n\tu64 offset = eb->start;\n\tunsigned long i, num_pages;\n\tunsigned long bio_flags = 0;\n\tint rw = (epd->sync_io ? WRITE_SYNC : WRITE) | REQ_META;\n\tint ret = 0;\n\n\tclear_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tatomic_set(&eb->io_pages, num_pages);\n\tif (btrfs_header_owner(eb) == BTRFS_TREE_LOG_OBJECTID)\n\t\tbio_flags = EXTENT_BIO_TREE_LOG;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tclear_page_dirty_for_io(p);\n\t\tset_page_writeback(p);\n\t\tret = submit_extent_page(rw, tree, p, offset >> 9,\n\t\t\t\t\t PAGE_CACHE_SIZE, 0, bdev, &epd->bio,\n\t\t\t\t\t -1, end_bio_extent_buffer_writepage,\n\t\t\t\t\t 0, epd->bio_flags, bio_flags);\n\t\tepd->bio_flags = bio_flags;\n\t\tif (ret) {\n\t\t\tset_btree_ioerr(p);\n\t\t\tend_page_writeback(p);\n\t\t\tif (atomic_sub_and_test(num_pages - i, &eb->io_pages))\n\t\t\t\tend_extent_buffer_writeback(eb);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tupdate_nr_written(p, wbc, 1);\n\t\tunlock_page(p);\n\t}\n\n\tif (unlikely(ret)) {\n\t\tfor (; i < num_pages; i++) {\n\t\t\tstruct page *p = eb->pages[i];\n\t\t\tclear_page_dirty_for_io(p);\n\t\t\tunlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline_for_stack int write_one_eb(struct extent_buffer *eb,\n\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tstruct extent_page_data *epd)\n{\n\tstruct block_device *bdev = fs_info->fs_devices->latest_bdev;\n\tstruct extent_io_tree *tree = &BTRFS_I(fs_info->btree_inode)->io_tree;\n\tu64 offset = eb->start;\n\tunsigned long i, num_pages;\n\tunsigned long bio_flags = 0;\n\tint rw = (epd->sync_io ? WRITE_SYNC : WRITE) | REQ_META;\n\tint ret = 0;\n\n\tclear_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tatomic_set(&eb->io_pages, num_pages);\n\tif (btrfs_header_owner(eb) == BTRFS_TREE_LOG_OBJECTID)\n\t\tbio_flags = EXTENT_BIO_TREE_LOG;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tclear_page_dirty_for_io(p);\n\t\tset_page_writeback(p);\n\t\tret = submit_extent_page(rw, tree, p, offset >> 9,\n\t\t\t\t\t PAGE_CACHE_SIZE, 0, bdev, &epd->bio,\n\t\t\t\t\t -1, end_bio_extent_buffer_writepage,\n\t\t\t\t\t 0, epd->bio_flags, bio_flags);\n\t\tepd->bio_flags = bio_flags;\n\t\tif (ret) {\n\t\t\tset_btree_ioerr(p);\n\t\t\tend_page_writeback(p);\n\t\t\tif (atomic_sub_and_test(num_pages - i, &eb->io_pages))\n\t\t\t\tend_extent_buffer_writeback(eb);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tupdate_nr_written(p, wbc, 1);\n\t\tunlock_page(p);\n\t}\n\n\tif (unlikely(ret)) {\n\t\tfor (; i < num_pages; i++) {\n\t\t\tstruct page *p = eb->pages[i];\n\t\t\tclear_page_dirty_for_io(p);\n\t\t\tunlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_buffer_for_io",
          "args": [
            "eb",
            "fs_info",
            "&epd"
          ],
          "line": 3863
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_buffer_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3556-3625",
          "snippet": "static noinline_for_stack int\nlock_extent_buffer_for_io(struct extent_buffer *eb,\n\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_page_data *epd)\n{\n\tunsigned long i, num_pages;\n\tint flush = 0;\n\tint ret = 0;\n\n\tif (!btrfs_try_tree_write_lock(eb)) {\n\t\tflush = 1;\n\t\tflush_write_bio(epd);\n\t\tbtrfs_tree_lock(eb);\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags)) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tif (!epd->sync_io)\n\t\t\treturn 0;\n\t\tif (!flush) {\n\t\t\tflush_write_bio(epd);\n\t\t\tflush = 1;\n\t\t}\n\t\twhile (1) {\n\t\t\twait_on_extent_buffer_writeback(eb);\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (!test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags))\n\t\t\t\tbreak;\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t}\n\t}\n\n\t/*\n\t * We need to do this to prevent races in people who check if the eb is\n\t * under IO since we can end up having no IO bits set for a short period\n\t * of time.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)) {\n\t\tset_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\t\tspin_unlock(&eb->refs_lock);\n\t\tbtrfs_set_header_flag(eb, BTRFS_HEADER_FLAG_WRITTEN);\n\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t     -eb->len,\n\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\tret = 1;\n\t} else {\n\t\tspin_unlock(&eb->refs_lock);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (!trylock_page(p)) {\n\t\t\tif (!flush) {\n\t\t\t\tflush_write_bio(epd);\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic noinline_for_stack int\nlock_extent_buffer_for_io(struct extent_buffer *eb,\n\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_page_data *epd)\n{\n\tunsigned long i, num_pages;\n\tint flush = 0;\n\tint ret = 0;\n\n\tif (!btrfs_try_tree_write_lock(eb)) {\n\t\tflush = 1;\n\t\tflush_write_bio(epd);\n\t\tbtrfs_tree_lock(eb);\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags)) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tif (!epd->sync_io)\n\t\t\treturn 0;\n\t\tif (!flush) {\n\t\t\tflush_write_bio(epd);\n\t\t\tflush = 1;\n\t\t}\n\t\twhile (1) {\n\t\t\twait_on_extent_buffer_writeback(eb);\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (!test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags))\n\t\t\t\tbreak;\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t}\n\t}\n\n\t/*\n\t * We need to do this to prevent races in people who check if the eb is\n\t * under IO since we can end up having no IO bits set for a short period\n\t * of time.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)) {\n\t\tset_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\t\tspin_unlock(&eb->refs_lock);\n\t\tbtrfs_set_header_flag(eb, BTRFS_HEADER_FLAG_WRITTEN);\n\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t     -eb->len,\n\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\tret = 1;\n\t} else {\n\t\tspin_unlock(&eb->refs_lock);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (!trylock_page(p)) {\n\t\t\tif (!flush) {\n\t\t\t\tflush_write_bio(epd);\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 3858
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&eb->refs"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!eb"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 3834
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_lookup_tag",
          "args": [
            "&pvec",
            "mapping",
            "&index",
            "tag",
            "min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end - index",
            "(pgoff_t)PAGEVEC_SIZE-1"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag_pages_for_writeback",
          "args": [
            "mapping",
            "index",
            "end"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagevec_init",
          "args": [
            "&pvec",
            "0"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "mapping->host"
          ],
          "line": 3782
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint btree_write_cache_pages(struct address_space *mapping,\n\t\t\t\t   struct writeback_control *wbc)\n{\n\tstruct extent_io_tree *tree = &BTRFS_I(mapping->host)->io_tree;\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(mapping->host)->root->fs_info;\n\tstruct extent_buffer *eb, *prev_eb = NULL;\n\tstruct extent_page_data epd = {\n\t\t.bio = NULL,\n\t\t.tree = tree,\n\t\t.extent_locked = 0,\n\t\t.sync_io = wbc->sync_mode == WB_SYNC_ALL,\n\t\t.bio_flags = 0,\n\t};\n\tint ret = 0;\n\tint done = 0;\n\tint nr_to_write_done = 0;\n\tstruct pagevec pvec;\n\tint nr_pages;\n\tpgoff_t index;\n\tpgoff_t end;\t\t/* Inclusive */\n\tint scanned = 0;\n\tint tag;\n\n\tpagevec_init(&pvec, 0);\n\tif (wbc->range_cyclic) {\n\t\tindex = mapping->writeback_index; /* Start from prev offset */\n\t\tend = -1;\n\t} else {\n\t\tindex = wbc->range_start >> PAGE_CACHE_SHIFT;\n\t\tend = wbc->range_end >> PAGE_CACHE_SHIFT;\n\t\tscanned = 1;\n\t}\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\ttag_pages_for_writeback(mapping, index, end);\n\twhile (!done && !nr_to_write_done && (index <= end) &&\n\t       (nr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\tmin(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1))) {\n\t\tunsigned i;\n\n\t\tscanned = 1;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (!PagePrivate(page))\n\t\t\t\tcontinue;\n\n\t\t\tif (!wbc->range_cyclic && page->index > end) {\n\t\t\t\tdone = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_lock(&mapping->private_lock);\n\t\t\tif (!PagePrivate(page)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\teb = (struct extent_buffer *)page->private;\n\n\t\t\t/*\n\t\t\t * Shouldn't happen and normally this would be a BUG_ON\n\t\t\t * but no sense in crashing the users box for something\n\t\t\t * we can survive anyway.\n\t\t\t */\n\t\t\tif (WARN_ON(!eb)) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (eb == prev_eb) {\n\t\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = atomic_inc_not_zero(&eb->refs);\n\t\t\tspin_unlock(&mapping->private_lock);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\n\t\t\tprev_eb = eb;\n\t\t\tret = lock_extent_buffer_for_io(eb, fs_info, &epd);\n\t\t\tif (!ret) {\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = write_one_eb(eb, fs_info, wbc, &epd);\n\t\t\tif (ret) {\n\t\t\t\tdone = 1;\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree_extent_buffer(eb);\n\n\t\t\t/*\n\t\t\t * the filesystem may choose to bump up nr_to_write.\n\t\t\t * We have to make sure to honor the new nr_to_write\n\t\t\t * at any time\n\t\t\t */\n\t\t\tnr_to_write_done = wbc->nr_to_write <= 0;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\tif (!scanned && !done) {\n\t\t/*\n\t\t * We hit the last page and there is more work to be done: wrap\n\t\t * back to the start of the file\n\t\t */\n\t\tscanned = 1;\n\t\tindex = 0;\n\t\tgoto retry;\n\t}\n\tflush_write_bio(&epd);\n\treturn ret;\n}"
  },
  {
    "function_name": "write_one_eb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3725-3776",
    "snippet": "static noinline_for_stack int write_one_eb(struct extent_buffer *eb,\n\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tstruct extent_page_data *epd)\n{\n\tstruct block_device *bdev = fs_info->fs_devices->latest_bdev;\n\tstruct extent_io_tree *tree = &BTRFS_I(fs_info->btree_inode)->io_tree;\n\tu64 offset = eb->start;\n\tunsigned long i, num_pages;\n\tunsigned long bio_flags = 0;\n\tint rw = (epd->sync_io ? WRITE_SYNC : WRITE) | REQ_META;\n\tint ret = 0;\n\n\tclear_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tatomic_set(&eb->io_pages, num_pages);\n\tif (btrfs_header_owner(eb) == BTRFS_TREE_LOG_OBJECTID)\n\t\tbio_flags = EXTENT_BIO_TREE_LOG;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tclear_page_dirty_for_io(p);\n\t\tset_page_writeback(p);\n\t\tret = submit_extent_page(rw, tree, p, offset >> 9,\n\t\t\t\t\t PAGE_CACHE_SIZE, 0, bdev, &epd->bio,\n\t\t\t\t\t -1, end_bio_extent_buffer_writepage,\n\t\t\t\t\t 0, epd->bio_flags, bio_flags);\n\t\tepd->bio_flags = bio_flags;\n\t\tif (ret) {\n\t\t\tset_btree_ioerr(p);\n\t\t\tend_page_writeback(p);\n\t\t\tif (atomic_sub_and_test(num_pages - i, &eb->io_pages))\n\t\t\t\tend_extent_buffer_writeback(eb);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tupdate_nr_written(p, wbc, 1);\n\t\tunlock_page(p);\n\t}\n\n\tif (unlikely(ret)) {\n\t\tfor (; i < num_pages; i++) {\n\t\t\tstruct page *p = eb->pages[i];\n\t\t\tclear_page_dirty_for_io(p);\n\t\t\tunlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "p"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "p"
          ],
          "line": 3770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_nr_written",
          "args": [
            "p",
            "wbc",
            "1"
          ],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "update_nr_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3203-3211",
          "snippet": "static noinline void update_nr_written(struct page *page,\n\t\t\t\t      struct writeback_control *wbc,\n\t\t\t\t      unsigned long nr_written)\n{\n\twbc->nr_to_write -= nr_written;\n\tif (wbc->range_cyclic || (wbc->nr_to_write > 0 &&\n\t    wbc->range_start == 0 && wbc->range_end == LLONG_MAX))\n\t\tpage->mapping->writeback_index = page->index + nr_written;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void update_nr_written(struct page *page,\n\t\t\t\t      struct writeback_control *wbc,\n\t\t\t\t      unsigned long nr_written)\n{\n\twbc->nr_to_write -= nr_written;\n\tif (wbc->range_cyclic || (wbc->nr_to_write > 0 &&\n\t    wbc->range_start == 0 && wbc->range_end == LLONG_MAX))\n\t\tpage->mapping->writeback_index = page->index + nr_written;\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_extent_buffer_writeback",
          "args": [
            "eb"
          ],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "end_extent_buffer_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3627-3632",
          "snippet": "static void end_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\tclear_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&eb->bflags, EXTENT_BUFFER_WRITEBACK);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void end_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\tclear_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&eb->bflags, EXTENT_BUFFER_WRITEBACK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_sub_and_test",
          "args": [
            "num_pages - i",
            "&eb->io_pages"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "p"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_btree_ioerr",
          "args": [
            "p"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "set_btree_ioerr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3634-3694",
          "snippet": "static void set_btree_ioerr(struct page *page)\n{\n\tstruct extent_buffer *eb = (struct extent_buffer *)page->private;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(eb->fs_info->btree_inode);\n\n\tSetPageError(page);\n\tif (test_and_set_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags))\n\t\treturn;\n\n\t/*\n\t * If writeback for a btree extent that doesn't belong to a log tree\n\t * failed, increment the counter transaction->eb_write_errors.\n\t * We do this because while the transaction is running and before it's\n\t * committing (when we call filemap_fdata[write|wait]_range against\n\t * the btree inode), we might have\n\t * btree_inode->i_mapping->a_ops->writepages() called by the VM - if it\n\t * returns an error or an error happens during writeback, when we're\n\t * committing the transaction we wouldn't know about it, since the pages\n\t * can be no longer dirty nor marked anymore for writeback (if a\n\t * subsequent modification to the extent buffer didn't happen before the\n\t * transaction commit), which makes filemap_fdata[write|wait]_range not\n\t * able to find the pages tagged with SetPageError at transaction\n\t * commit time. So if this happens we must abort the transaction,\n\t * otherwise we commit a super block with btree roots that point to\n\t * btree nodes/leafs whose content on disk is invalid - either garbage\n\t * or the content of some node/leaf from a past generation that got\n\t * cowed or deleted and is no longer valid.\n\t *\n\t * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would\n\t * not be enough - we need to distinguish between log tree extents vs\n\t * non-log tree extents, and the next filemap_fdatawait_range() call\n\t * will catch and clear such errors in the mapping - and that call might\n\t * be from a log sync and not from a transaction commit. Also, checking\n\t * for the eb flag EXTENT_BUFFER_WRITE_ERR at transaction commit time is\n\t * not done and would not be reliable - the eb might have been released\n\t * from memory and reading it back again means that flag would not be\n\t * set (since it's a runtime flag, not persisted on disk).\n\t *\n\t * Using the flags below in the btree inode also makes us achieve the\n\t * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started\n\t * writeback for all dirty pages and before filemap_fdatawait_range()\n\t * is called, the writeback for all dirty pages had already finished\n\t * with errors - because we were not using AS_EIO/AS_ENOSPC,\n\t * filemap_fdatawait_range() would return success, as it could not know\n\t * that writeback errors happened (the pages were no longer tagged for\n\t * writeback).\n\t */\n\tswitch (eb->log_index) {\n\tcase -1:\n\t\tset_bit(BTRFS_INODE_BTREE_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 0:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 1:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* unexpected, logic error */\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_btree_ioerr(struct page *page)\n{\n\tstruct extent_buffer *eb = (struct extent_buffer *)page->private;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(eb->fs_info->btree_inode);\n\n\tSetPageError(page);\n\tif (test_and_set_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags))\n\t\treturn;\n\n\t/*\n\t * If writeback for a btree extent that doesn't belong to a log tree\n\t * failed, increment the counter transaction->eb_write_errors.\n\t * We do this because while the transaction is running and before it's\n\t * committing (when we call filemap_fdata[write|wait]_range against\n\t * the btree inode), we might have\n\t * btree_inode->i_mapping->a_ops->writepages() called by the VM - if it\n\t * returns an error or an error happens during writeback, when we're\n\t * committing the transaction we wouldn't know about it, since the pages\n\t * can be no longer dirty nor marked anymore for writeback (if a\n\t * subsequent modification to the extent buffer didn't happen before the\n\t * transaction commit), which makes filemap_fdata[write|wait]_range not\n\t * able to find the pages tagged with SetPageError at transaction\n\t * commit time. So if this happens we must abort the transaction,\n\t * otherwise we commit a super block with btree roots that point to\n\t * btree nodes/leafs whose content on disk is invalid - either garbage\n\t * or the content of some node/leaf from a past generation that got\n\t * cowed or deleted and is no longer valid.\n\t *\n\t * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would\n\t * not be enough - we need to distinguish between log tree extents vs\n\t * non-log tree extents, and the next filemap_fdatawait_range() call\n\t * will catch and clear such errors in the mapping - and that call might\n\t * be from a log sync and not from a transaction commit. Also, checking\n\t * for the eb flag EXTENT_BUFFER_WRITE_ERR at transaction commit time is\n\t * not done and would not be reliable - the eb might have been released\n\t * from memory and reading it back again means that flag would not be\n\t * set (since it's a runtime flag, not persisted on disk).\n\t *\n\t * Using the flags below in the btree inode also makes us achieve the\n\t * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started\n\t * writeback for all dirty pages and before filemap_fdatawait_range()\n\t * is called, the writeback for all dirty pages had already finished\n\t * with errors - because we were not using AS_EIO/AS_ENOSPC,\n\t * filemap_fdatawait_range() would return success, as it could not know\n\t * that writeback errors happened (the pages were no longer tagged for\n\t * writeback).\n\t */\n\tswitch (eb->log_index) {\n\tcase -1:\n\t\tset_bit(BTRFS_INODE_BTREE_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 0:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 1:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* unexpected, logic error */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_extent_page",
          "args": [
            "rw",
            "tree",
            "p",
            "offset >> 9",
            "PAGE_CACHE_SIZE",
            "0",
            "bdev",
            "&epd->bio",
            "-1",
            "end_bio_extent_buffer_writepage",
            "0",
            "epd->bio_flags",
            "bio_flags"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "submit_extent_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2789-2848",
          "snippet": "static int submit_extent_page(int rw, struct extent_io_tree *tree,\n\t\t\t      struct page *page, sector_t sector,\n\t\t\t      size_t size, unsigned long offset,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct bio **bio_ret,\n\t\t\t      unsigned long max_pages,\n\t\t\t      bio_end_io_t end_io_func,\n\t\t\t      int mirror_num,\n\t\t\t      unsigned long prev_bio_flags,\n\t\t\t      unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio *bio;\n\tint nr;\n\tint contig = 0;\n\tint this_compressed = bio_flags & EXTENT_BIO_COMPRESSED;\n\tint old_compressed = prev_bio_flags & EXTENT_BIO_COMPRESSED;\n\tsize_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);\n\n\tif (bio_ret && *bio_ret) {\n\t\tbio = *bio_ret;\n\t\tif (old_compressed)\n\t\t\tcontig = bio->bi_iter.bi_sector == sector;\n\t\telse\n\t\t\tcontig = bio_end_sector(bio) == sector;\n\n\t\tif (prev_bio_flags != bio_flags || !contig ||\n\t\t    merge_bio(rw, tree, page, offset, page_size, bio, bio_flags) ||\n\t\t    bio_add_page(bio, page, page_size, offset) < page_size) {\n\t\t\tret = submit_one_bio(rw, bio, mirror_num,\n\t\t\t\t\t     prev_bio_flags);\n\t\t\tif (ret < 0) {\n\t\t\t\t*bio_ret = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbio = NULL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (this_compressed)\n\t\tnr = BIO_MAX_PAGES;\n\telse\n\t\tnr = bio_get_nr_vecs(bdev);\n\n\tbio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_add_page(bio, page, page_size, offset);\n\tbio->bi_end_io = end_io_func;\n\tbio->bi_private = tree;\n\n\tif (bio_ret)\n\t\t*bio_ret = bio;\n\telse\n\t\tret = submit_one_bio(rw, bio, mirror_num, bio_flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int submit_extent_page(int rw, struct extent_io_tree *tree,\n\t\t\t      struct page *page, sector_t sector,\n\t\t\t      size_t size, unsigned long offset,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct bio **bio_ret,\n\t\t\t      unsigned long max_pages,\n\t\t\t      bio_end_io_t end_io_func,\n\t\t\t      int mirror_num,\n\t\t\t      unsigned long prev_bio_flags,\n\t\t\t      unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio *bio;\n\tint nr;\n\tint contig = 0;\n\tint this_compressed = bio_flags & EXTENT_BIO_COMPRESSED;\n\tint old_compressed = prev_bio_flags & EXTENT_BIO_COMPRESSED;\n\tsize_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);\n\n\tif (bio_ret && *bio_ret) {\n\t\tbio = *bio_ret;\n\t\tif (old_compressed)\n\t\t\tcontig = bio->bi_iter.bi_sector == sector;\n\t\telse\n\t\t\tcontig = bio_end_sector(bio) == sector;\n\n\t\tif (prev_bio_flags != bio_flags || !contig ||\n\t\t    merge_bio(rw, tree, page, offset, page_size, bio, bio_flags) ||\n\t\t    bio_add_page(bio, page, page_size, offset) < page_size) {\n\t\t\tret = submit_one_bio(rw, bio, mirror_num,\n\t\t\t\t\t     prev_bio_flags);\n\t\t\tif (ret < 0) {\n\t\t\t\t*bio_ret = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbio = NULL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (this_compressed)\n\t\tnr = BIO_MAX_PAGES;\n\telse\n\t\tnr = bio_get_nr_vecs(bdev);\n\n\tbio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_add_page(bio, page, page_size, offset);\n\tbio->bi_end_io = end_io_func;\n\tbio->bi_private = tree;\n\n\tif (bio_ret)\n\t\t*bio_ret = bio;\n\telse\n\t\tret = submit_one_bio(rw, bio, mirror_num, bio_flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "p"
          ],
          "line": 3748
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "p"
          ],
          "line": 3747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "eb"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&eb->io_pages",
            "num_pages"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 3739
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXTENT_BUFFER_WRITE_ERR",
            "&eb->bflags"
          ],
          "line": 3738
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "fs_info->btree_inode"
          ],
          "line": 3731
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline_for_stack int write_one_eb(struct extent_buffer *eb,\n\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\tstruct writeback_control *wbc,\n\t\t\tstruct extent_page_data *epd)\n{\n\tstruct block_device *bdev = fs_info->fs_devices->latest_bdev;\n\tstruct extent_io_tree *tree = &BTRFS_I(fs_info->btree_inode)->io_tree;\n\tu64 offset = eb->start;\n\tunsigned long i, num_pages;\n\tunsigned long bio_flags = 0;\n\tint rw = (epd->sync_io ? WRITE_SYNC : WRITE) | REQ_META;\n\tint ret = 0;\n\n\tclear_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags);\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tatomic_set(&eb->io_pages, num_pages);\n\tif (btrfs_header_owner(eb) == BTRFS_TREE_LOG_OBJECTID)\n\t\tbio_flags = EXTENT_BIO_TREE_LOG;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tclear_page_dirty_for_io(p);\n\t\tset_page_writeback(p);\n\t\tret = submit_extent_page(rw, tree, p, offset >> 9,\n\t\t\t\t\t PAGE_CACHE_SIZE, 0, bdev, &epd->bio,\n\t\t\t\t\t -1, end_bio_extent_buffer_writepage,\n\t\t\t\t\t 0, epd->bio_flags, bio_flags);\n\t\tepd->bio_flags = bio_flags;\n\t\tif (ret) {\n\t\t\tset_btree_ioerr(p);\n\t\t\tend_page_writeback(p);\n\t\t\tif (atomic_sub_and_test(num_pages - i, &eb->io_pages))\n\t\t\t\tend_extent_buffer_writeback(eb);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tupdate_nr_written(p, wbc, 1);\n\t\tunlock_page(p);\n\t}\n\n\tif (unlikely(ret)) {\n\t\tfor (; i < num_pages; i++) {\n\t\t\tstruct page *p = eb->pages[i];\n\t\t\tclear_page_dirty_for_io(p);\n\t\t\tunlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "end_bio_extent_buffer_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3696-3723",
    "snippet": "static void end_bio_extent_buffer_writepage(struct bio *bio, int err)\n{\n\tstruct bio_vec *bvec;\n\tstruct extent_buffer *eb;\n\tint i, done;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\teb = (struct extent_buffer *)page->private;\n\t\tBUG_ON(!eb);\n\t\tdone = atomic_dec_and_test(&eb->io_pages);\n\n\t\tif (err || test_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags)) {\n\t\t\tClearPageUptodate(page);\n\t\t\tset_btree_ioerr(page);\n\t\t}\n\n\t\tend_page_writeback(page);\n\n\t\tif (!done)\n\t\t\tcontinue;\n\n\t\tend_extent_buffer_writeback(eb);\n\t}\n\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_extent_buffer_writeback",
          "args": [
            "eb"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "end_extent_buffer_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3627-3632",
          "snippet": "static void end_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\tclear_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&eb->bflags, EXTENT_BUFFER_WRITEBACK);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void end_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\tclear_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&eb->bflags, EXTENT_BUFFER_WRITEBACK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_btree_ioerr",
          "args": [
            "page"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "set_btree_ioerr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3634-3694",
          "snippet": "static void set_btree_ioerr(struct page *page)\n{\n\tstruct extent_buffer *eb = (struct extent_buffer *)page->private;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(eb->fs_info->btree_inode);\n\n\tSetPageError(page);\n\tif (test_and_set_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags))\n\t\treturn;\n\n\t/*\n\t * If writeback for a btree extent that doesn't belong to a log tree\n\t * failed, increment the counter transaction->eb_write_errors.\n\t * We do this because while the transaction is running and before it's\n\t * committing (when we call filemap_fdata[write|wait]_range against\n\t * the btree inode), we might have\n\t * btree_inode->i_mapping->a_ops->writepages() called by the VM - if it\n\t * returns an error or an error happens during writeback, when we're\n\t * committing the transaction we wouldn't know about it, since the pages\n\t * can be no longer dirty nor marked anymore for writeback (if a\n\t * subsequent modification to the extent buffer didn't happen before the\n\t * transaction commit), which makes filemap_fdata[write|wait]_range not\n\t * able to find the pages tagged with SetPageError at transaction\n\t * commit time. So if this happens we must abort the transaction,\n\t * otherwise we commit a super block with btree roots that point to\n\t * btree nodes/leafs whose content on disk is invalid - either garbage\n\t * or the content of some node/leaf from a past generation that got\n\t * cowed or deleted and is no longer valid.\n\t *\n\t * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would\n\t * not be enough - we need to distinguish between log tree extents vs\n\t * non-log tree extents, and the next filemap_fdatawait_range() call\n\t * will catch and clear such errors in the mapping - and that call might\n\t * be from a log sync and not from a transaction commit. Also, checking\n\t * for the eb flag EXTENT_BUFFER_WRITE_ERR at transaction commit time is\n\t * not done and would not be reliable - the eb might have been released\n\t * from memory and reading it back again means that flag would not be\n\t * set (since it's a runtime flag, not persisted on disk).\n\t *\n\t * Using the flags below in the btree inode also makes us achieve the\n\t * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started\n\t * writeback for all dirty pages and before filemap_fdatawait_range()\n\t * is called, the writeback for all dirty pages had already finished\n\t * with errors - because we were not using AS_EIO/AS_ENOSPC,\n\t * filemap_fdatawait_range() would return success, as it could not know\n\t * that writeback errors happened (the pages were no longer tagged for\n\t * writeback).\n\t */\n\tswitch (eb->log_index) {\n\tcase -1:\n\t\tset_bit(BTRFS_INODE_BTREE_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 0:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 1:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* unexpected, logic error */\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_btree_ioerr(struct page *page)\n{\n\tstruct extent_buffer *eb = (struct extent_buffer *)page->private;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(eb->fs_info->btree_inode);\n\n\tSetPageError(page);\n\tif (test_and_set_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags))\n\t\treturn;\n\n\t/*\n\t * If writeback for a btree extent that doesn't belong to a log tree\n\t * failed, increment the counter transaction->eb_write_errors.\n\t * We do this because while the transaction is running and before it's\n\t * committing (when we call filemap_fdata[write|wait]_range against\n\t * the btree inode), we might have\n\t * btree_inode->i_mapping->a_ops->writepages() called by the VM - if it\n\t * returns an error or an error happens during writeback, when we're\n\t * committing the transaction we wouldn't know about it, since the pages\n\t * can be no longer dirty nor marked anymore for writeback (if a\n\t * subsequent modification to the extent buffer didn't happen before the\n\t * transaction commit), which makes filemap_fdata[write|wait]_range not\n\t * able to find the pages tagged with SetPageError at transaction\n\t * commit time. So if this happens we must abort the transaction,\n\t * otherwise we commit a super block with btree roots that point to\n\t * btree nodes/leafs whose content on disk is invalid - either garbage\n\t * or the content of some node/leaf from a past generation that got\n\t * cowed or deleted and is no longer valid.\n\t *\n\t * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would\n\t * not be enough - we need to distinguish between log tree extents vs\n\t * non-log tree extents, and the next filemap_fdatawait_range() call\n\t * will catch and clear such errors in the mapping - and that call might\n\t * be from a log sync and not from a transaction commit. Also, checking\n\t * for the eb flag EXTENT_BUFFER_WRITE_ERR at transaction commit time is\n\t * not done and would not be reliable - the eb might have been released\n\t * from memory and reading it back again means that flag would not be\n\t * set (since it's a runtime flag, not persisted on disk).\n\t *\n\t * Using the flags below in the btree inode also makes us achieve the\n\t * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started\n\t * writeback for all dirty pages and before filemap_fdatawait_range()\n\t * is called, the writeback for all dirty pages had already finished\n\t * with errors - because we were not using AS_EIO/AS_ENOSPC,\n\t * filemap_fdatawait_range() would return success, as it could not know\n\t * that writeback errors happened (the pages were no longer tagged for\n\t * writeback).\n\t */\n\tswitch (eb->log_index) {\n\tcase -1:\n\t\tset_bit(BTRFS_INODE_BTREE_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 0:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 1:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* unexpected, logic error */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 3710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_WRITE_ERR",
            "&eb->bflags"
          ],
          "line": 3709
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&eb->io_pages"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!eb"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void end_bio_extent_buffer_writepage(struct bio *bio, int err)\n{\n\tstruct bio_vec *bvec;\n\tstruct extent_buffer *eb;\n\tint i, done;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\teb = (struct extent_buffer *)page->private;\n\t\tBUG_ON(!eb);\n\t\tdone = atomic_dec_and_test(&eb->io_pages);\n\n\t\tif (err || test_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags)) {\n\t\t\tClearPageUptodate(page);\n\t\t\tset_btree_ioerr(page);\n\t\t}\n\n\t\tend_page_writeback(page);\n\n\t\tif (!done)\n\t\t\tcontinue;\n\n\t\tend_extent_buffer_writeback(eb);\n\t}\n\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "set_btree_ioerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3634-3694",
    "snippet": "static void set_btree_ioerr(struct page *page)\n{\n\tstruct extent_buffer *eb = (struct extent_buffer *)page->private;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(eb->fs_info->btree_inode);\n\n\tSetPageError(page);\n\tif (test_and_set_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags))\n\t\treturn;\n\n\t/*\n\t * If writeback for a btree extent that doesn't belong to a log tree\n\t * failed, increment the counter transaction->eb_write_errors.\n\t * We do this because while the transaction is running and before it's\n\t * committing (when we call filemap_fdata[write|wait]_range against\n\t * the btree inode), we might have\n\t * btree_inode->i_mapping->a_ops->writepages() called by the VM - if it\n\t * returns an error or an error happens during writeback, when we're\n\t * committing the transaction we wouldn't know about it, since the pages\n\t * can be no longer dirty nor marked anymore for writeback (if a\n\t * subsequent modification to the extent buffer didn't happen before the\n\t * transaction commit), which makes filemap_fdata[write|wait]_range not\n\t * able to find the pages tagged with SetPageError at transaction\n\t * commit time. So if this happens we must abort the transaction,\n\t * otherwise we commit a super block with btree roots that point to\n\t * btree nodes/leafs whose content on disk is invalid - either garbage\n\t * or the content of some node/leaf from a past generation that got\n\t * cowed or deleted and is no longer valid.\n\t *\n\t * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would\n\t * not be enough - we need to distinguish between log tree extents vs\n\t * non-log tree extents, and the next filemap_fdatawait_range() call\n\t * will catch and clear such errors in the mapping - and that call might\n\t * be from a log sync and not from a transaction commit. Also, checking\n\t * for the eb flag EXTENT_BUFFER_WRITE_ERR at transaction commit time is\n\t * not done and would not be reliable - the eb might have been released\n\t * from memory and reading it back again means that flag would not be\n\t * set (since it's a runtime flag, not persisted on disk).\n\t *\n\t * Using the flags below in the btree inode also makes us achieve the\n\t * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started\n\t * writeback for all dirty pages and before filemap_fdatawait_range()\n\t * is called, the writeback for all dirty pages had already finished\n\t * with errors - because we were not using AS_EIO/AS_ENOSPC,\n\t * filemap_fdatawait_range() would return success, as it could not know\n\t * that writeback errors happened (the pages were no longer tagged for\n\t * writeback).\n\t */\n\tswitch (eb->log_index) {\n\tcase -1:\n\t\tset_bit(BTRFS_INODE_BTREE_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 0:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 1:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* unexpected, logic error */\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_INODE_BTREE_LOG2_ERR",
            "&btree_ino->runtime_flags"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "EXTENT_BUFFER_WRITE_ERR",
            "&eb->bflags"
          ],
          "line": 3640
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "eb->fs_info->btree_inode"
          ],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_btree_ioerr(struct page *page)\n{\n\tstruct extent_buffer *eb = (struct extent_buffer *)page->private;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(eb->fs_info->btree_inode);\n\n\tSetPageError(page);\n\tif (test_and_set_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags))\n\t\treturn;\n\n\t/*\n\t * If writeback for a btree extent that doesn't belong to a log tree\n\t * failed, increment the counter transaction->eb_write_errors.\n\t * We do this because while the transaction is running and before it's\n\t * committing (when we call filemap_fdata[write|wait]_range against\n\t * the btree inode), we might have\n\t * btree_inode->i_mapping->a_ops->writepages() called by the VM - if it\n\t * returns an error or an error happens during writeback, when we're\n\t * committing the transaction we wouldn't know about it, since the pages\n\t * can be no longer dirty nor marked anymore for writeback (if a\n\t * subsequent modification to the extent buffer didn't happen before the\n\t * transaction commit), which makes filemap_fdata[write|wait]_range not\n\t * able to find the pages tagged with SetPageError at transaction\n\t * commit time. So if this happens we must abort the transaction,\n\t * otherwise we commit a super block with btree roots that point to\n\t * btree nodes/leafs whose content on disk is invalid - either garbage\n\t * or the content of some node/leaf from a past generation that got\n\t * cowed or deleted and is no longer valid.\n\t *\n\t * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would\n\t * not be enough - we need to distinguish between log tree extents vs\n\t * non-log tree extents, and the next filemap_fdatawait_range() call\n\t * will catch and clear such errors in the mapping - and that call might\n\t * be from a log sync and not from a transaction commit. Also, checking\n\t * for the eb flag EXTENT_BUFFER_WRITE_ERR at transaction commit time is\n\t * not done and would not be reliable - the eb might have been released\n\t * from memory and reading it back again means that flag would not be\n\t * set (since it's a runtime flag, not persisted on disk).\n\t *\n\t * Using the flags below in the btree inode also makes us achieve the\n\t * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started\n\t * writeback for all dirty pages and before filemap_fdatawait_range()\n\t * is called, the writeback for all dirty pages had already finished\n\t * with errors - because we were not using AS_EIO/AS_ENOSPC,\n\t * filemap_fdatawait_range() would return success, as it could not know\n\t * that writeback errors happened (the pages were no longer tagged for\n\t * writeback).\n\t */\n\tswitch (eb->log_index) {\n\tcase -1:\n\t\tset_bit(BTRFS_INODE_BTREE_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 0:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tcase 1:\n\t\tset_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\t\tbreak;\n\tdefault:\n\t\tBUG(); /* unexpected, logic error */\n\t}\n}"
  },
  {
    "function_name": "end_extent_buffer_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3627-3632",
    "snippet": "static void end_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\tclear_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&eb->bflags, EXTENT_BUFFER_WRITEBACK);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&eb->bflags",
            "EXTENT_BUFFER_WRITEBACK"
          ],
          "line": 3631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 3630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXTENT_BUFFER_WRITEBACK",
            "&eb->bflags"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void end_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\tclear_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&eb->bflags, EXTENT_BUFFER_WRITEBACK);\n}"
  },
  {
    "function_name": "lock_extent_buffer_for_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3556-3625",
    "snippet": "static noinline_for_stack int\nlock_extent_buffer_for_io(struct extent_buffer *eb,\n\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_page_data *epd)\n{\n\tunsigned long i, num_pages;\n\tint flush = 0;\n\tint ret = 0;\n\n\tif (!btrfs_try_tree_write_lock(eb)) {\n\t\tflush = 1;\n\t\tflush_write_bio(epd);\n\t\tbtrfs_tree_lock(eb);\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags)) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tif (!epd->sync_io)\n\t\t\treturn 0;\n\t\tif (!flush) {\n\t\t\tflush_write_bio(epd);\n\t\t\tflush = 1;\n\t\t}\n\t\twhile (1) {\n\t\t\twait_on_extent_buffer_writeback(eb);\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (!test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags))\n\t\t\t\tbreak;\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t}\n\t}\n\n\t/*\n\t * We need to do this to prevent races in people who check if the eb is\n\t * under IO since we can end up having no IO bits set for a short period\n\t * of time.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)) {\n\t\tset_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\t\tspin_unlock(&eb->refs_lock);\n\t\tbtrfs_set_header_flag(eb, BTRFS_HEADER_FLAG_WRITTEN);\n\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t     -eb->len,\n\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\tret = 1;\n\t} else {\n\t\tspin_unlock(&eb->refs_lock);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (!trylock_page(p)) {\n\t\t\tif (!flush) {\n\t\t\t\tflush_write_bio(epd);\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "p"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_write_bio",
          "args": [
            "epd"
          ],
          "line": 3617
        },
        "resolved": true,
        "details": {
          "function_name": "flush_write_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4052-4056",
          "snippet": "static noinline void flush_write_bio(void *data)\n{\n\tstruct extent_page_data *epd = data;\n\tflush_epd_write_bio(epd);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void flush_write_bio(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstatic noinline void flush_write_bio(void *data)\n{\n\tstruct extent_page_data *epd = data;\n\tflush_epd_write_bio(epd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_page",
          "args": [
            "p"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "eb"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 3603
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__percpu_counter_add",
          "args": [
            "&fs_info->dirty_metadata_bytes",
            "-eb->len",
            "fs_info->dirty_metadata_batch"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_flag",
          "args": [
            "eb",
            "BTRFS_HEADER_FLAG_WRITTEN"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2803-2808",
          "snippet": "static inline int btrfs_set_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags | flag);\n\treturn (flags & flag) == flag;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_set_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags | flag);\n\treturn (flags & flag) == flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_BUFFER_WRITEBACK",
            "&eb->bflags"
          ],
          "line": 3595
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "EXTENT_BUFFER_DIRTY",
            "&eb->bflags"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&eb->refs_lock"
          ],
          "line": 3593
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_BUFFER_WRITEBACK",
            "&eb->bflags"
          ],
          "line": 3582
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "eb"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_extent_buffer_writeback",
          "args": [
            "eb"
          ],
          "line": 3580
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_extent_buffer_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3550-3554",
          "snippet": "void wait_on_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\twait_on_bit_io(&eb->bflags, EXTENT_BUFFER_WRITEBACK,\n\t\t       TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid wait_on_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\twait_on_bit_io(&eb->bflags, EXTENT_BUFFER_WRITEBACK,\n\t\t       TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_try_tree_write_lock",
          "args": [
            "eb"
          ],
          "line": 3565
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_try_tree_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "175-191",
          "snippet": "int btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic noinline_for_stack int\nlock_extent_buffer_for_io(struct extent_buffer *eb,\n\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_page_data *epd)\n{\n\tunsigned long i, num_pages;\n\tint flush = 0;\n\tint ret = 0;\n\n\tif (!btrfs_try_tree_write_lock(eb)) {\n\t\tflush = 1;\n\t\tflush_write_bio(epd);\n\t\tbtrfs_tree_lock(eb);\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags)) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tif (!epd->sync_io)\n\t\t\treturn 0;\n\t\tif (!flush) {\n\t\t\tflush_write_bio(epd);\n\t\t\tflush = 1;\n\t\t}\n\t\twhile (1) {\n\t\t\twait_on_extent_buffer_writeback(eb);\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (!test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags))\n\t\t\t\tbreak;\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t}\n\t}\n\n\t/*\n\t * We need to do this to prevent races in people who check if the eb is\n\t * under IO since we can end up having no IO bits set for a short period\n\t * of time.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)) {\n\t\tset_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\t\tspin_unlock(&eb->refs_lock);\n\t\tbtrfs_set_header_flag(eb, BTRFS_HEADER_FLAG_WRITTEN);\n\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t     -eb->len,\n\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\tret = 1;\n\t} else {\n\t\tspin_unlock(&eb->refs_lock);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (!trylock_page(p)) {\n\t\t\tif (!flush) {\n\t\t\t\tflush_write_bio(epd);\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wait_on_extent_buffer_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3550-3554",
    "snippet": "void wait_on_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\twait_on_bit_io(&eb->bflags, EXTENT_BUFFER_WRITEBACK,\n\t\t       TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit_io",
          "args": [
            "&eb->bflags",
            "EXTENT_BUFFER_WRITEBACK",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid wait_on_extent_buffer_writeback(struct extent_buffer *eb)\n{\n\twait_on_bit_io(&eb->bflags, EXTENT_BUFFER_WRITEBACK,\n\t\t       TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "__extent_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3474-3548",
    "snippet": "static int __extent_writepage(struct page *page, struct writeback_control *wbc,\n\t\t\t      void *data)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_page_data *epd = data;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\tint nr = 0;\n\tsize_t pg_offset = 0;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned long end_index = i_size >> PAGE_CACHE_SHIFT;\n\tint write_flags;\n\tunsigned long nr_written = 0;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\twrite_flags = WRITE_SYNC;\n\telse\n\t\twrite_flags = WRITE;\n\n\ttrace___extent_writepage(page, inode, wbc);\n\n\tWARN_ON(!PageLocked(page));\n\n\tClearPageError(page);\n\n\tpg_offset = i_size & (PAGE_CACHE_SIZE - 1);\n\tif (page->index > end_index ||\n\t   (page->index == end_index && !pg_offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (page->index == end_index) {\n\t\tchar *userpage;\n\n\t\tuserpage = kmap_atomic(page);\n\t\tmemset(userpage + pg_offset, 0,\n\t\t       PAGE_CACHE_SIZE - pg_offset);\n\t\tkunmap_atomic(userpage);\n\t\tflush_dcache_page(page);\n\t}\n\n\tpg_offset = 0;\n\n\tset_page_extent_mapped(page);\n\n\tret = writepage_delalloc(inode, page, wbc, epd, start, &nr_written);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\tif (ret)\n\t\tgoto done;\n\n\tret = __extent_writepage_io(inode, page, wbc, epd,\n\t\t\t\t    i_size, nr_written, write_flags, &nr);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\ndone:\n\tif (nr == 0) {\n\t\t/* make sure the mapping tag for page dirty gets cleared */\n\t\tset_page_writeback(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (PageError(page)) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tend_extent_writepage(page, ret, start, page_end);\n\t}\n\tunlock_page(page);\n\treturn ret;\n\ndone_unlocked:\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline void flush_write_bio(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_extent_writepage",
          "args": [
            "page",
            "ret",
            "start",
            "page_end"
          ],
          "line": 3541
        },
        "resolved": true,
        "details": {
          "function_name": "end_extent_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2451-2473",
          "snippet": "int end_extent_writepage(struct page *page, int err, u64 start, u64 end)\n{\n\tint uptodate = (err == 0);\n\tstruct extent_io_tree *tree;\n\tint ret = 0;\n\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\n\tif (tree->ops && tree->ops->writepage_end_io_hook) {\n\t\tret = tree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t       end, NULL, uptodate);\n\t\tif (ret)\n\t\t\tuptodate = 0;\n\t}\n\n\tif (!uptodate) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tmapping_set_error(page->mapping, ret);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint end_extent_writepage(struct page *page, int err, u64 start, u64 end)\n{\n\tint uptodate = (err == 0);\n\tstruct extent_io_tree *tree;\n\tint ret = 0;\n\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\n\tif (tree->ops && tree->ops->writepage_end_io_hook) {\n\t\tret = tree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t       end, NULL, uptodate);\n\t\tif (ret)\n\t\t\tuptodate = 0;\n\t}\n\n\tif (!uptodate) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tmapping_set_error(page->mapping, ret);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 3539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 3537
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 3536
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__extent_writepage_io",
          "args": [
            "inode",
            "page",
            "wbc",
            "epd",
            "i_size",
            "nr_written",
            "write_flags",
            "&nr"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "__extent_writepage_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3312-3466",
          "snippet": "static noinline_for_stack int __extent_writepage_io(struct inode *inode,\n\t\t\t\t struct page *page,\n\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t struct extent_page_data *epd,\n\t\t\t\t loff_t i_size,\n\t\t\t\t unsigned long nr_written,\n\t\t\t\t int write_flags, int *nr_ret)\n{\n\tstruct extent_io_tree *tree = epd->tree;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 block_start;\n\tu64 iosize;\n\tsector_t sector;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tsize_t pg_offset = 0;\n\tsize_t blocksize;\n\tint ret = 0;\n\tint nr = 0;\n\tbool compressed;\n\n\tif (tree->ops && tree->ops->writepage_start_hook) {\n\t\tret = tree->ops->writepage_start_hook(page, start,\n\t\t\t\t\t\t      page_end);\n\t\tif (ret) {\n\t\t\t/* Fixup worker will requeue */\n\t\t\tif (ret == -EBUSY)\n\t\t\t\twbc->pages_skipped++;\n\t\t\telse\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\n\t\t\tupdate_nr_written(page, wbc, nr_written);\n\t\t\tunlock_page(page);\n\t\t\tret = 1;\n\t\t\tgoto done_unlocked;\n\t\t}\n\t}\n\n\t/*\n\t * we don't want to touch the inode after unlocking the page,\n\t * so we update the mapping writeback index now\n\t */\n\tupdate_nr_written(page, wbc, nr_written + 1);\n\n\tend = page_end;\n\tif (i_size <= start) {\n\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\ttree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t\t\t page_end, NULL, 1);\n\t\tgoto done;\n\t}\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\twhile (cur <= end) {\n\t\tu64 em_end;\n\t\tif (cur >= i_size) {\n\t\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, cur,\n\t\t\t\t\t\t\t page_end, NULL, 1);\n\t\t\tbreak;\n\t\t}\n\t\tem = epd->get_extent(inode, page, pg_offset, cur,\n\t\t\t\t     end - cur + 1, 1);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tret = PTR_ERR_OR_ZERO(em);\n\t\t\tbreak;\n\t\t}\n\n\t\textent_offset = cur - em->start;\n\t\tem_end = extent_map_end(em);\n\t\tBUG_ON(em_end <= cur);\n\t\tBUG_ON(end < cur);\n\t\tiosize = min(em_end - cur, end - cur + 1);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/*\n\t\t * compressed and inline extents are written through other\n\t\t * paths in the FS\n\t\t */\n\t\tif (compressed || block_start == EXTENT_MAP_HOLE ||\n\t\t    block_start == EXTENT_MAP_INLINE) {\n\t\t\t/*\n\t\t\t * end_io notification does not happen here for\n\t\t\t * compressed extents\n\t\t\t */\n\t\t\tif (!compressed && tree->ops &&\n\t\t\t    tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, cur,\n\t\t\t\t\t\t\t cur + iosize - 1,\n\t\t\t\t\t\t\t NULL, 1);\n\t\t\telse if (compressed) {\n\t\t\t\t/* we don't want to end_page_writeback on\n\t\t\t\t * a compressed extent.  this happens\n\t\t\t\t * elsewhere\n\t\t\t\t */\n\t\t\t\tnr++;\n\t\t\t}\n\n\t\t\tcur += iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tree->ops && tree->ops->writepage_io_hook) {\n\t\t\tret = tree->ops->writepage_io_hook(page, cur,\n\t\t\t\t\t\tcur + iosize - 1);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t} else {\n\t\t\tunsigned long max_nr = (i_size >> PAGE_CACHE_SHIFT) + 1;\n\n\t\t\tset_range_writeback(tree, cur, cur + iosize - 1);\n\t\t\tif (!PageWriteback(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"page %lu not writeback, cur %llu end %llu\",\n\t\t\t\t       page->index, cur, end);\n\t\t\t}\n\n\t\t\tret = submit_extent_page(write_flags, tree, page,\n\t\t\t\t\t\t sector, iosize, pg_offset,\n\t\t\t\t\t\t bdev, &epd->bio, max_nr,\n\t\t\t\t\t\t end_bio_extent_writepage,\n\t\t\t\t\t\t 0, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tSetPageError(page);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t\tnr++;\n\t}\ndone:\n\t*nr_ret = nr;\n\ndone_unlocked:\n\n\t/* drop our reference on any cached states */\n\tfree_extent_state(cached_state);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline_for_stack int __extent_writepage_io(struct inode *inode,\n\t\t\t\t struct page *page,\n\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t struct extent_page_data *epd,\n\t\t\t\t loff_t i_size,\n\t\t\t\t unsigned long nr_written,\n\t\t\t\t int write_flags, int *nr_ret)\n{\n\tstruct extent_io_tree *tree = epd->tree;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 block_start;\n\tu64 iosize;\n\tsector_t sector;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tsize_t pg_offset = 0;\n\tsize_t blocksize;\n\tint ret = 0;\n\tint nr = 0;\n\tbool compressed;\n\n\tif (tree->ops && tree->ops->writepage_start_hook) {\n\t\tret = tree->ops->writepage_start_hook(page, start,\n\t\t\t\t\t\t      page_end);\n\t\tif (ret) {\n\t\t\t/* Fixup worker will requeue */\n\t\t\tif (ret == -EBUSY)\n\t\t\t\twbc->pages_skipped++;\n\t\t\telse\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\n\t\t\tupdate_nr_written(page, wbc, nr_written);\n\t\t\tunlock_page(page);\n\t\t\tret = 1;\n\t\t\tgoto done_unlocked;\n\t\t}\n\t}\n\n\t/*\n\t * we don't want to touch the inode after unlocking the page,\n\t * so we update the mapping writeback index now\n\t */\n\tupdate_nr_written(page, wbc, nr_written + 1);\n\n\tend = page_end;\n\tif (i_size <= start) {\n\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\ttree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t\t\t page_end, NULL, 1);\n\t\tgoto done;\n\t}\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\twhile (cur <= end) {\n\t\tu64 em_end;\n\t\tif (cur >= i_size) {\n\t\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, cur,\n\t\t\t\t\t\t\t page_end, NULL, 1);\n\t\t\tbreak;\n\t\t}\n\t\tem = epd->get_extent(inode, page, pg_offset, cur,\n\t\t\t\t     end - cur + 1, 1);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tret = PTR_ERR_OR_ZERO(em);\n\t\t\tbreak;\n\t\t}\n\n\t\textent_offset = cur - em->start;\n\t\tem_end = extent_map_end(em);\n\t\tBUG_ON(em_end <= cur);\n\t\tBUG_ON(end < cur);\n\t\tiosize = min(em_end - cur, end - cur + 1);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/*\n\t\t * compressed and inline extents are written through other\n\t\t * paths in the FS\n\t\t */\n\t\tif (compressed || block_start == EXTENT_MAP_HOLE ||\n\t\t    block_start == EXTENT_MAP_INLINE) {\n\t\t\t/*\n\t\t\t * end_io notification does not happen here for\n\t\t\t * compressed extents\n\t\t\t */\n\t\t\tif (!compressed && tree->ops &&\n\t\t\t    tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, cur,\n\t\t\t\t\t\t\t cur + iosize - 1,\n\t\t\t\t\t\t\t NULL, 1);\n\t\t\telse if (compressed) {\n\t\t\t\t/* we don't want to end_page_writeback on\n\t\t\t\t * a compressed extent.  this happens\n\t\t\t\t * elsewhere\n\t\t\t\t */\n\t\t\t\tnr++;\n\t\t\t}\n\n\t\t\tcur += iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tree->ops && tree->ops->writepage_io_hook) {\n\t\t\tret = tree->ops->writepage_io_hook(page, cur,\n\t\t\t\t\t\tcur + iosize - 1);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t} else {\n\t\t\tunsigned long max_nr = (i_size >> PAGE_CACHE_SHIFT) + 1;\n\n\t\t\tset_range_writeback(tree, cur, cur + iosize - 1);\n\t\t\tif (!PageWriteback(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"page %lu not writeback, cur %llu end %llu\",\n\t\t\t\t       page->index, cur, end);\n\t\t\t}\n\n\t\t\tret = submit_extent_page(write_flags, tree, page,\n\t\t\t\t\t\t sector, iosize, pg_offset,\n\t\t\t\t\t\t bdev, &epd->bio, max_nr,\n\t\t\t\t\t\t end_bio_extent_writepage,\n\t\t\t\t\t\t 0, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tSetPageError(page);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t\tnr++;\n\t}\ndone:\n\t*nr_ret = nr;\n\ndone_unlocked:\n\n\t/* drop our reference on any cached states */\n\tfree_extent_state(cached_state);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "writepage_delalloc",
          "args": [
            "inode",
            "page",
            "wbc",
            "epd",
            "start",
            "&nr_written"
          ],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "writepage_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3223-3302",
          "snippet": "static noinline_for_stack int writepage_delalloc(struct inode *inode,\n\t\t\t      struct page *page, struct writeback_control *wbc,\n\t\t\t      struct extent_page_data *epd,\n\t\t\t      u64 delalloc_start,\n\t\t\t      unsigned long *nr_written)\n{\n\tstruct extent_io_tree *tree = epd->tree;\n\tu64 page_end = delalloc_start + PAGE_CACHE_SIZE - 1;\n\tu64 nr_delalloc;\n\tu64 delalloc_to_write = 0;\n\tu64 delalloc_end = 0;\n\tint ret;\n\tint page_started = 0;\n\n\tif (epd->extent_locked || !tree->ops || !tree->ops->fill_delalloc)\n\t\treturn 0;\n\n\twhile (delalloc_end < page_end) {\n\t\tnr_delalloc = find_lock_delalloc_range(inode, tree,\n\t\t\t\t\t       page,\n\t\t\t\t\t       &delalloc_start,\n\t\t\t\t\t       &delalloc_end,\n\t\t\t\t\t       BTRFS_MAX_EXTENT_SIZE);\n\t\tif (nr_delalloc == 0) {\n\t\t\tdelalloc_start = delalloc_end + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tret = tree->ops->fill_delalloc(inode, page,\n\t\t\t\t\t       delalloc_start,\n\t\t\t\t\t       delalloc_end,\n\t\t\t\t\t       &page_started,\n\t\t\t\t\t       nr_written);\n\t\t/* File system has been set read-only */\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\t/* fill_delalloc should be return < 0 for error\n\t\t\t * but just in case, we use > 0 here meaning the\n\t\t\t * IO is started, so we don't want to return > 0\n\t\t\t * unless things are going well.\n\t\t\t */\n\t\t\tret = ret < 0 ? ret : -EIO;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * delalloc_end is already one less than the total\n\t\t * length, so we don't subtract one from\n\t\t * PAGE_CACHE_SIZE\n\t\t */\n\t\tdelalloc_to_write += (delalloc_end - delalloc_start +\n\t\t\t\t      PAGE_CACHE_SIZE) >>\n\t\t\t\t      PAGE_CACHE_SHIFT;\n\t\tdelalloc_start = delalloc_end + 1;\n\t}\n\tif (wbc->nr_to_write < delalloc_to_write) {\n\t\tint thresh = 8192;\n\n\t\tif (delalloc_to_write < thresh * 2)\n\t\t\tthresh = delalloc_to_write;\n\t\twbc->nr_to_write = min_t(u64, delalloc_to_write,\n\t\t\t\t\t thresh);\n\t}\n\n\t/* did the fill delalloc function already unlock and start\n\t * the IO?\n\t */\n\tif (page_started) {\n\t\t/*\n\t\t * we've unlocked the page, so we can't update\n\t\t * the mapping's writeback index, just update\n\t\t * nr_to_write.\n\t\t */\n\t\twbc->nr_to_write -= *nr_written;\n\t\treturn 1;\n\t}\n\n\tret = 0;\n\ndone:\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline_for_stack int writepage_delalloc(struct inode *inode,\n\t\t\t      struct page *page, struct writeback_control *wbc,\n\t\t\t      struct extent_page_data *epd,\n\t\t\t      u64 delalloc_start,\n\t\t\t      unsigned long *nr_written)\n{\n\tstruct extent_io_tree *tree = epd->tree;\n\tu64 page_end = delalloc_start + PAGE_CACHE_SIZE - 1;\n\tu64 nr_delalloc;\n\tu64 delalloc_to_write = 0;\n\tu64 delalloc_end = 0;\n\tint ret;\n\tint page_started = 0;\n\n\tif (epd->extent_locked || !tree->ops || !tree->ops->fill_delalloc)\n\t\treturn 0;\n\n\twhile (delalloc_end < page_end) {\n\t\tnr_delalloc = find_lock_delalloc_range(inode, tree,\n\t\t\t\t\t       page,\n\t\t\t\t\t       &delalloc_start,\n\t\t\t\t\t       &delalloc_end,\n\t\t\t\t\t       BTRFS_MAX_EXTENT_SIZE);\n\t\tif (nr_delalloc == 0) {\n\t\t\tdelalloc_start = delalloc_end + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tret = tree->ops->fill_delalloc(inode, page,\n\t\t\t\t\t       delalloc_start,\n\t\t\t\t\t       delalloc_end,\n\t\t\t\t\t       &page_started,\n\t\t\t\t\t       nr_written);\n\t\t/* File system has been set read-only */\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\t/* fill_delalloc should be return < 0 for error\n\t\t\t * but just in case, we use > 0 here meaning the\n\t\t\t * IO is started, so we don't want to return > 0\n\t\t\t * unless things are going well.\n\t\t\t */\n\t\t\tret = ret < 0 ? ret : -EIO;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * delalloc_end is already one less than the total\n\t\t * length, so we don't subtract one from\n\t\t * PAGE_CACHE_SIZE\n\t\t */\n\t\tdelalloc_to_write += (delalloc_end - delalloc_start +\n\t\t\t\t      PAGE_CACHE_SIZE) >>\n\t\t\t\t      PAGE_CACHE_SHIFT;\n\t\tdelalloc_start = delalloc_end + 1;\n\t}\n\tif (wbc->nr_to_write < delalloc_to_write) {\n\t\tint thresh = 8192;\n\n\t\tif (delalloc_to_write < thresh * 2)\n\t\t\tthresh = delalloc_to_write;\n\t\twbc->nr_to_write = min_t(u64, delalloc_to_write,\n\t\t\t\t\t thresh);\n\t}\n\n\t/* did the fill delalloc function already unlock and start\n\t * the IO?\n\t */\n\tif (page_started) {\n\t\t/*\n\t\t * we've unlocked the page, so we can't update\n\t\t * the mapping's writeback index, just update\n\t\t * nr_to_write.\n\t\t */\n\t\twbc->nr_to_write -= *nr_written;\n\t\treturn 1;\n\t}\n\n\tret = 0;\n\ndone:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_extent_mapped",
          "args": [
            "page"
          ],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_extent_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2862-2869",
          "snippet": "void set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 3515
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "userpage"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "userpage + pg_offset",
            "0",
            "PAGE_CACHE_SIZE - pg_offset"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page->mapping->a_ops->invalidatepage",
          "args": [
            "page",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace___extent_writepage",
          "args": [
            "page",
            "inode",
            "wbc"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstatic int __extent_writepage(struct page *page, struct writeback_control *wbc,\n\t\t\t      void *data)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_page_data *epd = data;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\tint nr = 0;\n\tsize_t pg_offset = 0;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned long end_index = i_size >> PAGE_CACHE_SHIFT;\n\tint write_flags;\n\tunsigned long nr_written = 0;\n\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\twrite_flags = WRITE_SYNC;\n\telse\n\t\twrite_flags = WRITE;\n\n\ttrace___extent_writepage(page, inode, wbc);\n\n\tWARN_ON(!PageLocked(page));\n\n\tClearPageError(page);\n\n\tpg_offset = i_size & (PAGE_CACHE_SIZE - 1);\n\tif (page->index > end_index ||\n\t   (page->index == end_index && !pg_offset)) {\n\t\tpage->mapping->a_ops->invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\tif (page->index == end_index) {\n\t\tchar *userpage;\n\n\t\tuserpage = kmap_atomic(page);\n\t\tmemset(userpage + pg_offset, 0,\n\t\t       PAGE_CACHE_SIZE - pg_offset);\n\t\tkunmap_atomic(userpage);\n\t\tflush_dcache_page(page);\n\t}\n\n\tpg_offset = 0;\n\n\tset_page_extent_mapped(page);\n\n\tret = writepage_delalloc(inode, page, wbc, epd, start, &nr_written);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\tif (ret)\n\t\tgoto done;\n\n\tret = __extent_writepage_io(inode, page, wbc, epd,\n\t\t\t\t    i_size, nr_written, write_flags, &nr);\n\tif (ret == 1)\n\t\tgoto done_unlocked;\n\ndone:\n\tif (nr == 0) {\n\t\t/* make sure the mapping tag for page dirty gets cleared */\n\t\tset_page_writeback(page);\n\t\tend_page_writeback(page);\n\t}\n\tif (PageError(page)) {\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tend_extent_writepage(page, ret, start, page_end);\n\t}\n\tunlock_page(page);\n\treturn ret;\n\ndone_unlocked:\n\treturn 0;\n}"
  },
  {
    "function_name": "__extent_writepage_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3312-3466",
    "snippet": "static noinline_for_stack int __extent_writepage_io(struct inode *inode,\n\t\t\t\t struct page *page,\n\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t struct extent_page_data *epd,\n\t\t\t\t loff_t i_size,\n\t\t\t\t unsigned long nr_written,\n\t\t\t\t int write_flags, int *nr_ret)\n{\n\tstruct extent_io_tree *tree = epd->tree;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 block_start;\n\tu64 iosize;\n\tsector_t sector;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tsize_t pg_offset = 0;\n\tsize_t blocksize;\n\tint ret = 0;\n\tint nr = 0;\n\tbool compressed;\n\n\tif (tree->ops && tree->ops->writepage_start_hook) {\n\t\tret = tree->ops->writepage_start_hook(page, start,\n\t\t\t\t\t\t      page_end);\n\t\tif (ret) {\n\t\t\t/* Fixup worker will requeue */\n\t\t\tif (ret == -EBUSY)\n\t\t\t\twbc->pages_skipped++;\n\t\t\telse\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\n\t\t\tupdate_nr_written(page, wbc, nr_written);\n\t\t\tunlock_page(page);\n\t\t\tret = 1;\n\t\t\tgoto done_unlocked;\n\t\t}\n\t}\n\n\t/*\n\t * we don't want to touch the inode after unlocking the page,\n\t * so we update the mapping writeback index now\n\t */\n\tupdate_nr_written(page, wbc, nr_written + 1);\n\n\tend = page_end;\n\tif (i_size <= start) {\n\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\ttree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t\t\t page_end, NULL, 1);\n\t\tgoto done;\n\t}\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\twhile (cur <= end) {\n\t\tu64 em_end;\n\t\tif (cur >= i_size) {\n\t\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, cur,\n\t\t\t\t\t\t\t page_end, NULL, 1);\n\t\t\tbreak;\n\t\t}\n\t\tem = epd->get_extent(inode, page, pg_offset, cur,\n\t\t\t\t     end - cur + 1, 1);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tret = PTR_ERR_OR_ZERO(em);\n\t\t\tbreak;\n\t\t}\n\n\t\textent_offset = cur - em->start;\n\t\tem_end = extent_map_end(em);\n\t\tBUG_ON(em_end <= cur);\n\t\tBUG_ON(end < cur);\n\t\tiosize = min(em_end - cur, end - cur + 1);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/*\n\t\t * compressed and inline extents are written through other\n\t\t * paths in the FS\n\t\t */\n\t\tif (compressed || block_start == EXTENT_MAP_HOLE ||\n\t\t    block_start == EXTENT_MAP_INLINE) {\n\t\t\t/*\n\t\t\t * end_io notification does not happen here for\n\t\t\t * compressed extents\n\t\t\t */\n\t\t\tif (!compressed && tree->ops &&\n\t\t\t    tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, cur,\n\t\t\t\t\t\t\t cur + iosize - 1,\n\t\t\t\t\t\t\t NULL, 1);\n\t\t\telse if (compressed) {\n\t\t\t\t/* we don't want to end_page_writeback on\n\t\t\t\t * a compressed extent.  this happens\n\t\t\t\t * elsewhere\n\t\t\t\t */\n\t\t\t\tnr++;\n\t\t\t}\n\n\t\t\tcur += iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tree->ops && tree->ops->writepage_io_hook) {\n\t\t\tret = tree->ops->writepage_io_hook(page, cur,\n\t\t\t\t\t\tcur + iosize - 1);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t} else {\n\t\t\tunsigned long max_nr = (i_size >> PAGE_CACHE_SHIFT) + 1;\n\n\t\t\tset_range_writeback(tree, cur, cur + iosize - 1);\n\t\t\tif (!PageWriteback(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"page %lu not writeback, cur %llu end %llu\",\n\t\t\t\t       page->index, cur, end);\n\t\t\t}\n\n\t\t\tret = submit_extent_page(write_flags, tree, page,\n\t\t\t\t\t\t sector, iosize, pg_offset,\n\t\t\t\t\t\t bdev, &epd->bio, max_nr,\n\t\t\t\t\t\t end_bio_extent_writepage,\n\t\t\t\t\t\t 0, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tSetPageError(page);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t\tnr++;\n\t}\ndone:\n\t*nr_ret = nr;\n\ndone_unlocked:\n\n\t/* drop our reference on any cached states */\n\tfree_extent_state(cached_state);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "cached_state"
          ],
          "line": 3464
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_extent_page",
          "args": [
            "write_flags",
            "tree",
            "page",
            "sector",
            "iosize",
            "pg_offset",
            "bdev",
            "&epd->bio",
            "max_nr",
            "end_bio_extent_writepage",
            "0",
            "0",
            "0"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "submit_extent_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2789-2848",
          "snippet": "static int submit_extent_page(int rw, struct extent_io_tree *tree,\n\t\t\t      struct page *page, sector_t sector,\n\t\t\t      size_t size, unsigned long offset,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct bio **bio_ret,\n\t\t\t      unsigned long max_pages,\n\t\t\t      bio_end_io_t end_io_func,\n\t\t\t      int mirror_num,\n\t\t\t      unsigned long prev_bio_flags,\n\t\t\t      unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio *bio;\n\tint nr;\n\tint contig = 0;\n\tint this_compressed = bio_flags & EXTENT_BIO_COMPRESSED;\n\tint old_compressed = prev_bio_flags & EXTENT_BIO_COMPRESSED;\n\tsize_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);\n\n\tif (bio_ret && *bio_ret) {\n\t\tbio = *bio_ret;\n\t\tif (old_compressed)\n\t\t\tcontig = bio->bi_iter.bi_sector == sector;\n\t\telse\n\t\t\tcontig = bio_end_sector(bio) == sector;\n\n\t\tif (prev_bio_flags != bio_flags || !contig ||\n\t\t    merge_bio(rw, tree, page, offset, page_size, bio, bio_flags) ||\n\t\t    bio_add_page(bio, page, page_size, offset) < page_size) {\n\t\t\tret = submit_one_bio(rw, bio, mirror_num,\n\t\t\t\t\t     prev_bio_flags);\n\t\t\tif (ret < 0) {\n\t\t\t\t*bio_ret = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbio = NULL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (this_compressed)\n\t\tnr = BIO_MAX_PAGES;\n\telse\n\t\tnr = bio_get_nr_vecs(bdev);\n\n\tbio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_add_page(bio, page, page_size, offset);\n\tbio->bi_end_io = end_io_func;\n\tbio->bi_private = tree;\n\n\tif (bio_ret)\n\t\t*bio_ret = bio;\n\telse\n\t\tret = submit_one_bio(rw, bio, mirror_num, bio_flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int submit_extent_page(int rw, struct extent_io_tree *tree,\n\t\t\t      struct page *page, sector_t sector,\n\t\t\t      size_t size, unsigned long offset,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct bio **bio_ret,\n\t\t\t      unsigned long max_pages,\n\t\t\t      bio_end_io_t end_io_func,\n\t\t\t      int mirror_num,\n\t\t\t      unsigned long prev_bio_flags,\n\t\t\t      unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio *bio;\n\tint nr;\n\tint contig = 0;\n\tint this_compressed = bio_flags & EXTENT_BIO_COMPRESSED;\n\tint old_compressed = prev_bio_flags & EXTENT_BIO_COMPRESSED;\n\tsize_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);\n\n\tif (bio_ret && *bio_ret) {\n\t\tbio = *bio_ret;\n\t\tif (old_compressed)\n\t\t\tcontig = bio->bi_iter.bi_sector == sector;\n\t\telse\n\t\t\tcontig = bio_end_sector(bio) == sector;\n\n\t\tif (prev_bio_flags != bio_flags || !contig ||\n\t\t    merge_bio(rw, tree, page, offset, page_size, bio, bio_flags) ||\n\t\t    bio_add_page(bio, page, page_size, offset) < page_size) {\n\t\t\tret = submit_one_bio(rw, bio, mirror_num,\n\t\t\t\t\t     prev_bio_flags);\n\t\t\tif (ret < 0) {\n\t\t\t\t*bio_ret = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbio = NULL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (this_compressed)\n\t\tnr = BIO_MAX_PAGES;\n\telse\n\t\tnr = bio_get_nr_vecs(bdev);\n\n\tbio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_add_page(bio, page, page_size, offset);\n\tbio->bi_end_io = end_io_func;\n\tbio->bi_private = tree;\n\n\tif (bio_ret)\n\t\t*bio_ret = bio;\n\telse\n\t\tret = submit_one_bio(rw, bio, mirror_num, bio_flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "\"page %lu not writeback, cur %llu end %llu\"",
            "page->index",
            "cur",
            "end"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_range_writeback",
          "args": [
            "tree",
            "cur",
            "cur + iosize - 1"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "set_range_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1422-1436",
          "snippet": "static int set_range_writeback(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(tree->mapping, index);\n\t\tBUG_ON(!page); /* Pages should be in the extent_io_tree */\n\t\tset_page_writeback(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int set_range_writeback(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(tree->mapping, index);\n\t\tBUG_ON(!page); /* Pages should be in the extent_io_tree */\n\t\tset_page_writeback(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->writepage_io_hook",
          "args": [
            "page",
            "cur",
            "cur + iosize - 1"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->writepage_end_io_hook",
          "args": [
            "page",
            "cur",
            "cur + iosize - 1",
            "NULL",
            "1"
          ],
          "line": 3412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_COMPRESSED",
            "&em->flags"
          ],
          "line": 3396
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "iosize",
            "blocksize"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "em_end - cur",
            "end - cur + 1"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end < cur"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "em_end <= cur"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR_OR_ZERO",
          "args": [
            "em"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 3382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "em"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epd->get_extent",
          "args": [
            "inode",
            "page",
            "pg_offset",
            "cur",
            "end - cur + 1",
            "1"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->writepage_end_io_hook",
          "args": [
            "page",
            "cur",
            "page_end",
            "NULL",
            "1"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->writepage_end_io_hook",
          "args": [
            "page",
            "start",
            "page_end",
            "NULL",
            "1"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_nr_written",
          "args": [
            "page",
            "wbc",
            "nr_written + 1"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "update_nr_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3203-3211",
          "snippet": "static noinline void update_nr_written(struct page *page,\n\t\t\t\t      struct writeback_control *wbc,\n\t\t\t\t      unsigned long nr_written)\n{\n\twbc->nr_to_write -= nr_written;\n\tif (wbc->range_cyclic || (wbc->nr_to_write > 0 &&\n\t    wbc->range_start == 0 && wbc->range_end == LLONG_MAX))\n\t\tpage->mapping->writeback_index = page->index + nr_written;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void update_nr_written(struct page *page,\n\t\t\t\t      struct writeback_control *wbc,\n\t\t\t\t      unsigned long nr_written)\n{\n\twbc->nr_to_write -= nr_written;\n\tif (wbc->range_cyclic || (wbc->nr_to_write > 0 &&\n\t    wbc->range_start == 0 && wbc->range_end == LLONG_MAX))\n\t\tpage->mapping->writeback_index = page->index + nr_written;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->writepage_start_hook",
          "args": [
            "page",
            "start",
            "page_end"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline_for_stack int __extent_writepage_io(struct inode *inode,\n\t\t\t\t struct page *page,\n\t\t\t\t struct writeback_control *wbc,\n\t\t\t\t struct extent_page_data *epd,\n\t\t\t\t loff_t i_size,\n\t\t\t\t unsigned long nr_written,\n\t\t\t\t int write_flags, int *nr_ret)\n{\n\tstruct extent_io_tree *tree = epd->tree;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 block_start;\n\tu64 iosize;\n\tsector_t sector;\n\tstruct extent_state *cached_state = NULL;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tsize_t pg_offset = 0;\n\tsize_t blocksize;\n\tint ret = 0;\n\tint nr = 0;\n\tbool compressed;\n\n\tif (tree->ops && tree->ops->writepage_start_hook) {\n\t\tret = tree->ops->writepage_start_hook(page, start,\n\t\t\t\t\t\t      page_end);\n\t\tif (ret) {\n\t\t\t/* Fixup worker will requeue */\n\t\t\tif (ret == -EBUSY)\n\t\t\t\twbc->pages_skipped++;\n\t\t\telse\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\n\t\t\tupdate_nr_written(page, wbc, nr_written);\n\t\t\tunlock_page(page);\n\t\t\tret = 1;\n\t\t\tgoto done_unlocked;\n\t\t}\n\t}\n\n\t/*\n\t * we don't want to touch the inode after unlocking the page,\n\t * so we update the mapping writeback index now\n\t */\n\tupdate_nr_written(page, wbc, nr_written + 1);\n\n\tend = page_end;\n\tif (i_size <= start) {\n\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\ttree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t\t\t page_end, NULL, 1);\n\t\tgoto done;\n\t}\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\twhile (cur <= end) {\n\t\tu64 em_end;\n\t\tif (cur >= i_size) {\n\t\t\tif (tree->ops && tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, cur,\n\t\t\t\t\t\t\t page_end, NULL, 1);\n\t\t\tbreak;\n\t\t}\n\t\tem = epd->get_extent(inode, page, pg_offset, cur,\n\t\t\t\t     end - cur + 1, 1);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tret = PTR_ERR_OR_ZERO(em);\n\t\t\tbreak;\n\t\t}\n\n\t\textent_offset = cur - em->start;\n\t\tem_end = extent_map_end(em);\n\t\tBUG_ON(em_end <= cur);\n\t\tBUG_ON(end < cur);\n\t\tiosize = min(em_end - cur, end - cur + 1);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/*\n\t\t * compressed and inline extents are written through other\n\t\t * paths in the FS\n\t\t */\n\t\tif (compressed || block_start == EXTENT_MAP_HOLE ||\n\t\t    block_start == EXTENT_MAP_INLINE) {\n\t\t\t/*\n\t\t\t * end_io notification does not happen here for\n\t\t\t * compressed extents\n\t\t\t */\n\t\t\tif (!compressed && tree->ops &&\n\t\t\t    tree->ops->writepage_end_io_hook)\n\t\t\t\ttree->ops->writepage_end_io_hook(page, cur,\n\t\t\t\t\t\t\t cur + iosize - 1,\n\t\t\t\t\t\t\t NULL, 1);\n\t\t\telse if (compressed) {\n\t\t\t\t/* we don't want to end_page_writeback on\n\t\t\t\t * a compressed extent.  this happens\n\t\t\t\t * elsewhere\n\t\t\t\t */\n\t\t\t\tnr++;\n\t\t\t}\n\n\t\t\tcur += iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tree->ops && tree->ops->writepage_io_hook) {\n\t\t\tret = tree->ops->writepage_io_hook(page, cur,\n\t\t\t\t\t\tcur + iosize - 1);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t} else {\n\t\t\tunsigned long max_nr = (i_size >> PAGE_CACHE_SHIFT) + 1;\n\n\t\t\tset_range_writeback(tree, cur, cur + iosize - 1);\n\t\t\tif (!PageWriteback(page)) {\n\t\t\t\tbtrfs_err(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t   \"page %lu not writeback, cur %llu end %llu\",\n\t\t\t\t       page->index, cur, end);\n\t\t\t}\n\n\t\t\tret = submit_extent_page(write_flags, tree, page,\n\t\t\t\t\t\t sector, iosize, pg_offset,\n\t\t\t\t\t\t bdev, &epd->bio, max_nr,\n\t\t\t\t\t\t end_bio_extent_writepage,\n\t\t\t\t\t\t 0, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tSetPageError(page);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t\tnr++;\n\t}\ndone:\n\t*nr_ret = nr;\n\ndone_unlocked:\n\n\t/* drop our reference on any cached states */\n\tfree_extent_state(cached_state);\n\treturn ret;\n}"
  },
  {
    "function_name": "writepage_delalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3223-3302",
    "snippet": "static noinline_for_stack int writepage_delalloc(struct inode *inode,\n\t\t\t      struct page *page, struct writeback_control *wbc,\n\t\t\t      struct extent_page_data *epd,\n\t\t\t      u64 delalloc_start,\n\t\t\t      unsigned long *nr_written)\n{\n\tstruct extent_io_tree *tree = epd->tree;\n\tu64 page_end = delalloc_start + PAGE_CACHE_SIZE - 1;\n\tu64 nr_delalloc;\n\tu64 delalloc_to_write = 0;\n\tu64 delalloc_end = 0;\n\tint ret;\n\tint page_started = 0;\n\n\tif (epd->extent_locked || !tree->ops || !tree->ops->fill_delalloc)\n\t\treturn 0;\n\n\twhile (delalloc_end < page_end) {\n\t\tnr_delalloc = find_lock_delalloc_range(inode, tree,\n\t\t\t\t\t       page,\n\t\t\t\t\t       &delalloc_start,\n\t\t\t\t\t       &delalloc_end,\n\t\t\t\t\t       BTRFS_MAX_EXTENT_SIZE);\n\t\tif (nr_delalloc == 0) {\n\t\t\tdelalloc_start = delalloc_end + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tret = tree->ops->fill_delalloc(inode, page,\n\t\t\t\t\t       delalloc_start,\n\t\t\t\t\t       delalloc_end,\n\t\t\t\t\t       &page_started,\n\t\t\t\t\t       nr_written);\n\t\t/* File system has been set read-only */\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\t/* fill_delalloc should be return < 0 for error\n\t\t\t * but just in case, we use > 0 here meaning the\n\t\t\t * IO is started, so we don't want to return > 0\n\t\t\t * unless things are going well.\n\t\t\t */\n\t\t\tret = ret < 0 ? ret : -EIO;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * delalloc_end is already one less than the total\n\t\t * length, so we don't subtract one from\n\t\t * PAGE_CACHE_SIZE\n\t\t */\n\t\tdelalloc_to_write += (delalloc_end - delalloc_start +\n\t\t\t\t      PAGE_CACHE_SIZE) >>\n\t\t\t\t      PAGE_CACHE_SHIFT;\n\t\tdelalloc_start = delalloc_end + 1;\n\t}\n\tif (wbc->nr_to_write < delalloc_to_write) {\n\t\tint thresh = 8192;\n\n\t\tif (delalloc_to_write < thresh * 2)\n\t\t\tthresh = delalloc_to_write;\n\t\twbc->nr_to_write = min_t(u64, delalloc_to_write,\n\t\t\t\t\t thresh);\n\t}\n\n\t/* did the fill delalloc function already unlock and start\n\t * the IO?\n\t */\n\tif (page_started) {\n\t\t/*\n\t\t * we've unlocked the page, so we can't update\n\t\t * the mapping's writeback index, just update\n\t\t * nr_to_write.\n\t\t */\n\t\twbc->nr_to_write -= *nr_written;\n\t\treturn 1;\n\t}\n\n\tret = 0;\n\ndone:\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "delalloc_to_write",
            "thresh"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->fill_delalloc",
          "args": [
            "inode",
            "page",
            "delalloc_start",
            "delalloc_end",
            "&page_started",
            "nr_written"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_delalloc_range",
          "args": [
            "inode",
            "tree",
            "page",
            "&delalloc_start",
            "&delalloc_end",
            "BTRFS_MAX_EXTENT_SIZE"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_delalloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1675-1753",
          "snippet": "STATIC u64 find_lock_delalloc_range(struct inode *inode,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *locked_page, u64 *start,\n\t\t\t\t    u64 *end, u64 max_bytes)\n{\n\tu64 delalloc_start;\n\tu64 delalloc_end;\n\tu64 found;\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tint loops = 0;\n\nagain:\n\t/* step one, find a bunch of delalloc bytes starting at start */\n\tdelalloc_start = *start;\n\tdelalloc_end = 0;\n\tfound = find_delalloc_range(tree, &delalloc_start, &delalloc_end,\n\t\t\t\t    max_bytes, &cached_state);\n\tif (!found || delalloc_end <= *start) {\n\t\t*start = delalloc_start;\n\t\t*end = delalloc_end;\n\t\tfree_extent_state(cached_state);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * start comes from the offset of locked_page.  We have to lock\n\t * pages in order, so we can't process delalloc bytes before\n\t * locked_page\n\t */\n\tif (delalloc_start < *start)\n\t\tdelalloc_start = *start;\n\n\t/*\n\t * make sure to limit the number of pages we try to lock down\n\t */\n\tif (delalloc_end + 1 - delalloc_start > max_bytes)\n\t\tdelalloc_end = delalloc_start + max_bytes - 1;\n\n\t/* step two, lock all the pages after the page that has start */\n\tret = lock_delalloc_pages(inode, locked_page,\n\t\t\t\t  delalloc_start, delalloc_end);\n\tif (ret == -EAGAIN) {\n\t\t/* some of the pages are gone, lets avoid looping by\n\t\t * shortening the size of the delalloc range we're searching\n\t\t */\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tif (!loops) {\n\t\t\tmax_bytes = PAGE_CACHE_SIZE;\n\t\t\tloops = 1;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tfound = 0;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tBUG_ON(ret); /* Only valid values are 0 and -EAGAIN */\n\n\t/* step three, lock the state bits for the whole range */\n\tlock_extent_bits(tree, delalloc_start, delalloc_end, 0, &cached_state);\n\n\t/* then test to make sure it is all still delalloc */\n\tret = test_range_bit(tree, delalloc_start, delalloc_end,\n\t\t\t     EXTENT_DELALLOC, 1, cached_state);\n\tif (!ret) {\n\t\tunlock_extent_cached(tree, delalloc_start, delalloc_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start, delalloc_end);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\n\tfree_extent_state(cached_state);\n\t*start = delalloc_start;\n\t*end = delalloc_end;\nout_failed:\n\treturn found;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nSTATIC u64 find_lock_delalloc_range(struct inode *inode,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *locked_page, u64 *start,\n\t\t\t\t    u64 *end, u64 max_bytes)\n{\n\tu64 delalloc_start;\n\tu64 delalloc_end;\n\tu64 found;\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tint loops = 0;\n\nagain:\n\t/* step one, find a bunch of delalloc bytes starting at start */\n\tdelalloc_start = *start;\n\tdelalloc_end = 0;\n\tfound = find_delalloc_range(tree, &delalloc_start, &delalloc_end,\n\t\t\t\t    max_bytes, &cached_state);\n\tif (!found || delalloc_end <= *start) {\n\t\t*start = delalloc_start;\n\t\t*end = delalloc_end;\n\t\tfree_extent_state(cached_state);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * start comes from the offset of locked_page.  We have to lock\n\t * pages in order, so we can't process delalloc bytes before\n\t * locked_page\n\t */\n\tif (delalloc_start < *start)\n\t\tdelalloc_start = *start;\n\n\t/*\n\t * make sure to limit the number of pages we try to lock down\n\t */\n\tif (delalloc_end + 1 - delalloc_start > max_bytes)\n\t\tdelalloc_end = delalloc_start + max_bytes - 1;\n\n\t/* step two, lock all the pages after the page that has start */\n\tret = lock_delalloc_pages(inode, locked_page,\n\t\t\t\t  delalloc_start, delalloc_end);\n\tif (ret == -EAGAIN) {\n\t\t/* some of the pages are gone, lets avoid looping by\n\t\t * shortening the size of the delalloc range we're searching\n\t\t */\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tif (!loops) {\n\t\t\tmax_bytes = PAGE_CACHE_SIZE;\n\t\t\tloops = 1;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tfound = 0;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tBUG_ON(ret); /* Only valid values are 0 and -EAGAIN */\n\n\t/* step three, lock the state bits for the whole range */\n\tlock_extent_bits(tree, delalloc_start, delalloc_end, 0, &cached_state);\n\n\t/* then test to make sure it is all still delalloc */\n\tret = test_range_bit(tree, delalloc_start, delalloc_end,\n\t\t\t     EXTENT_DELALLOC, 1, cached_state);\n\tif (!ret) {\n\t\tunlock_extent_cached(tree, delalloc_start, delalloc_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start, delalloc_end);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\n\tfree_extent_state(cached_state);\n\t*start = delalloc_start;\n\t*end = delalloc_end;\nout_failed:\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline_for_stack int writepage_delalloc(struct inode *inode,\n\t\t\t      struct page *page, struct writeback_control *wbc,\n\t\t\t      struct extent_page_data *epd,\n\t\t\t      u64 delalloc_start,\n\t\t\t      unsigned long *nr_written)\n{\n\tstruct extent_io_tree *tree = epd->tree;\n\tu64 page_end = delalloc_start + PAGE_CACHE_SIZE - 1;\n\tu64 nr_delalloc;\n\tu64 delalloc_to_write = 0;\n\tu64 delalloc_end = 0;\n\tint ret;\n\tint page_started = 0;\n\n\tif (epd->extent_locked || !tree->ops || !tree->ops->fill_delalloc)\n\t\treturn 0;\n\n\twhile (delalloc_end < page_end) {\n\t\tnr_delalloc = find_lock_delalloc_range(inode, tree,\n\t\t\t\t\t       page,\n\t\t\t\t\t       &delalloc_start,\n\t\t\t\t\t       &delalloc_end,\n\t\t\t\t\t       BTRFS_MAX_EXTENT_SIZE);\n\t\tif (nr_delalloc == 0) {\n\t\t\tdelalloc_start = delalloc_end + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tret = tree->ops->fill_delalloc(inode, page,\n\t\t\t\t\t       delalloc_start,\n\t\t\t\t\t       delalloc_end,\n\t\t\t\t\t       &page_started,\n\t\t\t\t\t       nr_written);\n\t\t/* File system has been set read-only */\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\t/* fill_delalloc should be return < 0 for error\n\t\t\t * but just in case, we use > 0 here meaning the\n\t\t\t * IO is started, so we don't want to return > 0\n\t\t\t * unless things are going well.\n\t\t\t */\n\t\t\tret = ret < 0 ? ret : -EIO;\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * delalloc_end is already one less than the total\n\t\t * length, so we don't subtract one from\n\t\t * PAGE_CACHE_SIZE\n\t\t */\n\t\tdelalloc_to_write += (delalloc_end - delalloc_start +\n\t\t\t\t      PAGE_CACHE_SIZE) >>\n\t\t\t\t      PAGE_CACHE_SHIFT;\n\t\tdelalloc_start = delalloc_end + 1;\n\t}\n\tif (wbc->nr_to_write < delalloc_to_write) {\n\t\tint thresh = 8192;\n\n\t\tif (delalloc_to_write < thresh * 2)\n\t\t\tthresh = delalloc_to_write;\n\t\twbc->nr_to_write = min_t(u64, delalloc_to_write,\n\t\t\t\t\t thresh);\n\t}\n\n\t/* did the fill delalloc function already unlock and start\n\t * the IO?\n\t */\n\tif (page_started) {\n\t\t/*\n\t\t * we've unlocked the page, so we can't update\n\t\t * the mapping's writeback index, just update\n\t\t * nr_to_write.\n\t\t */\n\t\twbc->nr_to_write -= *nr_written;\n\t\treturn 1;\n\t}\n\n\tret = 0;\n\ndone:\n\treturn ret;\n}"
  },
  {
    "function_name": "update_nr_written",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3203-3211",
    "snippet": "static noinline void update_nr_written(struct page *page,\n\t\t\t\t      struct writeback_control *wbc,\n\t\t\t\t      unsigned long nr_written)\n{\n\twbc->nr_to_write -= nr_written;\n\tif (wbc->range_cyclic || (wbc->nr_to_write > 0 &&\n\t    wbc->range_start == 0 && wbc->range_end == LLONG_MAX))\n\t\tpage->mapping->writeback_index = page->index + nr_written;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void update_nr_written(struct page *page,\n\t\t\t\t      struct writeback_control *wbc,\n\t\t\t\t      unsigned long nr_written)\n{\n\twbc->nr_to_write -= nr_written;\n\tif (wbc->range_cyclic || (wbc->nr_to_write > 0 &&\n\t    wbc->range_start == 0 && wbc->range_end == LLONG_MAX))\n\t\tpage->mapping->writeback_index = page->index + nr_written;\n}"
  },
  {
    "function_name": "extent_read_full_page_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3189-3201",
    "snippet": "int extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_one_bio",
          "args": [
            "READ",
            "bio",
            "mirror_num",
            "bio_flags"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "submit_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2749-2774",
          "snippet": "static int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_readpage",
          "args": [
            "tree",
            "page",
            "get_extent",
            "NULL",
            "&bio",
            "mirror_num",
            "&bio_flags",
            "READ"
          ],
          "line": 3196
        },
        "resolved": true,
        "details": {
          "function_name": "__do_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2904-3075",
          "snippet": "static int __do_readpage(struct extent_io_tree *tree,\n\t\t\t struct page *page,\n\t\t\t get_extent_t *get_extent,\n\t\t\t struct extent_map **em_cached,\n\t\t\t struct bio **bio, int mirror_num,\n\t\t\t unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 last_byte = i_size_read(inode);\n\tu64 block_start;\n\tu64 cur_end;\n\tsector_t sector;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tint ret;\n\tint nr = 0;\n\tint parent_locked = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\tsize_t pg_offset = 0;\n\tsize_t iosize;\n\tsize_t disk_io_size;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tunsigned long this_bio_flag = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\n\tset_page_extent_mapped(page);\n\n\tend = page_end;\n\tif (!PageUptodate(page)) {\n\t\tif (cleancache_get_page(page) == 0) {\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tunlock_extent(tree, start, end);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (page->index == last_byte >> PAGE_CACHE_SHIFT) {\n\t\tchar *userpage;\n\t\tsize_t zero_offset = last_byte & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (zero_offset) {\n\t\t\tiosize = PAGE_CACHE_SIZE - zero_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + zero_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t}\n\t}\n\twhile (cur <= end) {\n\t\tunsigned long pnr = (last_byte >> PAGE_CACHE_SHIFT) + 1;\n\n\t\tif (cur >= last_byte) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tiosize = PAGE_CACHE_SIZE - pg_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent_cached(tree, cur,\n\t\t\t\t\t\t     cur + iosize - 1,\n\t\t\t\t\t\t     &cached, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tem = __get_extent_map(inode, page, pg_offset, cur,\n\t\t\t\t      end - cur + 1, get_extent, em_cached);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, end);\n\t\t\tbreak;\n\t\t}\n\t\textent_offset = cur - em->start;\n\t\tBUG_ON(extent_map_end(em) <= cur);\n\t\tBUG_ON(end < cur);\n\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tthis_bio_flag |= EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&this_bio_flag,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tiosize = min(extent_map_end(em) - cur, end - cur + 1);\n\t\tcur_end = min(extent_map_end(em) - 1, end);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tif (this_bio_flag & EXTENT_BIO_COMPRESSED) {\n\t\t\tdisk_io_size = em->block_len;\n\t\t\tsector = em->block_start >> 9;\n\t\t} else {\n\t\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\t\tdisk_io_size = iosize;\n\t\t}\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\tblock_start = EXTENT_MAP_HOLE;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/* we've found a hole, just zero and go on */\n\t\tif (block_start == EXTENT_MAP_HOLE) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tunlock_extent_cached(tree, cur, cur + iosize - 1,\n\t\t\t                     &cached, GFP_NOFS);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* the get_extent function already copied into the page */\n\t\tif (test_range_bit(tree, cur, cur_end,\n\t\t\t\t   EXTENT_UPTODATE, 1, NULL)) {\n\t\t\tcheck_page_uptodate(tree, page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we have an inline extent but it didn't get marked up\n\t\t * to date.  Error out\n\t\t */\n\t\tif (block_start == EXTENT_MAP_INLINE) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpnr -= page->index;\n\t\tret = submit_extent_page(rw, tree, page,\n\t\t\t\t\t sector, disk_io_size, pg_offset,\n\t\t\t\t\t bdev, bio, pnr,\n\t\t\t\t\t end_bio_extent_readpage, mirror_num,\n\t\t\t\t\t *bio_flags,\n\t\t\t\t\t this_bio_flag);\n\t\tif (!ret) {\n\t\t\tnr++;\n\t\t\t*bio_flags = this_bio_flag;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t}\nout:\n\tif (!nr) {\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __do_readpage(struct extent_io_tree *tree,\n\t\t\t struct page *page,\n\t\t\t get_extent_t *get_extent,\n\t\t\t struct extent_map **em_cached,\n\t\t\t struct bio **bio, int mirror_num,\n\t\t\t unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 last_byte = i_size_read(inode);\n\tu64 block_start;\n\tu64 cur_end;\n\tsector_t sector;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tint ret;\n\tint nr = 0;\n\tint parent_locked = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\tsize_t pg_offset = 0;\n\tsize_t iosize;\n\tsize_t disk_io_size;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tunsigned long this_bio_flag = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\n\tset_page_extent_mapped(page);\n\n\tend = page_end;\n\tif (!PageUptodate(page)) {\n\t\tif (cleancache_get_page(page) == 0) {\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tunlock_extent(tree, start, end);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (page->index == last_byte >> PAGE_CACHE_SHIFT) {\n\t\tchar *userpage;\n\t\tsize_t zero_offset = last_byte & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (zero_offset) {\n\t\t\tiosize = PAGE_CACHE_SIZE - zero_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + zero_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t}\n\t}\n\twhile (cur <= end) {\n\t\tunsigned long pnr = (last_byte >> PAGE_CACHE_SHIFT) + 1;\n\n\t\tif (cur >= last_byte) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tiosize = PAGE_CACHE_SIZE - pg_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent_cached(tree, cur,\n\t\t\t\t\t\t     cur + iosize - 1,\n\t\t\t\t\t\t     &cached, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tem = __get_extent_map(inode, page, pg_offset, cur,\n\t\t\t\t      end - cur + 1, get_extent, em_cached);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, end);\n\t\t\tbreak;\n\t\t}\n\t\textent_offset = cur - em->start;\n\t\tBUG_ON(extent_map_end(em) <= cur);\n\t\tBUG_ON(end < cur);\n\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tthis_bio_flag |= EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&this_bio_flag,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tiosize = min(extent_map_end(em) - cur, end - cur + 1);\n\t\tcur_end = min(extent_map_end(em) - 1, end);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tif (this_bio_flag & EXTENT_BIO_COMPRESSED) {\n\t\t\tdisk_io_size = em->block_len;\n\t\t\tsector = em->block_start >> 9;\n\t\t} else {\n\t\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\t\tdisk_io_size = iosize;\n\t\t}\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\tblock_start = EXTENT_MAP_HOLE;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/* we've found a hole, just zero and go on */\n\t\tif (block_start == EXTENT_MAP_HOLE) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tunlock_extent_cached(tree, cur, cur + iosize - 1,\n\t\t\t                     &cached, GFP_NOFS);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* the get_extent function already copied into the page */\n\t\tif (test_range_bit(tree, cur, cur_end,\n\t\t\t\t   EXTENT_UPTODATE, 1, NULL)) {\n\t\t\tcheck_page_uptodate(tree, page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we have an inline extent but it didn't get marked up\n\t\t * to date.  Error out\n\t\t */\n\t\tif (block_start == EXTENT_MAP_INLINE) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpnr -= page->index;\n\t\tret = submit_extent_page(rw, tree, page,\n\t\t\t\t\t sector, disk_io_size, pg_offset,\n\t\t\t\t\t bdev, bio, pnr,\n\t\t\t\t\t end_bio_extent_readpage, mirror_num,\n\t\t\t\t\t *bio_flags,\n\t\t\t\t\t this_bio_flag);\n\t\tif (!ret) {\n\t\t\tnr++;\n\t\t\t*bio_flags = this_bio_flag;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t}\nout:\n\tif (!nr) {\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_read_full_page_nolock(struct extent_io_tree *tree, struct page *page,\n\t\t\t\t get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = EXTENT_BIO_PARENT_LOCKED;\n\tint ret;\n\n\tret = __do_readpage(tree, page, get_extent, NULL, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "extent_read_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3175-3187",
    "snippet": "int extent_read_full_page(struct extent_io_tree *tree, struct page *page,\n\t\t\t    get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\tint ret;\n\n\tret = __extent_read_full_page(tree, page, get_extent, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_one_bio",
          "args": [
            "READ",
            "bio",
            "mirror_num",
            "bio_flags"
          ],
          "line": 3185
        },
        "resolved": true,
        "details": {
          "function_name": "submit_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2749-2774",
          "snippet": "static int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__extent_read_full_page",
          "args": [
            "tree",
            "page",
            "get_extent",
            "&bio",
            "mirror_num",
            "&bio_flags",
            "READ"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "__extent_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3148-3173",
          "snippet": "static int __extent_read_full_page(struct extent_io_tree *tree,\n\t\t\t\t   struct page *page,\n\t\t\t\t   get_extent_t *get_extent,\n\t\t\t\t   struct bio **bio, int mirror_num,\n\t\t\t\t   unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_extent(inode, start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tret = __do_readpage(tree, page, get_extent, NULL, bio, mirror_num,\n\t\t\t    bio_flags, rw);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __extent_read_full_page(struct extent_io_tree *tree,\n\t\t\t\t   struct page *page,\n\t\t\t\t   get_extent_t *get_extent,\n\t\t\t\t   struct bio **bio, int mirror_num,\n\t\t\t\t   unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_extent(inode, start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tret = __do_readpage(tree, page, get_extent, NULL, bio, mirror_num,\n\t\t\t    bio_flags, rw);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_read_full_page(struct extent_io_tree *tree, struct page *page,\n\t\t\t    get_extent_t *get_extent, int mirror_num)\n{\n\tstruct bio *bio = NULL;\n\tunsigned long bio_flags = 0;\n\tint ret;\n\n\tret = __extent_read_full_page(tree, page, get_extent, &bio, mirror_num,\n\t\t\t\t      &bio_flags, READ);\n\tif (bio)\n\t\tret = submit_one_bio(READ, bio, mirror_num, bio_flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__extent_read_full_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3148-3173",
    "snippet": "static int __extent_read_full_page(struct extent_io_tree *tree,\n\t\t\t\t   struct page *page,\n\t\t\t\t   get_extent_t *get_extent,\n\t\t\t\t   struct bio **bio, int mirror_num,\n\t\t\t\t   unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_extent(inode, start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tret = __do_readpage(tree, page, get_extent, NULL, bio, mirror_num,\n\t\t\t    bio_flags, rw);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_readpage",
          "args": [
            "tree",
            "page",
            "get_extent",
            "NULL",
            "bio",
            "mirror_num",
            "bio_flags",
            "rw"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "__do_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2904-3075",
          "snippet": "static int __do_readpage(struct extent_io_tree *tree,\n\t\t\t struct page *page,\n\t\t\t get_extent_t *get_extent,\n\t\t\t struct extent_map **em_cached,\n\t\t\t struct bio **bio, int mirror_num,\n\t\t\t unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 last_byte = i_size_read(inode);\n\tu64 block_start;\n\tu64 cur_end;\n\tsector_t sector;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tint ret;\n\tint nr = 0;\n\tint parent_locked = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\tsize_t pg_offset = 0;\n\tsize_t iosize;\n\tsize_t disk_io_size;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tunsigned long this_bio_flag = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\n\tset_page_extent_mapped(page);\n\n\tend = page_end;\n\tif (!PageUptodate(page)) {\n\t\tif (cleancache_get_page(page) == 0) {\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tunlock_extent(tree, start, end);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (page->index == last_byte >> PAGE_CACHE_SHIFT) {\n\t\tchar *userpage;\n\t\tsize_t zero_offset = last_byte & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (zero_offset) {\n\t\t\tiosize = PAGE_CACHE_SIZE - zero_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + zero_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t}\n\t}\n\twhile (cur <= end) {\n\t\tunsigned long pnr = (last_byte >> PAGE_CACHE_SHIFT) + 1;\n\n\t\tif (cur >= last_byte) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tiosize = PAGE_CACHE_SIZE - pg_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent_cached(tree, cur,\n\t\t\t\t\t\t     cur + iosize - 1,\n\t\t\t\t\t\t     &cached, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tem = __get_extent_map(inode, page, pg_offset, cur,\n\t\t\t\t      end - cur + 1, get_extent, em_cached);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, end);\n\t\t\tbreak;\n\t\t}\n\t\textent_offset = cur - em->start;\n\t\tBUG_ON(extent_map_end(em) <= cur);\n\t\tBUG_ON(end < cur);\n\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tthis_bio_flag |= EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&this_bio_flag,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tiosize = min(extent_map_end(em) - cur, end - cur + 1);\n\t\tcur_end = min(extent_map_end(em) - 1, end);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tif (this_bio_flag & EXTENT_BIO_COMPRESSED) {\n\t\t\tdisk_io_size = em->block_len;\n\t\t\tsector = em->block_start >> 9;\n\t\t} else {\n\t\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\t\tdisk_io_size = iosize;\n\t\t}\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\tblock_start = EXTENT_MAP_HOLE;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/* we've found a hole, just zero and go on */\n\t\tif (block_start == EXTENT_MAP_HOLE) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tunlock_extent_cached(tree, cur, cur + iosize - 1,\n\t\t\t                     &cached, GFP_NOFS);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* the get_extent function already copied into the page */\n\t\tif (test_range_bit(tree, cur, cur_end,\n\t\t\t\t   EXTENT_UPTODATE, 1, NULL)) {\n\t\t\tcheck_page_uptodate(tree, page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we have an inline extent but it didn't get marked up\n\t\t * to date.  Error out\n\t\t */\n\t\tif (block_start == EXTENT_MAP_INLINE) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpnr -= page->index;\n\t\tret = submit_extent_page(rw, tree, page,\n\t\t\t\t\t sector, disk_io_size, pg_offset,\n\t\t\t\t\t bdev, bio, pnr,\n\t\t\t\t\t end_bio_extent_readpage, mirror_num,\n\t\t\t\t\t *bio_flags,\n\t\t\t\t\t this_bio_flag);\n\t\tif (!ret) {\n\t\t\tnr++;\n\t\t\t*bio_flags = this_bio_flag;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t}\nout:\n\tif (!nr) {\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __do_readpage(struct extent_io_tree *tree,\n\t\t\t struct page *page,\n\t\t\t get_extent_t *get_extent,\n\t\t\t struct extent_map **em_cached,\n\t\t\t struct bio **bio, int mirror_num,\n\t\t\t unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 last_byte = i_size_read(inode);\n\tu64 block_start;\n\tu64 cur_end;\n\tsector_t sector;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tint ret;\n\tint nr = 0;\n\tint parent_locked = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\tsize_t pg_offset = 0;\n\tsize_t iosize;\n\tsize_t disk_io_size;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tunsigned long this_bio_flag = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\n\tset_page_extent_mapped(page);\n\n\tend = page_end;\n\tif (!PageUptodate(page)) {\n\t\tif (cleancache_get_page(page) == 0) {\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tunlock_extent(tree, start, end);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (page->index == last_byte >> PAGE_CACHE_SHIFT) {\n\t\tchar *userpage;\n\t\tsize_t zero_offset = last_byte & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (zero_offset) {\n\t\t\tiosize = PAGE_CACHE_SIZE - zero_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + zero_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t}\n\t}\n\twhile (cur <= end) {\n\t\tunsigned long pnr = (last_byte >> PAGE_CACHE_SHIFT) + 1;\n\n\t\tif (cur >= last_byte) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tiosize = PAGE_CACHE_SIZE - pg_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent_cached(tree, cur,\n\t\t\t\t\t\t     cur + iosize - 1,\n\t\t\t\t\t\t     &cached, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tem = __get_extent_map(inode, page, pg_offset, cur,\n\t\t\t\t      end - cur + 1, get_extent, em_cached);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, end);\n\t\t\tbreak;\n\t\t}\n\t\textent_offset = cur - em->start;\n\t\tBUG_ON(extent_map_end(em) <= cur);\n\t\tBUG_ON(end < cur);\n\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tthis_bio_flag |= EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&this_bio_flag,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tiosize = min(extent_map_end(em) - cur, end - cur + 1);\n\t\tcur_end = min(extent_map_end(em) - 1, end);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tif (this_bio_flag & EXTENT_BIO_COMPRESSED) {\n\t\t\tdisk_io_size = em->block_len;\n\t\t\tsector = em->block_start >> 9;\n\t\t} else {\n\t\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\t\tdisk_io_size = iosize;\n\t\t}\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\tblock_start = EXTENT_MAP_HOLE;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/* we've found a hole, just zero and go on */\n\t\tif (block_start == EXTENT_MAP_HOLE) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tunlock_extent_cached(tree, cur, cur + iosize - 1,\n\t\t\t                     &cached, GFP_NOFS);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* the get_extent function already copied into the page */\n\t\tif (test_range_bit(tree, cur, cur_end,\n\t\t\t\t   EXTENT_UPTODATE, 1, NULL)) {\n\t\t\tcheck_page_uptodate(tree, page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we have an inline extent but it didn't get marked up\n\t\t * to date.  Error out\n\t\t */\n\t\tif (block_start == EXTENT_MAP_INLINE) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpnr -= page->index;\n\t\tret = submit_extent_page(rw, tree, page,\n\t\t\t\t\t sector, disk_io_size, pg_offset,\n\t\t\t\t\t bdev, bio, pnr,\n\t\t\t\t\t end_bio_extent_readpage, mirror_num,\n\t\t\t\t\t *bio_flags,\n\t\t\t\t\t this_bio_flag);\n\t\tif (!ret) {\n\t\t\tnr++;\n\t\t\t*bio_flags = this_bio_flag;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t}\nout:\n\tif (!nr) {\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_ordered_extent",
          "args": [
            "inode",
            "ordered",
            "1"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "697-717",
          "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "tree",
            "start",
            "end"
          ],
          "line": 3165
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_extent",
          "args": [
            "inode",
            "start"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "777-798",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "tree",
            "start",
            "end"
          ],
          "line": 3161
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_buffer_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3556-3625",
          "snippet": "static noinline_for_stack int\nlock_extent_buffer_for_io(struct extent_buffer *eb,\n\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_page_data *epd)\n{\n\tunsigned long i, num_pages;\n\tint flush = 0;\n\tint ret = 0;\n\n\tif (!btrfs_try_tree_write_lock(eb)) {\n\t\tflush = 1;\n\t\tflush_write_bio(epd);\n\t\tbtrfs_tree_lock(eb);\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags)) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tif (!epd->sync_io)\n\t\t\treturn 0;\n\t\tif (!flush) {\n\t\t\tflush_write_bio(epd);\n\t\t\tflush = 1;\n\t\t}\n\t\twhile (1) {\n\t\t\twait_on_extent_buffer_writeback(eb);\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (!test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags))\n\t\t\t\tbreak;\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t}\n\t}\n\n\t/*\n\t * We need to do this to prevent races in people who check if the eb is\n\t * under IO since we can end up having no IO bits set for a short period\n\t * of time.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)) {\n\t\tset_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\t\tspin_unlock(&eb->refs_lock);\n\t\tbtrfs_set_header_flag(eb, BTRFS_HEADER_FLAG_WRITTEN);\n\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t     -eb->len,\n\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\tret = 1;\n\t} else {\n\t\tspin_unlock(&eb->refs_lock);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (!trylock_page(p)) {\n\t\t\tif (!flush) {\n\t\t\t\tflush_write_bio(epd);\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic noinline_for_stack int\nlock_extent_buffer_for_io(struct extent_buffer *eb,\n\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_page_data *epd)\n{\n\tunsigned long i, num_pages;\n\tint flush = 0;\n\tint ret = 0;\n\n\tif (!btrfs_try_tree_write_lock(eb)) {\n\t\tflush = 1;\n\t\tflush_write_bio(epd);\n\t\tbtrfs_tree_lock(eb);\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags)) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tif (!epd->sync_io)\n\t\t\treturn 0;\n\t\tif (!flush) {\n\t\t\tflush_write_bio(epd);\n\t\t\tflush = 1;\n\t\t}\n\t\twhile (1) {\n\t\t\twait_on_extent_buffer_writeback(eb);\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (!test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags))\n\t\t\t\tbreak;\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t}\n\t}\n\n\t/*\n\t * We need to do this to prevent races in people who check if the eb is\n\t * under IO since we can end up having no IO bits set for a short period\n\t * of time.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)) {\n\t\tset_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\t\tspin_unlock(&eb->refs_lock);\n\t\tbtrfs_set_header_flag(eb, BTRFS_HEADER_FLAG_WRITTEN);\n\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t     -eb->len,\n\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\tret = 1;\n\t} else {\n\t\tspin_unlock(&eb->refs_lock);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (!trylock_page(p)) {\n\t\t\tif (!flush) {\n\t\t\t\tflush_write_bio(epd);\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __extent_read_full_page(struct extent_io_tree *tree,\n\t\t\t\t   struct page *page,\n\t\t\t\t   get_extent_t *get_extent,\n\t\t\t\t   struct bio **bio, int mirror_num,\n\t\t\t\t   unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct btrfs_ordered_extent *ordered;\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tint ret;\n\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_extent(inode, start);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tret = __do_readpage(tree, page, get_extent, NULL, bio, mirror_num,\n\t\t\t    bio_flags, rw);\n\treturn ret;\n}"
  },
  {
    "function_name": "__extent_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3108-3146",
    "snippet": "static void __extent_readpages(struct extent_io_tree *tree,\n\t\t\t       struct page *pages[],\n\t\t\t       int nr_pages, get_extent_t *get_extent,\n\t\t\t       struct extent_map **em_cached,\n\t\t\t       struct bio **bio, int mirror_num,\n\t\t\t       unsigned long *bio_flags, int rw)\n{\n\tu64 start = 0;\n\tu64 end = 0;\n\tu64 page_start;\n\tint index;\n\tint first_index = 0;\n\n\tfor (index = 0; index < nr_pages; index++) {\n\t\tpage_start = page_offset(pages[index]);\n\t\tif (!end) {\n\t\t\tstart = page_start;\n\t\t\tend = start + PAGE_CACHE_SIZE - 1;\n\t\t\tfirst_index = index;\n\t\t} else if (end + 1 == page_start) {\n\t\t\tend += PAGE_CACHE_SIZE;\n\t\t} else {\n\t\t\t__do_contiguous_readpages(tree, &pages[first_index],\n\t\t\t\t\t\t  index - first_index, start,\n\t\t\t\t\t\t  end, get_extent, em_cached,\n\t\t\t\t\t\t  bio, mirror_num, bio_flags,\n\t\t\t\t\t\t  rw);\n\t\t\tstart = page_start;\n\t\t\tend = start + PAGE_CACHE_SIZE - 1;\n\t\t\tfirst_index = index;\n\t\t}\n\t}\n\n\tif (end)\n\t\t__do_contiguous_readpages(tree, &pages[first_index],\n\t\t\t\t\t  index - first_index, start,\n\t\t\t\t\t  end, get_extent, em_cached, bio,\n\t\t\t\t\t  mirror_num, bio_flags, rw);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_contiguous_readpages",
          "args": [
            "tree",
            "&pages[first_index]",
            "index - first_index",
            "start",
            "end",
            "get_extent",
            "em_cached",
            "bio",
            "mirror_num",
            "bio_flags",
            "rw"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "__do_contiguous_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3077-3106",
          "snippet": "static inline void __do_contiguous_readpages(struct extent_io_tree *tree,\n\t\t\t\t\t     struct page *pages[], int nr_pages,\n\t\t\t\t\t     u64 start, u64 end,\n\t\t\t\t\t     get_extent_t *get_extent,\n\t\t\t\t\t     struct extent_map **em_cached,\n\t\t\t\t\t     struct bio **bio, int mirror_num,\n\t\t\t\t\t     unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode;\n\tstruct btrfs_ordered_extent *ordered;\n\tint index;\n\n\tinode = pages[0]->mapping->host;\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_range(inode, start,\n\t\t\t\t\t\t     end - start + 1);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tfor (index = 0; index < nr_pages; index++) {\n\t\t__do_readpage(tree, pages[index], get_extent, em_cached, bio,\n\t\t\t      mirror_num, bio_flags, rw);\n\t\tpage_cache_release(pages[index]);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline void __do_contiguous_readpages(struct extent_io_tree *tree,\n\t\t\t\t\t     struct page *pages[], int nr_pages,\n\t\t\t\t\t     u64 start, u64 end,\n\t\t\t\t\t     get_extent_t *get_extent,\n\t\t\t\t\t     struct extent_map **em_cached,\n\t\t\t\t\t     struct bio **bio, int mirror_num,\n\t\t\t\t\t     unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode;\n\tstruct btrfs_ordered_extent *ordered;\n\tint index;\n\n\tinode = pages[0]->mapping->host;\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_range(inode, start,\n\t\t\t\t\t\t     end - start + 1);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tfor (index = 0; index < nr_pages; index++) {\n\t\t__do_readpage(tree, pages[index], get_extent, em_cached, bio,\n\t\t\t      mirror_num, bio_flags, rw);\n\t\tpage_cache_release(pages[index]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "pages[index]"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void __extent_readpages(struct extent_io_tree *tree,\n\t\t\t       struct page *pages[],\n\t\t\t       int nr_pages, get_extent_t *get_extent,\n\t\t\t       struct extent_map **em_cached,\n\t\t\t       struct bio **bio, int mirror_num,\n\t\t\t       unsigned long *bio_flags, int rw)\n{\n\tu64 start = 0;\n\tu64 end = 0;\n\tu64 page_start;\n\tint index;\n\tint first_index = 0;\n\n\tfor (index = 0; index < nr_pages; index++) {\n\t\tpage_start = page_offset(pages[index]);\n\t\tif (!end) {\n\t\t\tstart = page_start;\n\t\t\tend = start + PAGE_CACHE_SIZE - 1;\n\t\t\tfirst_index = index;\n\t\t} else if (end + 1 == page_start) {\n\t\t\tend += PAGE_CACHE_SIZE;\n\t\t} else {\n\t\t\t__do_contiguous_readpages(tree, &pages[first_index],\n\t\t\t\t\t\t  index - first_index, start,\n\t\t\t\t\t\t  end, get_extent, em_cached,\n\t\t\t\t\t\t  bio, mirror_num, bio_flags,\n\t\t\t\t\t\t  rw);\n\t\t\tstart = page_start;\n\t\t\tend = start + PAGE_CACHE_SIZE - 1;\n\t\t\tfirst_index = index;\n\t\t}\n\t}\n\n\tif (end)\n\t\t__do_contiguous_readpages(tree, &pages[first_index],\n\t\t\t\t\t  index - first_index, start,\n\t\t\t\t\t  end, get_extent, em_cached, bio,\n\t\t\t\t\t  mirror_num, bio_flags, rw);\n}"
  },
  {
    "function_name": "__do_contiguous_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "3077-3106",
    "snippet": "static inline void __do_contiguous_readpages(struct extent_io_tree *tree,\n\t\t\t\t\t     struct page *pages[], int nr_pages,\n\t\t\t\t\t     u64 start, u64 end,\n\t\t\t\t\t     get_extent_t *get_extent,\n\t\t\t\t\t     struct extent_map **em_cached,\n\t\t\t\t\t     struct bio **bio, int mirror_num,\n\t\t\t\t\t     unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode;\n\tstruct btrfs_ordered_extent *ordered;\n\tint index;\n\n\tinode = pages[0]->mapping->host;\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_range(inode, start,\n\t\t\t\t\t\t     end - start + 1);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tfor (index = 0; index < nr_pages; index++) {\n\t\t__do_readpage(tree, pages[index], get_extent, em_cached, bio,\n\t\t\t      mirror_num, bio_flags, rw);\n\t\tpage_cache_release(pages[index]);\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[index]"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__do_readpage",
          "args": [
            "tree",
            "pages[index]",
            "get_extent",
            "em_cached",
            "bio",
            "mirror_num",
            "bio_flags",
            "rw"
          ],
          "line": 3102
        },
        "resolved": true,
        "details": {
          "function_name": "__do_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2904-3075",
          "snippet": "static int __do_readpage(struct extent_io_tree *tree,\n\t\t\t struct page *page,\n\t\t\t get_extent_t *get_extent,\n\t\t\t struct extent_map **em_cached,\n\t\t\t struct bio **bio, int mirror_num,\n\t\t\t unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 last_byte = i_size_read(inode);\n\tu64 block_start;\n\tu64 cur_end;\n\tsector_t sector;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tint ret;\n\tint nr = 0;\n\tint parent_locked = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\tsize_t pg_offset = 0;\n\tsize_t iosize;\n\tsize_t disk_io_size;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tunsigned long this_bio_flag = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\n\tset_page_extent_mapped(page);\n\n\tend = page_end;\n\tif (!PageUptodate(page)) {\n\t\tif (cleancache_get_page(page) == 0) {\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tunlock_extent(tree, start, end);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (page->index == last_byte >> PAGE_CACHE_SHIFT) {\n\t\tchar *userpage;\n\t\tsize_t zero_offset = last_byte & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (zero_offset) {\n\t\t\tiosize = PAGE_CACHE_SIZE - zero_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + zero_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t}\n\t}\n\twhile (cur <= end) {\n\t\tunsigned long pnr = (last_byte >> PAGE_CACHE_SHIFT) + 1;\n\n\t\tif (cur >= last_byte) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tiosize = PAGE_CACHE_SIZE - pg_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent_cached(tree, cur,\n\t\t\t\t\t\t     cur + iosize - 1,\n\t\t\t\t\t\t     &cached, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tem = __get_extent_map(inode, page, pg_offset, cur,\n\t\t\t\t      end - cur + 1, get_extent, em_cached);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, end);\n\t\t\tbreak;\n\t\t}\n\t\textent_offset = cur - em->start;\n\t\tBUG_ON(extent_map_end(em) <= cur);\n\t\tBUG_ON(end < cur);\n\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tthis_bio_flag |= EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&this_bio_flag,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tiosize = min(extent_map_end(em) - cur, end - cur + 1);\n\t\tcur_end = min(extent_map_end(em) - 1, end);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tif (this_bio_flag & EXTENT_BIO_COMPRESSED) {\n\t\t\tdisk_io_size = em->block_len;\n\t\t\tsector = em->block_start >> 9;\n\t\t} else {\n\t\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\t\tdisk_io_size = iosize;\n\t\t}\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\tblock_start = EXTENT_MAP_HOLE;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/* we've found a hole, just zero and go on */\n\t\tif (block_start == EXTENT_MAP_HOLE) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tunlock_extent_cached(tree, cur, cur + iosize - 1,\n\t\t\t                     &cached, GFP_NOFS);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* the get_extent function already copied into the page */\n\t\tif (test_range_bit(tree, cur, cur_end,\n\t\t\t\t   EXTENT_UPTODATE, 1, NULL)) {\n\t\t\tcheck_page_uptodate(tree, page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we have an inline extent but it didn't get marked up\n\t\t * to date.  Error out\n\t\t */\n\t\tif (block_start == EXTENT_MAP_INLINE) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpnr -= page->index;\n\t\tret = submit_extent_page(rw, tree, page,\n\t\t\t\t\t sector, disk_io_size, pg_offset,\n\t\t\t\t\t bdev, bio, pnr,\n\t\t\t\t\t end_bio_extent_readpage, mirror_num,\n\t\t\t\t\t *bio_flags,\n\t\t\t\t\t this_bio_flag);\n\t\tif (!ret) {\n\t\t\tnr++;\n\t\t\t*bio_flags = this_bio_flag;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t}\nout:\n\tif (!nr) {\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __do_readpage(struct extent_io_tree *tree,\n\t\t\t struct page *page,\n\t\t\t get_extent_t *get_extent,\n\t\t\t struct extent_map **em_cached,\n\t\t\t struct bio **bio, int mirror_num,\n\t\t\t unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 last_byte = i_size_read(inode);\n\tu64 block_start;\n\tu64 cur_end;\n\tsector_t sector;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tint ret;\n\tint nr = 0;\n\tint parent_locked = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\tsize_t pg_offset = 0;\n\tsize_t iosize;\n\tsize_t disk_io_size;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tunsigned long this_bio_flag = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\n\tset_page_extent_mapped(page);\n\n\tend = page_end;\n\tif (!PageUptodate(page)) {\n\t\tif (cleancache_get_page(page) == 0) {\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tunlock_extent(tree, start, end);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (page->index == last_byte >> PAGE_CACHE_SHIFT) {\n\t\tchar *userpage;\n\t\tsize_t zero_offset = last_byte & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (zero_offset) {\n\t\t\tiosize = PAGE_CACHE_SIZE - zero_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + zero_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t}\n\t}\n\twhile (cur <= end) {\n\t\tunsigned long pnr = (last_byte >> PAGE_CACHE_SHIFT) + 1;\n\n\t\tif (cur >= last_byte) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tiosize = PAGE_CACHE_SIZE - pg_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent_cached(tree, cur,\n\t\t\t\t\t\t     cur + iosize - 1,\n\t\t\t\t\t\t     &cached, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tem = __get_extent_map(inode, page, pg_offset, cur,\n\t\t\t\t      end - cur + 1, get_extent, em_cached);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, end);\n\t\t\tbreak;\n\t\t}\n\t\textent_offset = cur - em->start;\n\t\tBUG_ON(extent_map_end(em) <= cur);\n\t\tBUG_ON(end < cur);\n\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tthis_bio_flag |= EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&this_bio_flag,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tiosize = min(extent_map_end(em) - cur, end - cur + 1);\n\t\tcur_end = min(extent_map_end(em) - 1, end);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tif (this_bio_flag & EXTENT_BIO_COMPRESSED) {\n\t\t\tdisk_io_size = em->block_len;\n\t\t\tsector = em->block_start >> 9;\n\t\t} else {\n\t\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\t\tdisk_io_size = iosize;\n\t\t}\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\tblock_start = EXTENT_MAP_HOLE;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/* we've found a hole, just zero and go on */\n\t\tif (block_start == EXTENT_MAP_HOLE) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tunlock_extent_cached(tree, cur, cur + iosize - 1,\n\t\t\t                     &cached, GFP_NOFS);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* the get_extent function already copied into the page */\n\t\tif (test_range_bit(tree, cur, cur_end,\n\t\t\t\t   EXTENT_UPTODATE, 1, NULL)) {\n\t\t\tcheck_page_uptodate(tree, page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we have an inline extent but it didn't get marked up\n\t\t * to date.  Error out\n\t\t */\n\t\tif (block_start == EXTENT_MAP_INLINE) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpnr -= page->index;\n\t\tret = submit_extent_page(rw, tree, page,\n\t\t\t\t\t sector, disk_io_size, pg_offset,\n\t\t\t\t\t bdev, bio, pnr,\n\t\t\t\t\t end_bio_extent_readpage, mirror_num,\n\t\t\t\t\t *bio_flags,\n\t\t\t\t\t this_bio_flag);\n\t\tif (!ret) {\n\t\t\tnr++;\n\t\t\t*bio_flags = this_bio_flag;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t}\nout:\n\tif (!nr) {\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_ordered_extent",
          "args": [
            "inode",
            "ordered",
            "1"
          ],
          "line": 3097
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "697-717",
          "snippet": "void btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_start_ordered_extent(struct inode *inode,\n\t\t\t\t       struct btrfs_ordered_extent *entry,\n\t\t\t\t       int wait)\n{\n\tu64 start = entry->file_offset;\n\tu64 end = start + entry->len - 1;\n\n\ttrace_btrfs_ordered_extent_start(inode, entry);\n\n\t/*\n\t * pages in the range can be dirty, clean or writeback.  We\n\t * start IO on any dirty ones so the wait doesn't stall waiting\n\t * for the flusher thread to find them\n\t */\n\tif (!test_bit(BTRFS_ORDERED_DIRECT, &entry->flags))\n\t\tfilemap_fdatawrite_range(inode->i_mapping, start, end);\n\tif (wait) {\n\t\twait_event(entry->wait, test_bit(BTRFS_ORDERED_COMPLETE,\n\t\t\t\t\t\t &entry->flags));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "tree",
            "start",
            "end"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_range",
          "args": [
            "inode",
            "start",
            "end - start + 1"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "803-839",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_range(struct inode *inode,\n\t\t\t\t\t\t\tu64 file_offset,\n\t\t\t\t\t\t\tu64 len)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node) {\n\t\tnode = tree_search(tree, file_offset + len);\n\t\tif (!node)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\t\tif (range_overlaps(entry, file_offset, len))\n\t\t\tbreak;\n\n\t\tif (entry->file_offset >= file_offset + len) {\n\t\t\tentry = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tentry = NULL;\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "tree",
            "start",
            "end"
          ],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_buffer_for_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "3556-3625",
          "snippet": "static noinline_for_stack int\nlock_extent_buffer_for_io(struct extent_buffer *eb,\n\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_page_data *epd)\n{\n\tunsigned long i, num_pages;\n\tint flush = 0;\n\tint ret = 0;\n\n\tif (!btrfs_try_tree_write_lock(eb)) {\n\t\tflush = 1;\n\t\tflush_write_bio(epd);\n\t\tbtrfs_tree_lock(eb);\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags)) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tif (!epd->sync_io)\n\t\t\treturn 0;\n\t\tif (!flush) {\n\t\t\tflush_write_bio(epd);\n\t\t\tflush = 1;\n\t\t}\n\t\twhile (1) {\n\t\t\twait_on_extent_buffer_writeback(eb);\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (!test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags))\n\t\t\t\tbreak;\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t}\n\t}\n\n\t/*\n\t * We need to do this to prevent races in people who check if the eb is\n\t * under IO since we can end up having no IO bits set for a short period\n\t * of time.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)) {\n\t\tset_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\t\tspin_unlock(&eb->refs_lock);\n\t\tbtrfs_set_header_flag(eb, BTRFS_HEADER_FLAG_WRITTEN);\n\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t     -eb->len,\n\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\tret = 1;\n\t} else {\n\t\tspin_unlock(&eb->refs_lock);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (!trylock_page(p)) {\n\t\t\tif (!flush) {\n\t\t\t\tflush_write_bio(epd);\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic noinline_for_stack int\nlock_extent_buffer_for_io(struct extent_buffer *eb,\n\t\t\t  struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_page_data *epd)\n{\n\tunsigned long i, num_pages;\n\tint flush = 0;\n\tint ret = 0;\n\n\tif (!btrfs_try_tree_write_lock(eb)) {\n\t\tflush = 1;\n\t\tflush_write_bio(epd);\n\t\tbtrfs_tree_lock(eb);\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags)) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tif (!epd->sync_io)\n\t\t\treturn 0;\n\t\tif (!flush) {\n\t\t\tflush_write_bio(epd);\n\t\t\tflush = 1;\n\t\t}\n\t\twhile (1) {\n\t\t\twait_on_extent_buffer_writeback(eb);\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (!test_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags))\n\t\t\t\tbreak;\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t}\n\t}\n\n\t/*\n\t * We need to do this to prevent races in people who check if the eb is\n\t * under IO since we can end up having no IO bits set for a short period\n\t * of time.\n\t */\n\tspin_lock(&eb->refs_lock);\n\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &eb->bflags)) {\n\t\tset_bit(EXTENT_BUFFER_WRITEBACK, &eb->bflags);\n\t\tspin_unlock(&eb->refs_lock);\n\t\tbtrfs_set_header_flag(eb, BTRFS_HEADER_FLAG_WRITTEN);\n\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t     -eb->len,\n\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\tret = 1;\n\t} else {\n\t\tspin_unlock(&eb->refs_lock);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\n\tif (!ret)\n\t\treturn ret;\n\n\tnum_pages = num_extent_pages(eb->start, eb->len);\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tif (!trylock_page(p)) {\n\t\t\tif (!flush) {\n\t\t\t\tflush_write_bio(epd);\n\t\t\t\tflush = 1;\n\t\t\t}\n\t\t\tlock_page(p);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline void __do_contiguous_readpages(struct extent_io_tree *tree,\n\t\t\t\t\t     struct page *pages[], int nr_pages,\n\t\t\t\t\t     u64 start, u64 end,\n\t\t\t\t\t     get_extent_t *get_extent,\n\t\t\t\t\t     struct extent_map **em_cached,\n\t\t\t\t\t     struct bio **bio, int mirror_num,\n\t\t\t\t\t     unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode;\n\tstruct btrfs_ordered_extent *ordered;\n\tint index;\n\n\tinode = pages[0]->mapping->host;\n\twhile (1) {\n\t\tlock_extent(tree, start, end);\n\t\tordered = btrfs_lookup_ordered_range(inode, start,\n\t\t\t\t\t\t     end - start + 1);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tunlock_extent(tree, start, end);\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tbtrfs_put_ordered_extent(ordered);\n\t}\n\n\tfor (index = 0; index < nr_pages; index++) {\n\t\t__do_readpage(tree, pages[index], get_extent, em_cached, bio,\n\t\t\t      mirror_num, bio_flags, rw);\n\t\tpage_cache_release(pages[index]);\n\t}\n}"
  },
  {
    "function_name": "__do_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2904-3075",
    "snippet": "static int __do_readpage(struct extent_io_tree *tree,\n\t\t\t struct page *page,\n\t\t\t get_extent_t *get_extent,\n\t\t\t struct extent_map **em_cached,\n\t\t\t struct bio **bio, int mirror_num,\n\t\t\t unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 last_byte = i_size_read(inode);\n\tu64 block_start;\n\tu64 cur_end;\n\tsector_t sector;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tint ret;\n\tint nr = 0;\n\tint parent_locked = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\tsize_t pg_offset = 0;\n\tsize_t iosize;\n\tsize_t disk_io_size;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tunsigned long this_bio_flag = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\n\tset_page_extent_mapped(page);\n\n\tend = page_end;\n\tif (!PageUptodate(page)) {\n\t\tif (cleancache_get_page(page) == 0) {\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tunlock_extent(tree, start, end);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (page->index == last_byte >> PAGE_CACHE_SHIFT) {\n\t\tchar *userpage;\n\t\tsize_t zero_offset = last_byte & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (zero_offset) {\n\t\t\tiosize = PAGE_CACHE_SIZE - zero_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + zero_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t}\n\t}\n\twhile (cur <= end) {\n\t\tunsigned long pnr = (last_byte >> PAGE_CACHE_SHIFT) + 1;\n\n\t\tif (cur >= last_byte) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tiosize = PAGE_CACHE_SIZE - pg_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent_cached(tree, cur,\n\t\t\t\t\t\t     cur + iosize - 1,\n\t\t\t\t\t\t     &cached, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tem = __get_extent_map(inode, page, pg_offset, cur,\n\t\t\t\t      end - cur + 1, get_extent, em_cached);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, end);\n\t\t\tbreak;\n\t\t}\n\t\textent_offset = cur - em->start;\n\t\tBUG_ON(extent_map_end(em) <= cur);\n\t\tBUG_ON(end < cur);\n\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tthis_bio_flag |= EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&this_bio_flag,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tiosize = min(extent_map_end(em) - cur, end - cur + 1);\n\t\tcur_end = min(extent_map_end(em) - 1, end);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tif (this_bio_flag & EXTENT_BIO_COMPRESSED) {\n\t\t\tdisk_io_size = em->block_len;\n\t\t\tsector = em->block_start >> 9;\n\t\t} else {\n\t\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\t\tdisk_io_size = iosize;\n\t\t}\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\tblock_start = EXTENT_MAP_HOLE;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/* we've found a hole, just zero and go on */\n\t\tif (block_start == EXTENT_MAP_HOLE) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tunlock_extent_cached(tree, cur, cur + iosize - 1,\n\t\t\t                     &cached, GFP_NOFS);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* the get_extent function already copied into the page */\n\t\tif (test_range_bit(tree, cur, cur_end,\n\t\t\t\t   EXTENT_UPTODATE, 1, NULL)) {\n\t\t\tcheck_page_uptodate(tree, page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we have an inline extent but it didn't get marked up\n\t\t * to date.  Error out\n\t\t */\n\t\tif (block_start == EXTENT_MAP_INLINE) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpnr -= page->index;\n\t\tret = submit_extent_page(rw, tree, page,\n\t\t\t\t\t sector, disk_io_size, pg_offset,\n\t\t\t\t\t bdev, bio, pnr,\n\t\t\t\t\t end_bio_extent_readpage, mirror_num,\n\t\t\t\t\t *bio_flags,\n\t\t\t\t\t this_bio_flag);\n\t\tif (!ret) {\n\t\t\tnr++;\n\t\t\t*bio_flags = this_bio_flag;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t}\nout:\n\tif (!nr) {\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "tree",
            "cur",
            "cur + iosize - 1"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_extent_page",
          "args": [
            "rw",
            "tree",
            "page",
            "sector",
            "disk_io_size",
            "pg_offset",
            "bdev",
            "bio",
            "pnr",
            "end_bio_extent_readpage",
            "mirror_num",
            "*bio_flags",
            "this_bio_flag"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "submit_extent_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2789-2848",
          "snippet": "static int submit_extent_page(int rw, struct extent_io_tree *tree,\n\t\t\t      struct page *page, sector_t sector,\n\t\t\t      size_t size, unsigned long offset,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct bio **bio_ret,\n\t\t\t      unsigned long max_pages,\n\t\t\t      bio_end_io_t end_io_func,\n\t\t\t      int mirror_num,\n\t\t\t      unsigned long prev_bio_flags,\n\t\t\t      unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio *bio;\n\tint nr;\n\tint contig = 0;\n\tint this_compressed = bio_flags & EXTENT_BIO_COMPRESSED;\n\tint old_compressed = prev_bio_flags & EXTENT_BIO_COMPRESSED;\n\tsize_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);\n\n\tif (bio_ret && *bio_ret) {\n\t\tbio = *bio_ret;\n\t\tif (old_compressed)\n\t\t\tcontig = bio->bi_iter.bi_sector == sector;\n\t\telse\n\t\t\tcontig = bio_end_sector(bio) == sector;\n\n\t\tif (prev_bio_flags != bio_flags || !contig ||\n\t\t    merge_bio(rw, tree, page, offset, page_size, bio, bio_flags) ||\n\t\t    bio_add_page(bio, page, page_size, offset) < page_size) {\n\t\t\tret = submit_one_bio(rw, bio, mirror_num,\n\t\t\t\t\t     prev_bio_flags);\n\t\t\tif (ret < 0) {\n\t\t\t\t*bio_ret = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbio = NULL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (this_compressed)\n\t\tnr = BIO_MAX_PAGES;\n\telse\n\t\tnr = bio_get_nr_vecs(bdev);\n\n\tbio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_add_page(bio, page, page_size, offset);\n\tbio->bi_end_io = end_io_func;\n\tbio->bi_private = tree;\n\n\tif (bio_ret)\n\t\t*bio_ret = bio;\n\telse\n\t\tret = submit_one_bio(rw, bio, mirror_num, bio_flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int submit_extent_page(int rw, struct extent_io_tree *tree,\n\t\t\t      struct page *page, sector_t sector,\n\t\t\t      size_t size, unsigned long offset,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct bio **bio_ret,\n\t\t\t      unsigned long max_pages,\n\t\t\t      bio_end_io_t end_io_func,\n\t\t\t      int mirror_num,\n\t\t\t      unsigned long prev_bio_flags,\n\t\t\t      unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio *bio;\n\tint nr;\n\tint contig = 0;\n\tint this_compressed = bio_flags & EXTENT_BIO_COMPRESSED;\n\tint old_compressed = prev_bio_flags & EXTENT_BIO_COMPRESSED;\n\tsize_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);\n\n\tif (bio_ret && *bio_ret) {\n\t\tbio = *bio_ret;\n\t\tif (old_compressed)\n\t\t\tcontig = bio->bi_iter.bi_sector == sector;\n\t\telse\n\t\t\tcontig = bio_end_sector(bio) == sector;\n\n\t\tif (prev_bio_flags != bio_flags || !contig ||\n\t\t    merge_bio(rw, tree, page, offset, page_size, bio, bio_flags) ||\n\t\t    bio_add_page(bio, page, page_size, offset) < page_size) {\n\t\t\tret = submit_one_bio(rw, bio, mirror_num,\n\t\t\t\t\t     prev_bio_flags);\n\t\t\tif (ret < 0) {\n\t\t\t\t*bio_ret = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbio = NULL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (this_compressed)\n\t\tnr = BIO_MAX_PAGES;\n\telse\n\t\tnr = bio_get_nr_vecs(bdev);\n\n\tbio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_add_page(bio, page, page_size, offset);\n\tbio->bi_end_io = end_io_func;\n\tbio->bi_private = tree;\n\n\tif (bio_ret)\n\t\t*bio_ret = bio;\n\telse\n\t\tret = submit_one_bio(rw, bio, mirror_num, bio_flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_page_uptodate",
          "args": [
            "tree",
            "page"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "check_page_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1985-1991",
          "snippet": "static void check_page_uptodate(struct extent_io_tree *tree, struct page *page)\n{\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tif (test_range_bit(tree, start, end, EXTENT_UPTODATE, 1, NULL))\n\t\tSetPageUptodate(page);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void check_page_uptodate(struct extent_io_tree *tree, struct page *page)\n{\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tif (test_range_bit(tree, start, end, EXTENT_UPTODATE, 1, NULL))\n\t\tSetPageUptodate(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_range_bit",
          "args": [
            "tree",
            "cur",
            "cur_end",
            "EXTENT_UPTODATE",
            "1",
            "NULL"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "test_range_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1931-1979",
          "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "tree",
            "cur",
            "cur + iosize - 1",
            "&cached",
            "GFP_NOFS"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_extent_uptodate",
          "args": [
            "tree",
            "cur",
            "cur + iosize - 1",
            "&cached",
            "GFP_NOFS"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1314-1319",
          "snippet": "int set_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_UPTODATE, NULL,\n\t\t\t      cached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_UPTODATE, NULL,\n\t\t\t      cached_state, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "userpage"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "userpage + pg_offset",
            "0",
            "iosize"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 3007
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_PREALLOC",
            "&em->flags"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "iosize",
            "blocksize"
          ],
          "line": 2995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "extent_map_end(em) - 1",
            "end"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_set_compress_type",
          "args": [
            "&this_bio_flag",
            "em->compress_type"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "extent_set_compress_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "164-168",
          "snippet": "static inline void extent_set_compress_type(unsigned long *bio_flags,\n\t\t\t\t\t    int compress_type)\n{\n\t*bio_flags |= compress_type << EXTENT_BIO_FLAG_SHIFT;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BIO_FLAG_SHIFT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\n#define EXTENT_BIO_FLAG_SHIFT 16\n\nstatic inline void extent_set_compress_type(unsigned long *bio_flags,\n\t\t\t\t\t    int compress_type)\n{\n\t*bio_flags |= compress_type << EXTENT_BIO_FLAG_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end < cur"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "extent_map_end(em) <= cur"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "em"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_extent_map",
          "args": [
            "inode",
            "page",
            "pg_offset",
            "cur",
            "end - cur + 1",
            "get_extent",
            "em_cached"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "__get_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2871-2897",
          "snippet": "static struct extent_map *\n__get_extent_map(struct inode *inode, struct page *page, size_t pg_offset,\n\t\t u64 start, u64 len, get_extent_t *get_extent,\n\t\t struct extent_map **em_cached)\n{\n\tstruct extent_map *em;\n\n\tif (em_cached && *em_cached) {\n\t\tem = *em_cached;\n\t\tif (extent_map_in_tree(em) && start >= em->start &&\n\t\t    start < extent_map_end(em)) {\n\t\t\tatomic_inc(&em->refs);\n\t\t\treturn em;\n\t\t}\n\n\t\tfree_extent_map(em);\n\t\t*em_cached = NULL;\n\t}\n\n\tem = get_extent(inode, page, pg_offset, start, len, 0);\n\tif (em_cached && !IS_ERR_OR_NULL(em)) {\n\t\tBUG_ON(*em_cached);\n\t\tatomic_inc(&em->refs);\n\t\t*em_cached = em;\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_map *\n__get_extent_map(struct inode *inode, struct page *page, size_t pg_offset,\n\t\t u64 start, u64 len, get_extent_t *get_extent,\n\t\t struct extent_map **em_cached)\n{\n\tstruct extent_map *em;\n\n\tif (em_cached && *em_cached) {\n\t\tem = *em_cached;\n\t\tif (extent_map_in_tree(em) && start >= em->start &&\n\t\t    start < extent_map_end(em)) {\n\t\t\tatomic_inc(&em->refs);\n\t\t\treturn em;\n\t\t}\n\n\t\tfree_extent_map(em);\n\t\t*em_cached = NULL;\n\t}\n\n\tem = get_extent(inode, page, pg_offset, start, len, 0);\n\tif (em_cached && !IS_ERR_OR_NULL(em)) {\n\t\tBUG_ON(*em_cached);\n\t\tatomic_inc(&em->refs);\n\t\t*em_cached = em;\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "userpage"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "userpage + pg_offset",
            "0",
            "iosize"
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "userpage"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "userpage + zero_offset",
            "0",
            "iosize"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "blocksize != PAGE_SIZE"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleancache_get_page",
          "args": [
            "page"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_extent_mapped",
          "args": [
            "page"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_extent_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2862-2869",
          "snippet": "void set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __do_readpage(struct extent_io_tree *tree,\n\t\t\t struct page *page,\n\t\t\t get_extent_t *get_extent,\n\t\t\t struct extent_map **em_cached,\n\t\t\t struct bio **bio, int mirror_num,\n\t\t\t unsigned long *bio_flags, int rw)\n{\n\tstruct inode *inode = page->mapping->host;\n\tu64 start = page_offset(page);\n\tu64 page_end = start + PAGE_CACHE_SIZE - 1;\n\tu64 end;\n\tu64 cur = start;\n\tu64 extent_offset;\n\tu64 last_byte = i_size_read(inode);\n\tu64 block_start;\n\tu64 cur_end;\n\tsector_t sector;\n\tstruct extent_map *em;\n\tstruct block_device *bdev;\n\tint ret;\n\tint nr = 0;\n\tint parent_locked = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\tsize_t pg_offset = 0;\n\tsize_t iosize;\n\tsize_t disk_io_size;\n\tsize_t blocksize = inode->i_sb->s_blocksize;\n\tunsigned long this_bio_flag = *bio_flags & EXTENT_BIO_PARENT_LOCKED;\n\n\tset_page_extent_mapped(page);\n\n\tend = page_end;\n\tif (!PageUptodate(page)) {\n\t\tif (cleancache_get_page(page) == 0) {\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tunlock_extent(tree, start, end);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (page->index == last_byte >> PAGE_CACHE_SHIFT) {\n\t\tchar *userpage;\n\t\tsize_t zero_offset = last_byte & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (zero_offset) {\n\t\t\tiosize = PAGE_CACHE_SIZE - zero_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + zero_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t}\n\t}\n\twhile (cur <= end) {\n\t\tunsigned long pnr = (last_byte >> PAGE_CACHE_SHIFT) + 1;\n\n\t\tif (cur >= last_byte) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tiosize = PAGE_CACHE_SIZE - pg_offset;\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent_cached(tree, cur,\n\t\t\t\t\t\t     cur + iosize - 1,\n\t\t\t\t\t\t     &cached, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tem = __get_extent_map(inode, page, pg_offset, cur,\n\t\t\t\t      end - cur + 1, get_extent, em_cached);\n\t\tif (IS_ERR_OR_NULL(em)) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, end);\n\t\t\tbreak;\n\t\t}\n\t\textent_offset = cur - em->start;\n\t\tBUG_ON(extent_map_end(em) <= cur);\n\t\tBUG_ON(end < cur);\n\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tthis_bio_flag |= EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&this_bio_flag,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tiosize = min(extent_map_end(em) - cur, end - cur + 1);\n\t\tcur_end = min(extent_map_end(em) - 1, end);\n\t\tiosize = ALIGN(iosize, blocksize);\n\t\tif (this_bio_flag & EXTENT_BIO_COMPRESSED) {\n\t\t\tdisk_io_size = em->block_len;\n\t\t\tsector = em->block_start >> 9;\n\t\t} else {\n\t\t\tsector = (em->block_start + extent_offset) >> 9;\n\t\t\tdisk_io_size = iosize;\n\t\t}\n\t\tbdev = em->bdev;\n\t\tblock_start = em->block_start;\n\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\tblock_start = EXTENT_MAP_HOLE;\n\t\tfree_extent_map(em);\n\t\tem = NULL;\n\n\t\t/* we've found a hole, just zero and go on */\n\t\tif (block_start == EXTENT_MAP_HOLE) {\n\t\t\tchar *userpage;\n\t\t\tstruct extent_state *cached = NULL;\n\n\t\t\tuserpage = kmap_atomic(page);\n\t\t\tmemset(userpage + pg_offset, 0, iosize);\n\t\t\tflush_dcache_page(page);\n\t\t\tkunmap_atomic(userpage);\n\n\t\t\tset_extent_uptodate(tree, cur, cur + iosize - 1,\n\t\t\t\t\t    &cached, GFP_NOFS);\n\t\t\tunlock_extent_cached(tree, cur, cur + iosize - 1,\n\t\t\t                     &cached, GFP_NOFS);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* the get_extent function already copied into the page */\n\t\tif (test_range_bit(tree, cur, cur_end,\n\t\t\t\t   EXTENT_UPTODATE, 1, NULL)) {\n\t\t\tcheck_page_uptodate(tree, page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\t\t/* we have an inline extent but it didn't get marked up\n\t\t * to date.  Error out\n\t\t */\n\t\tif (block_start == EXTENT_MAP_INLINE) {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t\tcur = cur + iosize;\n\t\t\tpg_offset += iosize;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpnr -= page->index;\n\t\tret = submit_extent_page(rw, tree, page,\n\t\t\t\t\t sector, disk_io_size, pg_offset,\n\t\t\t\t\t bdev, bio, pnr,\n\t\t\t\t\t end_bio_extent_readpage, mirror_num,\n\t\t\t\t\t *bio_flags,\n\t\t\t\t\t this_bio_flag);\n\t\tif (!ret) {\n\t\t\tnr++;\n\t\t\t*bio_flags = this_bio_flag;\n\t\t} else {\n\t\t\tSetPageError(page);\n\t\t\tif (!parent_locked)\n\t\t\t\tunlock_extent(tree, cur, cur + iosize - 1);\n\t\t}\n\t\tcur = cur + iosize;\n\t\tpg_offset += iosize;\n\t}\nout:\n\tif (!nr) {\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__get_extent_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2871-2897",
    "snippet": "static struct extent_map *\n__get_extent_map(struct inode *inode, struct page *page, size_t pg_offset,\n\t\t u64 start, u64 len, get_extent_t *get_extent,\n\t\t struct extent_map **em_cached)\n{\n\tstruct extent_map *em;\n\n\tif (em_cached && *em_cached) {\n\t\tem = *em_cached;\n\t\tif (extent_map_in_tree(em) && start >= em->start &&\n\t\t    start < extent_map_end(em)) {\n\t\t\tatomic_inc(&em->refs);\n\t\t\treturn em;\n\t\t}\n\n\t\tfree_extent_map(em);\n\t\t*em_cached = NULL;\n\t}\n\n\tem = get_extent(inode, page, pg_offset, start, len, 0);\n\tif (em_cached && !IS_ERR_OR_NULL(em)) {\n\t\tBUG_ON(*em_cached);\n\t\tatomic_inc(&em->refs);\n\t\t*em_cached = em;\n\t}\n\treturn em;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&em->refs"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*em_cached"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "em"
          ],
          "line": 2891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_extent",
          "args": [
            "inode",
            "page",
            "pg_offset",
            "start",
            "len",
            "0"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_extent_fiemap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "6744-6869",
          "snippet": "struct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct extent_map *btrfs_get_extent_fiemap(struct inode *inode, struct page *page,\n\t\t\t\t\t   size_t pg_offset, u64 start, u64 len,\n\t\t\t\t\t   int create)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *hole_em = NULL;\n\tu64 range_start = start;\n\tu64 end;\n\tu64 found;\n\tu64 found_end;\n\tint err = 0;\n\n\tem = btrfs_get_extent(inode, page, pg_offset, start, len, create);\n\tif (IS_ERR(em))\n\t\treturn em;\n\tif (em) {\n\t\t/*\n\t\t * if our em maps to\n\t\t * -  a hole or\n\t\t * -  a pre-alloc extent,\n\t\t * there might actually be delalloc bytes behind it.\n\t\t */\n\t\tif (em->block_start != EXTENT_MAP_HOLE &&\n\t\t    !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))\n\t\t\treturn em;\n\t\telse\n\t\t\thole_em = em;\n\t}\n\n\t/* check to see if we've wrapped (len == -1 or similar) */\n\tend = start + len;\n\tif (end < start)\n\t\tend = (u64)-1;\n\telse\n\t\tend -= 1;\n\n\tem = NULL;\n\n\t/* ok, we didn't find anything, lets look for delalloc */\n\tfound = count_range_bits(&BTRFS_I(inode)->io_tree, &range_start,\n\t\t\t\t end, len, EXTENT_DELALLOC, 1);\n\tfound_end = range_start + found;\n\tif (found_end < range_start)\n\t\tfound_end = (u64)-1;\n\n\t/*\n\t * we didn't find anything useful, return\n\t * the original results from get_extent()\n\t */\n\tif (range_start > end || found_end <= start) {\n\t\tem = hole_em;\n\t\thole_em = NULL;\n\t\tgoto out;\n\t}\n\n\t/* adjust the range_start to make sure it doesn't\n\t * go backwards from the start they passed in\n\t */\n\trange_start = max(start, range_start);\n\tfound = found_end - range_start;\n\n\tif (found > 0) {\n\t\tu64 hole_start = start;\n\t\tu64 hole_len = len;\n\n\t\tem = alloc_extent_map();\n\t\tif (!em) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * when btrfs_get_extent can't find anything it\n\t\t * returns one huge hole\n\t\t *\n\t\t * make sure what it found really fits our range, and\n\t\t * adjust to make sure it is based on the start from\n\t\t * the caller\n\t\t */\n\t\tif (hole_em) {\n\t\t\tu64 calc_end = extent_map_end(hole_em);\n\n\t\t\tif (calc_end <= start || (hole_em->start > end)) {\n\t\t\t\tfree_extent_map(hole_em);\n\t\t\t\thole_em = NULL;\n\t\t\t} else {\n\t\t\t\thole_start = max(hole_em->start, start);\n\t\t\t\thole_len = calc_end - hole_start;\n\t\t\t}\n\t\t}\n\t\tem->bdev = NULL;\n\t\tif (hole_em && range_start > hole_start) {\n\t\t\t/* our hole starts before our delalloc, so we\n\t\t\t * have to return just the parts of the hole\n\t\t\t * that go until  the delalloc starts\n\t\t\t */\n\t\t\tem->len = min(hole_len,\n\t\t\t\t      range_start - hole_start);\n\t\t\tem->start = hole_start;\n\t\t\tem->orig_start = hole_start;\n\t\t\t/*\n\t\t\t * don't adjust block start at all,\n\t\t\t * it is fixed at EXTENT_MAP_HOLE\n\t\t\t */\n\t\t\tem->block_start = hole_em->block_start;\n\t\t\tem->block_len = hole_len;\n\t\t\tif (test_bit(EXTENT_FLAG_PREALLOC, &hole_em->flags))\n\t\t\t\tset_bit(EXTENT_FLAG_PREALLOC, &em->flags);\n\t\t} else {\n\t\t\tem->start = range_start;\n\t\t\tem->len = found;\n\t\t\tem->orig_start = range_start;\n\t\t\tem->block_start = EXTENT_MAP_DELALLOC;\n\t\t\tem->block_len = found;\n\t\t}\n\t} else if (hole_em) {\n\t\treturn hole_em;\n\t}\nout:\n\n\tfree_extent_map(hole_em);\n\tif (err) {\n\t\tfree_extent_map(em);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn em;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&em->refs"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_in_tree",
          "args": [
            "em"
          ],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "47-50",
          "snippet": "static inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline int extent_map_in_tree(const struct extent_map *em)\n{\n\treturn !RB_EMPTY_NODE(&em->rb_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_map *\n__get_extent_map(struct inode *inode, struct page *page, size_t pg_offset,\n\t\t u64 start, u64 len, get_extent_t *get_extent,\n\t\t struct extent_map **em_cached)\n{\n\tstruct extent_map *em;\n\n\tif (em_cached && *em_cached) {\n\t\tem = *em_cached;\n\t\tif (extent_map_in_tree(em) && start >= em->start &&\n\t\t    start < extent_map_end(em)) {\n\t\t\tatomic_inc(&em->refs);\n\t\t\treturn em;\n\t\t}\n\n\t\tfree_extent_map(em);\n\t\t*em_cached = NULL;\n\t}\n\n\tem = get_extent(inode, page, pg_offset, start, len, 0);\n\tif (em_cached && !IS_ERR_OR_NULL(em)) {\n\t\tBUG_ON(*em_cached);\n\t\tatomic_inc(&em->refs);\n\t\t*em_cached = em;\n\t}\n\treturn em;\n}"
  },
  {
    "function_name": "set_page_extent_mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2862-2869",
    "snippet": "void set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "EXTENT_PAGE_PRIVATE"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}"
  },
  {
    "function_name": "attach_extent_buffer_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2850-2860",
    "snippet": "static void attach_extent_buffer_page(struct extent_buffer *eb,\n\t\t\t\t      struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long)eb);\n\t} else {\n\t\tWARN_ON(page->private != (unsigned long)eb);\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page->private != (unsigned long)eb"
          ],
          "line": 2858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long)eb"
          ],
          "line": 2856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void attach_extent_buffer_page(struct extent_buffer *eb,\n\t\t\t\t      struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, (unsigned long)eb);\n\t} else {\n\t\tWARN_ON(page->private != (unsigned long)eb);\n\t}\n}"
  },
  {
    "function_name": "submit_extent_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2789-2848",
    "snippet": "static int submit_extent_page(int rw, struct extent_io_tree *tree,\n\t\t\t      struct page *page, sector_t sector,\n\t\t\t      size_t size, unsigned long offset,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct bio **bio_ret,\n\t\t\t      unsigned long max_pages,\n\t\t\t      bio_end_io_t end_io_func,\n\t\t\t      int mirror_num,\n\t\t\t      unsigned long prev_bio_flags,\n\t\t\t      unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio *bio;\n\tint nr;\n\tint contig = 0;\n\tint this_compressed = bio_flags & EXTENT_BIO_COMPRESSED;\n\tint old_compressed = prev_bio_flags & EXTENT_BIO_COMPRESSED;\n\tsize_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);\n\n\tif (bio_ret && *bio_ret) {\n\t\tbio = *bio_ret;\n\t\tif (old_compressed)\n\t\t\tcontig = bio->bi_iter.bi_sector == sector;\n\t\telse\n\t\t\tcontig = bio_end_sector(bio) == sector;\n\n\t\tif (prev_bio_flags != bio_flags || !contig ||\n\t\t    merge_bio(rw, tree, page, offset, page_size, bio, bio_flags) ||\n\t\t    bio_add_page(bio, page, page_size, offset) < page_size) {\n\t\t\tret = submit_one_bio(rw, bio, mirror_num,\n\t\t\t\t\t     prev_bio_flags);\n\t\t\tif (ret < 0) {\n\t\t\t\t*bio_ret = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbio = NULL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (this_compressed)\n\t\tnr = BIO_MAX_PAGES;\n\telse\n\t\tnr = bio_get_nr_vecs(bdev);\n\n\tbio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_add_page(bio, page, page_size, offset);\n\tbio->bi_end_io = end_io_func;\n\tbio->bi_private = tree;\n\n\tif (bio_ret)\n\t\t*bio_ret = bio;\n\telse\n\t\tret = submit_one_bio(rw, bio, mirror_num, bio_flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_one_bio",
          "args": [
            "rw",
            "bio",
            "mirror_num",
            "bio_flags"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "submit_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2749-2774",
          "snippet": "static int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "page_size",
            "offset"
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_bio_alloc",
          "args": [
            "bdev",
            "sector",
            "nr",
            "GFP_NOFS | __GFP_HIGH"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2690-2715",
          "snippet": "struct bio *\nbtrfs_bio_alloc(struct block_device *bdev, u64 first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_flags, nr_vecs, btrfs_bioset);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2)) {\n\t\t\tbio = bio_alloc_bioset(gfp_flags,\n\t\t\t\t\t       nr_vecs, btrfs_bioset);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *\nbtrfs_bio_alloc(struct block_device *bdev, u64 first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_flags, nr_vecs, btrfs_bioset);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2)) {\n\t\t\tbio = bio_alloc_bioset(gfp_flags,\n\t\t\t\t\t       nr_vecs, btrfs_bioset);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "bdev"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "page_size",
            "offset"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_bio",
          "args": [
            "rw",
            "tree",
            "page",
            "offset",
            "page_size",
            "bio",
            "bio_flags"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "merge_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2776-2787",
          "snippet": "static int merge_bio(int rw, struct extent_io_tree *tree, struct page *page,\n\t\t     unsigned long offset, size_t size, struct bio *bio,\n\t\t     unsigned long bio_flags)\n{\n\tint ret = 0;\n\tif (tree->ops && tree->ops->merge_bio_hook)\n\t\tret = tree->ops->merge_bio_hook(rw, page, offset, size, bio,\n\t\t\t\t\t\tbio_flags);\n\tBUG_ON(ret < 0);\n\treturn ret;\n\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int merge_bio(int rw, struct extent_io_tree *tree, struct page *page,\n\t\t     unsigned long offset, size_t size, struct bio *bio,\n\t\t     unsigned long bio_flags)\n{\n\tint ret = 0;\n\tif (tree->ops && tree->ops->merge_bio_hook)\n\t\tret = tree->ops->merge_bio_hook(rw, page, offset, size, bio,\n\t\t\t\t\t\tbio_flags);\n\tBUG_ON(ret < 0);\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_end_sector",
          "args": [
            "bio"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "size",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int submit_extent_page(int rw, struct extent_io_tree *tree,\n\t\t\t      struct page *page, sector_t sector,\n\t\t\t      size_t size, unsigned long offset,\n\t\t\t      struct block_device *bdev,\n\t\t\t      struct bio **bio_ret,\n\t\t\t      unsigned long max_pages,\n\t\t\t      bio_end_io_t end_io_func,\n\t\t\t      int mirror_num,\n\t\t\t      unsigned long prev_bio_flags,\n\t\t\t      unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio *bio;\n\tint nr;\n\tint contig = 0;\n\tint this_compressed = bio_flags & EXTENT_BIO_COMPRESSED;\n\tint old_compressed = prev_bio_flags & EXTENT_BIO_COMPRESSED;\n\tsize_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);\n\n\tif (bio_ret && *bio_ret) {\n\t\tbio = *bio_ret;\n\t\tif (old_compressed)\n\t\t\tcontig = bio->bi_iter.bi_sector == sector;\n\t\telse\n\t\t\tcontig = bio_end_sector(bio) == sector;\n\n\t\tif (prev_bio_flags != bio_flags || !contig ||\n\t\t    merge_bio(rw, tree, page, offset, page_size, bio, bio_flags) ||\n\t\t    bio_add_page(bio, page, page_size, offset) < page_size) {\n\t\t\tret = submit_one_bio(rw, bio, mirror_num,\n\t\t\t\t\t     prev_bio_flags);\n\t\t\tif (ret < 0) {\n\t\t\t\t*bio_ret = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbio = NULL;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (this_compressed)\n\t\tnr = BIO_MAX_PAGES;\n\telse\n\t\tnr = bio_get_nr_vecs(bdev);\n\n\tbio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);\n\tif (!bio)\n\t\treturn -ENOMEM;\n\n\tbio_add_page(bio, page, page_size, offset);\n\tbio->bi_end_io = end_io_func;\n\tbio->bi_private = tree;\n\n\tif (bio_ret)\n\t\t*bio_ret = bio;\n\telse\n\t\tret = submit_one_bio(rw, bio, mirror_num, bio_flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "merge_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2776-2787",
    "snippet": "static int merge_bio(int rw, struct extent_io_tree *tree, struct page *page,\n\t\t     unsigned long offset, size_t size, struct bio *bio,\n\t\t     unsigned long bio_flags)\n{\n\tint ret = 0;\n\tif (tree->ops && tree->ops->merge_bio_hook)\n\t\tret = tree->ops->merge_bio_hook(rw, page, offset, size, bio,\n\t\t\t\t\t\tbio_flags);\n\tBUG_ON(ret < 0);\n\treturn ret;\n\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->merge_bio_hook",
          "args": [
            "rw",
            "page",
            "offset",
            "size",
            "bio",
            "bio_flags"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int merge_bio(int rw, struct extent_io_tree *tree, struct page *page,\n\t\t     unsigned long offset, size_t size, struct bio *bio,\n\t\t     unsigned long bio_flags)\n{\n\tint ret = 0;\n\tif (tree->ops && tree->ops->merge_bio_hook)\n\t\tret = tree->ops->merge_bio_hook(rw, page, offset, size, bio,\n\t\t\t\t\t\tbio_flags);\n\tBUG_ON(ret < 0);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "submit_one_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2749-2774",
    "snippet": "static int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_flagged",
          "args": [
            "bio",
            "BIO_EOPNOTSUPP"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_submit_bio",
          "args": [
            "rw",
            "bio"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree->ops->submit_bio_hook",
          "args": [
            "page->mapping->host",
            "rw",
            "bio",
            "mirror_num",
            "bio_flags",
            "start"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "bio"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int __must_check submit_one_bio(int rw, struct bio *bio,\n\t\t\t\t       int mirror_num, unsigned long bio_flags)\n{\n\tint ret = 0;\n\tstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\n\tstruct page *page = bvec->bv_page;\n\tstruct extent_io_tree *tree = bio->bi_private;\n\tu64 start;\n\n\tstart = page_offset(page) + bvec->bv_offset;\n\n\tbio->bi_private = NULL;\n\n\tbio_get(bio);\n\n\tif (tree->ops && tree->ops->submit_bio_hook)\n\t\tret = tree->ops->submit_bio_hook(page->mapping->host, rw, bio,\n\t\t\t\t\t   mirror_num, bio_flags, start);\n\telse\n\t\tbtrfsic_submit_bio(rw, bio);\n\n\tif (bio_flagged(bio, BIO_EOPNOTSUPP))\n\t\tret = -EOPNOTSUPP;\n\tbio_put(bio);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_io_bio_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2733-2746",
    "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bio_set *btrfs_bioset;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "bio"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_alloc_bioset",
          "args": [
            "gfp_mask",
            "nr_iovecs",
            "btrfs_bioset"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
  },
  {
    "function_name": "btrfs_bio_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2717-2730",
    "snippet": "struct bio *btrfs_bio_clone(struct bio *bio, gfp_t gfp_mask)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *new;\n\n\tnew = bio_clone_bioset(bio, gfp_mask, btrfs_bioset);\n\tif (new) {\n\t\tbtrfs_bio = btrfs_io_bio(new);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn new;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bio_set *btrfs_bioset;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "new"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_clone_bioset",
          "args": [
            "bio",
            "gfp_mask",
            "btrfs_bioset"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_bio_clone(struct bio *bio, gfp_t gfp_mask)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *new;\n\n\tnew = bio_clone_bioset(bio, gfp_mask, btrfs_bioset);\n\tif (new) {\n\t\tbtrfs_bio = btrfs_io_bio(new);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn new;\n}"
  },
  {
    "function_name": "btrfs_bio_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2690-2715",
    "snippet": "struct bio *\nbtrfs_bio_alloc(struct block_device *bdev, u64 first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_flags, nr_vecs, btrfs_bioset);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2)) {\n\t\t\tbio = bio_alloc_bioset(gfp_flags,\n\t\t\t\t\t       nr_vecs, btrfs_bioset);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bio_set *btrfs_bioset;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "bio"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_alloc_bioset",
          "args": [
            "gfp_flags",
            "nr_vecs",
            "btrfs_bioset"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc_bioset",
          "args": [
            "gfp_flags",
            "nr_vecs",
            "btrfs_bioset"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *\nbtrfs_bio_alloc(struct block_device *bdev, u64 first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_flags, nr_vecs, btrfs_bioset);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2)) {\n\t\t\tbio = bio_alloc_bioset(gfp_flags,\n\t\t\t\t\t       nr_vecs, btrfs_bioset);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
  },
  {
    "function_name": "end_bio_extent_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2546-2684",
    "snippet": "static void end_bio_extent_readpage(struct bio *bio, int err)\n{\n\tstruct bio_vec *bvec;\n\tint uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\n\tstruct btrfs_io_bio *io_bio = btrfs_io_bio(bio);\n\tstruct extent_io_tree *tree;\n\tu64 offset = 0;\n\tu64 start;\n\tu64 end;\n\tu64 len;\n\tu64 extent_start = 0;\n\tu64 extent_len = 0;\n\tint mirror;\n\tint ret;\n\tint i;\n\n\tif (err)\n\t\tuptodate = 0;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tpr_debug(\"end_bio_extent_readpage: bi_sector=%llu, err=%d, \"\n\t\t\t \"mirror=%u\\n\", (u64)bio->bi_iter.bi_sector, err,\n\t\t\t io_bio->mirror_num);\n\t\ttree = &BTRFS_I(inode)->io_tree;\n\n\t\t/* We always issue full-page reads, but if some block\n\t\t * in a page fails to read, blk_update_request() will\n\t\t * advance bv_offset and adjust bv_len to compensate.\n\t\t * Print a warning for nonzero offsets, and an error\n\t\t * if they don't add up to a full page.  */\n\t\tif (bvec->bv_offset || bvec->bv_len != PAGE_CACHE_SIZE) {\n\t\t\tif (bvec->bv_offset + bvec->bv_len != PAGE_CACHE_SIZE)\n\t\t\t\tbtrfs_err(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t\t   \"partial page read in btrfs with offset %u and length %u\",\n\t\t\t\t\tbvec->bv_offset, bvec->bv_len);\n\t\t\telse\n\t\t\t\tbtrfs_info(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t\t   \"incomplete page read in btrfs with offset %u and \"\n\t\t\t\t   \"length %u\",\n\t\t\t\t\tbvec->bv_offset, bvec->bv_len);\n\t\t}\n\n\t\tstart = page_offset(page);\n\t\tend = start + bvec->bv_offset + bvec->bv_len - 1;\n\t\tlen = bvec->bv_len;\n\n\t\tmirror = io_bio->mirror_num;\n\t\tif (likely(uptodate && tree->ops &&\n\t\t\t   tree->ops->readpage_end_io_hook)) {\n\t\t\tret = tree->ops->readpage_end_io_hook(io_bio, offset,\n\t\t\t\t\t\t\t      page, start, end,\n\t\t\t\t\t\t\t      mirror);\n\t\t\tif (ret)\n\t\t\t\tuptodate = 0;\n\t\t\telse\n\t\t\t\tclean_io_failure(inode, start, page, 0);\n\t\t}\n\n\t\tif (likely(uptodate))\n\t\t\tgoto readpage_ok;\n\n\t\tif (tree->ops && tree->ops->readpage_io_failed_hook) {\n\t\t\tret = tree->ops->readpage_io_failed_hook(page, mirror);\n\t\t\tif (!ret && !err &&\n\t\t\t    test_bit(BIO_UPTODATE, &bio->bi_flags))\n\t\t\t\tuptodate = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The generic bio_readpage_error handles errors the\n\t\t\t * following way: If possible, new read requests are\n\t\t\t * created and submitted and will end up in\n\t\t\t * end_bio_extent_readpage as well (if we're lucky, not\n\t\t\t * in the !uptodate case). In that case it returns 0 and\n\t\t\t * we just go on with the next page in our bio. If it\n\t\t\t * can't handle the error it will return -EIO and we\n\t\t\t * remain responsible for that page.\n\t\t\t */\n\t\t\tret = bio_readpage_error(bio, offset, page, start, end,\n\t\t\t\t\t\t mirror);\n\t\t\tif (ret == 0) {\n\t\t\t\tuptodate =\n\t\t\t\t\ttest_bit(BIO_UPTODATE, &bio->bi_flags);\n\t\t\t\tif (err)\n\t\t\t\t\tuptodate = 0;\n\t\t\t\toffset += len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\nreadpage_ok:\n\t\tif (likely(uptodate)) {\n\t\t\tloff_t i_size = i_size_read(inode);\n\t\t\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\t\t\tunsigned off;\n\n\t\t\t/* Zero out the end if this page straddles i_size */\n\t\t\toff = i_size & (PAGE_CACHE_SIZE-1);\n\t\t\tif (page->index == end_index && off)\n\t\t\t\tzero_user_segment(page, off, PAGE_CACHE_SIZE);\n\t\t\tSetPageUptodate(page);\n\t\t} else {\n\t\t\tClearPageUptodate(page);\n\t\t\tSetPageError(page);\n\t\t}\n\t\tunlock_page(page);\n\t\toffset += len;\n\n\t\tif (unlikely(!uptodate)) {\n\t\t\tif (extent_len) {\n\t\t\t\tendio_readpage_release_extent(tree,\n\t\t\t\t\t\t\t      extent_start,\n\t\t\t\t\t\t\t      extent_len, 1);\n\t\t\t\textent_start = 0;\n\t\t\t\textent_len = 0;\n\t\t\t}\n\t\t\tendio_readpage_release_extent(tree, start,\n\t\t\t\t\t\t      end - start + 1, 0);\n\t\t} else if (!extent_len) {\n\t\t\textent_start = start;\n\t\t\textent_len = end + 1 - start;\n\t\t} else if (extent_start + extent_len == start) {\n\t\t\textent_len += end + 1 - start;\n\t\t} else {\n\t\t\tendio_readpage_release_extent(tree, extent_start,\n\t\t\t\t\t\t      extent_len, uptodate);\n\t\t\textent_start = start;\n\t\t\textent_len = end + 1 - start;\n\t\t}\n\t}\n\n\tif (extent_len)\n\t\tendio_readpage_release_extent(tree, extent_start, extent_len,\n\t\t\t\t\t      uptodate);\n\tif (io_bio->end_io)\n\t\tio_bio->end_io(io_bio, err);\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_bio->end_io",
          "args": [
            "io_bio",
            "err"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endio_readpage_release_extent",
          "args": [
            "tree",
            "extent_start",
            "extent_len",
            "uptodate"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "endio_readpage_release_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2523-2533",
          "snippet": "static void\nendio_readpage_release_extent(struct extent_io_tree *tree, u64 start, u64 len,\n\t\t\t      int uptodate)\n{\n\tstruct extent_state *cached = NULL;\n\tu64 end = start + len - 1;\n\n\tif (uptodate && tree->track_uptodate)\n\t\tset_extent_uptodate(tree, start, end, &cached, GFP_ATOMIC);\n\tunlock_extent_cached(tree, start, end, &cached, GFP_ATOMIC);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void\nendio_readpage_release_extent(struct extent_io_tree *tree, u64 start, u64 len,\n\t\t\t      int uptodate)\n{\n\tstruct extent_state *cached = NULL;\n\tu64 end = start + len - 1;\n\n\tif (uptodate && tree->track_uptodate)\n\t\tset_extent_uptodate(tree, start, end, &cached, GFP_ATOMIC);\n\tunlock_extent_cached(tree, start, end, &cached, GFP_ATOMIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!uptodate"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "off",
            "PAGE_CACHE_SIZE"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "uptodate"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_readpage_error",
          "args": [
            "bio",
            "offset",
            "page",
            "start",
            "end",
            "mirror"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "bio_readpage_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2397-2447",
          "snippet": "static int bio_readpage_error(struct bio *failed_bio, u64 phy_offset,\n\t\t\t      struct page *page, u64 start, u64 end,\n\t\t\t      int failed_mirror)\n{\n\tstruct io_failure_record *failrec;\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct bio *bio;\n\tint read_mode;\n\tint ret;\n\n\tBUG_ON(failed_bio->bi_rw & REQ_WRITE);\n\n\tret = btrfs_get_io_failure_record(inode, start, end, &failrec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_check_repairable(inode, failed_bio, failrec, failed_mirror);\n\tif (!ret) {\n\t\tfree_io_failure(inode, failrec);\n\t\treturn -EIO;\n\t}\n\n\tif (failed_bio->bi_vcnt > 1)\n\t\tread_mode = READ_SYNC | REQ_FAILFAST_DEV;\n\telse\n\t\tread_mode = READ_SYNC;\n\n\tphy_offset >>= inode->i_sb->s_blocksize_bits;\n\tbio = btrfs_create_repair_bio(inode, failed_bio, failrec, page,\n\t\t\t\t      start - page_offset(page),\n\t\t\t\t      (int)phy_offset, failed_bio->bi_end_io,\n\t\t\t\t      NULL);\n\tif (!bio) {\n\t\tfree_io_failure(inode, failrec);\n\t\treturn -EIO;\n\t}\n\n\tpr_debug(\"Repair Read Error: submitting new read[%#x] to this_mirror=%d, in_validation=%d\\n\",\n\t\t read_mode, failrec->this_mirror, failrec->in_validation);\n\n\tret = tree->ops->submit_bio_hook(inode, read_mode, bio,\n\t\t\t\t\t failrec->this_mirror,\n\t\t\t\t\t failrec->bio_flags, 0);\n\tif (ret) {\n\t\tfree_io_failure(inode, failrec);\n\t\tbio_put(bio);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int bio_readpage_error(struct bio *failed_bio, u64 phy_offset,\n\t\t\t      struct page *page, u64 start, u64 end,\n\t\t\t      int failed_mirror)\n{\n\tstruct io_failure_record *failrec;\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct bio *bio;\n\tint read_mode;\n\tint ret;\n\n\tBUG_ON(failed_bio->bi_rw & REQ_WRITE);\n\n\tret = btrfs_get_io_failure_record(inode, start, end, &failrec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_check_repairable(inode, failed_bio, failrec, failed_mirror);\n\tif (!ret) {\n\t\tfree_io_failure(inode, failrec);\n\t\treturn -EIO;\n\t}\n\n\tif (failed_bio->bi_vcnt > 1)\n\t\tread_mode = READ_SYNC | REQ_FAILFAST_DEV;\n\telse\n\t\tread_mode = READ_SYNC;\n\n\tphy_offset >>= inode->i_sb->s_blocksize_bits;\n\tbio = btrfs_create_repair_bio(inode, failed_bio, failrec, page,\n\t\t\t\t      start - page_offset(page),\n\t\t\t\t      (int)phy_offset, failed_bio->bi_end_io,\n\t\t\t\t      NULL);\n\tif (!bio) {\n\t\tfree_io_failure(inode, failrec);\n\t\treturn -EIO;\n\t}\n\n\tpr_debug(\"Repair Read Error: submitting new read[%#x] to this_mirror=%d, in_validation=%d\\n\",\n\t\t read_mode, failrec->this_mirror, failrec->in_validation);\n\n\tret = tree->ops->submit_bio_hook(inode, read_mode, bio,\n\t\t\t\t\t failrec->this_mirror,\n\t\t\t\t\t failrec->bio_flags, 0);\n\tif (ret) {\n\t\tfree_io_failure(inode, failrec);\n\t\tbio_put(bio);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree->ops->readpage_io_failed_hook",
          "args": [
            "page",
            "mirror"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "uptodate"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clean_io_failure",
          "args": [
            "inode",
            "start",
            "page",
            "0"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "clean_io_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2112-2167",
          "snippet": "int clean_io_failure(struct inode *inode, u64 start, struct page *page,\n\t\t     unsigned int pg_offset)\n{\n\tu64 private;\n\tu64 private_failure;\n\tstruct io_failure_record *failrec;\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct extent_state *state;\n\tint num_copies;\n\tint ret;\n\n\tprivate = 0;\n\tret = count_range_bits(&BTRFS_I(inode)->io_failure_tree, &private,\n\t\t\t\t(u64)-1, 1, EXTENT_DIRTY, 0);\n\tif (!ret)\n\t\treturn 0;\n\n\tret = get_state_private(&BTRFS_I(inode)->io_failure_tree, start,\n\t\t\t\t&private_failure);\n\tif (ret)\n\t\treturn 0;\n\n\tfailrec = (struct io_failure_record *)(unsigned long) private_failure;\n\tBUG_ON(!failrec->this_mirror);\n\n\tif (failrec->in_validation) {\n\t\t/* there was no real error, just free the record */\n\t\tpr_debug(\"clean_io_failure: freeing dummy error at %llu\\n\",\n\t\t\t failrec->start);\n\t\tgoto out;\n\t}\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\tgoto out;\n\n\tspin_lock(&BTRFS_I(inode)->io_tree.lock);\n\tstate = find_first_extent_bit_state(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t    failrec->start,\n\t\t\t\t\t    EXTENT_LOCKED);\n\tspin_unlock(&BTRFS_I(inode)->io_tree.lock);\n\n\tif (state && state->start <= failrec->start &&\n\t    state->end >= failrec->start + failrec->len - 1) {\n\t\tnum_copies = btrfs_num_copies(fs_info, failrec->logical,\n\t\t\t\t\t      failrec->len);\n\t\tif (num_copies > 1)  {\n\t\t\trepair_io_failure(inode, start, failrec->len,\n\t\t\t\t\t  failrec->logical, page,\n\t\t\t\t\t  pg_offset, failrec->failed_mirror);\n\t\t}\n\t}\n\nout:\n\tfree_io_failure(inode, failrec);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint clean_io_failure(struct inode *inode, u64 start, struct page *page,\n\t\t     unsigned int pg_offset)\n{\n\tu64 private;\n\tu64 private_failure;\n\tstruct io_failure_record *failrec;\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct extent_state *state;\n\tint num_copies;\n\tint ret;\n\n\tprivate = 0;\n\tret = count_range_bits(&BTRFS_I(inode)->io_failure_tree, &private,\n\t\t\t\t(u64)-1, 1, EXTENT_DIRTY, 0);\n\tif (!ret)\n\t\treturn 0;\n\n\tret = get_state_private(&BTRFS_I(inode)->io_failure_tree, start,\n\t\t\t\t&private_failure);\n\tif (ret)\n\t\treturn 0;\n\n\tfailrec = (struct io_failure_record *)(unsigned long) private_failure;\n\tBUG_ON(!failrec->this_mirror);\n\n\tif (failrec->in_validation) {\n\t\t/* there was no real error, just free the record */\n\t\tpr_debug(\"clean_io_failure: freeing dummy error at %llu\\n\",\n\t\t\t failrec->start);\n\t\tgoto out;\n\t}\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\tgoto out;\n\n\tspin_lock(&BTRFS_I(inode)->io_tree.lock);\n\tstate = find_first_extent_bit_state(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t    failrec->start,\n\t\t\t\t\t    EXTENT_LOCKED);\n\tspin_unlock(&BTRFS_I(inode)->io_tree.lock);\n\n\tif (state && state->start <= failrec->start &&\n\t    state->end >= failrec->start + failrec->len - 1) {\n\t\tnum_copies = btrfs_num_copies(fs_info, failrec->logical,\n\t\t\t\t\t      failrec->len);\n\t\tif (num_copies > 1)  {\n\t\t\trepair_io_failure(inode, start, failrec->len,\n\t\t\t\t\t  failrec->logical, page,\n\t\t\t\t\t  pg_offset, failrec->failed_mirror);\n\t\t}\n\t}\n\nout:\n\tfree_io_failure(inode, failrec);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree->ops->readpage_end_io_hook",
          "args": [
            "io_bio",
            "offset",
            "page",
            "start",
            "end",
            "mirror"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "uptodate && tree->ops &&\n\t\t\t   tree->ops->readpage_end_io_hook"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "BTRFS_I(page->mapping->host)->root->fs_info",
            "\"incomplete page read in btrfs with offset %u and \"\n\t\t\t\t   \"length %u\"",
            "bvec->bv_offset",
            "bvec->bv_len"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 2585
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "BTRFS_I(page->mapping->host)->root->fs_info",
            "\"partial page read in btrfs with offset %u and length %u\"",
            "bvec->bv_offset",
            "bvec->bv_len"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"end_bio_extent_readpage: bi_sector=%llu, err=%d, \"\n\t\t\t \"mirror=%u\\n\"",
            "(u64)bio->bi_iter.bi_sector",
            "err",
            "io_bio->mirror_num"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "bio"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void end_bio_extent_readpage(struct bio *bio, int err)\n{\n\tstruct bio_vec *bvec;\n\tint uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\n\tstruct btrfs_io_bio *io_bio = btrfs_io_bio(bio);\n\tstruct extent_io_tree *tree;\n\tu64 offset = 0;\n\tu64 start;\n\tu64 end;\n\tu64 len;\n\tu64 extent_start = 0;\n\tu64 extent_len = 0;\n\tint mirror;\n\tint ret;\n\tint i;\n\n\tif (err)\n\t\tuptodate = 0;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\t\tstruct inode *inode = page->mapping->host;\n\n\t\tpr_debug(\"end_bio_extent_readpage: bi_sector=%llu, err=%d, \"\n\t\t\t \"mirror=%u\\n\", (u64)bio->bi_iter.bi_sector, err,\n\t\t\t io_bio->mirror_num);\n\t\ttree = &BTRFS_I(inode)->io_tree;\n\n\t\t/* We always issue full-page reads, but if some block\n\t\t * in a page fails to read, blk_update_request() will\n\t\t * advance bv_offset and adjust bv_len to compensate.\n\t\t * Print a warning for nonzero offsets, and an error\n\t\t * if they don't add up to a full page.  */\n\t\tif (bvec->bv_offset || bvec->bv_len != PAGE_CACHE_SIZE) {\n\t\t\tif (bvec->bv_offset + bvec->bv_len != PAGE_CACHE_SIZE)\n\t\t\t\tbtrfs_err(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t\t   \"partial page read in btrfs with offset %u and length %u\",\n\t\t\t\t\tbvec->bv_offset, bvec->bv_len);\n\t\t\telse\n\t\t\t\tbtrfs_info(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t\t   \"incomplete page read in btrfs with offset %u and \"\n\t\t\t\t   \"length %u\",\n\t\t\t\t\tbvec->bv_offset, bvec->bv_len);\n\t\t}\n\n\t\tstart = page_offset(page);\n\t\tend = start + bvec->bv_offset + bvec->bv_len - 1;\n\t\tlen = bvec->bv_len;\n\n\t\tmirror = io_bio->mirror_num;\n\t\tif (likely(uptodate && tree->ops &&\n\t\t\t   tree->ops->readpage_end_io_hook)) {\n\t\t\tret = tree->ops->readpage_end_io_hook(io_bio, offset,\n\t\t\t\t\t\t\t      page, start, end,\n\t\t\t\t\t\t\t      mirror);\n\t\t\tif (ret)\n\t\t\t\tuptodate = 0;\n\t\t\telse\n\t\t\t\tclean_io_failure(inode, start, page, 0);\n\t\t}\n\n\t\tif (likely(uptodate))\n\t\t\tgoto readpage_ok;\n\n\t\tif (tree->ops && tree->ops->readpage_io_failed_hook) {\n\t\t\tret = tree->ops->readpage_io_failed_hook(page, mirror);\n\t\t\tif (!ret && !err &&\n\t\t\t    test_bit(BIO_UPTODATE, &bio->bi_flags))\n\t\t\t\tuptodate = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The generic bio_readpage_error handles errors the\n\t\t\t * following way: If possible, new read requests are\n\t\t\t * created and submitted and will end up in\n\t\t\t * end_bio_extent_readpage as well (if we're lucky, not\n\t\t\t * in the !uptodate case). In that case it returns 0 and\n\t\t\t * we just go on with the next page in our bio. If it\n\t\t\t * can't handle the error it will return -EIO and we\n\t\t\t * remain responsible for that page.\n\t\t\t */\n\t\t\tret = bio_readpage_error(bio, offset, page, start, end,\n\t\t\t\t\t\t mirror);\n\t\t\tif (ret == 0) {\n\t\t\t\tuptodate =\n\t\t\t\t\ttest_bit(BIO_UPTODATE, &bio->bi_flags);\n\t\t\t\tif (err)\n\t\t\t\t\tuptodate = 0;\n\t\t\t\toffset += len;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\nreadpage_ok:\n\t\tif (likely(uptodate)) {\n\t\t\tloff_t i_size = i_size_read(inode);\n\t\t\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\t\t\tunsigned off;\n\n\t\t\t/* Zero out the end if this page straddles i_size */\n\t\t\toff = i_size & (PAGE_CACHE_SIZE-1);\n\t\t\tif (page->index == end_index && off)\n\t\t\t\tzero_user_segment(page, off, PAGE_CACHE_SIZE);\n\t\t\tSetPageUptodate(page);\n\t\t} else {\n\t\t\tClearPageUptodate(page);\n\t\t\tSetPageError(page);\n\t\t}\n\t\tunlock_page(page);\n\t\toffset += len;\n\n\t\tif (unlikely(!uptodate)) {\n\t\t\tif (extent_len) {\n\t\t\t\tendio_readpage_release_extent(tree,\n\t\t\t\t\t\t\t      extent_start,\n\t\t\t\t\t\t\t      extent_len, 1);\n\t\t\t\textent_start = 0;\n\t\t\t\textent_len = 0;\n\t\t\t}\n\t\t\tendio_readpage_release_extent(tree, start,\n\t\t\t\t\t\t      end - start + 1, 0);\n\t\t} else if (!extent_len) {\n\t\t\textent_start = start;\n\t\t\textent_len = end + 1 - start;\n\t\t} else if (extent_start + extent_len == start) {\n\t\t\textent_len += end + 1 - start;\n\t\t} else {\n\t\t\tendio_readpage_release_extent(tree, extent_start,\n\t\t\t\t\t\t      extent_len, uptodate);\n\t\t\textent_start = start;\n\t\t\textent_len = end + 1 - start;\n\t\t}\n\t}\n\n\tif (extent_len)\n\t\tendio_readpage_release_extent(tree, extent_start, extent_len,\n\t\t\t\t\t      uptodate);\n\tif (io_bio->end_io)\n\t\tio_bio->end_io(io_bio, err);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "endio_readpage_release_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2523-2533",
    "snippet": "static void\nendio_readpage_release_extent(struct extent_io_tree *tree, u64 start, u64 len,\n\t\t\t      int uptodate)\n{\n\tstruct extent_state *cached = NULL;\n\tu64 end = start + len - 1;\n\n\tif (uptodate && tree->track_uptodate)\n\t\tset_extent_uptodate(tree, start, end, &cached, GFP_ATOMIC);\n\tunlock_extent_cached(tree, start, end, &cached, GFP_ATOMIC);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "tree",
            "start",
            "end",
            "&cached",
            "GFP_ATOMIC"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_extent_uptodate",
          "args": [
            "tree",
            "start",
            "end",
            "&cached",
            "GFP_ATOMIC"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1314-1319",
          "snippet": "int set_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_UPTODATE, NULL,\n\t\t\t      cached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_UPTODATE, NULL,\n\t\t\t      cached_state, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void\nendio_readpage_release_extent(struct extent_io_tree *tree, u64 start, u64 len,\n\t\t\t      int uptodate)\n{\n\tstruct extent_state *cached = NULL;\n\tu64 end = start + len - 1;\n\n\tif (uptodate && tree->track_uptodate)\n\t\tset_extent_uptodate(tree, start, end, &cached, GFP_ATOMIC);\n\tunlock_extent_cached(tree, start, end, &cached, GFP_ATOMIC);\n}"
  },
  {
    "function_name": "end_bio_extent_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2484-2521",
    "snippet": "static void end_bio_extent_writepage(struct bio *bio, int err)\n{\n\tstruct bio_vec *bvec;\n\tu64 start;\n\tu64 end;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\t/* We always issue full-page reads, but if some block\n\t\t * in a page fails to read, blk_update_request() will\n\t\t * advance bv_offset and adjust bv_len to compensate.\n\t\t * Print a warning for nonzero offsets, and an error\n\t\t * if they don't add up to a full page.  */\n\t\tif (bvec->bv_offset || bvec->bv_len != PAGE_CACHE_SIZE) {\n\t\t\tif (bvec->bv_offset + bvec->bv_len != PAGE_CACHE_SIZE)\n\t\t\t\tbtrfs_err(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t\t   \"partial page write in btrfs with offset %u and length %u\",\n\t\t\t\t\tbvec->bv_offset, bvec->bv_len);\n\t\t\telse\n\t\t\t\tbtrfs_info(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t\t   \"incomplete page write in btrfs with offset %u and \"\n\t\t\t\t   \"length %u\",\n\t\t\t\t\tbvec->bv_offset, bvec->bv_len);\n\t\t}\n\n\t\tstart = page_offset(page);\n\t\tend = start + bvec->bv_offset + bvec->bv_len - 1;\n\n\t\tif (end_extent_writepage(page, err, start, end))\n\t\t\tcontinue;\n\n\t\tend_page_writeback(page);\n\t}\n\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_extent_writepage",
          "args": [
            "page",
            "err",
            "start",
            "end"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "end_extent_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2451-2473",
          "snippet": "int end_extent_writepage(struct page *page, int err, u64 start, u64 end)\n{\n\tint uptodate = (err == 0);\n\tstruct extent_io_tree *tree;\n\tint ret = 0;\n\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\n\tif (tree->ops && tree->ops->writepage_end_io_hook) {\n\t\tret = tree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t       end, NULL, uptodate);\n\t\tif (ret)\n\t\t\tuptodate = 0;\n\t}\n\n\tif (!uptodate) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tmapping_set_error(page->mapping, ret);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint end_extent_writepage(struct page *page, int err, u64 start, u64 end)\n{\n\tint uptodate = (err == 0);\n\tstruct extent_io_tree *tree;\n\tint ret = 0;\n\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\n\tif (tree->ops && tree->ops->writepage_end_io_hook) {\n\t\tret = tree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t       end, NULL, uptodate);\n\t\tif (ret)\n\t\t\tuptodate = 0;\n\t}\n\n\tif (!uptodate) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tmapping_set_error(page->mapping, ret);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "BTRFS_I(page->mapping->host)->root->fs_info",
            "\"incomplete page write in btrfs with offset %u and \"\n\t\t\t\t   \"length %u\"",
            "bvec->bv_offset",
            "bvec->bv_len"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "BTRFS_I(page->mapping->host)->root->fs_info",
            "\"partial page write in btrfs with offset %u and length %u\"",
            "bvec->bv_offset",
            "bvec->bv_len"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "bio",
            "i"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void end_bio_extent_writepage(struct bio *bio, int err)\n{\n\tstruct bio_vec *bvec;\n\tu64 start;\n\tu64 end;\n\tint i;\n\n\tbio_for_each_segment_all(bvec, bio, i) {\n\t\tstruct page *page = bvec->bv_page;\n\n\t\t/* We always issue full-page reads, but if some block\n\t\t * in a page fails to read, blk_update_request() will\n\t\t * advance bv_offset and adjust bv_len to compensate.\n\t\t * Print a warning for nonzero offsets, and an error\n\t\t * if they don't add up to a full page.  */\n\t\tif (bvec->bv_offset || bvec->bv_len != PAGE_CACHE_SIZE) {\n\t\t\tif (bvec->bv_offset + bvec->bv_len != PAGE_CACHE_SIZE)\n\t\t\t\tbtrfs_err(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t\t   \"partial page write in btrfs with offset %u and length %u\",\n\t\t\t\t\tbvec->bv_offset, bvec->bv_len);\n\t\t\telse\n\t\t\t\tbtrfs_info(BTRFS_I(page->mapping->host)->root->fs_info,\n\t\t\t\t   \"incomplete page write in btrfs with offset %u and \"\n\t\t\t\t   \"length %u\",\n\t\t\t\t\tbvec->bv_offset, bvec->bv_len);\n\t\t}\n\n\t\tstart = page_offset(page);\n\t\tend = start + bvec->bv_offset + bvec->bv_len - 1;\n\n\t\tif (end_extent_writepage(page, err, start, end))\n\t\t\tcontinue;\n\n\t\tend_page_writeback(page);\n\t}\n\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "end_extent_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2451-2473",
    "snippet": "int end_extent_writepage(struct page *page, int err, u64 start, u64 end)\n{\n\tint uptodate = (err == 0);\n\tstruct extent_io_tree *tree;\n\tint ret = 0;\n\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\n\tif (tree->ops && tree->ops->writepage_end_io_hook) {\n\t\tret = tree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t       end, NULL, uptodate);\n\t\tif (ret)\n\t\t\tuptodate = 0;\n\t}\n\n\tif (!uptodate) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tmapping_set_error(page->mapping, ret);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "page->mapping",
            "ret"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->writepage_end_io_hook",
          "args": [
            "page",
            "start",
            "end",
            "NULL",
            "uptodate"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint end_extent_writepage(struct page *page, int err, u64 start, u64 end)\n{\n\tint uptodate = (err == 0);\n\tstruct extent_io_tree *tree;\n\tint ret = 0;\n\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\n\tif (tree->ops && tree->ops->writepage_end_io_hook) {\n\t\tret = tree->ops->writepage_end_io_hook(page, start,\n\t\t\t\t\t       end, NULL, uptodate);\n\t\tif (ret)\n\t\t\tuptodate = 0;\n\t}\n\n\tif (!uptodate) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tmapping_set_error(page->mapping, ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "bio_readpage_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2397-2447",
    "snippet": "static int bio_readpage_error(struct bio *failed_bio, u64 phy_offset,\n\t\t\t      struct page *page, u64 start, u64 end,\n\t\t\t      int failed_mirror)\n{\n\tstruct io_failure_record *failrec;\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct bio *bio;\n\tint read_mode;\n\tint ret;\n\n\tBUG_ON(failed_bio->bi_rw & REQ_WRITE);\n\n\tret = btrfs_get_io_failure_record(inode, start, end, &failrec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_check_repairable(inode, failed_bio, failrec, failed_mirror);\n\tif (!ret) {\n\t\tfree_io_failure(inode, failrec);\n\t\treturn -EIO;\n\t}\n\n\tif (failed_bio->bi_vcnt > 1)\n\t\tread_mode = READ_SYNC | REQ_FAILFAST_DEV;\n\telse\n\t\tread_mode = READ_SYNC;\n\n\tphy_offset >>= inode->i_sb->s_blocksize_bits;\n\tbio = btrfs_create_repair_bio(inode, failed_bio, failrec, page,\n\t\t\t\t      start - page_offset(page),\n\t\t\t\t      (int)phy_offset, failed_bio->bi_end_io,\n\t\t\t\t      NULL);\n\tif (!bio) {\n\t\tfree_io_failure(inode, failrec);\n\t\treturn -EIO;\n\t}\n\n\tpr_debug(\"Repair Read Error: submitting new read[%#x] to this_mirror=%d, in_validation=%d\\n\",\n\t\t read_mode, failrec->this_mirror, failrec->in_validation);\n\n\tret = tree->ops->submit_bio_hook(inode, read_mode, bio,\n\t\t\t\t\t failrec->this_mirror,\n\t\t\t\t\t failrec->bio_flags, 0);\n\tif (ret) {\n\t\tfree_io_failure(inode, failrec);\n\t\tbio_put(bio);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_io_failure",
          "args": [
            "inode",
            "failrec"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "free_io_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1993-2014",
          "snippet": "int free_io_failure(struct inode *inode, struct io_failure_record *rec)\n{\n\tint ret;\n\tint err = 0;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\n\tset_state_private(failure_tree, rec->start, 0);\n\tret = clear_extent_bits(failure_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\tif (ret)\n\t\terr = ret;\n\n\tret = clear_extent_bits(&BTRFS_I(inode)->io_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\tif (ret && !err)\n\t\terr = ret;\n\n\tkfree(rec);\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint free_io_failure(struct inode *inode, struct io_failure_record *rec)\n{\n\tint ret;\n\tint err = 0;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\n\tset_state_private(failure_tree, rec->start, 0);\n\tret = clear_extent_bits(failure_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\tif (ret)\n\t\terr = ret;\n\n\tret = clear_extent_bits(&BTRFS_I(inode)->io_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\tif (ret && !err)\n\t\terr = ret;\n\n\tkfree(rec);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree->ops->submit_bio_hook",
          "args": [
            "inode",
            "read_mode",
            "bio",
            "failrec->this_mirror",
            "failrec->bio_flags",
            "0"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Repair Read Error: submitting new read[%#x] to this_mirror=%d, in_validation=%d\\n\"",
            "read_mode",
            "failrec->this_mirror",
            "failrec->in_validation"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_repair_bio",
          "args": [
            "inode",
            "failed_bio",
            "failrec",
            "page",
            "start - page_offset(page)",
            "(int)phy_offset",
            "failed_bio->bi_end_io",
            "NULL"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_repair_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2353-2387",
          "snippet": "struct bio *btrfs_create_repair_bio(struct inode *inode, struct bio *failed_bio,\n\t\t\t\t    struct io_failure_record *failrec,\n\t\t\t\t    struct page *page, int pg_offset, int icsum,\n\t\t\t\t    bio_end_io_t *endio_func, void *data)\n{\n\tstruct bio *bio;\n\tstruct btrfs_io_bio *btrfs_failed_bio;\n\tstruct btrfs_io_bio *btrfs_bio;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn NULL;\n\n\tbio->bi_end_io = endio_func;\n\tbio->bi_iter.bi_sector = failrec->logical >> 9;\n\tbio->bi_bdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_private = data;\n\n\tbtrfs_failed_bio = btrfs_io_bio(failed_bio);\n\tif (btrfs_failed_bio->csum) {\n\t\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\t\tu16 csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\ticsum *= csum_size;\n\t\tmemcpy(btrfs_bio->csum, btrfs_failed_bio->csum + icsum,\n\t\t       csum_size);\n\t}\n\n\tbio_add_page(bio, page, failrec->len, pg_offset);\n\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void flush_write_bio(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstruct bio *btrfs_create_repair_bio(struct inode *inode, struct bio *failed_bio,\n\t\t\t\t    struct io_failure_record *failrec,\n\t\t\t\t    struct page *page, int pg_offset, int icsum,\n\t\t\t\t    bio_end_io_t *endio_func, void *data)\n{\n\tstruct bio *bio;\n\tstruct btrfs_io_bio *btrfs_failed_bio;\n\tstruct btrfs_io_bio *btrfs_bio;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn NULL;\n\n\tbio->bi_end_io = endio_func;\n\tbio->bi_iter.bi_sector = failrec->logical >> 9;\n\tbio->bi_bdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_private = data;\n\n\tbtrfs_failed_bio = btrfs_io_bio(failed_bio);\n\tif (btrfs_failed_bio->csum) {\n\t\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\t\tu16 csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\ticsum *= csum_size;\n\t\tmemcpy(btrfs_bio->csum, btrfs_failed_bio->csum + icsum,\n\t\t       csum_size);\n\t}\n\n\tbio_add_page(bio, page, failrec->len, pg_offset);\n\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_check_repairable",
          "args": [
            "inode",
            "failed_bio",
            "failrec",
            "failed_mirror"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_repairable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2291-2350",
          "snippet": "int btrfs_check_repairable(struct inode *inode, struct bio *failed_bio,\n\t\t\t   struct io_failure_record *failrec, int failed_mirror)\n{\n\tint num_copies;\n\n\tnum_copies = btrfs_num_copies(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t      failrec->logical, failrec->len);\n\tif (num_copies == 1) {\n\t\t/*\n\t\t * we only have a single copy of the data, so don't bother with\n\t\t * all the retry and error correction code that follows. no\n\t\t * matter what the error is, it is very likely to persist.\n\t\t */\n\t\tpr_debug(\"Check Repairable: cannot repair, num_copies=%d, next_mirror %d, failed_mirror %d\\n\",\n\t\t\t num_copies, failrec->this_mirror, failed_mirror);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * there are two premises:\n\t *\ta) deliver good data to the caller\n\t *\tb) correct the bad sectors on disk\n\t */\n\tif (failed_bio->bi_vcnt > 1) {\n\t\t/*\n\t\t * to fulfill b), we need to know the exact failing sectors, as\n\t\t * we don't want to rewrite any more than the failed ones. thus,\n\t\t * we need separate read requests for the failed bio\n\t\t *\n\t\t * if the following BUG_ON triggers, our validation request got\n\t\t * merged. we need separate requests for our algorithm to work.\n\t\t */\n\t\tBUG_ON(failrec->in_validation);\n\t\tfailrec->in_validation = 1;\n\t\tfailrec->this_mirror = failed_mirror;\n\t} else {\n\t\t/*\n\t\t * we're ready to fulfill a) and b) alongside. get a good copy\n\t\t * of the failed sector and if we succeed, we have setup\n\t\t * everything for repair_io_failure to do the rest for us.\n\t\t */\n\t\tif (failrec->in_validation) {\n\t\t\tBUG_ON(failrec->this_mirror != failed_mirror);\n\t\t\tfailrec->in_validation = 0;\n\t\t\tfailrec->this_mirror = 0;\n\t\t}\n\t\tfailrec->failed_mirror = failed_mirror;\n\t\tfailrec->this_mirror++;\n\t\tif (failrec->this_mirror == failed_mirror)\n\t\t\tfailrec->this_mirror++;\n\t}\n\n\tif (failrec->this_mirror > num_copies) {\n\t\tpr_debug(\"Check Repairable: (fail) num_copies=%d, next_mirror %d, failed_mirror %d\\n\",\n\t\t\t num_copies, failrec->this_mirror, failed_mirror);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void flush_write_bio(void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nint btrfs_check_repairable(struct inode *inode, struct bio *failed_bio,\n\t\t\t   struct io_failure_record *failrec, int failed_mirror)\n{\n\tint num_copies;\n\n\tnum_copies = btrfs_num_copies(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t      failrec->logical, failrec->len);\n\tif (num_copies == 1) {\n\t\t/*\n\t\t * we only have a single copy of the data, so don't bother with\n\t\t * all the retry and error correction code that follows. no\n\t\t * matter what the error is, it is very likely to persist.\n\t\t */\n\t\tpr_debug(\"Check Repairable: cannot repair, num_copies=%d, next_mirror %d, failed_mirror %d\\n\",\n\t\t\t num_copies, failrec->this_mirror, failed_mirror);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * there are two premises:\n\t *\ta) deliver good data to the caller\n\t *\tb) correct the bad sectors on disk\n\t */\n\tif (failed_bio->bi_vcnt > 1) {\n\t\t/*\n\t\t * to fulfill b), we need to know the exact failing sectors, as\n\t\t * we don't want to rewrite any more than the failed ones. thus,\n\t\t * we need separate read requests for the failed bio\n\t\t *\n\t\t * if the following BUG_ON triggers, our validation request got\n\t\t * merged. we need separate requests for our algorithm to work.\n\t\t */\n\t\tBUG_ON(failrec->in_validation);\n\t\tfailrec->in_validation = 1;\n\t\tfailrec->this_mirror = failed_mirror;\n\t} else {\n\t\t/*\n\t\t * we're ready to fulfill a) and b) alongside. get a good copy\n\t\t * of the failed sector and if we succeed, we have setup\n\t\t * everything for repair_io_failure to do the rest for us.\n\t\t */\n\t\tif (failrec->in_validation) {\n\t\t\tBUG_ON(failrec->this_mirror != failed_mirror);\n\t\t\tfailrec->in_validation = 0;\n\t\t\tfailrec->this_mirror = 0;\n\t\t}\n\t\tfailrec->failed_mirror = failed_mirror;\n\t\tfailrec->this_mirror++;\n\t\tif (failrec->this_mirror == failed_mirror)\n\t\t\tfailrec->this_mirror++;\n\t}\n\n\tif (failrec->this_mirror > num_copies) {\n\t\tpr_debug(\"Check Repairable: (fail) num_copies=%d, next_mirror %d, failed_mirror %d\\n\",\n\t\t\t num_copies, failrec->this_mirror, failed_mirror);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_io_failure_record",
          "args": [
            "inode",
            "start",
            "end",
            "&failrec"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_io_failure_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2203-2289",
          "snippet": "int btrfs_get_io_failure_record(struct inode *inode, u64 start, u64 end,\n\t\t\t\tstruct io_failure_record **failrec_ret)\n{\n\tstruct io_failure_record *failrec;\n\tu64 private;\n\tstruct extent_map *em;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tint ret;\n\tu64 logical;\n\n\tret = get_state_private(failure_tree, start, &private);\n\tif (ret) {\n\t\tfailrec = kzalloc(sizeof(*failrec), GFP_NOFS);\n\t\tif (!failrec)\n\t\t\treturn -ENOMEM;\n\n\t\tfailrec->start = start;\n\t\tfailrec->len = end - start + 1;\n\t\tfailrec->this_mirror = 0;\n\t\tfailrec->bio_flags = 0;\n\t\tfailrec->in_validation = 0;\n\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, failrec->len);\n\t\tif (!em) {\n\t\t\tread_unlock(&em_tree->lock);\n\t\t\tkfree(failrec);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (em->start > start || em->start + em->len <= start) {\n\t\t\tfree_extent_map(em);\n\t\t\tem = NULL;\n\t\t}\n\t\tread_unlock(&em_tree->lock);\n\t\tif (!em) {\n\t\t\tkfree(failrec);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tlogical = start - em->start;\n\t\tlogical = em->block_start + logical;\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tlogical = em->block_start;\n\t\t\tfailrec->bio_flags = EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&failrec->bio_flags,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tpr_debug(\"Get IO Failure Record: (new) logical=%llu, start=%llu, len=%llu\\n\",\n\t\t\t logical, start, failrec->len);\n\n\t\tfailrec->logical = logical;\n\t\tfree_extent_map(em);\n\n\t\t/* set the bits in the private failure tree */\n\t\tret = set_extent_bits(failure_tree, start, end,\n\t\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\t\tif (ret >= 0)\n\t\t\tret = set_state_private(failure_tree, start,\n\t\t\t\t\t\t(u64)(unsigned long)failrec);\n\t\t/* set the bits in the inode's tree */\n\t\tif (ret >= 0)\n\t\t\tret = set_extent_bits(tree, start, end, EXTENT_DAMAGED,\n\t\t\t\t\t\tGFP_NOFS);\n\t\tif (ret < 0) {\n\t\t\tkfree(failrec);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfailrec = (struct io_failure_record *)(unsigned long)private;\n\t\tpr_debug(\"Get IO Failure Record: (found) logical=%llu, start=%llu, len=%llu, validation=%d\\n\",\n\t\t\t failrec->logical, failrec->start, failrec->len,\n\t\t\t failrec->in_validation);\n\t\t/*\n\t\t * when data can be on disk more than twice, add to failrec here\n\t\t * (e.g. with a list for failed_mirror) to make\n\t\t * clean_io_failure() clean all those errors at once.\n\t\t */\n\t}\n\n\t*failrec_ret = failrec;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline void flush_write_bio(void *data);",
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint btrfs_get_io_failure_record(struct inode *inode, u64 start, u64 end,\n\t\t\t\tstruct io_failure_record **failrec_ret)\n{\n\tstruct io_failure_record *failrec;\n\tu64 private;\n\tstruct extent_map *em;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tint ret;\n\tu64 logical;\n\n\tret = get_state_private(failure_tree, start, &private);\n\tif (ret) {\n\t\tfailrec = kzalloc(sizeof(*failrec), GFP_NOFS);\n\t\tif (!failrec)\n\t\t\treturn -ENOMEM;\n\n\t\tfailrec->start = start;\n\t\tfailrec->len = end - start + 1;\n\t\tfailrec->this_mirror = 0;\n\t\tfailrec->bio_flags = 0;\n\t\tfailrec->in_validation = 0;\n\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, failrec->len);\n\t\tif (!em) {\n\t\t\tread_unlock(&em_tree->lock);\n\t\t\tkfree(failrec);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (em->start > start || em->start + em->len <= start) {\n\t\t\tfree_extent_map(em);\n\t\t\tem = NULL;\n\t\t}\n\t\tread_unlock(&em_tree->lock);\n\t\tif (!em) {\n\t\t\tkfree(failrec);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tlogical = start - em->start;\n\t\tlogical = em->block_start + logical;\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tlogical = em->block_start;\n\t\t\tfailrec->bio_flags = EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&failrec->bio_flags,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tpr_debug(\"Get IO Failure Record: (new) logical=%llu, start=%llu, len=%llu\\n\",\n\t\t\t logical, start, failrec->len);\n\n\t\tfailrec->logical = logical;\n\t\tfree_extent_map(em);\n\n\t\t/* set the bits in the private failure tree */\n\t\tret = set_extent_bits(failure_tree, start, end,\n\t\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\t\tif (ret >= 0)\n\t\t\tret = set_state_private(failure_tree, start,\n\t\t\t\t\t\t(u64)(unsigned long)failrec);\n\t\t/* set the bits in the inode's tree */\n\t\tif (ret >= 0)\n\t\t\tret = set_extent_bits(tree, start, end, EXTENT_DAMAGED,\n\t\t\t\t\t\tGFP_NOFS);\n\t\tif (ret < 0) {\n\t\t\tkfree(failrec);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfailrec = (struct io_failure_record *)(unsigned long)private;\n\t\tpr_debug(\"Get IO Failure Record: (found) logical=%llu, start=%llu, len=%llu, validation=%d\\n\",\n\t\t\t failrec->logical, failrec->start, failrec->len,\n\t\t\t failrec->in_validation);\n\t\t/*\n\t\t * when data can be on disk more than twice, add to failrec here\n\t\t * (e.g. with a list for failed_mirror) to make\n\t\t * clean_io_failure() clean all those errors at once.\n\t\t */\n\t}\n\n\t*failrec_ret = failrec;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "failed_bio->bi_rw & REQ_WRITE"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int bio_readpage_error(struct bio *failed_bio, u64 phy_offset,\n\t\t\t      struct page *page, u64 start, u64 end,\n\t\t\t      int failed_mirror)\n{\n\tstruct io_failure_record *failrec;\n\tstruct inode *inode = page->mapping->host;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct bio *bio;\n\tint read_mode;\n\tint ret;\n\n\tBUG_ON(failed_bio->bi_rw & REQ_WRITE);\n\n\tret = btrfs_get_io_failure_record(inode, start, end, &failrec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_check_repairable(inode, failed_bio, failrec, failed_mirror);\n\tif (!ret) {\n\t\tfree_io_failure(inode, failrec);\n\t\treturn -EIO;\n\t}\n\n\tif (failed_bio->bi_vcnt > 1)\n\t\tread_mode = READ_SYNC | REQ_FAILFAST_DEV;\n\telse\n\t\tread_mode = READ_SYNC;\n\n\tphy_offset >>= inode->i_sb->s_blocksize_bits;\n\tbio = btrfs_create_repair_bio(inode, failed_bio, failrec, page,\n\t\t\t\t      start - page_offset(page),\n\t\t\t\t      (int)phy_offset, failed_bio->bi_end_io,\n\t\t\t\t      NULL);\n\tif (!bio) {\n\t\tfree_io_failure(inode, failrec);\n\t\treturn -EIO;\n\t}\n\n\tpr_debug(\"Repair Read Error: submitting new read[%#x] to this_mirror=%d, in_validation=%d\\n\",\n\t\t read_mode, failrec->this_mirror, failrec->in_validation);\n\n\tret = tree->ops->submit_bio_hook(inode, read_mode, bio,\n\t\t\t\t\t failrec->this_mirror,\n\t\t\t\t\t failrec->bio_flags, 0);\n\tif (ret) {\n\t\tfree_io_failure(inode, failrec);\n\t\tbio_put(bio);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_create_repair_bio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2353-2387",
    "snippet": "struct bio *btrfs_create_repair_bio(struct inode *inode, struct bio *failed_bio,\n\t\t\t\t    struct io_failure_record *failrec,\n\t\t\t\t    struct page *page, int pg_offset, int icsum,\n\t\t\t\t    bio_end_io_t *endio_func, void *data)\n{\n\tstruct bio *bio;\n\tstruct btrfs_io_bio *btrfs_failed_bio;\n\tstruct btrfs_io_bio *btrfs_bio;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn NULL;\n\n\tbio->bi_end_io = endio_func;\n\tbio->bi_iter.bi_sector = failrec->logical >> 9;\n\tbio->bi_bdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_private = data;\n\n\tbtrfs_failed_bio = btrfs_io_bio(failed_bio);\n\tif (btrfs_failed_bio->csum) {\n\t\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\t\tu16 csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\ticsum *= csum_size;\n\t\tmemcpy(btrfs_bio->csum, btrfs_failed_bio->csum + icsum,\n\t\t       csum_size);\n\t}\n\n\tbio_add_page(bio, page, failrec->len, pg_offset);\n\n\treturn bio;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline void flush_write_bio(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "failrec->len",
            "pg_offset"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "btrfs_bio->csum",
            "btrfs_failed_bio->csum + icsum",
            "csum_size"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio",
          "args": [
            "bio"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.h",
          "lines": "281-284",
          "snippet": "static inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}",
          "includes": [
            "#include <linux/seqlock.h>",
            "#include \"async-thread.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/sort.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n#include \"async-thread.h\"\n#include <linux/btrfs.h>\n#include <linux/sort.h>\n#include <linux/bio.h>\n\nstatic inline struct btrfs_io_bio *btrfs_io_bio(struct bio *bio)\n{\n\treturn container_of(bio, struct btrfs_io_bio, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "fs_info->super_copy"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nstruct bio *btrfs_create_repair_bio(struct inode *inode, struct bio *failed_bio,\n\t\t\t\t    struct io_failure_record *failrec,\n\t\t\t\t    struct page *page, int pg_offset, int icsum,\n\t\t\t\t    bio_end_io_t *endio_func, void *data)\n{\n\tstruct bio *bio;\n\tstruct btrfs_io_bio *btrfs_failed_bio;\n\tstruct btrfs_io_bio *btrfs_bio;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn NULL;\n\n\tbio->bi_end_io = endio_func;\n\tbio->bi_iter.bi_sector = failrec->logical >> 9;\n\tbio->bi_bdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_private = data;\n\n\tbtrfs_failed_bio = btrfs_io_bio(failed_bio);\n\tif (btrfs_failed_bio->csum) {\n\t\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\t\tu16 csum_size = btrfs_super_csum_size(fs_info->super_copy);\n\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = btrfs_bio->csum_inline;\n\t\ticsum *= csum_size;\n\t\tmemcpy(btrfs_bio->csum, btrfs_failed_bio->csum + icsum,\n\t\t       csum_size);\n\t}\n\n\tbio_add_page(bio, page, failrec->len, pg_offset);\n\n\treturn bio;\n}"
  },
  {
    "function_name": "btrfs_check_repairable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2291-2350",
    "snippet": "int btrfs_check_repairable(struct inode *inode, struct bio *failed_bio,\n\t\t\t   struct io_failure_record *failrec, int failed_mirror)\n{\n\tint num_copies;\n\n\tnum_copies = btrfs_num_copies(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t      failrec->logical, failrec->len);\n\tif (num_copies == 1) {\n\t\t/*\n\t\t * we only have a single copy of the data, so don't bother with\n\t\t * all the retry and error correction code that follows. no\n\t\t * matter what the error is, it is very likely to persist.\n\t\t */\n\t\tpr_debug(\"Check Repairable: cannot repair, num_copies=%d, next_mirror %d, failed_mirror %d\\n\",\n\t\t\t num_copies, failrec->this_mirror, failed_mirror);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * there are two premises:\n\t *\ta) deliver good data to the caller\n\t *\tb) correct the bad sectors on disk\n\t */\n\tif (failed_bio->bi_vcnt > 1) {\n\t\t/*\n\t\t * to fulfill b), we need to know the exact failing sectors, as\n\t\t * we don't want to rewrite any more than the failed ones. thus,\n\t\t * we need separate read requests for the failed bio\n\t\t *\n\t\t * if the following BUG_ON triggers, our validation request got\n\t\t * merged. we need separate requests for our algorithm to work.\n\t\t */\n\t\tBUG_ON(failrec->in_validation);\n\t\tfailrec->in_validation = 1;\n\t\tfailrec->this_mirror = failed_mirror;\n\t} else {\n\t\t/*\n\t\t * we're ready to fulfill a) and b) alongside. get a good copy\n\t\t * of the failed sector and if we succeed, we have setup\n\t\t * everything for repair_io_failure to do the rest for us.\n\t\t */\n\t\tif (failrec->in_validation) {\n\t\t\tBUG_ON(failrec->this_mirror != failed_mirror);\n\t\t\tfailrec->in_validation = 0;\n\t\t\tfailrec->this_mirror = 0;\n\t\t}\n\t\tfailrec->failed_mirror = failed_mirror;\n\t\tfailrec->this_mirror++;\n\t\tif (failrec->this_mirror == failed_mirror)\n\t\t\tfailrec->this_mirror++;\n\t}\n\n\tif (failrec->this_mirror > num_copies) {\n\t\tpr_debug(\"Check Repairable: (fail) num_copies=%d, next_mirror %d, failed_mirror %d\\n\",\n\t\t\t num_copies, failrec->this_mirror, failed_mirror);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline void flush_write_bio(void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Check Repairable: (fail) num_copies=%d, next_mirror %d, failed_mirror %d\\n\"",
            "num_copies",
            "failrec->this_mirror",
            "failed_mirror"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "failrec->this_mirror != failed_mirror"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "failrec->in_validation"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Check Repairable: cannot repair, num_copies=%d, next_mirror %d, failed_mirror %d\\n\"",
            "num_copies",
            "failrec->this_mirror",
            "failed_mirror"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "failrec->logical",
            "failrec->len"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\n\nint btrfs_check_repairable(struct inode *inode, struct bio *failed_bio,\n\t\t\t   struct io_failure_record *failrec, int failed_mirror)\n{\n\tint num_copies;\n\n\tnum_copies = btrfs_num_copies(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t      failrec->logical, failrec->len);\n\tif (num_copies == 1) {\n\t\t/*\n\t\t * we only have a single copy of the data, so don't bother with\n\t\t * all the retry and error correction code that follows. no\n\t\t * matter what the error is, it is very likely to persist.\n\t\t */\n\t\tpr_debug(\"Check Repairable: cannot repair, num_copies=%d, next_mirror %d, failed_mirror %d\\n\",\n\t\t\t num_copies, failrec->this_mirror, failed_mirror);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * there are two premises:\n\t *\ta) deliver good data to the caller\n\t *\tb) correct the bad sectors on disk\n\t */\n\tif (failed_bio->bi_vcnt > 1) {\n\t\t/*\n\t\t * to fulfill b), we need to know the exact failing sectors, as\n\t\t * we don't want to rewrite any more than the failed ones. thus,\n\t\t * we need separate read requests for the failed bio\n\t\t *\n\t\t * if the following BUG_ON triggers, our validation request got\n\t\t * merged. we need separate requests for our algorithm to work.\n\t\t */\n\t\tBUG_ON(failrec->in_validation);\n\t\tfailrec->in_validation = 1;\n\t\tfailrec->this_mirror = failed_mirror;\n\t} else {\n\t\t/*\n\t\t * we're ready to fulfill a) and b) alongside. get a good copy\n\t\t * of the failed sector and if we succeed, we have setup\n\t\t * everything for repair_io_failure to do the rest for us.\n\t\t */\n\t\tif (failrec->in_validation) {\n\t\t\tBUG_ON(failrec->this_mirror != failed_mirror);\n\t\t\tfailrec->in_validation = 0;\n\t\t\tfailrec->this_mirror = 0;\n\t\t}\n\t\tfailrec->failed_mirror = failed_mirror;\n\t\tfailrec->this_mirror++;\n\t\tif (failrec->this_mirror == failed_mirror)\n\t\t\tfailrec->this_mirror++;\n\t}\n\n\tif (failrec->this_mirror > num_copies) {\n\t\tpr_debug(\"Check Repairable: (fail) num_copies=%d, next_mirror %d, failed_mirror %d\\n\",\n\t\t\t num_copies, failrec->this_mirror, failed_mirror);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_get_io_failure_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2203-2289",
    "snippet": "int btrfs_get_io_failure_record(struct inode *inode, u64 start, u64 end,\n\t\t\t\tstruct io_failure_record **failrec_ret)\n{\n\tstruct io_failure_record *failrec;\n\tu64 private;\n\tstruct extent_map *em;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tint ret;\n\tu64 logical;\n\n\tret = get_state_private(failure_tree, start, &private);\n\tif (ret) {\n\t\tfailrec = kzalloc(sizeof(*failrec), GFP_NOFS);\n\t\tif (!failrec)\n\t\t\treturn -ENOMEM;\n\n\t\tfailrec->start = start;\n\t\tfailrec->len = end - start + 1;\n\t\tfailrec->this_mirror = 0;\n\t\tfailrec->bio_flags = 0;\n\t\tfailrec->in_validation = 0;\n\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, failrec->len);\n\t\tif (!em) {\n\t\t\tread_unlock(&em_tree->lock);\n\t\t\tkfree(failrec);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (em->start > start || em->start + em->len <= start) {\n\t\t\tfree_extent_map(em);\n\t\t\tem = NULL;\n\t\t}\n\t\tread_unlock(&em_tree->lock);\n\t\tif (!em) {\n\t\t\tkfree(failrec);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tlogical = start - em->start;\n\t\tlogical = em->block_start + logical;\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tlogical = em->block_start;\n\t\t\tfailrec->bio_flags = EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&failrec->bio_flags,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tpr_debug(\"Get IO Failure Record: (new) logical=%llu, start=%llu, len=%llu\\n\",\n\t\t\t logical, start, failrec->len);\n\n\t\tfailrec->logical = logical;\n\t\tfree_extent_map(em);\n\n\t\t/* set the bits in the private failure tree */\n\t\tret = set_extent_bits(failure_tree, start, end,\n\t\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\t\tif (ret >= 0)\n\t\t\tret = set_state_private(failure_tree, start,\n\t\t\t\t\t\t(u64)(unsigned long)failrec);\n\t\t/* set the bits in the inode's tree */\n\t\tif (ret >= 0)\n\t\t\tret = set_extent_bits(tree, start, end, EXTENT_DAMAGED,\n\t\t\t\t\t\tGFP_NOFS);\n\t\tif (ret < 0) {\n\t\t\tkfree(failrec);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfailrec = (struct io_failure_record *)(unsigned long)private;\n\t\tpr_debug(\"Get IO Failure Record: (found) logical=%llu, start=%llu, len=%llu, validation=%d\\n\",\n\t\t\t failrec->logical, failrec->start, failrec->len,\n\t\t\t failrec->in_validation);\n\t\t/*\n\t\t * when data can be on disk more than twice, add to failrec here\n\t\t * (e.g. with a list for failed_mirror) to make\n\t\t * clean_io_failure() clean all those errors at once.\n\t\t */\n\t}\n\n\t*failrec_ret = failrec;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline void flush_write_bio(void *data);",
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Get IO Failure Record: (found) logical=%llu, start=%llu, len=%llu, validation=%d\\n\"",
            "failrec->logical",
            "failrec->start",
            "failrec->len",
            "failrec->in_validation"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "failrec"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_extent_bits",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_DAMAGED",
            "GFP_NOFS"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1270-1275",
          "snippet": "int set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_state_private",
          "args": [
            "failure_tree",
            "start",
            "(u64)(unsigned long)failrec"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "set_state_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1871-1896",
          "snippet": "static int set_state_private(struct extent_io_tree *tree, u64 start, u64 private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate->private = private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int set_state_private(struct extent_io_tree *tree, u64 start, u64 private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate->private = private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Get IO Failure Record: (new) logical=%llu, start=%llu, len=%llu\\n\"",
            "logical",
            "start",
            "failrec->len"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_set_compress_type",
          "args": [
            "&failrec->bio_flags",
            "em->compress_type"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "extent_set_compress_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "164-168",
          "snippet": "static inline void extent_set_compress_type(unsigned long *bio_flags,\n\t\t\t\t\t    int compress_type)\n{\n\t*bio_flags |= compress_type << EXTENT_BIO_FLAG_SHIFT;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BIO_FLAG_SHIFT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\n#define EXTENT_BIO_FLAG_SHIFT 16\n\nstatic inline void extent_set_compress_type(unsigned long *bio_flags,\n\t\t\t\t\t    int compress_type)\n{\n\t*bio_flags |= compress_type << EXTENT_BIO_FLAG_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "EXTENT_FLAG_COMPRESSED",
            "&em->flags"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "failrec"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "failrec"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "start",
            "failrec->len"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*failrec)",
            "GFP_NOFS"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_state_private",
          "args": [
            "failure_tree",
            "start",
            "&private"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "get_state_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1898-1923",
          "snippet": "int get_state_private(struct extent_io_tree *tree, u64 start, u64 *private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*private = state->private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint get_state_private(struct extent_io_tree *tree, u64 start, u64 *private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*private = state->private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void flush_write_bio(void *data);\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint btrfs_get_io_failure_record(struct inode *inode, u64 start, u64 end,\n\t\t\t\tstruct io_failure_record **failrec_ret)\n{\n\tstruct io_failure_record *failrec;\n\tu64 private;\n\tstruct extent_map *em;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tint ret;\n\tu64 logical;\n\n\tret = get_state_private(failure_tree, start, &private);\n\tif (ret) {\n\t\tfailrec = kzalloc(sizeof(*failrec), GFP_NOFS);\n\t\tif (!failrec)\n\t\t\treturn -ENOMEM;\n\n\t\tfailrec->start = start;\n\t\tfailrec->len = end - start + 1;\n\t\tfailrec->this_mirror = 0;\n\t\tfailrec->bio_flags = 0;\n\t\tfailrec->in_validation = 0;\n\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, failrec->len);\n\t\tif (!em) {\n\t\t\tread_unlock(&em_tree->lock);\n\t\t\tkfree(failrec);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (em->start > start || em->start + em->len <= start) {\n\t\t\tfree_extent_map(em);\n\t\t\tem = NULL;\n\t\t}\n\t\tread_unlock(&em_tree->lock);\n\t\tif (!em) {\n\t\t\tkfree(failrec);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tlogical = start - em->start;\n\t\tlogical = em->block_start + logical;\n\t\tif (test_bit(EXTENT_FLAG_COMPRESSED, &em->flags)) {\n\t\t\tlogical = em->block_start;\n\t\t\tfailrec->bio_flags = EXTENT_BIO_COMPRESSED;\n\t\t\textent_set_compress_type(&failrec->bio_flags,\n\t\t\t\t\t\t em->compress_type);\n\t\t}\n\n\t\tpr_debug(\"Get IO Failure Record: (new) logical=%llu, start=%llu, len=%llu\\n\",\n\t\t\t logical, start, failrec->len);\n\n\t\tfailrec->logical = logical;\n\t\tfree_extent_map(em);\n\n\t\t/* set the bits in the private failure tree */\n\t\tret = set_extent_bits(failure_tree, start, end,\n\t\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\t\tif (ret >= 0)\n\t\t\tret = set_state_private(failure_tree, start,\n\t\t\t\t\t\t(u64)(unsigned long)failrec);\n\t\t/* set the bits in the inode's tree */\n\t\tif (ret >= 0)\n\t\t\tret = set_extent_bits(tree, start, end, EXTENT_DAMAGED,\n\t\t\t\t\t\tGFP_NOFS);\n\t\tif (ret < 0) {\n\t\t\tkfree(failrec);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfailrec = (struct io_failure_record *)(unsigned long)private;\n\t\tpr_debug(\"Get IO Failure Record: (found) logical=%llu, start=%llu, len=%llu, validation=%d\\n\",\n\t\t\t failrec->logical, failrec->start, failrec->len,\n\t\t\t failrec->in_validation);\n\t\t/*\n\t\t * when data can be on disk more than twice, add to failrec here\n\t\t * (e.g. with a list for failed_mirror) to make\n\t\t * clean_io_failure() clean all those errors at once.\n\t\t */\n\t}\n\n\t*failrec_ret = failrec;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_free_io_failure_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2175-2201",
    "snippet": "void btrfs_free_io_failure_record(struct inode *inode, u64 start, u64 end)\n{\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\tstruct io_failure_record *failrec;\n\tstruct extent_state *state, *next;\n\n\tif (RB_EMPTY_ROOT(&failure_tree->state))\n\t\treturn;\n\n\tspin_lock(&failure_tree->lock);\n\tstate = find_first_extent_bit_state(failure_tree, start, EXTENT_DIRTY);\n\twhile (state) {\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tASSERT(state->end <= end);\n\n\t\tnext = next_state(state);\n\n\t\tfailrec = (struct io_failure_record *)(unsigned long)state->private;\n\t\tfree_extent_state(state);\n\t\tkfree(failrec);\n\n\t\tstate = next;\n\t}\n\tspin_unlock(&failure_tree->lock);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&failure_tree->lock"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "failrec"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "state"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_state",
          "args": [
            "state"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "next_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "496-503",
          "snippet": "static struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->end <= end"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit_state",
          "args": [
            "failure_tree",
            "start",
            "EXTENT_DIRTY"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1442-1468",
          "snippet": "static struct extent_state *\nfind_first_extent_bit_state(struct extent_io_tree *tree,\n\t\t\t    u64 start, unsigned bits)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->end >= start && (state->state & bits))\n\t\t\treturn state;\n\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic struct extent_state *\nfind_first_extent_bit_state(struct extent_io_tree *tree,\n\t\t\t    u64 start, unsigned bits)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->end >= start && (state->state & bits))\n\t\t\treturn state;\n\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&failure_tree->lock"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&failure_tree->state"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid btrfs_free_io_failure_record(struct inode *inode, u64 start, u64 end)\n{\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\tstruct io_failure_record *failrec;\n\tstruct extent_state *state, *next;\n\n\tif (RB_EMPTY_ROOT(&failure_tree->state))\n\t\treturn;\n\n\tspin_lock(&failure_tree->lock);\n\tstate = find_first_extent_bit_state(failure_tree, start, EXTENT_DIRTY);\n\twhile (state) {\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tASSERT(state->end <= end);\n\n\t\tnext = next_state(state);\n\n\t\tfailrec = (struct io_failure_record *)(unsigned long)state->private;\n\t\tfree_extent_state(state);\n\t\tkfree(failrec);\n\n\t\tstate = next;\n\t}\n\tspin_unlock(&failure_tree->lock);\n}"
  },
  {
    "function_name": "clean_io_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2112-2167",
    "snippet": "int clean_io_failure(struct inode *inode, u64 start, struct page *page,\n\t\t     unsigned int pg_offset)\n{\n\tu64 private;\n\tu64 private_failure;\n\tstruct io_failure_record *failrec;\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct extent_state *state;\n\tint num_copies;\n\tint ret;\n\n\tprivate = 0;\n\tret = count_range_bits(&BTRFS_I(inode)->io_failure_tree, &private,\n\t\t\t\t(u64)-1, 1, EXTENT_DIRTY, 0);\n\tif (!ret)\n\t\treturn 0;\n\n\tret = get_state_private(&BTRFS_I(inode)->io_failure_tree, start,\n\t\t\t\t&private_failure);\n\tif (ret)\n\t\treturn 0;\n\n\tfailrec = (struct io_failure_record *)(unsigned long) private_failure;\n\tBUG_ON(!failrec->this_mirror);\n\n\tif (failrec->in_validation) {\n\t\t/* there was no real error, just free the record */\n\t\tpr_debug(\"clean_io_failure: freeing dummy error at %llu\\n\",\n\t\t\t failrec->start);\n\t\tgoto out;\n\t}\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\tgoto out;\n\n\tspin_lock(&BTRFS_I(inode)->io_tree.lock);\n\tstate = find_first_extent_bit_state(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t    failrec->start,\n\t\t\t\t\t    EXTENT_LOCKED);\n\tspin_unlock(&BTRFS_I(inode)->io_tree.lock);\n\n\tif (state && state->start <= failrec->start &&\n\t    state->end >= failrec->start + failrec->len - 1) {\n\t\tnum_copies = btrfs_num_copies(fs_info, failrec->logical,\n\t\t\t\t\t      failrec->len);\n\t\tif (num_copies > 1)  {\n\t\t\trepair_io_failure(inode, start, failrec->len,\n\t\t\t\t\t  failrec->logical, page,\n\t\t\t\t\t  pg_offset, failrec->failed_mirror);\n\t\t}\n\t}\n\nout:\n\tfree_io_failure(inode, failrec);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_io_failure",
          "args": [
            "inode",
            "failrec"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "free_io_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1993-2014",
          "snippet": "int free_io_failure(struct inode *inode, struct io_failure_record *rec)\n{\n\tint ret;\n\tint err = 0;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\n\tset_state_private(failure_tree, rec->start, 0);\n\tret = clear_extent_bits(failure_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\tif (ret)\n\t\terr = ret;\n\n\tret = clear_extent_bits(&BTRFS_I(inode)->io_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\tif (ret && !err)\n\t\terr = ret;\n\n\tkfree(rec);\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint free_io_failure(struct inode *inode, struct io_failure_record *rec)\n{\n\tint ret;\n\tint err = 0;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\n\tset_state_private(failure_tree, rec->start, 0);\n\tret = clear_extent_bits(failure_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\tif (ret)\n\t\terr = ret;\n\n\tret = clear_extent_bits(&BTRFS_I(inode)->io_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\tif (ret && !err)\n\t\terr = ret;\n\n\tkfree(rec);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "repair_io_failure",
          "args": [
            "inode",
            "start",
            "failrec->len",
            "failrec->logical",
            "page",
            "pg_offset",
            "failrec->failed_mirror"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "repair_io_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2026-2082",
          "snippet": "int repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,\n\t\t      struct page *page, unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tu64 map_length = 0;\n\tu64 sector;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tint ret;\n\n\tASSERT(!(fs_info->sb->s_flags & MS_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\t/* we can't repair anything in raid56 yet */\n\tif (btrfs_is_parity_mirror(map_tree, logical, length, mirror_num))\n\t\treturn 0;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn -EIO;\n\tbio->bi_iter.bi_size = 0;\n\tmap_length = length;\n\n\tret = btrfs_map_block(fs_info, WRITE, logical,\n\t\t\t      &map_length, &bbio, mirror_num);\n\tif (ret) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tBUG_ON(mirror_num != bbio->mirror_num);\n\tsector = bbio->stripes[mirror_num-1].physical >> 9;\n\tbio->bi_iter.bi_sector = sector;\n\tdev = bbio->stripes[mirror_num-1].dev;\n\tbtrfs_put_bbio(bbio);\n\tif (!dev || !dev->bdev || !dev->writeable) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tbio->bi_bdev = dev->bdev;\n\tbio_add_page(bio, page, length, pg_offset);\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio)) {\n\t\t/* try to remap that extent elsewhere? */\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tprintk_ratelimited_in_rcu(KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\",\n\t\t\t\t  btrfs_ino(inode), start,\n\t\t\t\t  rcu_str_deref(dev->name), sector);\n\tbio_put(bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,\n\t\t      struct page *page, unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tu64 map_length = 0;\n\tu64 sector;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tint ret;\n\n\tASSERT(!(fs_info->sb->s_flags & MS_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\t/* we can't repair anything in raid56 yet */\n\tif (btrfs_is_parity_mirror(map_tree, logical, length, mirror_num))\n\t\treturn 0;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn -EIO;\n\tbio->bi_iter.bi_size = 0;\n\tmap_length = length;\n\n\tret = btrfs_map_block(fs_info, WRITE, logical,\n\t\t\t      &map_length, &bbio, mirror_num);\n\tif (ret) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tBUG_ON(mirror_num != bbio->mirror_num);\n\tsector = bbio->stripes[mirror_num-1].physical >> 9;\n\tbio->bi_iter.bi_sector = sector;\n\tdev = bbio->stripes[mirror_num-1].dev;\n\tbtrfs_put_bbio(bbio);\n\tif (!dev || !dev->bdev || !dev->writeable) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tbio->bi_bdev = dev->bdev;\n\tbio_add_page(bio, page, length, pg_offset);\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio)) {\n\t\t/* try to remap that extent elsewhere? */\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tprintk_ratelimited_in_rcu(KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\",\n\t\t\t\t  btrfs_ino(inode), start,\n\t\t\t\t  rcu_str_deref(dev->name), sector);\n\tbio_put(bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_num_copies",
          "args": [
            "fs_info",
            "failrec->logical",
            "failrec->len"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_num_copies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4740-4790",
          "snippet": "int btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_num_copies(struct btrfs_fs_info *fs_info, u64 logical, u64 len)\n{\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\n\t/*\n\t * We could return errors for these cases, but that could get ugly and\n\t * we'd probably do the same thing which is just not do anything else\n\t * and exit, so return 1 so the callers don't try to use other copies.\n\t */\n\tif (!em) {\n\t\tbtrfs_crit(fs_info, \"No mapping for %Lu-%Lu\", logical,\n\t\t\t    logical+len);\n\t\treturn 1;\n\t}\n\n\tif (em->start > logical || em->start + em->len < logical) {\n\t\tbtrfs_crit(fs_info, \"Invalid mapping for %Lu-%Lu, got \"\n\t\t\t    \"%Lu-%Lu\", logical, logical+len, em->start,\n\t\t\t    em->start + em->len);\n\t\tfree_extent_map(em);\n\t\treturn 1;\n\t}\n\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))\n\t\tret = map->num_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID10)\n\t\tret = map->sub_stripes;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID5)\n\t\tret = 2;\n\telse if (map->type & BTRFS_BLOCK_GROUP_RAID6)\n\t\tret = 3;\n\telse\n\t\tret = 1;\n\tfree_extent_map(em);\n\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tif (btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))\n\t\tret++;\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&BTRFS_I(inode)->io_tree.lock"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit_state",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "failrec->start",
            "EXTENT_LOCKED"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1442-1468",
          "snippet": "static struct extent_state *\nfind_first_extent_bit_state(struct extent_io_tree *tree,\n\t\t\t    u64 start, unsigned bits)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->end >= start && (state->state & bits))\n\t\t\treturn state;\n\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic struct extent_state *\nfind_first_extent_bit_state(struct extent_io_tree *tree,\n\t\t\t    u64 start, unsigned bits)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->end >= start && (state->state & bits))\n\t\t\treturn state;\n\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&BTRFS_I(inode)->io_tree.lock"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"clean_io_failure: freeing dummy error at %llu\\n\"",
            "failrec->start"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!failrec->this_mirror"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_state_private",
          "args": [
            "&BTRFS_I(inode)->io_failure_tree",
            "start",
            "&private_failure"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "get_state_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1898-1923",
          "snippet": "int get_state_private(struct extent_io_tree *tree, u64 start, u64 *private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*private = state->private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint get_state_private(struct extent_io_tree *tree, u64 start, u64 *private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*private = state->private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_range_bits",
          "args": [
            "&BTRFS_I(inode)->io_failure_tree",
            "&private",
            "(u64)-1",
            "1",
            "EXTENT_DIRTY",
            "0"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "count_range_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1812-1865",
          "snippet": "u64 count_range_bits(struct extent_io_tree *tree,\n\t\t     u64 *start, u64 search_end, u64 max_bytes,\n\t\t     unsigned bits, int contig)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 total_bytes = 0;\n\tu64 last = 0;\n\tint found = 0;\n\n\tif (WARN_ON(search_end <= cur_start))\n\t\treturn 0;\n\n\tspin_lock(&tree->lock);\n\tif (cur_start == 0 && bits == EXTENT_DIRTY) {\n\t\ttotal_bytes = tree->dirty_bytes;\n\t\tgoto out;\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->start > search_end)\n\t\t\tbreak;\n\t\tif (contig && found && state->start > last + 1)\n\t\t\tbreak;\n\t\tif (state->end >= cur_start && (state->state & bits) == bits) {\n\t\t\ttotal_bytes += min(search_end, state->end) + 1 -\n\t\t\t\t       max(cur_start, state->start);\n\t\t\tif (total_bytes >= max_bytes)\n\t\t\t\tbreak;\n\t\t\tif (!found) {\n\t\t\t\t*start = max(cur_start, state->start);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tlast = state->end;\n\t\t} else if (contig && found) {\n\t\t\tbreak;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn total_bytes;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nu64 count_range_bits(struct extent_io_tree *tree,\n\t\t     u64 *start, u64 search_end, u64 max_bytes,\n\t\t     unsigned bits, int contig)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 total_bytes = 0;\n\tu64 last = 0;\n\tint found = 0;\n\n\tif (WARN_ON(search_end <= cur_start))\n\t\treturn 0;\n\n\tspin_lock(&tree->lock);\n\tif (cur_start == 0 && bits == EXTENT_DIRTY) {\n\t\ttotal_bytes = tree->dirty_bytes;\n\t\tgoto out;\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->start > search_end)\n\t\t\tbreak;\n\t\tif (contig && found && state->start > last + 1)\n\t\t\tbreak;\n\t\tif (state->end >= cur_start && (state->state & bits) == bits) {\n\t\t\ttotal_bytes += min(search_end, state->end) + 1 -\n\t\t\t\t       max(cur_start, state->start);\n\t\t\tif (total_bytes >= max_bytes)\n\t\t\t\tbreak;\n\t\t\tif (!found) {\n\t\t\t\t*start = max(cur_start, state->start);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tlast = state->end;\n\t\t} else if (contig && found) {\n\t\t\tbreak;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn total_bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint clean_io_failure(struct inode *inode, u64 start, struct page *page,\n\t\t     unsigned int pg_offset)\n{\n\tu64 private;\n\tu64 private_failure;\n\tstruct io_failure_record *failrec;\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct extent_state *state;\n\tint num_copies;\n\tint ret;\n\n\tprivate = 0;\n\tret = count_range_bits(&BTRFS_I(inode)->io_failure_tree, &private,\n\t\t\t\t(u64)-1, 1, EXTENT_DIRTY, 0);\n\tif (!ret)\n\t\treturn 0;\n\n\tret = get_state_private(&BTRFS_I(inode)->io_failure_tree, start,\n\t\t\t\t&private_failure);\n\tif (ret)\n\t\treturn 0;\n\n\tfailrec = (struct io_failure_record *)(unsigned long) private_failure;\n\tBUG_ON(!failrec->this_mirror);\n\n\tif (failrec->in_validation) {\n\t\t/* there was no real error, just free the record */\n\t\tpr_debug(\"clean_io_failure: freeing dummy error at %llu\\n\",\n\t\t\t failrec->start);\n\t\tgoto out;\n\t}\n\tif (fs_info->sb->s_flags & MS_RDONLY)\n\t\tgoto out;\n\n\tspin_lock(&BTRFS_I(inode)->io_tree.lock);\n\tstate = find_first_extent_bit_state(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t    failrec->start,\n\t\t\t\t\t    EXTENT_LOCKED);\n\tspin_unlock(&BTRFS_I(inode)->io_tree.lock);\n\n\tif (state && state->start <= failrec->start &&\n\t    state->end >= failrec->start + failrec->len - 1) {\n\t\tnum_copies = btrfs_num_copies(fs_info, failrec->logical,\n\t\t\t\t\t      failrec->len);\n\t\tif (num_copies > 1)  {\n\t\t\trepair_io_failure(inode, start, failrec->len,\n\t\t\t\t\t  failrec->logical, page,\n\t\t\t\t\t  pg_offset, failrec->failed_mirror);\n\t\t}\n\t}\n\nout:\n\tfree_io_failure(inode, failrec);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "repair_eb_io_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2084-2106",
    "snippet": "int repair_eb_io_failure(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t int mirror_num)\n{\n\tu64 start = eb->start;\n\tunsigned long i, num_pages = num_extent_pages(eb->start, eb->len);\n\tint ret = 0;\n\n\tif (root->fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tret = repair_io_failure(root->fs_info->btree_inode, start,\n\t\t\t\t\tPAGE_CACHE_SIZE, start, p,\n\t\t\t\t\tstart - page_offset(p), mirror_num);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart += PAGE_CACHE_SIZE;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "repair_io_failure",
          "args": [
            "root->fs_info->btree_inode",
            "start",
            "PAGE_CACHE_SIZE",
            "start",
            "p",
            "start - page_offset(p)",
            "mirror_num"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "repair_io_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2026-2082",
          "snippet": "int repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,\n\t\t      struct page *page, unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tu64 map_length = 0;\n\tu64 sector;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tint ret;\n\n\tASSERT(!(fs_info->sb->s_flags & MS_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\t/* we can't repair anything in raid56 yet */\n\tif (btrfs_is_parity_mirror(map_tree, logical, length, mirror_num))\n\t\treturn 0;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn -EIO;\n\tbio->bi_iter.bi_size = 0;\n\tmap_length = length;\n\n\tret = btrfs_map_block(fs_info, WRITE, logical,\n\t\t\t      &map_length, &bbio, mirror_num);\n\tif (ret) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tBUG_ON(mirror_num != bbio->mirror_num);\n\tsector = bbio->stripes[mirror_num-1].physical >> 9;\n\tbio->bi_iter.bi_sector = sector;\n\tdev = bbio->stripes[mirror_num-1].dev;\n\tbtrfs_put_bbio(bbio);\n\tif (!dev || !dev->bdev || !dev->writeable) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tbio->bi_bdev = dev->bdev;\n\tbio_add_page(bio, page, length, pg_offset);\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio)) {\n\t\t/* try to remap that extent elsewhere? */\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tprintk_ratelimited_in_rcu(KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\",\n\t\t\t\t  btrfs_ino(inode), start,\n\t\t\t\t  rcu_str_deref(dev->name), sector);\n\tbio_put(bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,\n\t\t      struct page *page, unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tu64 map_length = 0;\n\tu64 sector;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tint ret;\n\n\tASSERT(!(fs_info->sb->s_flags & MS_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\t/* we can't repair anything in raid56 yet */\n\tif (btrfs_is_parity_mirror(map_tree, logical, length, mirror_num))\n\t\treturn 0;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn -EIO;\n\tbio->bi_iter.bi_size = 0;\n\tmap_length = length;\n\n\tret = btrfs_map_block(fs_info, WRITE, logical,\n\t\t\t      &map_length, &bbio, mirror_num);\n\tif (ret) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tBUG_ON(mirror_num != bbio->mirror_num);\n\tsector = bbio->stripes[mirror_num-1].physical >> 9;\n\tbio->bi_iter.bi_sector = sector;\n\tdev = bbio->stripes[mirror_num-1].dev;\n\tbtrfs_put_bbio(bbio);\n\tif (!dev || !dev->bdev || !dev->writeable) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tbio->bi_bdev = dev->bdev;\n\tbio_add_page(bio, page, length, pg_offset);\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio)) {\n\t\t/* try to remap that extent elsewhere? */\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tprintk_ratelimited_in_rcu(KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\",\n\t\t\t\t  btrfs_ino(inode), start,\n\t\t\t\t  rcu_str_deref(dev->name), sector);\n\tbio_put(bio);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "p"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_extent_pages",
          "args": [
            "eb->start",
            "eb->len"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "num_extent_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "281-285",
          "snippet": "static inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline unsigned long num_extent_pages(u64 start, u64 len)\n{\n\treturn ((start + len + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT) -\n\t\t(start >> PAGE_CACHE_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint repair_eb_io_failure(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t int mirror_num)\n{\n\tu64 start = eb->start;\n\tunsigned long i, num_pages = num_extent_pages(eb->start, eb->len);\n\tint ret = 0;\n\n\tif (root->fs_info->sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tstruct page *p = eb->pages[i];\n\n\t\tret = repair_io_failure(root->fs_info->btree_inode, start,\n\t\t\t\t\tPAGE_CACHE_SIZE, start, p,\n\t\t\t\t\tstart - page_offset(p), mirror_num);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstart += PAGE_CACHE_SIZE;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "repair_io_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "2026-2082",
    "snippet": "int repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,\n\t\t      struct page *page, unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tu64 map_length = 0;\n\tu64 sector;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tint ret;\n\n\tASSERT(!(fs_info->sb->s_flags & MS_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\t/* we can't repair anything in raid56 yet */\n\tif (btrfs_is_parity_mirror(map_tree, logical, length, mirror_num))\n\t\treturn 0;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn -EIO;\n\tbio->bi_iter.bi_size = 0;\n\tmap_length = length;\n\n\tret = btrfs_map_block(fs_info, WRITE, logical,\n\t\t\t      &map_length, &bbio, mirror_num);\n\tif (ret) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tBUG_ON(mirror_num != bbio->mirror_num);\n\tsector = bbio->stripes[mirror_num-1].physical >> 9;\n\tbio->bi_iter.bi_sector = sector;\n\tdev = bbio->stripes[mirror_num-1].dev;\n\tbtrfs_put_bbio(bbio);\n\tif (!dev || !dev->bdev || !dev->writeable) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tbio->bi_bdev = dev->bdev;\n\tbio_add_page(bio, page, length, pg_offset);\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio)) {\n\t\t/* try to remap that extent elsewhere? */\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tprintk_ratelimited_in_rcu(KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\",\n\t\t\t\t  btrfs_ino(inode), start,\n\t\t\t\t  rcu_str_deref(dev->name), sector);\n\tbio_put(bio);\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited_in_rcu",
          "args": [
            "KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\"",
            "btrfs_ino(inode)",
            "start",
            "rcu_str_deref(dev->name)",
            "sector"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_str_deref",
          "args": [
            "dev->name"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_stat_inc_and_print",
          "args": [
            "dev",
            "BTRFS_DEV_STAT_WRITE_ERRS"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_stat_inc_and_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "6595-6599",
          "snippet": "void btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_dev_stat_inc_and_print(struct btrfs_device *dev, int index)\n{\n\tbtrfs_dev_stat_inc(dev, index);\n\tbtrfs_dev_stat_print_on_error(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfsic_submit_bio_wait",
          "args": [
            "WRITE_SYNC",
            "bio"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "btrfsic_submit_bio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/check-integrity.c",
          "lines": "3067-3071",
          "snippet": "int btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}",
          "includes": [
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"extent_io.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"extent_io.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint btrfsic_submit_bio_wait(int rw, struct bio *bio)\n{\n\t__btrfsic_submit_bio(rw, bio);\n\treturn submit_bio_wait(rw, bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "length",
            "pg_offset"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "bbio"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mirror_num != bbio->mirror_num"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_map_block",
          "args": [
            "fs_info",
            "WRITE",
            "logical",
            "&map_length",
            "&bbio",
            "mirror_num"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5484-5490",
          "snippet": "int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_io_bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_is_parity_mirror",
          "args": [
            "map_tree",
            "logical",
            "length",
            "mirror_num"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_is_parity_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4814-4833",
          "snippet": "int btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,\n\t\t\t   u64 logical, u64 len, int mirror_num)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret = 0;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\tBUG_ON(!em);\n\n\tBUG_ON(em->start > logical || em->start + em->len < logical);\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)\n\t\tret = 1;\n\tfree_extent_map(em);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_is_parity_mirror(struct btrfs_mapping_tree *map_tree,\n\t\t\t   u64 logical, u64 len, int mirror_num)\n{\n\tstruct extent_map *em;\n\tstruct map_lookup *map;\n\tstruct extent_map_tree *em_tree = &map_tree->map_tree;\n\tint ret = 0;\n\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree, logical, len);\n\tread_unlock(&em_tree->lock);\n\tBUG_ON(!em);\n\n\tBUG_ON(em->start > logical || em->start + em->len < logical);\n\tmap = (struct map_lookup *)em->bdev;\n\tif (map->type & BTRFS_BLOCK_GROUP_RAID56_MASK)\n\t\tret = 1;\n\tfree_extent_map(em);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mirror_num"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(fs_info->sb->s_flags & MS_RDONLY)"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint repair_io_failure(struct inode *inode, u64 start, u64 length, u64 logical,\n\t\t      struct page *page, unsigned int pg_offset, int mirror_num)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct bio *bio;\n\tstruct btrfs_device *dev;\n\tu64 map_length = 0;\n\tu64 sector;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree;\n\tint ret;\n\n\tASSERT(!(fs_info->sb->s_flags & MS_RDONLY));\n\tBUG_ON(!mirror_num);\n\n\t/* we can't repair anything in raid56 yet */\n\tif (btrfs_is_parity_mirror(map_tree, logical, length, mirror_num))\n\t\treturn 0;\n\n\tbio = btrfs_io_bio_alloc(GFP_NOFS, 1);\n\tif (!bio)\n\t\treturn -EIO;\n\tbio->bi_iter.bi_size = 0;\n\tmap_length = length;\n\n\tret = btrfs_map_block(fs_info, WRITE, logical,\n\t\t\t      &map_length, &bbio, mirror_num);\n\tif (ret) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tBUG_ON(mirror_num != bbio->mirror_num);\n\tsector = bbio->stripes[mirror_num-1].physical >> 9;\n\tbio->bi_iter.bi_sector = sector;\n\tdev = bbio->stripes[mirror_num-1].dev;\n\tbtrfs_put_bbio(bbio);\n\tif (!dev || !dev->bdev || !dev->writeable) {\n\t\tbio_put(bio);\n\t\treturn -EIO;\n\t}\n\tbio->bi_bdev = dev->bdev;\n\tbio_add_page(bio, page, length, pg_offset);\n\n\tif (btrfsic_submit_bio_wait(WRITE_SYNC, bio)) {\n\t\t/* try to remap that extent elsewhere? */\n\t\tbio_put(bio);\n\t\tbtrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_WRITE_ERRS);\n\t\treturn -EIO;\n\t}\n\n\tprintk_ratelimited_in_rcu(KERN_INFO\n\t\t\t\t  \"BTRFS: read error corrected: ino %llu off %llu (dev %s sector %llu)\\n\",\n\t\t\t\t  btrfs_ino(inode), start,\n\t\t\t\t  rcu_str_deref(dev->name), sector);\n\tbio_put(bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "free_io_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1993-2014",
    "snippet": "int free_io_failure(struct inode *inode, struct io_failure_record *rec)\n{\n\tint ret;\n\tint err = 0;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\n\tset_state_private(failure_tree, rec->start, 0);\n\tret = clear_extent_bits(failure_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\tif (ret)\n\t\terr = ret;\n\n\tret = clear_extent_bits(&BTRFS_I(inode)->io_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\tif (ret && !err)\n\t\terr = ret;\n\n\tkfree(rec);\n\treturn err;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rec"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "rec->start",
            "rec->start + rec->len - 1",
            "EXTENT_DAMAGED",
            "GFP_NOFS"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1277-1281",
          "snippet": "int clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_state_private",
          "args": [
            "failure_tree",
            "rec->start",
            "0"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "set_state_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1871-1896",
          "snippet": "static int set_state_private(struct extent_io_tree *tree, u64 start, u64 private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate->private = private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int set_state_private(struct extent_io_tree *tree, u64 start, u64 private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate->private = private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint free_io_failure(struct inode *inode, struct io_failure_record *rec)\n{\n\tint ret;\n\tint err = 0;\n\tstruct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;\n\n\tset_state_private(failure_tree, rec->start, 0);\n\tret = clear_extent_bits(failure_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_LOCKED | EXTENT_DIRTY, GFP_NOFS);\n\tif (ret)\n\t\terr = ret;\n\n\tret = clear_extent_bits(&BTRFS_I(inode)->io_tree, rec->start,\n\t\t\t\trec->start + rec->len - 1,\n\t\t\t\tEXTENT_DAMAGED, GFP_NOFS);\n\tif (ret && !err)\n\t\terr = ret;\n\n\tkfree(rec);\n\treturn err;\n}"
  },
  {
    "function_name": "check_page_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1985-1991",
    "snippet": "static void check_page_uptodate(struct extent_io_tree *tree, struct page *page)\n{\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tif (test_range_bit(tree, start, end, EXTENT_UPTODATE, 1, NULL))\n\t\tSetPageUptodate(page);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_range_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_UPTODATE",
            "1",
            "NULL"
          ],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "test_range_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1931-1979",
          "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void check_page_uptodate(struct extent_io_tree *tree, struct page *page)\n{\n\tu64 start = page_offset(page);\n\tu64 end = start + PAGE_CACHE_SIZE - 1;\n\tif (test_range_bit(tree, start, end, EXTENT_UPTODATE, 1, NULL))\n\t\tSetPageUptodate(page);\n}"
  },
  {
    "function_name": "test_range_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1931-1979",
    "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "start"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "340-344",
          "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_state_in_tree",
          "args": [
            "cached"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "extent_state_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "28-31",
          "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
  },
  {
    "function_name": "get_state_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1898-1923",
    "snippet": "int get_state_private(struct extent_io_tree *tree, u64 start, u64 *private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*private = state->private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "start"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "340-344",
          "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint get_state_private(struct extent_io_tree *tree, u64 start, u64 *private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\t*private = state->private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "set_state_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1871-1896",
    "snippet": "static int set_state_private(struct extent_io_tree *tree, u64 start, u64 private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate->private = private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "start"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "340-344",
          "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int set_state_private(struct extent_io_tree *tree, u64 start, u64 private)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tint ret = 0;\n\n\tspin_lock(&tree->lock);\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\n\tif (state->start != start) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tstate->private = private;\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "count_range_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1812-1865",
    "snippet": "u64 count_range_bits(struct extent_io_tree *tree,\n\t\t     u64 *start, u64 search_end, u64 max_bytes,\n\t\t     unsigned bits, int contig)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 total_bytes = 0;\n\tu64 last = 0;\n\tint found = 0;\n\n\tif (WARN_ON(search_end <= cur_start))\n\t\treturn 0;\n\n\tspin_lock(&tree->lock);\n\tif (cur_start == 0 && bits == EXTENT_DIRTY) {\n\t\ttotal_bytes = tree->dirty_bytes;\n\t\tgoto out;\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->start > search_end)\n\t\t\tbreak;\n\t\tif (contig && found && state->start > last + 1)\n\t\t\tbreak;\n\t\tif (state->end >= cur_start && (state->state & bits) == bits) {\n\t\t\ttotal_bytes += min(search_end, state->end) + 1 -\n\t\t\t\t       max(cur_start, state->start);\n\t\t\tif (total_bytes >= max_bytes)\n\t\t\t\tbreak;\n\t\t\tif (!found) {\n\t\t\t\t*start = max(cur_start, state->start);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tlast = state->end;\n\t\t} else if (contig && found) {\n\t\t\tbreak;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn total_bytes;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "cur_start",
            "state->start"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "search_end",
            "state->end"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "cur_start"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "340-344",
          "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "search_end <= cur_start"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nu64 count_range_bits(struct extent_io_tree *tree,\n\t\t     u64 *start, u64 search_end, u64 max_bytes,\n\t\t     unsigned bits, int contig)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 total_bytes = 0;\n\tu64 last = 0;\n\tint found = 0;\n\n\tif (WARN_ON(search_end <= cur_start))\n\t\treturn 0;\n\n\tspin_lock(&tree->lock);\n\tif (cur_start == 0 && bits == EXTENT_DIRTY) {\n\t\ttotal_bytes = tree->dirty_bytes;\n\t\tgoto out;\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->start > search_end)\n\t\t\tbreak;\n\t\tif (contig && found && state->start > last + 1)\n\t\t\tbreak;\n\t\tif (state->end >= cur_start && (state->state & bits) == bits) {\n\t\t\ttotal_bytes += min(search_end, state->end) + 1 -\n\t\t\t\t       max(cur_start, state->start);\n\t\t\tif (total_bytes >= max_bytes)\n\t\t\t\tbreak;\n\t\t\tif (!found) {\n\t\t\t\t*start = max(cur_start, state->start);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tlast = state->end;\n\t\t} else if (contig && found) {\n\t\t\tbreak;\n\t\t}\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn total_bytes;\n}"
  },
  {
    "function_name": "extent_clear_unlock_delalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1755-1805",
    "snippet": "int extent_clear_unlock_delalloc(struct inode *inode, u64 start, u64 end,\n\t\t\t\t struct page *locked_page,\n\t\t\t\t unsigned clear_bits,\n\t\t\t\t unsigned long page_ops)\n{\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\n\tclear_extent_bit(tree, start, end, clear_bits, 1, 0, NULL, GFP_NOFS);\n\tif (page_ops == 0)\n\t\treturn 0;\n\n\tif ((page_ops & PAGE_SET_ERROR) && nr_pages > 0)\n\t\tmapping_set_error(inode->i_mapping, -EIO);\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nr_pages, ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\n\t\t\tif (page_ops & PAGE_SET_PRIVATE2)\n\t\t\t\tSetPagePrivate2(pages[i]);\n\n\t\t\tif (pages[i] == locked_page) {\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (page_ops & PAGE_CLEAR_DIRTY)\n\t\t\t\tclear_page_dirty_for_io(pages[i]);\n\t\t\tif (page_ops & PAGE_SET_WRITEBACK)\n\t\t\t\tset_page_writeback(pages[i]);\n\t\t\tif (page_ops & PAGE_SET_ERROR)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tif (page_ops & PAGE_END_WRITEBACK)\n\t\t\t\tend_page_writeback(pages[i]);\n\t\t\tif (page_ops & PAGE_UNLOCK)\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "pages[i]"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "pages[i]"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "pages[i]"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "pages[i]"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate2",
          "args": [
            "pages[i]"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "inode->i_mapping",
            "index",
            "min_t(unsigned long,\n\t\t\t\t     nr_pages, ARRAY_SIZE(pages))",
            "pages"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "nr_pages",
            "ARRAY_SIZE(pages)"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "-EIO"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "clear_bits",
            "1",
            "0",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_clear_unlock_delalloc(struct inode *inode, u64 start, u64 end,\n\t\t\t\t struct page *locked_page,\n\t\t\t\t unsigned clear_bits,\n\t\t\t\t unsigned long page_ops)\n{\n\tstruct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\n\tclear_extent_bit(tree, start, end, clear_bits, 1, 0, NULL, GFP_NOFS);\n\tif (page_ops == 0)\n\t\treturn 0;\n\n\tif ((page_ops & PAGE_SET_ERROR) && nr_pages > 0)\n\t\tmapping_set_error(inode->i_mapping, -EIO);\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nr_pages, ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\n\t\t\tif (page_ops & PAGE_SET_PRIVATE2)\n\t\t\t\tSetPagePrivate2(pages[i]);\n\n\t\t\tif (pages[i] == locked_page) {\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (page_ops & PAGE_CLEAR_DIRTY)\n\t\t\t\tclear_page_dirty_for_io(pages[i]);\n\t\t\tif (page_ops & PAGE_SET_WRITEBACK)\n\t\t\t\tset_page_writeback(pages[i]);\n\t\t\tif (page_ops & PAGE_SET_ERROR)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tif (page_ops & PAGE_END_WRITEBACK)\n\t\t\t\tend_page_writeback(pages[i]);\n\t\t\tif (page_ops & PAGE_UNLOCK)\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "find_lock_delalloc_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1675-1753",
    "snippet": "STATIC u64 find_lock_delalloc_range(struct inode *inode,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *locked_page, u64 *start,\n\t\t\t\t    u64 *end, u64 max_bytes)\n{\n\tu64 delalloc_start;\n\tu64 delalloc_end;\n\tu64 found;\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tint loops = 0;\n\nagain:\n\t/* step one, find a bunch of delalloc bytes starting at start */\n\tdelalloc_start = *start;\n\tdelalloc_end = 0;\n\tfound = find_delalloc_range(tree, &delalloc_start, &delalloc_end,\n\t\t\t\t    max_bytes, &cached_state);\n\tif (!found || delalloc_end <= *start) {\n\t\t*start = delalloc_start;\n\t\t*end = delalloc_end;\n\t\tfree_extent_state(cached_state);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * start comes from the offset of locked_page.  We have to lock\n\t * pages in order, so we can't process delalloc bytes before\n\t * locked_page\n\t */\n\tif (delalloc_start < *start)\n\t\tdelalloc_start = *start;\n\n\t/*\n\t * make sure to limit the number of pages we try to lock down\n\t */\n\tif (delalloc_end + 1 - delalloc_start > max_bytes)\n\t\tdelalloc_end = delalloc_start + max_bytes - 1;\n\n\t/* step two, lock all the pages after the page that has start */\n\tret = lock_delalloc_pages(inode, locked_page,\n\t\t\t\t  delalloc_start, delalloc_end);\n\tif (ret == -EAGAIN) {\n\t\t/* some of the pages are gone, lets avoid looping by\n\t\t * shortening the size of the delalloc range we're searching\n\t\t */\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tif (!loops) {\n\t\t\tmax_bytes = PAGE_CACHE_SIZE;\n\t\t\tloops = 1;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tfound = 0;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tBUG_ON(ret); /* Only valid values are 0 and -EAGAIN */\n\n\t/* step three, lock the state bits for the whole range */\n\tlock_extent_bits(tree, delalloc_start, delalloc_end, 0, &cached_state);\n\n\t/* then test to make sure it is all still delalloc */\n\tret = test_range_bit(tree, delalloc_start, delalloc_end,\n\t\t\t     EXTENT_DELALLOC, 1, cached_state);\n\tif (!ret) {\n\t\tunlock_extent_cached(tree, delalloc_start, delalloc_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start, delalloc_end);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\n\tfree_extent_state(cached_state);\n\t*start = delalloc_start;\n\t*end = delalloc_end;\nout_failed:\n\treturn found;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "cached_state"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unlock_for_delalloc",
          "args": [
            "inode",
            "locked_page",
            "delalloc_start",
            "delalloc_end"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "__unlock_for_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1578-1605",
          "snippet": "static noinline void __unlock_for_delalloc(struct inode *inode,\n\t\t\t\t\t   struct page *locked_page,\n\t\t\t\t\t   u64 start, u64 end)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\n\tif (index == locked_page->index && end_index == index)\n\t\treturn;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (pages[i] != locked_page)\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void __unlock_for_delalloc(struct inode *inode,\n\t\t\t\t\t   struct page *locked_page,\n\t\t\t\t\t   u64 start, u64 end)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\n\tif (index == locked_page->index && end_index == index)\n\t\treturn;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (pages[i] != locked_page)\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent_cached",
          "args": [
            "tree",
            "delalloc_start",
            "delalloc_end",
            "&cached_state",
            "GFP_NOFS"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1373-1378",
          "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_range_bit",
          "args": [
            "tree",
            "delalloc_start",
            "delalloc_end",
            "EXTENT_DELALLOC",
            "1",
            "cached_state"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "test_range_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1931-1979",
          "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "tree",
            "delalloc_start",
            "delalloc_end",
            "0",
            "&cached_state"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_delalloc_pages",
          "args": [
            "inode",
            "locked_page",
            "delalloc_start",
            "delalloc_end"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "lock_delalloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1607-1667",
          "snippet": "static noinline int lock_delalloc_pages(struct inode *inode,\n\t\t\t\t\tstruct page *locked_page,\n\t\t\t\t\tu64 delalloc_start,\n\t\t\t\t\tu64 delalloc_end)\n{\n\tunsigned long index = delalloc_start >> PAGE_CACHE_SHIFT;\n\tunsigned long start_index = index;\n\tunsigned long end_index = delalloc_end >> PAGE_CACHE_SHIFT;\n\tunsigned long pages_locked = 0;\n\tstruct page *pages[16];\n\tunsigned long nrpages;\n\tint ret;\n\tint i;\n\n\t/* the caller is responsible for locking the start index */\n\tif (index == locked_page->index && index == end_index)\n\t\treturn 0;\n\n\t/* skip the page at the start index */\n\tnrpages = end_index - index + 1;\n\twhile (nrpages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nrpages, ARRAY_SIZE(pages)), pages);\n\t\tif (ret == 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\t/* now we have an array of pages, lock them all */\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/*\n\t\t\t * the caller is taking responsibility for\n\t\t\t * locked_page\n\t\t\t */\n\t\t\tif (pages[i] != locked_page) {\n\t\t\t\tlock_page(pages[i]);\n\t\t\t\tif (!PageDirty(pages[i]) ||\n\t\t\t\t    pages[i]->mapping != inode->i_mapping) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tunlock_page(pages[i]);\n\t\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tpages_locked++;\n\t\t}\n\t\tnrpages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n\tret = 0;\ndone:\n\tif (ret && pages_locked) {\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start,\n\t\t\t      ((u64)(start_index + pages_locked - 1)) <<\n\t\t\t      PAGE_CACHE_SHIFT);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline int lock_delalloc_pages(struct inode *inode,\n\t\t\t\t\tstruct page *locked_page,\n\t\t\t\t\tu64 delalloc_start,\n\t\t\t\t\tu64 delalloc_end)\n{\n\tunsigned long index = delalloc_start >> PAGE_CACHE_SHIFT;\n\tunsigned long start_index = index;\n\tunsigned long end_index = delalloc_end >> PAGE_CACHE_SHIFT;\n\tunsigned long pages_locked = 0;\n\tstruct page *pages[16];\n\tunsigned long nrpages;\n\tint ret;\n\tint i;\n\n\t/* the caller is responsible for locking the start index */\n\tif (index == locked_page->index && index == end_index)\n\t\treturn 0;\n\n\t/* skip the page at the start index */\n\tnrpages = end_index - index + 1;\n\twhile (nrpages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nrpages, ARRAY_SIZE(pages)), pages);\n\t\tif (ret == 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\t/* now we have an array of pages, lock them all */\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/*\n\t\t\t * the caller is taking responsibility for\n\t\t\t * locked_page\n\t\t\t */\n\t\t\tif (pages[i] != locked_page) {\n\t\t\t\tlock_page(pages[i]);\n\t\t\t\tif (!PageDirty(pages[i]) ||\n\t\t\t\t    pages[i]->mapping != inode->i_mapping) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tunlock_page(pages[i]);\n\t\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tpages_locked++;\n\t\t}\n\t\tnrpages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n\tret = 0;\ndone:\n\tif (ret && pages_locked) {\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start,\n\t\t\t      ((u64)(start_index + pages_locked - 1)) <<\n\t\t\t      PAGE_CACHE_SHIFT);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_delalloc_range",
          "args": [
            "tree",
            "&delalloc_start",
            "&delalloc_end",
            "max_bytes",
            "&cached_state"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "find_delalloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1524-1576",
          "snippet": "static noinline u64 find_delalloc_range(struct extent_io_tree *tree,\n\t\t\t\t\tu64 *start, u64 *end, u64 max_bytes,\n\t\t\t\t\tstruct extent_state **cached_state)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 found = 0;\n\tu64 total_bytes = 0;\n\n\tspin_lock(&tree->lock);\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node) {\n\t\tif (!found)\n\t\t\t*end = (u64)-1;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (found && (state->start != cur_start ||\n\t\t\t      (state->state & EXTENT_BOUNDARY))) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(state->state & EXTENT_DELALLOC)) {\n\t\t\tif (!found)\n\t\t\t\t*end = state->end;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!found) {\n\t\t\t*start = state->start;\n\t\t\t*cached_state = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t\tfound++;\n\t\t*end = state->end;\n\t\tcur_start = state->end + 1;\n\t\tnode = rb_next(node);\n\t\ttotal_bytes += state->end - state->start + 1;\n\t\tif (total_bytes >= max_bytes)\n\t\t\tbreak;\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn found;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline u64 find_delalloc_range(struct extent_io_tree *tree,\n\t\t\t\t\tu64 *start, u64 *end, u64 max_bytes,\n\t\t\t\t\tstruct extent_state **cached_state)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 found = 0;\n\tu64 total_bytes = 0;\n\n\tspin_lock(&tree->lock);\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node) {\n\t\tif (!found)\n\t\t\t*end = (u64)-1;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (found && (state->start != cur_start ||\n\t\t\t      (state->state & EXTENT_BOUNDARY))) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(state->state & EXTENT_DELALLOC)) {\n\t\t\tif (!found)\n\t\t\t\t*end = state->end;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!found) {\n\t\t\t*start = state->start;\n\t\t\t*cached_state = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t\tfound++;\n\t\t*end = state->end;\n\t\tcur_start = state->end + 1;\n\t\tnode = rb_next(node);\n\t\ttotal_bytes += state->end - state->start + 1;\n\t\tif (total_bytes >= max_bytes)\n\t\t\tbreak;\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nSTATIC u64 find_lock_delalloc_range(struct inode *inode,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *locked_page, u64 *start,\n\t\t\t\t    u64 *end, u64 max_bytes)\n{\n\tu64 delalloc_start;\n\tu64 delalloc_end;\n\tu64 found;\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tint loops = 0;\n\nagain:\n\t/* step one, find a bunch of delalloc bytes starting at start */\n\tdelalloc_start = *start;\n\tdelalloc_end = 0;\n\tfound = find_delalloc_range(tree, &delalloc_start, &delalloc_end,\n\t\t\t\t    max_bytes, &cached_state);\n\tif (!found || delalloc_end <= *start) {\n\t\t*start = delalloc_start;\n\t\t*end = delalloc_end;\n\t\tfree_extent_state(cached_state);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * start comes from the offset of locked_page.  We have to lock\n\t * pages in order, so we can't process delalloc bytes before\n\t * locked_page\n\t */\n\tif (delalloc_start < *start)\n\t\tdelalloc_start = *start;\n\n\t/*\n\t * make sure to limit the number of pages we try to lock down\n\t */\n\tif (delalloc_end + 1 - delalloc_start > max_bytes)\n\t\tdelalloc_end = delalloc_start + max_bytes - 1;\n\n\t/* step two, lock all the pages after the page that has start */\n\tret = lock_delalloc_pages(inode, locked_page,\n\t\t\t\t  delalloc_start, delalloc_end);\n\tif (ret == -EAGAIN) {\n\t\t/* some of the pages are gone, lets avoid looping by\n\t\t * shortening the size of the delalloc range we're searching\n\t\t */\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tif (!loops) {\n\t\t\tmax_bytes = PAGE_CACHE_SIZE;\n\t\t\tloops = 1;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tfound = 0;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tBUG_ON(ret); /* Only valid values are 0 and -EAGAIN */\n\n\t/* step three, lock the state bits for the whole range */\n\tlock_extent_bits(tree, delalloc_start, delalloc_end, 0, &cached_state);\n\n\t/* then test to make sure it is all still delalloc */\n\tret = test_range_bit(tree, delalloc_start, delalloc_end,\n\t\t\t     EXTENT_DELALLOC, 1, cached_state);\n\tif (!ret) {\n\t\tunlock_extent_cached(tree, delalloc_start, delalloc_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start, delalloc_end);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\n\tfree_extent_state(cached_state);\n\t*start = delalloc_start;\n\t*end = delalloc_end;\nout_failed:\n\treturn found;\n}"
  },
  {
    "function_name": "lock_delalloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1607-1667",
    "snippet": "static noinline int lock_delalloc_pages(struct inode *inode,\n\t\t\t\t\tstruct page *locked_page,\n\t\t\t\t\tu64 delalloc_start,\n\t\t\t\t\tu64 delalloc_end)\n{\n\tunsigned long index = delalloc_start >> PAGE_CACHE_SHIFT;\n\tunsigned long start_index = index;\n\tunsigned long end_index = delalloc_end >> PAGE_CACHE_SHIFT;\n\tunsigned long pages_locked = 0;\n\tstruct page *pages[16];\n\tunsigned long nrpages;\n\tint ret;\n\tint i;\n\n\t/* the caller is responsible for locking the start index */\n\tif (index == locked_page->index && index == end_index)\n\t\treturn 0;\n\n\t/* skip the page at the start index */\n\tnrpages = end_index - index + 1;\n\twhile (nrpages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nrpages, ARRAY_SIZE(pages)), pages);\n\t\tif (ret == 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\t/* now we have an array of pages, lock them all */\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/*\n\t\t\t * the caller is taking responsibility for\n\t\t\t * locked_page\n\t\t\t */\n\t\t\tif (pages[i] != locked_page) {\n\t\t\t\tlock_page(pages[i]);\n\t\t\t\tif (!PageDirty(pages[i]) ||\n\t\t\t\t    pages[i]->mapping != inode->i_mapping) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tunlock_page(pages[i]);\n\t\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tpages_locked++;\n\t\t}\n\t\tnrpages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n\tret = 0;\ndone:\n\tif (ret && pages_locked) {\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start,\n\t\t\t      ((u64)(start_index + pages_locked - 1)) <<\n\t\t\t      PAGE_CACHE_SHIFT);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__unlock_for_delalloc",
          "args": [
            "inode",
            "locked_page",
            "delalloc_start",
            "((u64)(start_index + pages_locked - 1)) <<\n\t\t\t      PAGE_CACHE_SHIFT"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "__unlock_for_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1578-1605",
          "snippet": "static noinline void __unlock_for_delalloc(struct inode *inode,\n\t\t\t\t\t   struct page *locked_page,\n\t\t\t\t\t   u64 start, u64 end)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\n\tif (index == locked_page->index && end_index == index)\n\t\treturn;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (pages[i] != locked_page)\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void __unlock_for_delalloc(struct inode *inode,\n\t\t\t\t\t   struct page *locked_page,\n\t\t\t\t\t   u64 start, u64 end)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\n\tif (index == locked_page->index && end_index == index)\n\t\treturn;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (pages[i] != locked_page)\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "start_index + pages_locked - 1"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "pages[i]"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "inode->i_mapping",
            "index",
            "min_t(unsigned long,\n\t\t\t\t     nrpages, ARRAY_SIZE(pages))",
            "pages"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "nrpages",
            "ARRAY_SIZE(pages)"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline int lock_delalloc_pages(struct inode *inode,\n\t\t\t\t\tstruct page *locked_page,\n\t\t\t\t\tu64 delalloc_start,\n\t\t\t\t\tu64 delalloc_end)\n{\n\tunsigned long index = delalloc_start >> PAGE_CACHE_SHIFT;\n\tunsigned long start_index = index;\n\tunsigned long end_index = delalloc_end >> PAGE_CACHE_SHIFT;\n\tunsigned long pages_locked = 0;\n\tstruct page *pages[16];\n\tunsigned long nrpages;\n\tint ret;\n\tint i;\n\n\t/* the caller is responsible for locking the start index */\n\tif (index == locked_page->index && index == end_index)\n\t\treturn 0;\n\n\t/* skip the page at the start index */\n\tnrpages = end_index - index + 1;\n\twhile (nrpages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nrpages, ARRAY_SIZE(pages)), pages);\n\t\tif (ret == 0) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\t/* now we have an array of pages, lock them all */\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/*\n\t\t\t * the caller is taking responsibility for\n\t\t\t * locked_page\n\t\t\t */\n\t\t\tif (pages[i] != locked_page) {\n\t\t\t\tlock_page(pages[i]);\n\t\t\t\tif (!PageDirty(pages[i]) ||\n\t\t\t\t    pages[i]->mapping != inode->i_mapping) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tunlock_page(pages[i]);\n\t\t\t\t\tpage_cache_release(pages[i]);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tpages_locked++;\n\t\t}\n\t\tnrpages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n\tret = 0;\ndone:\n\tif (ret && pages_locked) {\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start,\n\t\t\t      ((u64)(start_index + pages_locked - 1)) <<\n\t\t\t      PAGE_CACHE_SHIFT);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__unlock_for_delalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1578-1605",
    "snippet": "static noinline void __unlock_for_delalloc(struct inode *inode,\n\t\t\t\t\t   struct page *locked_page,\n\t\t\t\t\t   u64 start, u64 end)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\n\tif (index == locked_page->index && end_index == index)\n\t\treturn;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (pages[i] != locked_page)\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "inode->i_mapping",
            "index",
            "min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages))",
            "pages"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "nr_pages",
            "ARRAY_SIZE(pages)"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline void __unlock_for_delalloc(struct inode *inode,\n\t\t\t\t\t   struct page *locked_page,\n\t\t\t\t\t   u64 start, u64 end)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\n\tif (index == locked_page->index && end_index == index)\n\t\treturn;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (pages[i] != locked_page)\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "find_delalloc_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1524-1576",
    "snippet": "static noinline u64 find_delalloc_range(struct extent_io_tree *tree,\n\t\t\t\t\tu64 *start, u64 *end, u64 max_bytes,\n\t\t\t\t\tstruct extent_state **cached_state)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 found = 0;\n\tu64 total_bytes = 0;\n\n\tspin_lock(&tree->lock);\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node) {\n\t\tif (!found)\n\t\t\t*end = (u64)-1;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (found && (state->start != cur_start ||\n\t\t\t      (state->state & EXTENT_BOUNDARY))) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(state->state & EXTENT_DELALLOC)) {\n\t\t\tif (!found)\n\t\t\t\t*end = state->end;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!found) {\n\t\t\t*start = state->start;\n\t\t\t*cached_state = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t\tfound++;\n\t\t*end = state->end;\n\t\tcur_start = state->end + 1;\n\t\tnode = rb_next(node);\n\t\ttotal_bytes += state->end - state->start + 1;\n\t\tif (total_bytes >= max_bytes)\n\t\t\tbreak;\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn found;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&state->refs"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "cur_start"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "340-344",
          "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic noinline u64 find_delalloc_range(struct extent_io_tree *tree,\n\t\t\t\t\tu64 *start, u64 *end, u64 max_bytes,\n\t\t\t\t\tstruct extent_state **cached_state)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\tu64 cur_start = *start;\n\tu64 found = 0;\n\tu64 total_bytes = 0;\n\n\tspin_lock(&tree->lock);\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, cur_start);\n\tif (!node) {\n\t\tif (!found)\n\t\t\t*end = (u64)-1;\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (found && (state->start != cur_start ||\n\t\t\t      (state->state & EXTENT_BOUNDARY))) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(state->state & EXTENT_DELALLOC)) {\n\t\t\tif (!found)\n\t\t\t\t*end = state->end;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!found) {\n\t\t\t*start = state->start;\n\t\t\t*cached_state = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t\tfound++;\n\t\t*end = state->end;\n\t\tcur_start = state->end + 1;\n\t\tnode = rb_next(node);\n\t\ttotal_bytes += state->end - state->start + 1;\n\t\tif (total_bytes >= max_bytes)\n\t\t\tbreak;\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn found;\n}"
  },
  {
    "function_name": "find_first_extent_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1477-1516",
    "snippet": "int find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_state_if_flags",
          "args": [
            "state",
            "cached_state",
            "0"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "cache_state_if_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "804-814",
          "snippet": "static void cache_state_if_flags(struct extent_state *state,\n\t\t\t\t struct extent_state **cached_ptr,\n\t\t\t\t unsigned flags)\n{\n\tif (cached_ptr && !(*cached_ptr)) {\n\t\tif (!flags || (state->state & flags)) {\n\t\t\t*cached_ptr = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void cache_state_if_flags(struct extent_state *state,\n\t\t\t\t struct extent_state **cached_ptr,\n\t\t\t\t unsigned flags)\n{\n\tif (cached_ptr && !(*cached_ptr)) {\n\t\tif (!flags || (state->state & flags)) {\n\t\t\t*cached_ptr = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit_state",
          "args": [
            "tree",
            "start",
            "bits"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1442-1468",
          "snippet": "static struct extent_state *\nfind_first_extent_bit_state(struct extent_io_tree *tree,\n\t\t\t    u64 start, unsigned bits)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->end >= start && (state->state & bits))\n\t\t\treturn state;\n\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic struct extent_state *\nfind_first_extent_bit_state(struct extent_io_tree *tree,\n\t\t\t    u64 start, unsigned bits)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->end >= start && (state->state & bits))\n\t\t\treturn state;\n\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "*cached_state"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structextent_state",
            "rb_node"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&state->rb_node"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_state_in_tree",
          "args": [
            "state"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "extent_state_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "28-31",
          "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_first_extent_bit_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1442-1468",
    "snippet": "static struct extent_state *\nfind_first_extent_bit_state(struct extent_io_tree *tree,\n\t\t\t    u64 start, unsigned bits)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->end >= start && (state->state & bits))\n\t\t\treturn state;\n\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "start"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "340-344",
          "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic struct extent_state *\nfind_first_extent_bit_state(struct extent_io_tree *tree,\n\t\t\t    u64 start, unsigned bits)\n{\n\tstruct rb_node *node;\n\tstruct extent_state *state;\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\t\tif (state->end >= start && (state->state & bits))\n\t\t\treturn state;\n\n\t\tnode = rb_next(node);\n\t\tif (!node)\n\t\t\tbreak;\n\t}\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "set_range_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1422-1436",
    "snippet": "static int set_range_writeback(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(tree->mapping, index);\n\t\tBUG_ON(!page); /* Pages should be in the extent_io_tree */\n\t\tset_page_writeback(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "tree->mapping",
            "index"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int set_range_writeback(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(tree->mapping, index);\n\t\tBUG_ON(!page); /* Pages should be in the extent_io_tree */\n\t\tset_page_writeback(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "extent_range_redirty_for_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1402-1417",
    "snippet": "int extent_range_redirty_for_io(struct inode *inode, u64 start, u64 end)\n{\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(inode->i_mapping, index);\n\t\tBUG_ON(!page); /* Pages should be in the extent_io_tree */\n\t\t__set_page_dirty_nobuffers(page);\n\t\taccount_page_redirty(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "account_page_redirty",
          "args": [
            "page"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_range_redirty_for_io(struct inode *inode, u64 start, u64 end)\n{\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(inode->i_mapping, index);\n\t\tBUG_ON(!page); /* Pages should be in the extent_io_tree */\n\t\t__set_page_dirty_nobuffers(page);\n\t\taccount_page_redirty(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "extent_range_clear_dirty_for_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1386-1400",
    "snippet": "int extent_range_clear_dirty_for_io(struct inode *inode, u64 start, u64 end)\n{\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(inode->i_mapping, index);\n\t\tBUG_ON(!page); /* Pages should be in the extent_io_tree */\n\t\tclear_page_dirty_for_io(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_range_clear_dirty_for_io(struct inode *inode, u64 start, u64 end)\n{\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\n\twhile (index <= end_index) {\n\t\tpage = find_get_page(inode->i_mapping, index);\n\t\tBUG_ON(!page); /* Pages should be in the extent_io_tree */\n\t\tclear_page_dirty_for_io(page);\n\t\tpage_cache_release(page);\n\t\tindex++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "unlock_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1380-1384",
    "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_LOCKED",
            "1",
            "0",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
  },
  {
    "function_name": "unlock_extent_cached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1373-1378",
    "snippet": "int unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_LOCKED",
            "1",
            "0",
            "cached",
            "mask"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent_cached(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t struct extent_state **cached, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, cached,\n\t\t\t\tmask);\n}"
  },
  {
    "function_name": "try_lock_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1357-1371",
    "snippet": "int try_lock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\tint err;\n\tu64 failed_start;\n\n\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED, EXTENT_LOCKED,\n\t\t\t       &failed_start, NULL, GFP_NOFS);\n\tif (err == -EEXIST) {\n\t\tif (failed_start > start)\n\t\t\tclear_extent_bit(tree, start, failed_start - 1,\n\t\t\t\t\t EXTENT_LOCKED, 1, 0, NULL, GFP_NOFS);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "failed_start - 1",
            "EXTENT_LOCKED",
            "1",
            "0",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_LOCKED",
            "EXTENT_LOCKED",
            "&failed_start",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "__set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "834-1034",
          "snippet": "static int __must_check\n__set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t unsigned bits, unsigned exclusive_bits,\n\t\t u64 *failed_start, struct extent_state **cached_state,\n\t\t gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tbits |= EXTENT_FIRST_DELALLOC;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\tprealloc = alloc_extent_state(mask);\n\t\tBUG_ON(!prealloc);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = state->start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tmerge_state(tree, state);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tstate = next_state(state);\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tmerge_state(tree, state);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tstate = next_state(state);\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tmerge_state(tree, prealloc);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic int __must_check\n__set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t unsigned bits, unsigned exclusive_bits,\n\t\t u64 *failed_start, struct extent_state **cached_state,\n\t\t gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tbits |= EXTENT_FIRST_DELALLOC;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\tprealloc = alloc_extent_state(mask);\n\t\tBUG_ON(!prealloc);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = state->start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tmerge_state(tree, state);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tstate = next_state(state);\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tmerge_state(tree, state);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tstate = next_state(state);\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tmerge_state(tree, prealloc);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint try_lock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\tint err;\n\tu64 failed_start;\n\n\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED, EXTENT_LOCKED,\n\t\t\t       &failed_start, NULL, GFP_NOFS);\n\tif (err == -EEXIST) {\n\t\tif (failed_start > start)\n\t\t\tclear_extent_bit(tree, start, failed_start - 1,\n\t\t\t\t\t EXTENT_LOCKED, 1, 0, NULL, GFP_NOFS);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "lock_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1352-1355",
    "snippet": "int lock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn lock_extent_bits(tree, start, end, 0, NULL);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_extent_bits",
          "args": [
            "tree",
            "start",
            "end",
            "0",
            "NULL"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1332-1350",
          "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint lock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn lock_extent_bits(tree, start, end, 0, NULL);\n}"
  },
  {
    "function_name": "lock_extent_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1332-1350",
    "snippet": "int lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start > end"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_extent_bit",
          "args": [
            "tree",
            "failed_start",
            "end",
            "EXTENT_LOCKED"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "wait_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "744-788",
          "snippet": "static void wait_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t    unsigned long bits)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *node;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tspin_lock(&tree->lock);\nagain:\n\twhile (1) {\n\t\t/*\n\t\t * this search will find all the extents that end after\n\t\t * our range starts\n\t\t */\n\t\tnode = tree_search(tree, start);\nprocess_node:\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (state->start > end)\n\t\t\tgoto out;\n\n\t\tif (state->state & bits) {\n\t\t\tstart = state->start;\n\t\t\tatomic_inc(&state->refs);\n\t\t\twait_on_state(tree, state);\n\t\t\tfree_extent_state(state);\n\t\t\tgoto again;\n\t\t}\n\t\tstart = state->end + 1;\n\n\t\tif (start > end)\n\t\t\tbreak;\n\n\t\tif (!cond_resched_lock(&tree->lock)) {\n\t\t\tnode = rb_next(node);\n\t\t\tgoto process_node;\n\t\t}\n\t}\nout:\n\tspin_unlock(&tree->lock);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void wait_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t    unsigned long bits)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *node;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tspin_lock(&tree->lock);\nagain:\n\twhile (1) {\n\t\t/*\n\t\t * this search will find all the extents that end after\n\t\t * our range starts\n\t\t */\n\t\tnode = tree_search(tree, start);\nprocess_node:\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (state->start > end)\n\t\t\tgoto out;\n\n\t\tif (state->state & bits) {\n\t\t\tstart = state->start;\n\t\t\tatomic_inc(&state->refs);\n\t\t\twait_on_state(tree, state);\n\t\t\tfree_extent_state(state);\n\t\t\tgoto again;\n\t\t}\n\t\tstart = state->end + 1;\n\n\t\tif (start > end)\n\t\t\tbreak;\n\n\t\tif (!cond_resched_lock(&tree->lock)) {\n\t\t\tnode = rb_next(node);\n\t\t\tgoto process_node;\n\t\t}\n\t}\nout:\n\tspin_unlock(&tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_LOCKED | bits",
            "EXTENT_LOCKED",
            "&failed_start",
            "cached_state",
            "GFP_NOFS"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "__set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "834-1034",
          "snippet": "static int __must_check\n__set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t unsigned bits, unsigned exclusive_bits,\n\t\t u64 *failed_start, struct extent_state **cached_state,\n\t\t gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tbits |= EXTENT_FIRST_DELALLOC;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\tprealloc = alloc_extent_state(mask);\n\t\tBUG_ON(!prealloc);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = state->start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tmerge_state(tree, state);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tstate = next_state(state);\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tmerge_state(tree, state);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tstate = next_state(state);\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tmerge_state(tree, prealloc);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic int __must_check\n__set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t unsigned bits, unsigned exclusive_bits,\n\t\t u64 *failed_start, struct extent_state **cached_state,\n\t\t gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tbits |= EXTENT_FIRST_DELALLOC;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\tprealloc = alloc_extent_state(mask);\n\t\tBUG_ON(!prealloc);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = state->start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tmerge_state(tree, state);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tstate = next_state(state);\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tmerge_state(tree, state);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tstate = next_state(state);\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tmerge_state(tree, prealloc);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint lock_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, struct extent_state **cached_state)\n{\n\tint err;\n\tu64 failed_start;\n\n\twhile (1) {\n\t\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED | bits,\n\t\t\t\t       EXTENT_LOCKED, &failed_start,\n\t\t\t\t       cached_state, GFP_NOFS);\n\t\tif (err == -EEXIST) {\n\t\t\twait_extent_bit(tree, failed_start, end, EXTENT_LOCKED);\n\t\t\tstart = failed_start;\n\t\t} else\n\t\t\tbreak;\n\t\tWARN_ON(start > end);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "clear_extent_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1321-1326",
    "snippet": "int clear_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t  struct extent_state **cached_state, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_UPTODATE, 0, 0,\n\t\t\t\tcached_state, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_UPTODATE",
            "0",
            "0",
            "cached_state",
            "mask"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint clear_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t  struct extent_state **cached_state, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_UPTODATE, 0, 0,\n\t\t\t\tcached_state, mask);\n}"
  },
  {
    "function_name": "set_extent_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1314-1319",
    "snippet": "int set_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_UPTODATE, NULL,\n\t\t\t      cached_state, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_UPTODATE",
            "NULL",
            "cached_state",
            "mask"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1036-1042",
          "snippet": "int set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_uptodate(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_UPTODATE, NULL,\n\t\t\t      cached_state, mask);\n}"
  },
  {
    "function_name": "set_extent_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1307-1312",
    "snippet": "int set_extent_new(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_NEW, NULL,\n\t\t\t      NULL, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_NEW",
            "NULL",
            "NULL",
            "mask"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1036-1042",
          "snippet": "int set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_new(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_NEW, NULL,\n\t\t\t      NULL, mask);\n}"
  },
  {
    "function_name": "clear_extent_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1299-1305",
    "snippet": "int clear_extent_dirty(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t       gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end,\n\t\t\t\tEXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\tEXTENT_DO_ACCOUNTING, 0, 0, NULL, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\tEXTENT_DO_ACCOUNTING",
            "0",
            "0",
            "NULL",
            "mask"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint clear_extent_dirty(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t       gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end,\n\t\t\t\tEXTENT_DIRTY | EXTENT_DELALLOC |\n\t\t\t\tEXTENT_DO_ACCOUNTING, 0, 0, NULL, mask);\n}"
  },
  {
    "function_name": "set_extent_defrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1291-1297",
    "snippet": "int set_extent_defrag(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      struct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end,\n\t\t\t      EXTENT_DELALLOC | EXTENT_UPTODATE | EXTENT_DEFRAG,\n\t\t\t      NULL, cached_state, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_DELALLOC | EXTENT_UPTODATE | EXTENT_DEFRAG",
            "NULL",
            "cached_state",
            "mask"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1036-1042",
          "snippet": "int set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_defrag(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      struct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end,\n\t\t\t      EXTENT_DELALLOC | EXTENT_UPTODATE | EXTENT_DEFRAG,\n\t\t\t      NULL, cached_state, mask);\n}"
  },
  {
    "function_name": "set_extent_delalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1283-1289",
    "snippet": "int set_extent_delalloc(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end,\n\t\t\t      EXTENT_DELALLOC | EXTENT_UPTODATE,\n\t\t\t      NULL, cached_state, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_DELALLOC | EXTENT_UPTODATE",
            "NULL",
            "cached_state",
            "mask"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1036-1042",
          "snippet": "int set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_delalloc(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end,\n\t\t\t      EXTENT_DELALLOC | EXTENT_UPTODATE,\n\t\t\t      NULL, cached_state, mask);\n}"
  },
  {
    "function_name": "clear_extent_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1277-1281",
    "snippet": "int clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "bits",
            "0",
            "0",
            "NULL",
            "mask"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "572-724",
          "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}"
  },
  {
    "function_name": "set_extent_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1270-1275",
    "snippet": "int set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "bits",
            "NULL",
            "NULL",
            "mask"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1036-1042",
          "snippet": "int set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}"
  },
  {
    "function_name": "set_extent_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1263-1268",
    "snippet": "int set_extent_dirty(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_DIRTY, NULL,\n\t\t\t      NULL, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "EXTENT_DIRTY",
            "NULL",
            "NULL",
            "mask"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1036-1042",
          "snippet": "int set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_dirty(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, EXTENT_DIRTY, NULL,\n\t\t\t      NULL, mask);\n}"
  },
  {
    "function_name": "convert_extent_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1062-1260",
    "snippet": "int convert_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t       unsigned bits, unsigned clear_bits,\n\t\t       struct extent_state **cached_state, gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\tbool first_iteration = true;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Best effort, don't worry if extent state allocation fails\n\t\t * here for the first iteration. We might have a cached state\n\t\t * that matches exactly the target range, in which case no\n\t\t * extent state allocations are needed. We'll only know this\n\t\t * after locking the tree.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t\tif (!prealloc && !first_iteration)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tstate = clear_state_bit(tree, state, &clear_bits, 0);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tstate = clear_state_bit(tree, state, &clear_bits, 0);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tclear_state_bit(tree, prealloc, &clear_bits, 0);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tfirst_iteration = false;\n\tgoto again;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "prealloc"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_state_bit",
          "args": [
            "tree",
            "prealloc",
            "&clear_bits",
            "0"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "clear_state_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "512-542",
          "snippet": "static struct extent_state *clear_state_bit(struct extent_io_tree *tree,\n\t\t\t\t\t    struct extent_state *state,\n\t\t\t\t\t    unsigned *bits, int wake)\n{\n\tstruct extent_state *next;\n\tunsigned bits_to_clear = *bits & ~EXTENT_CTLBITS;\n\n\tif ((bits_to_clear & EXTENT_DIRTY) && (state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\tWARN_ON(range > tree->dirty_bytes);\n\t\ttree->dirty_bytes -= range;\n\t}\n\tclear_state_cb(tree, state, bits);\n\tstate->state &= ~bits_to_clear;\n\tif (wake)\n\t\twake_up(&state->wq);\n\tif (state->state == 0) {\n\t\tnext = next_state(state);\n\t\tif (extent_state_in_tree(state)) {\n\t\t\trb_erase(&state->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t\tfree_extent_state(state);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t}\n\t} else {\n\t\tmerge_state(tree, state);\n\t\tnext = next_state(state);\n\t}\n\treturn next;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic struct extent_state *clear_state_bit(struct extent_io_tree *tree,\n\t\t\t\t\t    struct extent_state *state,\n\t\t\t\t\t    unsigned *bits, int wake)\n{\n\tstruct extent_state *next;\n\tunsigned bits_to_clear = *bits & ~EXTENT_CTLBITS;\n\n\tif ((bits_to_clear & EXTENT_DIRTY) && (state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\tWARN_ON(range > tree->dirty_bytes);\n\t\ttree->dirty_bytes -= range;\n\t}\n\tclear_state_cb(tree, state, bits);\n\tstate->state &= ~bits_to_clear;\n\tif (wake)\n\t\twake_up(&state->wq);\n\tif (state->state == 0) {\n\t\tnext = next_state(state);\n\t\tif (extent_state_in_tree(state)) {\n\t\t\trb_erase(&state->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t\tfree_extent_state(state);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t}\n\t} else {\n\t\tmerge_state(tree, state);\n\t\tnext = next_state(state);\n\t}\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_state",
          "args": [
            "prealloc",
            "cached_state"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "cache_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "816-821",
          "snippet": "static void cache_state(struct extent_state *state,\n\t\t\tstruct extent_state **cached_ptr)\n{\n\treturn cache_state_if_flags(state, cached_ptr,\n\t\t\t\t    EXTENT_IOBITS | EXTENT_BOUNDARY);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void cache_state(struct extent_state *state,\n\t\t\tstruct extent_state **cached_ptr)\n{\n\treturn cache_state_if_flags(state, cached_ptr,\n\t\t\t\t    EXTENT_IOBITS | EXTENT_BOUNDARY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_state_bits",
          "args": [
            "tree",
            "prealloc",
            "&bits"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "set_state_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "790-802",
          "snippet": "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state,\n\t\t\t   unsigned *bits)\n{\n\tunsigned bits_to_set = *bits & ~EXTENT_CTLBITS;\n\n\tset_state_cb(tree, state, bits);\n\tif ((bits_to_set & EXTENT_DIRTY) && !(state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\ttree->dirty_bytes += range;\n\t}\n\tstate->state |= bits_to_set;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state,\n\t\t\t   unsigned *bits)\n{\n\tunsigned bits_to_set = *bits & ~EXTENT_CTLBITS;\n\n\tset_state_cb(tree, state, bits);\n\tif ((bits_to_set & EXTENT_DIRTY) && !(state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\ttree->dirty_bytes += range;\n\t}\n\tstate->state |= bits_to_set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_io_tree_panic",
          "args": [
            "tree",
            "err"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_state",
          "args": [
            "tree",
            "state",
            "prealloc",
            "end + 1"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "split_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "475-494",
          "snippet": "static int split_state(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t       struct extent_state *prealloc, u64 split)\n{\n\tstruct rb_node *node;\n\n\tsplit_cb(tree, orig, split);\n\n\tprealloc->start = orig->start;\n\tprealloc->end = split - 1;\n\tprealloc->state = orig->state;\n\torig->start = split;\n\n\tnode = tree_insert(&tree->state, &orig->rb_node, prealloc->end,\n\t\t\t   &prealloc->rb_node, NULL, NULL);\n\tif (node) {\n\t\tfree_extent_state(prealloc);\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int split_state(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t       struct extent_state *prealloc, u64 split)\n{\n\tstruct rb_node *node;\n\n\tsplit_cb(tree, orig, split);\n\n\tprealloc->start = orig->start;\n\tprealloc->end = split - 1;\n\tprealloc->state = orig->state;\n\torig->start = split;\n\n\tnode = tree_insert(&tree->state, &orig->rb_node, prealloc->end,\n\t\t\t   &prealloc->rb_node, NULL, NULL);\n\tif (node) {\n\t\tfree_extent_state(prealloc);\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_extent_state_atomic",
          "args": [
            "prealloc"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_state_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "544-551",
          "snippet": "static struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_state",
          "args": [
            "tree",
            "prealloc",
            "start",
            "this_end",
            "NULL",
            "NULL",
            "&bits"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "insert_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "425-452",
          "snippet": "static int insert_state(struct extent_io_tree *tree,\n\t\t\tstruct extent_state *state, u64 start, u64 end,\n\t\t\tstruct rb_node ***p,\n\t\t\tstruct rb_node **parent,\n\t\t\tunsigned *bits)\n{\n\tstruct rb_node *node;\n\n\tif (end < start)\n\t\tWARN(1, KERN_ERR \"BTRFS: end < start %llu %llu\\n\",\n\t\t       end, start);\n\tstate->start = start;\n\tstate->end = end;\n\n\tset_state_bits(tree, state, bits);\n\n\tnode = tree_insert(&tree->state, NULL, end, &state->rb_node, p, parent);\n\tif (node) {\n\t\tstruct extent_state *found;\n\t\tfound = rb_entry(node, struct extent_state, rb_node);\n\t\tprintk(KERN_ERR \"BTRFS: found node %llu %llu on insert of \"\n\t\t       \"%llu %llu\\n\",\n\t\t       found->start, found->end, start, end);\n\t\treturn -EEXIST;\n\t}\n\tmerge_state(tree, state);\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic int insert_state(struct extent_io_tree *tree,\n\t\t\tstruct extent_state *state, u64 start, u64 end,\n\t\t\tstruct rb_node ***p,\n\t\t\tstruct rb_node **parent,\n\t\t\tunsigned *bits)\n{\n\tstruct rb_node *node;\n\n\tif (end < start)\n\t\tWARN(1, KERN_ERR \"BTRFS: end < start %llu %llu\\n\",\n\t\t       end, start);\n\tstate->start = start;\n\tstate->end = end;\n\n\tset_state_bits(tree, state, bits);\n\n\tnode = tree_insert(&tree->state, NULL, end, &state->rb_node, p, parent);\n\tif (node) {\n\t\tstruct extent_state *found;\n\t\tfound = rb_entry(node, struct extent_state, rb_node);\n\t\tprintk(KERN_ERR \"BTRFS: found node %llu %llu on insert of \"\n\t\t       \"%llu %llu\\n\",\n\t\t       found->start, found->end, start, end);\n\t\treturn -EEXIST;\n\t}\n\tmerge_state(tree, state);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_for_insert",
          "args": [
            "tree",
            "start",
            "&p",
            "&parent"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "325-338",
          "snippet": "static inline struct rb_node *\ntree_search_for_insert(struct extent_io_tree *tree,\n\t\t       u64 offset,\n\t\t       struct rb_node ***p_ret,\n\t\t       struct rb_node **parent_ret)\n{\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\n\tret = __etree_search(tree, offset, &prev, NULL, p_ret, parent_ret);\n\tif (!ret)\n\t\treturn prev;\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *\ntree_search_for_insert(struct extent_io_tree *tree,\n\t\t       u64 offset,\n\t\t       struct rb_node ***p_ret,\n\t\t       struct rb_node **parent_ret)\n{\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\n\tret = __etree_search(tree, offset, &prev, NULL, p_ret, parent_ret);\n\tif (!ret)\n\t\treturn prev;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_state_in_tree",
          "args": [
            "state"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "extent_state_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "28-31",
          "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_debug_check_extent_io_range",
          "args": [
            "tree",
            "start",
            "end"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint convert_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t       unsigned bits, unsigned clear_bits,\n\t\t       struct extent_state **cached_state, gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\tbool first_iteration = true;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Best effort, don't worry if extent state allocation fails\n\t\t * here for the first iteration. We might have a cached state\n\t\t * that matches exactly the target range, in which case no\n\t\t * extent state allocations are needed. We'll only know this\n\t\t * after locking the tree.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t\tif (!prealloc && !first_iteration)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tstate = clear_state_bit(tree, state, &clear_bits, 0);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tstate = clear_state_bit(tree, state, &clear_bits, 0);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tif (!prealloc) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tclear_state_bit(tree, prealloc, &clear_bits, 0);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tfirst_iteration = false;\n\tgoto again;\n}"
  },
  {
    "function_name": "set_extent_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "1036-1042",
    "snippet": "int set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_extent_bit",
          "args": [
            "tree",
            "start",
            "end",
            "bits",
            "0",
            "failed_start",
            "cached_state",
            "mask"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "__set_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "834-1034",
          "snippet": "static int __must_check\n__set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t unsigned bits, unsigned exclusive_bits,\n\t\t u64 *failed_start, struct extent_state **cached_state,\n\t\t gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tbits |= EXTENT_FIRST_DELALLOC;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\tprealloc = alloc_extent_state(mask);\n\t\tBUG_ON(!prealloc);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = state->start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tmerge_state(tree, state);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tstate = next_state(state);\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tmerge_state(tree, state);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tstate = next_state(state);\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tmerge_state(tree, prealloc);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic int __must_check\n__set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t unsigned bits, unsigned exclusive_bits,\n\t\t u64 *failed_start, struct extent_state **cached_state,\n\t\t gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tbits |= EXTENT_FIRST_DELALLOC;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\tprealloc = alloc_extent_state(mask);\n\t\tBUG_ON(!prealloc);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = state->start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tmerge_state(tree, state);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tstate = next_state(state);\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tmerge_state(tree, state);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tstate = next_state(state);\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tmerge_state(tree, prealloc);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, u64 * failed_start,\n\t\t   struct extent_state **cached_state, gfp_t mask)\n{\n\treturn __set_extent_bit(tree, start, end, bits, 0, failed_start,\n\t\t\t\tcached_state, mask);\n}"
  },
  {
    "function_name": "__set_extent_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "834-1034",
    "snippet": "static int __must_check\n__set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t unsigned bits, unsigned exclusive_bits,\n\t\t u64 *failed_start, struct extent_state **cached_state,\n\t\t gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tbits |= EXTENT_FIRST_DELALLOC;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\tprealloc = alloc_extent_state(mask);\n\t\tBUG_ON(!prealloc);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = state->start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tmerge_state(tree, state);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tstate = next_state(state);\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tmerge_state(tree, state);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tstate = next_state(state);\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tmerge_state(tree, prealloc);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "prealloc"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_state",
          "args": [
            "tree",
            "prealloc"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "merge_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "363-396",
          "snippet": "static void merge_state(struct extent_io_tree *tree,\n\t\t        struct extent_state *state)\n{\n\tstruct extent_state *other;\n\tstruct rb_node *other_node;\n\n\tif (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\treturn;\n\n\tother_node = rb_prev(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->end == state->start - 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->start = other->start;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n\tother_node = rb_next(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->start == state->end + 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->end = other->end;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void merge_state(struct extent_io_tree *tree,\n\t\t        struct extent_state *state)\n{\n\tstruct extent_state *other;\n\tstruct rb_node *other_node;\n\n\tif (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\treturn;\n\n\tother_node = rb_prev(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->end == state->start - 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->start = other->start;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n\tother_node = rb_next(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->start == state->end + 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->end = other->end;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_state",
          "args": [
            "prealloc",
            "cached_state"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "cache_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "816-821",
          "snippet": "static void cache_state(struct extent_state *state,\n\t\t\tstruct extent_state **cached_ptr)\n{\n\treturn cache_state_if_flags(state, cached_ptr,\n\t\t\t\t    EXTENT_IOBITS | EXTENT_BOUNDARY);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void cache_state(struct extent_state *state,\n\t\t\tstruct extent_state **cached_ptr)\n{\n\treturn cache_state_if_flags(state, cached_ptr,\n\t\t\t\t    EXTENT_IOBITS | EXTENT_BOUNDARY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_state_bits",
          "args": [
            "tree",
            "prealloc",
            "&bits"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "set_state_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "790-802",
          "snippet": "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state,\n\t\t\t   unsigned *bits)\n{\n\tunsigned bits_to_set = *bits & ~EXTENT_CTLBITS;\n\n\tset_state_cb(tree, state, bits);\n\tif ((bits_to_set & EXTENT_DIRTY) && !(state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\ttree->dirty_bytes += range;\n\t}\n\tstate->state |= bits_to_set;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state,\n\t\t\t   unsigned *bits)\n{\n\tunsigned bits_to_set = *bits & ~EXTENT_CTLBITS;\n\n\tset_state_cb(tree, state, bits);\n\tif ((bits_to_set & EXTENT_DIRTY) && !(state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\ttree->dirty_bytes += range;\n\t}\n\tstate->state |= bits_to_set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_io_tree_panic",
          "args": [
            "tree",
            "err"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_state",
          "args": [
            "tree",
            "state",
            "prealloc",
            "end + 1"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "split_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "475-494",
          "snippet": "static int split_state(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t       struct extent_state *prealloc, u64 split)\n{\n\tstruct rb_node *node;\n\n\tsplit_cb(tree, orig, split);\n\n\tprealloc->start = orig->start;\n\tprealloc->end = split - 1;\n\tprealloc->state = orig->state;\n\torig->start = split;\n\n\tnode = tree_insert(&tree->state, &orig->rb_node, prealloc->end,\n\t\t\t   &prealloc->rb_node, NULL, NULL);\n\tif (node) {\n\t\tfree_extent_state(prealloc);\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int split_state(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t       struct extent_state *prealloc, u64 split)\n{\n\tstruct rb_node *node;\n\n\tsplit_cb(tree, orig, split);\n\n\tprealloc->start = orig->start;\n\tprealloc->end = split - 1;\n\tprealloc->state = orig->state;\n\torig->start = split;\n\n\tnode = tree_insert(&tree->state, &orig->rb_node, prealloc->end,\n\t\t\t   &prealloc->rb_node, NULL, NULL);\n\tif (node) {\n\t\tfree_extent_state(prealloc);\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!prealloc"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_extent_state_atomic",
          "args": [
            "prealloc"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_state_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "544-551",
          "snippet": "static struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_state",
          "args": [
            "tree",
            "prealloc",
            "start",
            "this_end",
            "NULL",
            "NULL",
            "&bits"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "insert_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "425-452",
          "snippet": "static int insert_state(struct extent_io_tree *tree,\n\t\t\tstruct extent_state *state, u64 start, u64 end,\n\t\t\tstruct rb_node ***p,\n\t\t\tstruct rb_node **parent,\n\t\t\tunsigned *bits)\n{\n\tstruct rb_node *node;\n\n\tif (end < start)\n\t\tWARN(1, KERN_ERR \"BTRFS: end < start %llu %llu\\n\",\n\t\t       end, start);\n\tstate->start = start;\n\tstate->end = end;\n\n\tset_state_bits(tree, state, bits);\n\n\tnode = tree_insert(&tree->state, NULL, end, &state->rb_node, p, parent);\n\tif (node) {\n\t\tstruct extent_state *found;\n\t\tfound = rb_entry(node, struct extent_state, rb_node);\n\t\tprintk(KERN_ERR \"BTRFS: found node %llu %llu on insert of \"\n\t\t       \"%llu %llu\\n\",\n\t\t       found->start, found->end, start, end);\n\t\treturn -EEXIST;\n\t}\n\tmerge_state(tree, state);\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic int insert_state(struct extent_io_tree *tree,\n\t\t\tstruct extent_state *state, u64 start, u64 end,\n\t\t\tstruct rb_node ***p,\n\t\t\tstruct rb_node **parent,\n\t\t\tunsigned *bits)\n{\n\tstruct rb_node *node;\n\n\tif (end < start)\n\t\tWARN(1, KERN_ERR \"BTRFS: end < start %llu %llu\\n\",\n\t\t       end, start);\n\tstate->start = start;\n\tstate->end = end;\n\n\tset_state_bits(tree, state, bits);\n\n\tnode = tree_insert(&tree->state, NULL, end, &state->rb_node, p, parent);\n\tif (node) {\n\t\tstruct extent_state *found;\n\t\tfound = rb_entry(node, struct extent_state, rb_node);\n\t\tprintk(KERN_ERR \"BTRFS: found node %llu %llu on insert of \"\n\t\t       \"%llu %llu\\n\",\n\t\t       found->start, found->end, start, end);\n\t\treturn -EEXIST;\n\t}\n\tmerge_state(tree, state);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!prealloc"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_state",
          "args": [
            "state"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "next_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "496-503",
          "snippet": "static struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!prealloc"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!prealloc"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search_for_insert",
          "args": [
            "tree",
            "start",
            "&p",
            "&parent"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "325-338",
          "snippet": "static inline struct rb_node *\ntree_search_for_insert(struct extent_io_tree *tree,\n\t\t       u64 offset,\n\t\t       struct rb_node ***p_ret,\n\t\t       struct rb_node **parent_ret)\n{\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\n\tret = __etree_search(tree, offset, &prev, NULL, p_ret, parent_ret);\n\tif (!ret)\n\t\treturn prev;\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *\ntree_search_for_insert(struct extent_io_tree *tree,\n\t\t       u64 offset,\n\t\t       struct rb_node ***p_ret,\n\t\t       struct rb_node **parent_ret)\n{\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\n\tret = __etree_search(tree, offset, &prev, NULL, p_ret, parent_ret);\n\tif (!ret)\n\t\treturn prev;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_state_in_tree",
          "args": [
            "state"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "extent_state_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "28-31",
          "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!prealloc"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_debug_check_extent_io_range",
          "args": [
            "tree",
            "start",
            "end"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic int __must_check\n__set_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t unsigned bits, unsigned exclusive_bits,\n\t\t u64 *failed_start, struct extent_state **cached_state,\n\t\t gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tstruct rb_node **p;\n\tstruct rb_node *parent;\n\tint err = 0;\n\tu64 last_start;\n\tu64 last_end;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tbits |= EXTENT_FIRST_DELALLOC;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\tprealloc = alloc_extent_state(mask);\n\t\tBUG_ON(!prealloc);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->start <= start && state->end > start &&\n\t\t    extent_state_in_tree(state)) {\n\t\t\tnode = &state->rb_node;\n\t\t\tgoto hit_next;\n\t\t}\n\t}\n\t/*\n\t * this search will find all the extents that end after\n\t * our range starts.\n\t */\n\tnode = tree_search_for_insert(tree, start, &p, &parent);\n\tif (!node) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = insert_state(tree, prealloc, start, end,\n\t\t\t\t   &p, &parent, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tlast_start = state->start;\n\tlast_end = state->end;\n\n\t/*\n\t * | ---- desired range ---- |\n\t * | state |\n\t *\n\t * Just lock what we found and keep going\n\t */\n\tif (state->start == start && state->end <= end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = state->start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_state_bits(tree, state, &bits);\n\t\tcache_state(state, cached_state);\n\t\tmerge_state(tree, state);\n\t\tif (last_end == (u64)-1)\n\t\t\tgoto out;\n\t\tstart = last_end + 1;\n\t\tstate = next_state(state);\n\t\tif (start < end && state && state->start == start &&\n\t\t    !need_resched())\n\t\t\tgoto hit_next;\n\t\tgoto search_again;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t * | state |\n\t *   or\n\t * | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip bits on\n\t * second half.\n\t *\n\t * If the extent we found extends past our\n\t * range, we just split and search again.  It'll get split\n\t * again the next time though.\n\t *\n\t * If the extent we found is inside our range, we set the\n\t * desired bit on it.\n\t */\n\tif (state->start < start) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tset_state_bits(tree, state, &bits);\n\t\t\tcache_state(state, cached_state);\n\t\t\tmerge_state(tree, state);\n\t\t\tif (last_end == (u64)-1)\n\t\t\t\tgoto out;\n\t\t\tstart = last_end + 1;\n\t\t\tstate = next_state(state);\n\t\t\tif (start < end && state && state->start == start &&\n\t\t\t    !need_resched())\n\t\t\t\tgoto hit_next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *     | state | or               | state |\n\t *\n\t * There's a hole, we need to insert something in it and\n\t * ignore the extent we found.\n\t */\n\tif (state->start > start) {\n\t\tu64 this_end;\n\t\tif (end < last_start)\n\t\t\tthis_end = end;\n\t\telse\n\t\t\tthis_end = last_start - 1;\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\n\t\t/*\n\t\t * Avoid to free 'prealloc' if it can be merged with\n\t\t * the later extent.\n\t\t */\n\t\terr = insert_state(tree, prealloc, start, this_end,\n\t\t\t\t   NULL, NULL, &bits);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tcache_state(prealloc, cached_state);\n\t\tprealloc = NULL;\n\t\tstart = this_end + 1;\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and set the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tif (state->state & exclusive_bits) {\n\t\t\t*failed_start = start;\n\t\t\terr = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tset_state_bits(tree, prealloc, &bits);\n\t\tcache_state(prealloc, cached_state);\n\t\tmerge_state(tree, prealloc);\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn err;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
  },
  {
    "function_name": "cache_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "816-821",
    "snippet": "static void cache_state(struct extent_state *state,\n\t\t\tstruct extent_state **cached_ptr)\n{\n\treturn cache_state_if_flags(state, cached_ptr,\n\t\t\t\t    EXTENT_IOBITS | EXTENT_BOUNDARY);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_state_if_flags",
          "args": [
            "state",
            "cached_ptr",
            "EXTENT_IOBITS | EXTENT_BOUNDARY"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "cache_state_if_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "804-814",
          "snippet": "static void cache_state_if_flags(struct extent_state *state,\n\t\t\t\t struct extent_state **cached_ptr,\n\t\t\t\t unsigned flags)\n{\n\tif (cached_ptr && !(*cached_ptr)) {\n\t\tif (!flags || (state->state & flags)) {\n\t\t\t*cached_ptr = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void cache_state_if_flags(struct extent_state *state,\n\t\t\t\t struct extent_state **cached_ptr,\n\t\t\t\t unsigned flags)\n{\n\tif (cached_ptr && !(*cached_ptr)) {\n\t\tif (!flags || (state->state & flags)) {\n\t\t\t*cached_ptr = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void cache_state(struct extent_state *state,\n\t\t\tstruct extent_state **cached_ptr)\n{\n\treturn cache_state_if_flags(state, cached_ptr,\n\t\t\t\t    EXTENT_IOBITS | EXTENT_BOUNDARY);\n}"
  },
  {
    "function_name": "cache_state_if_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "804-814",
    "snippet": "static void cache_state_if_flags(struct extent_state *state,\n\t\t\t\t struct extent_state **cached_ptr,\n\t\t\t\t unsigned flags)\n{\n\tif (cached_ptr && !(*cached_ptr)) {\n\t\tif (!flags || (state->state & flags)) {\n\t\t\t*cached_ptr = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&state->refs"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void cache_state_if_flags(struct extent_state *state,\n\t\t\t\t struct extent_state **cached_ptr,\n\t\t\t\t unsigned flags)\n{\n\tif (cached_ptr && !(*cached_ptr)) {\n\t\tif (!flags || (state->state & flags)) {\n\t\t\t*cached_ptr = state;\n\t\t\tatomic_inc(&state->refs);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "set_state_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "790-802",
    "snippet": "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state,\n\t\t\t   unsigned *bits)\n{\n\tunsigned bits_to_set = *bits & ~EXTENT_CTLBITS;\n\n\tset_state_cb(tree, state, bits);\n\tif ((bits_to_set & EXTENT_DIRTY) && !(state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\ttree->dirty_bytes += range;\n\t}\n\tstate->state |= bits_to_set;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_state_cb",
          "args": [
            "tree",
            "state",
            "bits"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "set_state_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "398-403",
          "snippet": "static void set_state_cb(struct extent_io_tree *tree,\n\t\t\t struct extent_state *state, unsigned *bits)\n{\n\tif (tree->ops && tree->ops->set_bit_hook)\n\t\ttree->ops->set_bit_hook(tree->mapping->host, state, bits);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void set_state_cb(struct extent_io_tree *tree,\n\t\t\t struct extent_state *state, unsigned *bits)\n{\n\tif (tree->ops && tree->ops->set_bit_hook)\n\t\ttree->ops->set_bit_hook(tree->mapping->host, state, bits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state,\n\t\t\t   unsigned *bits)\n{\n\tunsigned bits_to_set = *bits & ~EXTENT_CTLBITS;\n\n\tset_state_cb(tree, state, bits);\n\tif ((bits_to_set & EXTENT_DIRTY) && !(state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\ttree->dirty_bytes += range;\n\t}\n\tstate->state |= bits_to_set;\n}"
  },
  {
    "function_name": "wait_extent_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "744-788",
    "snippet": "static void wait_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t    unsigned long bits)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *node;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tspin_lock(&tree->lock);\nagain:\n\twhile (1) {\n\t\t/*\n\t\t * this search will find all the extents that end after\n\t\t * our range starts\n\t\t */\n\t\tnode = tree_search(tree, start);\nprocess_node:\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (state->start > end)\n\t\t\tgoto out;\n\n\t\tif (state->state & bits) {\n\t\t\tstart = state->start;\n\t\t\tatomic_inc(&state->refs);\n\t\t\twait_on_state(tree, state);\n\t\t\tfree_extent_state(state);\n\t\t\tgoto again;\n\t\t}\n\t\tstart = state->end + 1;\n\n\t\tif (start > end)\n\t\t\tbreak;\n\n\t\tif (!cond_resched_lock(&tree->lock)) {\n\t\t\tnode = rb_next(node);\n\t\t\tgoto process_node;\n\t\t}\n\t}\nout:\n\tspin_unlock(&tree->lock);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "state"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_state",
          "args": [
            "tree",
            "state"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "wait_on_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "726-737",
          "snippet": "static void wait_on_state(struct extent_io_tree *tree,\n\t\t\t  struct extent_state *state)\n\t\t__releases(tree->lock)\n\t\t__acquires(tree->lock)\n{\n\tDEFINE_WAIT(wait);\n\tprepare_to_wait(&state->wq, &wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&tree->lock);\n\tschedule();\n\tspin_lock(&tree->lock);\n\tfinish_wait(&state->wq, &wait);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void wait_on_state(struct extent_io_tree *tree,\n\t\t\t  struct extent_state *state)\n\t\t__releases(tree->lock)\n\t\t__acquires(tree->lock)\n{\n\tDEFINE_WAIT(wait);\n\tprepare_to_wait(&state->wq, &wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&tree->lock);\n\tschedule();\n\tspin_lock(&tree->lock);\n\tfinish_wait(&state->wq, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&state->refs"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "start"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "340-344",
          "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_debug_check_extent_io_range",
          "args": [
            "tree",
            "start",
            "end"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void wait_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\t    unsigned long bits)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *node;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tspin_lock(&tree->lock);\nagain:\n\twhile (1) {\n\t\t/*\n\t\t * this search will find all the extents that end after\n\t\t * our range starts\n\t\t */\n\t\tnode = tree_search(tree, start);\nprocess_node:\n\t\tif (!node)\n\t\t\tbreak;\n\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (state->start > end)\n\t\t\tgoto out;\n\n\t\tif (state->state & bits) {\n\t\t\tstart = state->start;\n\t\t\tatomic_inc(&state->refs);\n\t\t\twait_on_state(tree, state);\n\t\t\tfree_extent_state(state);\n\t\t\tgoto again;\n\t\t}\n\t\tstart = state->end + 1;\n\n\t\tif (start > end)\n\t\t\tbreak;\n\n\t\tif (!cond_resched_lock(&tree->lock)) {\n\t\t\tnode = rb_next(node);\n\t\t\tgoto process_node;\n\t\t}\n\t}\nout:\n\tspin_unlock(&tree->lock);\n}"
  },
  {
    "function_name": "wait_on_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "726-737",
    "snippet": "static void wait_on_state(struct extent_io_tree *tree,\n\t\t\t  struct extent_state *state)\n\t\t__releases(tree->lock)\n\t\t__acquires(tree->lock)\n{\n\tDEFINE_WAIT(wait);\n\tprepare_to_wait(&state->wq, &wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&tree->lock);\n\tschedule();\n\tspin_lock(&tree->lock);\n\tfinish_wait(&state->wq, &wait);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&state->wq",
            "&wait"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&state->wq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "tree->lock"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "tree->lock"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void wait_on_state(struct extent_io_tree *tree,\n\t\t\t  struct extent_state *state)\n\t\t__releases(tree->lock)\n\t\t__acquires(tree->lock)\n{\n\tDEFINE_WAIT(wait);\n\tprepare_to_wait(&state->wq, &wait, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&tree->lock);\n\tschedule();\n\tspin_lock(&tree->lock);\n\tfinish_wait(&state->wq, &wait);\n}"
  },
  {
    "function_name": "clear_extent_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "572-724",
    "snippet": "int clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->lock"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "prealloc"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_state_bit",
          "args": [
            "tree",
            "state",
            "&bits",
            "wake"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "clear_state_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "512-542",
          "snippet": "static struct extent_state *clear_state_bit(struct extent_io_tree *tree,\n\t\t\t\t\t    struct extent_state *state,\n\t\t\t\t\t    unsigned *bits, int wake)\n{\n\tstruct extent_state *next;\n\tunsigned bits_to_clear = *bits & ~EXTENT_CTLBITS;\n\n\tif ((bits_to_clear & EXTENT_DIRTY) && (state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\tWARN_ON(range > tree->dirty_bytes);\n\t\ttree->dirty_bytes -= range;\n\t}\n\tclear_state_cb(tree, state, bits);\n\tstate->state &= ~bits_to_clear;\n\tif (wake)\n\t\twake_up(&state->wq);\n\tif (state->state == 0) {\n\t\tnext = next_state(state);\n\t\tif (extent_state_in_tree(state)) {\n\t\t\trb_erase(&state->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t\tfree_extent_state(state);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t}\n\t} else {\n\t\tmerge_state(tree, state);\n\t\tnext = next_state(state);\n\t}\n\treturn next;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic struct extent_state *clear_state_bit(struct extent_io_tree *tree,\n\t\t\t\t\t    struct extent_state *state,\n\t\t\t\t\t    unsigned *bits, int wake)\n{\n\tstruct extent_state *next;\n\tunsigned bits_to_clear = *bits & ~EXTENT_CTLBITS;\n\n\tif ((bits_to_clear & EXTENT_DIRTY) && (state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\tWARN_ON(range > tree->dirty_bytes);\n\t\ttree->dirty_bytes -= range;\n\t}\n\tclear_state_cb(tree, state, bits);\n\tstate->state &= ~bits_to_clear;\n\tif (wake)\n\t\twake_up(&state->wq);\n\tif (state->state == 0) {\n\t\tnext = next_state(state);\n\t\tif (extent_state_in_tree(state)) {\n\t\t\trb_erase(&state->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t\tfree_extent_state(state);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t}\n\t} else {\n\t\tmerge_state(tree, state);\n\t\tnext = next_state(state);\n\t}\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&state->wq"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_io_tree_panic",
          "args": [
            "tree",
            "err"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_state",
          "args": [
            "tree",
            "state",
            "prealloc",
            "end + 1"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "split_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "475-494",
          "snippet": "static int split_state(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t       struct extent_state *prealloc, u64 split)\n{\n\tstruct rb_node *node;\n\n\tsplit_cb(tree, orig, split);\n\n\tprealloc->start = orig->start;\n\tprealloc->end = split - 1;\n\tprealloc->state = orig->state;\n\torig->start = split;\n\n\tnode = tree_insert(&tree->state, &orig->rb_node, prealloc->end,\n\t\t\t   &prealloc->rb_node, NULL, NULL);\n\tif (node) {\n\t\tfree_extent_state(prealloc);\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int split_state(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t       struct extent_state *prealloc, u64 split)\n{\n\tstruct rb_node *node;\n\n\tsplit_cb(tree, orig, split);\n\n\tprealloc->start = orig->start;\n\tprealloc->end = split - 1;\n\tprealloc->state = orig->state;\n\torig->start = split;\n\n\tnode = tree_insert(&tree->state, &orig->rb_node, prealloc->end,\n\t\t\t   &prealloc->rb_node, NULL, NULL);\n\tif (node) {\n\t\tfree_extent_state(prealloc);\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!prealloc"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_extent_state_atomic",
          "args": [
            "prealloc"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_state_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "544-551",
          "snippet": "static struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!prealloc"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_state",
          "args": [
            "state"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "next_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "496-503",
          "snippet": "static struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "state->end < start"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "tree",
            "start"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "340-344",
          "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cached->refs"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_state_in_tree",
          "args": [
            "cached"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "extent_state_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "28-31",
          "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->lock"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_debug_check_extent_io_range",
          "args": [
            "tree",
            "start",
            "end"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t     unsigned bits, int wake, int delete,\n\t\t     struct extent_state **cached_state,\n\t\t     gfp_t mask)\n{\n\tstruct extent_state *state;\n\tstruct extent_state *cached;\n\tstruct extent_state *prealloc = NULL;\n\tstruct rb_node *node;\n\tu64 last_end;\n\tint err;\n\tint clear = 0;\n\n\tbtrfs_debug_check_extent_io_range(tree, start, end);\n\n\tif (bits & EXTENT_DELALLOC)\n\t\tbits |= EXTENT_NORESERVE;\n\n\tif (delete)\n\t\tbits |= ~EXTENT_CTLBITS;\n\tbits |= EXTENT_FIRST_DELALLOC;\n\n\tif (bits & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\tclear = 1;\nagain:\n\tif (!prealloc && (mask & __GFP_WAIT)) {\n\t\t/*\n\t\t * Don't care for allocation failure here because we might end\n\t\t * up not needing the pre-allocated extent state at all, which\n\t\t * is the case if we only have in the tree extent states that\n\t\t * cover our input range and don't cover too any other range.\n\t\t * If we end up needing a new extent state we allocate it later.\n\t\t */\n\t\tprealloc = alloc_extent_state(mask);\n\t}\n\n\tspin_lock(&tree->lock);\n\tif (cached_state) {\n\t\tcached = *cached_state;\n\n\t\tif (clear) {\n\t\t\t*cached_state = NULL;\n\t\t\tcached_state = NULL;\n\t\t}\n\n\t\tif (cached && extent_state_in_tree(cached) &&\n\t\t    cached->start <= start && cached->end > start) {\n\t\t\tif (clear)\n\t\t\t\tatomic_dec(&cached->refs);\n\t\t\tstate = cached;\n\t\t\tgoto hit_next;\n\t\t}\n\t\tif (clear)\n\t\t\tfree_extent_state(cached);\n\t}\n\t/*\n\t * this search will find the extents that end after\n\t * our range starts\n\t */\n\tnode = tree_search(tree, start);\n\tif (!node)\n\t\tgoto out;\n\tstate = rb_entry(node, struct extent_state, rb_node);\nhit_next:\n\tif (state->start > end)\n\t\tgoto out;\n\tWARN_ON(state->end < start);\n\tlast_end = state->end;\n\n\t/* the state doesn't have the wanted bits, go ahead */\n\tif (!(state->state & bits)) {\n\t\tstate = next_state(state);\n\t\tgoto next;\n\t}\n\n\t/*\n\t *     | ---- desired range ---- |\n\t *  | state | or\n\t *  | ------------- state -------------- |\n\t *\n\t * We need to split the extent we found, and may flip\n\t * bits on second half.\n\t *\n\t * If the extent we found extends past our range, we\n\t * just split and search again.  It'll get split again\n\t * the next time though.\n\t *\n\t * If the extent we found is inside our range, we clear\n\t * the desired bit on it.\n\t */\n\n\tif (state->start < start) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, start);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tprealloc = NULL;\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (state->end <= end) {\n\t\t\tstate = clear_state_bit(tree, state, &bits, wake);\n\t\t\tgoto next;\n\t\t}\n\t\tgoto search_again;\n\t}\n\t/*\n\t * | ---- desired range ---- |\n\t *                        | state |\n\t * We need to split the extent, and clear the bit\n\t * on the first half\n\t */\n\tif (state->start <= end && state->end > end) {\n\t\tprealloc = alloc_extent_state_atomic(prealloc);\n\t\tBUG_ON(!prealloc);\n\t\terr = split_state(tree, state, prealloc, end + 1);\n\t\tif (err)\n\t\t\textent_io_tree_panic(tree, err);\n\n\t\tif (wake)\n\t\t\twake_up(&state->wq);\n\n\t\tclear_state_bit(tree, prealloc, &bits, wake);\n\n\t\tprealloc = NULL;\n\t\tgoto out;\n\t}\n\n\tstate = clear_state_bit(tree, state, &bits, wake);\nnext:\n\tif (last_end == (u64)-1)\n\t\tgoto out;\n\tstart = last_end + 1;\n\tif (start <= end && state && !need_resched())\n\t\tgoto hit_next;\n\tgoto search_again;\n\nout:\n\tspin_unlock(&tree->lock);\n\tif (prealloc)\n\t\tfree_extent_state(prealloc);\n\n\treturn 0;\n\nsearch_again:\n\tif (start > end)\n\t\tgoto out;\n\tspin_unlock(&tree->lock);\n\tif (mask & __GFP_WAIT)\n\t\tcond_resched();\n\tgoto again;\n}"
  },
  {
    "function_name": "extent_io_tree_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "553-558",
    "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_panic",
          "args": [
            "tree_fs_info(tree)",
            "err",
            "\"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_fs_info",
          "args": [
            "tree"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "tree_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "135-141",
          "snippet": "static inline struct btrfs_fs_info *\ntree_fs_info(struct extent_io_tree *tree)\n{\n\tif (!tree->mapping)\n\t\treturn NULL;\n\treturn btrfs_sb(tree->mapping->host->i_sb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct btrfs_fs_info *\ntree_fs_info(struct extent_io_tree *tree)\n{\n\tif (!tree->mapping)\n\t\treturn NULL;\n\treturn btrfs_sb(tree->mapping->host->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
  },
  {
    "function_name": "alloc_extent_state_atomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "544-551",
    "snippet": "static struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_extent_state",
          "args": [
            "GFP_ATOMIC"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_state_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "544-551",
          "snippet": "static struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *\nalloc_extent_state_atomic(struct extent_state *prealloc)\n{\n\tif (!prealloc)\n\t\tprealloc = alloc_extent_state(GFP_ATOMIC);\n\n\treturn prealloc;\n}"
  },
  {
    "function_name": "clear_state_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "512-542",
    "snippet": "static struct extent_state *clear_state_bit(struct extent_io_tree *tree,\n\t\t\t\t\t    struct extent_state *state,\n\t\t\t\t\t    unsigned *bits, int wake)\n{\n\tstruct extent_state *next;\n\tunsigned bits_to_clear = *bits & ~EXTENT_CTLBITS;\n\n\tif ((bits_to_clear & EXTENT_DIRTY) && (state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\tWARN_ON(range > tree->dirty_bytes);\n\t\ttree->dirty_bytes -= range;\n\t}\n\tclear_state_cb(tree, state, bits);\n\tstate->state &= ~bits_to_clear;\n\tif (wake)\n\t\twake_up(&state->wq);\n\tif (state->state == 0) {\n\t\tnext = next_state(state);\n\t\tif (extent_state_in_tree(state)) {\n\t\t\trb_erase(&state->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t\tfree_extent_state(state);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t}\n\t} else {\n\t\tmerge_state(tree, state);\n\t\tnext = next_state(state);\n\t}\n\treturn next;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_state",
          "args": [
            "state"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "next_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "496-503",
          "snippet": "static struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_state",
          "args": [
            "tree",
            "state"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "merge_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "363-396",
          "snippet": "static void merge_state(struct extent_io_tree *tree,\n\t\t        struct extent_state *state)\n{\n\tstruct extent_state *other;\n\tstruct rb_node *other_node;\n\n\tif (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\treturn;\n\n\tother_node = rb_prev(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->end == state->start - 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->start = other->start;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n\tother_node = rb_next(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->start == state->end + 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->end = other->end;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void merge_state(struct extent_io_tree *tree,\n\t\t        struct extent_state *state)\n{\n\tstruct extent_state *other;\n\tstruct rb_node *other_node;\n\n\tif (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\treturn;\n\n\tother_node = rb_prev(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->end == state->start - 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->start = other->start;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n\tother_node = rb_next(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->start == state->end + 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->end = other->end;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "state"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&state->rb_node"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&state->rb_node",
            "&tree->state"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_state_in_tree",
          "args": [
            "state"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "extent_state_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "28-31",
          "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&state->wq"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_state_cb",
          "args": [
            "tree",
            "state",
            "bits"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "clear_state_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "405-410",
          "snippet": "static void clear_state_cb(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits)\n{\n\tif (tree->ops && tree->ops->clear_bit_hook)\n\t\ttree->ops->clear_bit_hook(tree->mapping->host, state, bits);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void clear_state_cb(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits)\n{\n\tif (tree->ops && tree->ops->clear_bit_hook)\n\t\ttree->ops->clear_bit_hook(tree->mapping->host, state, bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "range > tree->dirty_bytes"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic struct extent_state *clear_state_bit(struct extent_io_tree *tree,\n\t\t\t\t\t    struct extent_state *state,\n\t\t\t\t\t    unsigned *bits, int wake)\n{\n\tstruct extent_state *next;\n\tunsigned bits_to_clear = *bits & ~EXTENT_CTLBITS;\n\n\tif ((bits_to_clear & EXTENT_DIRTY) && (state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\tWARN_ON(range > tree->dirty_bytes);\n\t\ttree->dirty_bytes -= range;\n\t}\n\tclear_state_cb(tree, state, bits);\n\tstate->state &= ~bits_to_clear;\n\tif (wake)\n\t\twake_up(&state->wq);\n\tif (state->state == 0) {\n\t\tnext = next_state(state);\n\t\tif (extent_state_in_tree(state)) {\n\t\t\trb_erase(&state->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&state->rb_node);\n\t\t\tfree_extent_state(state);\n\t\t} else {\n\t\t\tWARN_ON(1);\n\t\t}\n\t} else {\n\t\tmerge_state(tree, state);\n\t\tnext = next_state(state);\n\t}\n\treturn next;\n}"
  },
  {
    "function_name": "next_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "496-503",
    "snippet": "static struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structextent_state",
            "rb_node"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&state->rb_node"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct extent_state *next_state(struct extent_state *state)\n{\n\tstruct rb_node *next = rb_next(&state->rb_node);\n\tif (next)\n\t\treturn rb_entry(next, struct extent_state, rb_node);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "split_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "475-494",
    "snippet": "static int split_state(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t       struct extent_state *prealloc, u64 split)\n{\n\tstruct rb_node *node;\n\n\tsplit_cb(tree, orig, split);\n\n\tprealloc->start = orig->start;\n\tprealloc->end = split - 1;\n\tprealloc->state = orig->state;\n\torig->start = split;\n\n\tnode = tree_insert(&tree->state, &orig->rb_node, prealloc->end,\n\t\t\t   &prealloc->rb_node, NULL, NULL);\n\tif (node) {\n\t\tfree_extent_state(prealloc);\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "prealloc"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&tree->state",
            "&orig->rb_node",
            "prealloc->end",
            "&prealloc->rb_node",
            "NULL",
            "NULL"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "237-271",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root,\n\t\t\t\t   struct rb_node *search_start,\n\t\t\t\t   u64 offset,\n\t\t\t\t   struct rb_node *node,\n\t\t\t\t   struct rb_node ***p_in,\n\t\t\t\t   struct rb_node **parent_in)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\tif (p_in && parent_in) {\n\t\tp = *p_in;\n\t\tparent = *parent_in;\n\t\tgoto do_insert;\n\t}\n\n\tp = search_start ? &search_start : &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (offset < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\ndo_insert:\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rb_node *tree_insert(struct rb_root *root,\n\t\t\t\t   struct rb_node *search_start,\n\t\t\t\t   u64 offset,\n\t\t\t\t   struct rb_node *node,\n\t\t\t\t   struct rb_node ***p_in,\n\t\t\t\t   struct rb_node **parent_in)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\tif (p_in && parent_in) {\n\t\tp = *p_in;\n\t\tparent = *parent_in;\n\t\tgoto do_insert;\n\t}\n\n\tp = search_start ? &search_start : &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (offset < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\ndo_insert:\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_cb",
          "args": [
            "tree",
            "orig",
            "split"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "split_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "454-459",
          "snippet": "static void split_cb(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t     u64 split)\n{\n\tif (tree->ops && tree->ops->split_extent_hook)\n\t\ttree->ops->split_extent_hook(tree->mapping->host, orig, split);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void split_cb(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t     u64 split)\n{\n\tif (tree->ops && tree->ops->split_extent_hook)\n\t\ttree->ops->split_extent_hook(tree->mapping->host, orig, split);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic int split_state(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t       struct extent_state *prealloc, u64 split)\n{\n\tstruct rb_node *node;\n\n\tsplit_cb(tree, orig, split);\n\n\tprealloc->start = orig->start;\n\tprealloc->end = split - 1;\n\tprealloc->state = orig->state;\n\torig->start = split;\n\n\tnode = tree_insert(&tree->state, &orig->rb_node, prealloc->end,\n\t\t\t   &prealloc->rb_node, NULL, NULL);\n\tif (node) {\n\t\tfree_extent_state(prealloc);\n\t\treturn -EEXIST;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "split_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "454-459",
    "snippet": "static void split_cb(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t     u64 split)\n{\n\tif (tree->ops && tree->ops->split_extent_hook)\n\t\ttree->ops->split_extent_hook(tree->mapping->host, orig, split);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree->ops->split_extent_hook",
          "args": [
            "tree->mapping->host",
            "orig",
            "split"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void split_cb(struct extent_io_tree *tree, struct extent_state *orig,\n\t\t     u64 split)\n{\n\tif (tree->ops && tree->ops->split_extent_hook)\n\t\ttree->ops->split_extent_hook(tree->mapping->host, orig, split);\n}"
  },
  {
    "function_name": "insert_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "425-452",
    "snippet": "static int insert_state(struct extent_io_tree *tree,\n\t\t\tstruct extent_state *state, u64 start, u64 end,\n\t\t\tstruct rb_node ***p,\n\t\t\tstruct rb_node **parent,\n\t\t\tunsigned *bits)\n{\n\tstruct rb_node *node;\n\n\tif (end < start)\n\t\tWARN(1, KERN_ERR \"BTRFS: end < start %llu %llu\\n\",\n\t\t       end, start);\n\tstate->start = start;\n\tstate->end = end;\n\n\tset_state_bits(tree, state, bits);\n\n\tnode = tree_insert(&tree->state, NULL, end, &state->rb_node, p, parent);\n\tif (node) {\n\t\tstruct extent_state *found;\n\t\tfound = rb_entry(node, struct extent_state, rb_node);\n\t\tprintk(KERN_ERR \"BTRFS: found node %llu %llu on insert of \"\n\t\t       \"%llu %llu\\n\",\n\t\t       found->start, found->end, start, end);\n\t\treturn -EEXIST;\n\t}\n\tmerge_state(tree, state);\n\treturn 0;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge_state",
          "args": [
            "tree",
            "state"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "merge_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "363-396",
          "snippet": "static void merge_state(struct extent_io_tree *tree,\n\t\t        struct extent_state *state)\n{\n\tstruct extent_state *other;\n\tstruct rb_node *other_node;\n\n\tif (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\treturn;\n\n\tother_node = rb_prev(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->end == state->start - 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->start = other->start;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n\tother_node = rb_next(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->start == state->end + 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->end = other->end;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void merge_state(struct extent_io_tree *tree,\n\t\t        struct extent_state *state)\n{\n\tstruct extent_state *other;\n\tstruct rb_node *other_node;\n\n\tif (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\treturn;\n\n\tother_node = rb_prev(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->end == state->start - 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->start = other->start;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n\tother_node = rb_next(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->start == state->end + 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->end = other->end;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: found node %llu %llu on insert of \"\n\t\t       \"%llu %llu\\n\"",
            "found->start",
            "found->end",
            "start",
            "end"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structextent_state",
            "rb_node"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&tree->state",
            "NULL",
            "end",
            "&state->rb_node",
            "p",
            "parent"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "237-271",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root,\n\t\t\t\t   struct rb_node *search_start,\n\t\t\t\t   u64 offset,\n\t\t\t\t   struct rb_node *node,\n\t\t\t\t   struct rb_node ***p_in,\n\t\t\t\t   struct rb_node **parent_in)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\tif (p_in && parent_in) {\n\t\tp = *p_in;\n\t\tparent = *parent_in;\n\t\tgoto do_insert;\n\t}\n\n\tp = search_start ? &search_start : &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (offset < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\ndo_insert:\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rb_node *tree_insert(struct rb_root *root,\n\t\t\t\t   struct rb_node *search_start,\n\t\t\t\t   u64 offset,\n\t\t\t\t   struct rb_node *node,\n\t\t\t\t   struct rb_node ***p_in,\n\t\t\t\t   struct rb_node **parent_in)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\tif (p_in && parent_in) {\n\t\tp = *p_in;\n\t\tparent = *parent_in;\n\t\tgoto do_insert;\n\t}\n\n\tp = search_start ? &search_start : &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (offset < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\ndo_insert:\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_state_bits",
          "args": [
            "tree",
            "state",
            "bits"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "set_state_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "790-802",
          "snippet": "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state,\n\t\t\t   unsigned *bits)\n{\n\tunsigned bits_to_set = *bits & ~EXTENT_CTLBITS;\n\n\tset_state_cb(tree, state, bits);\n\tif ((bits_to_set & EXTENT_DIRTY) && !(state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\ttree->dirty_bytes += range;\n\t}\n\tstate->state |= bits_to_set;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state,\n\t\t\t   unsigned *bits)\n{\n\tunsigned bits_to_set = *bits & ~EXTENT_CTLBITS;\n\n\tset_state_cb(tree, state, bits);\n\tif ((bits_to_set & EXTENT_DIRTY) && !(state->state & EXTENT_DIRTY)) {\n\t\tu64 range = state->end - state->start + 1;\n\t\ttree->dirty_bytes += range;\n\t}\n\tstate->state |= bits_to_set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"BTRFS: end < start %llu %llu\\n\"",
            "end",
            "start"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic int insert_state(struct extent_io_tree *tree,\n\t\t\tstruct extent_state *state, u64 start, u64 end,\n\t\t\tstruct rb_node ***p,\n\t\t\tstruct rb_node **parent,\n\t\t\tunsigned *bits)\n{\n\tstruct rb_node *node;\n\n\tif (end < start)\n\t\tWARN(1, KERN_ERR \"BTRFS: end < start %llu %llu\\n\",\n\t\t       end, start);\n\tstate->start = start;\n\tstate->end = end;\n\n\tset_state_bits(tree, state, bits);\n\n\tnode = tree_insert(&tree->state, NULL, end, &state->rb_node, p, parent);\n\tif (node) {\n\t\tstruct extent_state *found;\n\t\tfound = rb_entry(node, struct extent_state, rb_node);\n\t\tprintk(KERN_ERR \"BTRFS: found node %llu %llu on insert of \"\n\t\t       \"%llu %llu\\n\",\n\t\t       found->start, found->end, start, end);\n\t\treturn -EEXIST;\n\t}\n\tmerge_state(tree, state);\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_state_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "405-410",
    "snippet": "static void clear_state_cb(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits)\n{\n\tif (tree->ops && tree->ops->clear_bit_hook)\n\t\ttree->ops->clear_bit_hook(tree->mapping->host, state, bits);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree->ops->clear_bit_hook",
          "args": [
            "tree->mapping->host",
            "state",
            "bits"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void clear_state_cb(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits)\n{\n\tif (tree->ops && tree->ops->clear_bit_hook)\n\t\ttree->ops->clear_bit_hook(tree->mapping->host, state, bits);\n}"
  },
  {
    "function_name": "set_state_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "398-403",
    "snippet": "static void set_state_cb(struct extent_io_tree *tree,\n\t\t\t struct extent_state *state, unsigned *bits)\n{\n\tif (tree->ops && tree->ops->set_bit_hook)\n\t\ttree->ops->set_bit_hook(tree->mapping->host, state, bits);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree->ops->set_bit_hook",
          "args": [
            "tree->mapping->host",
            "state",
            "bits"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nstatic void set_state_cb(struct extent_io_tree *tree,\n\t\t\t struct extent_state *state, unsigned *bits)\n{\n\tif (tree->ops && tree->ops->set_bit_hook)\n\t\ttree->ops->set_bit_hook(tree->mapping->host, state, bits);\n}"
  },
  {
    "function_name": "merge_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "363-396",
    "snippet": "static void merge_state(struct extent_io_tree *tree,\n\t\t        struct extent_state *state)\n{\n\tstruct extent_state *other;\n\tstruct rb_node *other_node;\n\n\tif (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\treturn;\n\n\tother_node = rb_prev(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->end == state->start - 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->start = other->start;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n\tother_node = rb_next(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->start == state->end + 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->end = other->end;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_state",
          "args": [
            "other"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "225-235",
          "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&other->rb_node"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&other->rb_node",
            "&tree->state"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_cb",
          "args": [
            "tree",
            "state",
            "other"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "merge_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "346-352",
          "snippet": "static void merge_cb(struct extent_io_tree *tree, struct extent_state *new,\n\t\t     struct extent_state *other)\n{\n\tif (tree->ops && tree->ops->merge_extent_hook)\n\t\ttree->ops->merge_extent_hook(tree->mapping->host, new,\n\t\t\t\t\t     other);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void merge_cb(struct extent_io_tree *tree, struct extent_state *new,\n\t\t     struct extent_state *other)\n{\n\tif (tree->ops && tree->ops->merge_extent_hook)\n\t\ttree->ops->merge_extent_hook(tree->mapping->host, new,\n\t\t\t\t\t     other);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "other_node",
            "structextent_state",
            "rb_node"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&state->rb_node"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&other->rb_node"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&other->rb_node",
            "&tree->state"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "other_node",
            "structextent_state",
            "rb_node"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&state->rb_node"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void merge_state(struct extent_io_tree *tree,\n\t\t        struct extent_state *state)\n{\n\tstruct extent_state *other;\n\tstruct rb_node *other_node;\n\n\tif (state->state & (EXTENT_IOBITS | EXTENT_BOUNDARY))\n\t\treturn;\n\n\tother_node = rb_prev(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->end == state->start - 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->start = other->start;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n\tother_node = rb_next(&state->rb_node);\n\tif (other_node) {\n\t\tother = rb_entry(other_node, struct extent_state, rb_node);\n\t\tif (other->start == state->end + 1 &&\n\t\t    other->state == state->state) {\n\t\t\tmerge_cb(tree, state, other);\n\t\t\tstate->end = other->end;\n\t\t\trb_erase(&other->rb_node, &tree->state);\n\t\t\tRB_CLEAR_NODE(&other->rb_node);\n\t\t\tfree_extent_state(other);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "merge_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "346-352",
    "snippet": "static void merge_cb(struct extent_io_tree *tree, struct extent_state *new,\n\t\t     struct extent_state *other)\n{\n\tif (tree->ops && tree->ops->merge_extent_hook)\n\t\ttree->ops->merge_extent_hook(tree->mapping->host, new,\n\t\t\t\t\t     other);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree->ops->merge_extent_hook",
          "args": [
            "tree->mapping->host",
            "new",
            "other"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void merge_cb(struct extent_io_tree *tree, struct extent_state *new,\n\t\t     struct extent_state *other)\n{\n\tif (tree->ops && tree->ops->merge_extent_hook)\n\t\ttree->ops->merge_extent_hook(tree->mapping->host, new,\n\t\t\t\t\t     other);\n}"
  },
  {
    "function_name": "tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "340-344",
    "snippet": "static inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_search_for_insert",
          "args": [
            "tree",
            "offset",
            "NULL",
            "NULL"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "325-338",
          "snippet": "static inline struct rb_node *\ntree_search_for_insert(struct extent_io_tree *tree,\n\t\t       u64 offset,\n\t\t       struct rb_node ***p_ret,\n\t\t       struct rb_node **parent_ret)\n{\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\n\tret = __etree_search(tree, offset, &prev, NULL, p_ret, parent_ret);\n\tif (!ret)\n\t\treturn prev;\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *\ntree_search_for_insert(struct extent_io_tree *tree,\n\t\t       u64 offset,\n\t\t       struct rb_node ***p_ret,\n\t\t       struct rb_node **parent_ret)\n{\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\n\tret = __etree_search(tree, offset, &prev, NULL, p_ret, parent_ret);\n\tif (!ret)\n\t\treturn prev;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *tree_search(struct extent_io_tree *tree,\n\t\t\t\t\t  u64 offset)\n{\n\treturn tree_search_for_insert(tree, offset, NULL, NULL);\n}"
  },
  {
    "function_name": "tree_search_for_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "325-338",
    "snippet": "static inline struct rb_node *\ntree_search_for_insert(struct extent_io_tree *tree,\n\t\t       u64 offset,\n\t\t       struct rb_node ***p_ret,\n\t\t       struct rb_node **parent_ret)\n{\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\n\tret = __etree_search(tree, offset, &prev, NULL, p_ret, parent_ret);\n\tif (!ret)\n\t\treturn prev;\n\treturn ret;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__etree_search",
          "args": [
            "tree",
            "offset",
            "&prev",
            "NULL",
            "p_ret",
            "parent_ret"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__etree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "273-323",
          "snippet": "static struct rb_node *__etree_search(struct extent_io_tree *tree, u64 offset,\n\t\t\t\t      struct rb_node **prev_ret,\n\t\t\t\t      struct rb_node **next_ret,\n\t\t\t\t      struct rb_node ***p_ret,\n\t\t\t\t      struct rb_node **parent_ret)\n{\n\tstruct rb_root *root = &tree->state;\n\tstruct rb_node **n = &root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *orig_prev = NULL;\n\tstruct tree_entry *entry;\n\tstruct tree_entry *prev_entry = NULL;\n\n\twhile (*n) {\n\t\tprev = *n;\n\t\tentry = rb_entry(prev, struct tree_entry, rb_node);\n\t\tprev_entry = entry;\n\n\t\tif (offset < entry->start)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tn = &(*n)->rb_right;\n\t\telse\n\t\t\treturn *n;\n\t}\n\n\tif (p_ret)\n\t\t*p_ret = n;\n\tif (parent_ret)\n\t\t*parent_ret = prev;\n\n\tif (prev_ret) {\n\t\torig_prev = prev;\n\t\twhile (prev && offset > prev_entry->end) {\n\t\t\tprev = rb_next(prev);\n\t\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\t}\n\t\t*prev_ret = prev;\n\t\tprev = orig_prev;\n\t}\n\n\tif (next_ret) {\n\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\twhile (prev && offset < prev_entry->start) {\n\t\t\tprev = rb_prev(prev);\n\t\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\t}\n\t\t*next_ret = prev;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rb_node *__etree_search(struct extent_io_tree *tree, u64 offset,\n\t\t\t\t      struct rb_node **prev_ret,\n\t\t\t\t      struct rb_node **next_ret,\n\t\t\t\t      struct rb_node ***p_ret,\n\t\t\t\t      struct rb_node **parent_ret)\n{\n\tstruct rb_root *root = &tree->state;\n\tstruct rb_node **n = &root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *orig_prev = NULL;\n\tstruct tree_entry *entry;\n\tstruct tree_entry *prev_entry = NULL;\n\n\twhile (*n) {\n\t\tprev = *n;\n\t\tentry = rb_entry(prev, struct tree_entry, rb_node);\n\t\tprev_entry = entry;\n\n\t\tif (offset < entry->start)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tn = &(*n)->rb_right;\n\t\telse\n\t\t\treturn *n;\n\t}\n\n\tif (p_ret)\n\t\t*p_ret = n;\n\tif (parent_ret)\n\t\t*parent_ret = prev;\n\n\tif (prev_ret) {\n\t\torig_prev = prev;\n\t\twhile (prev && offset > prev_entry->end) {\n\t\t\tprev = rb_next(prev);\n\t\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\t}\n\t\t*prev_ret = prev;\n\t\tprev = orig_prev;\n\t}\n\n\tif (next_ret) {\n\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\twhile (prev && offset < prev_entry->start) {\n\t\t\tprev = rb_prev(prev);\n\t\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\t}\n\t\t*next_ret = prev;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct rb_node *\ntree_search_for_insert(struct extent_io_tree *tree,\n\t\t       u64 offset,\n\t\t       struct rb_node ***p_ret,\n\t\t       struct rb_node **parent_ret)\n{\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *ret;\n\n\tret = __etree_search(tree, offset, &prev, NULL, p_ret, parent_ret);\n\tif (!ret)\n\t\treturn prev;\n\treturn ret;\n}"
  },
  {
    "function_name": "__etree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "273-323",
    "snippet": "static struct rb_node *__etree_search(struct extent_io_tree *tree, u64 offset,\n\t\t\t\t      struct rb_node **prev_ret,\n\t\t\t\t      struct rb_node **next_ret,\n\t\t\t\t      struct rb_node ***p_ret,\n\t\t\t\t      struct rb_node **parent_ret)\n{\n\tstruct rb_root *root = &tree->state;\n\tstruct rb_node **n = &root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *orig_prev = NULL;\n\tstruct tree_entry *entry;\n\tstruct tree_entry *prev_entry = NULL;\n\n\twhile (*n) {\n\t\tprev = *n;\n\t\tentry = rb_entry(prev, struct tree_entry, rb_node);\n\t\tprev_entry = entry;\n\n\t\tif (offset < entry->start)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tn = &(*n)->rb_right;\n\t\telse\n\t\t\treturn *n;\n\t}\n\n\tif (p_ret)\n\t\t*p_ret = n;\n\tif (parent_ret)\n\t\t*parent_ret = prev;\n\n\tif (prev_ret) {\n\t\torig_prev = prev;\n\t\twhile (prev && offset > prev_entry->end) {\n\t\t\tprev = rb_next(prev);\n\t\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\t}\n\t\t*prev_ret = prev;\n\t\tprev = orig_prev;\n\t}\n\n\tif (next_ret) {\n\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\twhile (prev && offset < prev_entry->start) {\n\t\t\tprev = rb_prev(prev);\n\t\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\t}\n\t\t*next_ret = prev;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structtree_entry",
            "rb_node"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "prev"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structtree_entry",
            "rb_node"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structtree_entry",
            "rb_node"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "prev"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structtree_entry",
            "rb_node"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rb_node *__etree_search(struct extent_io_tree *tree, u64 offset,\n\t\t\t\t      struct rb_node **prev_ret,\n\t\t\t\t      struct rb_node **next_ret,\n\t\t\t\t      struct rb_node ***p_ret,\n\t\t\t\t      struct rb_node **parent_ret)\n{\n\tstruct rb_root *root = &tree->state;\n\tstruct rb_node **n = &root->rb_node;\n\tstruct rb_node *prev = NULL;\n\tstruct rb_node *orig_prev = NULL;\n\tstruct tree_entry *entry;\n\tstruct tree_entry *prev_entry = NULL;\n\n\twhile (*n) {\n\t\tprev = *n;\n\t\tentry = rb_entry(prev, struct tree_entry, rb_node);\n\t\tprev_entry = entry;\n\n\t\tif (offset < entry->start)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tn = &(*n)->rb_right;\n\t\telse\n\t\t\treturn *n;\n\t}\n\n\tif (p_ret)\n\t\t*p_ret = n;\n\tif (parent_ret)\n\t\t*parent_ret = prev;\n\n\tif (prev_ret) {\n\t\torig_prev = prev;\n\t\twhile (prev && offset > prev_entry->end) {\n\t\t\tprev = rb_next(prev);\n\t\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\t}\n\t\t*prev_ret = prev;\n\t\tprev = orig_prev;\n\t}\n\n\tif (next_ret) {\n\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\twhile (prev && offset < prev_entry->start) {\n\t\t\tprev = rb_prev(prev);\n\t\t\tprev_entry = rb_entry(prev, struct tree_entry, rb_node);\n\t\t}\n\t\t*next_ret = prev;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "237-271",
    "snippet": "static struct rb_node *tree_insert(struct rb_root *root,\n\t\t\t\t   struct rb_node *search_start,\n\t\t\t\t   u64 offset,\n\t\t\t\t   struct rb_node *node,\n\t\t\t\t   struct rb_node ***p_in,\n\t\t\t\t   struct rb_node **parent_in)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\tif (p_in && parent_in) {\n\t\tp = *p_in;\n\t\tparent = *parent_in;\n\t\tgoto do_insert;\n\t}\n\n\tp = search_start ? &search_start : &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (offset < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\ndo_insert:\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent",
            "p"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structtree_entry",
            "rb_node"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct rb_node *tree_insert(struct rb_root *root,\n\t\t\t\t   struct rb_node *search_start,\n\t\t\t\t   u64 offset,\n\t\t\t\t   struct rb_node *node,\n\t\t\t\t   struct rb_node ***p_in,\n\t\t\t\t   struct rb_node **parent_in)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\tif (p_in && parent_in) {\n\t\tp = *p_in;\n\t\tparent = *parent_in;\n\t\tgoto do_insert;\n\t}\n\n\tp = search_start ? &search_start : &root->rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (offset < entry->start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (offset > entry->end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\ndo_insert:\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_extent_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "225-235",
    "snippet": "void free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_state_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "extent_state_cache",
            "state"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_free_extent_state",
          "args": [
            "state",
            "_RET_IP_"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leak_debug_del",
          "args": [
            "&state->leak_list"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leak_debug_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "49-57",
          "snippet": "static inline\nvoid btrfs_leak_debug_del(struct list_head *entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_del(entry);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline\nvoid btrfs_leak_debug_del(struct list_head *entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_del(entry);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "extent_state_in_tree(state)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_state_in_tree",
          "args": [
            "state"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "extent_state_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "28-31",
          "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&state->refs"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nvoid free_extent_state(struct extent_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tif (atomic_dec_and_test(&state->refs)) {\n\t\tWARN_ON(extent_state_in_tree(state));\n\t\tbtrfs_leak_debug_del(&state->leak_list);\n\t\ttrace_free_extent_state(state, _RET_IP_);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n}"
  },
  {
    "function_name": "alloc_extent_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "208-223",
    "snippet": "static struct extent_state *alloc_extent_state(gfp_t mask)\n{\n\tstruct extent_state *state;\n\n\tstate = kmem_cache_alloc(extent_state_cache, mask);\n\tif (!state)\n\t\treturn state;\n\tstate->state = 0;\n\tstate->private = 0;\n\tRB_CLEAR_NODE(&state->rb_node);\n\tbtrfs_leak_debug_add(&state->leak_list, &states);\n\tatomic_set(&state->refs, 1);\n\tinit_waitqueue_head(&state->wq);\n\ttrace_alloc_extent_state(state, mask, _RET_IP_);\n\treturn state;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_state_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_alloc_extent_state",
          "args": [
            "state",
            "mask",
            "_RET_IP_"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&state->wq"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&state->refs",
            "1"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leak_debug_add",
          "args": [
            "&state->leak_list",
            "&states"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leak_debug_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "39-47",
          "snippet": "static inline\nvoid btrfs_leak_debug_add(struct list_head *new, struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_add(new, head);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline\nvoid btrfs_leak_debug_add(struct list_head *new, struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_add(new, head);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&state->rb_node"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "extent_state_cache",
            "mask"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\n\nstatic struct extent_state *alloc_extent_state(gfp_t mask)\n{\n\tstruct extent_state *state;\n\n\tstate = kmem_cache_alloc(extent_state_cache, mask);\n\tif (!state)\n\t\treturn state;\n\tstate->state = 0;\n\tstate->private = 0;\n\tRB_CLEAR_NODE(&state->rb_node);\n\tbtrfs_leak_debug_add(&state->leak_list, &states);\n\tatomic_set(&state->refs, 1);\n\tinit_waitqueue_head(&state->wq);\n\ttrace_alloc_extent_state(state, mask, _RET_IP_);\n\treturn state;\n}"
  },
  {
    "function_name": "extent_io_tree_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "198-206",
    "snippet": "void extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&tree->lock"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}"
  },
  {
    "function_name": "extent_io_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "181-196",
    "snippet": "void extent_io_exit(void)\n{\n\tbtrfs_leak_debug_check();\n\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tif (extent_state_cache)\n\t\tkmem_cache_destroy(extent_state_cache);\n\tif (extent_buffer_cache)\n\t\tkmem_cache_destroy(extent_buffer_cache);\n\tif (btrfs_bioset)\n\t\tbioset_free(btrfs_bioset);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_state_cache;",
      "static struct kmem_cache *extent_buffer_cache;",
      "static struct bio_set *btrfs_bioset;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bioset_free",
          "args": [
            "btrfs_bioset"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "extent_buffer_cache"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "extent_state_cache"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leak_debug_check",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leak_debug_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "59-83",
          "snippet": "static inline\nvoid btrfs_leak_debug_check(void)\n{\n\tstruct extent_state *state;\n\tstruct extent_buffer *eb;\n\n\twhile (!list_empty(&states)) {\n\t\tstate = list_entry(states.next, struct extent_state, leak_list);\n\t\tpr_err(\"BTRFS: state leak: start %llu end %llu state %u in tree %d refs %d\\n\",\n\t\t       state->start, state->end, state->state,\n\t\t       extent_state_in_tree(state),\n\t\t       atomic_read(&state->refs));\n\t\tlist_del(&state->leak_list);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n\n\twhile (!list_empty(&buffers)) {\n\t\teb = list_entry(buffers.next, struct extent_buffer, leak_list);\n\t\tprintk(KERN_ERR \"BTRFS: buffer leak start %llu len %lu \"\n\t\t       \"refs %d\\n\",\n\t\t       eb->start, eb->len, atomic_read(&eb->refs));\n\t\tlist_del(&eb->leak_list);\n\t\tkmem_cache_free(extent_buffer_cache, eb);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;",
            "static struct kmem_cache *extent_buffer_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic inline\nvoid btrfs_leak_debug_check(void)\n{\n\tstruct extent_state *state;\n\tstruct extent_buffer *eb;\n\n\twhile (!list_empty(&states)) {\n\t\tstate = list_entry(states.next, struct extent_state, leak_list);\n\t\tpr_err(\"BTRFS: state leak: start %llu end %llu state %u in tree %d refs %d\\n\",\n\t\t       state->start, state->end, state->state,\n\t\t       extent_state_in_tree(state),\n\t\t       atomic_read(&state->refs));\n\t\tlist_del(&state->leak_list);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n\n\twhile (!list_empty(&buffers)) {\n\t\teb = list_entry(buffers.next, struct extent_buffer, leak_list);\n\t\tprintk(KERN_ERR \"BTRFS: buffer leak start %llu len %lu \"\n\t\t       \"refs %d\\n\",\n\t\t       eb->start, eb->len, atomic_read(&eb->refs));\n\t\tlist_del(&eb->leak_list);\n\t\tkmem_cache_free(extent_buffer_cache, eb);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\nstatic struct kmem_cache *extent_buffer_cache;\nstatic struct bio_set *btrfs_bioset;\n\nvoid extent_io_exit(void)\n{\n\tbtrfs_leak_debug_check();\n\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tif (extent_state_cache)\n\t\tkmem_cache_destroy(extent_state_cache);\n\tif (extent_buffer_cache)\n\t\tkmem_cache_destroy(extent_buffer_cache);\n\tif (btrfs_bioset)\n\t\tbioset_free(btrfs_bioset);\n}"
  },
  {
    "function_name": "extent_io_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "143-179",
    "snippet": "int __init extent_io_init(void)\n{\n\textent_state_cache = kmem_cache_create(\"btrfs_extent_state\",\n\t\t\tsizeof(struct extent_state), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_state_cache)\n\t\treturn -ENOMEM;\n\n\textent_buffer_cache = kmem_cache_create(\"btrfs_extent_buffer\",\n\t\t\tsizeof(struct extent_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_buffer_cache)\n\t\tgoto free_state_cache;\n\n\tbtrfs_bioset = bioset_create(BIO_POOL_SIZE,\n\t\t\t\t     offsetof(struct btrfs_io_bio, bio));\n\tif (!btrfs_bioset)\n\t\tgoto free_buffer_cache;\n\n\tif (bioset_integrity_create(btrfs_bioset, BIO_POOL_SIZE))\n\t\tgoto free_bioset;\n\n\treturn 0;\n\nfree_bioset:\n\tbioset_free(btrfs_bioset);\n\tbtrfs_bioset = NULL;\n\nfree_buffer_cache:\n\tkmem_cache_destroy(extent_buffer_cache);\n\textent_buffer_cache = NULL;\n\nfree_state_cache:\n\tkmem_cache_destroy(extent_state_cache);\n\textent_state_cache = NULL;\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_state_cache;",
      "static struct kmem_cache *extent_buffer_cache;",
      "static struct bio_set *btrfs_bioset;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "extent_state_cache"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "extent_buffer_cache"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bioset_free",
          "args": [
            "btrfs_bioset"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bioset_integrity_create",
          "args": [
            "btrfs_bioset",
            "BIO_POOL_SIZE"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bioset_create",
          "args": [
            "BIO_POOL_SIZE",
            "offsetof(struct btrfs_io_bio, bio)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_extent_buffer\"",
            "sizeof(struct extent_buffer)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_extent_state\"",
            "sizeof(struct extent_state)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\nstatic struct kmem_cache *extent_buffer_cache;\nstatic struct bio_set *btrfs_bioset;\n\nint __init extent_io_init(void)\n{\n\textent_state_cache = kmem_cache_create(\"btrfs_extent_state\",\n\t\t\tsizeof(struct extent_state), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_state_cache)\n\t\treturn -ENOMEM;\n\n\textent_buffer_cache = kmem_cache_create(\"btrfs_extent_buffer\",\n\t\t\tsizeof(struct extent_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_buffer_cache)\n\t\tgoto free_state_cache;\n\n\tbtrfs_bioset = bioset_create(BIO_POOL_SIZE,\n\t\t\t\t     offsetof(struct btrfs_io_bio, bio));\n\tif (!btrfs_bioset)\n\t\tgoto free_buffer_cache;\n\n\tif (bioset_integrity_create(btrfs_bioset, BIO_POOL_SIZE))\n\t\tgoto free_bioset;\n\n\treturn 0;\n\nfree_bioset:\n\tbioset_free(btrfs_bioset);\n\tbtrfs_bioset = NULL;\n\nfree_buffer_cache:\n\tkmem_cache_destroy(extent_buffer_cache);\n\textent_buffer_cache = NULL;\n\nfree_state_cache:\n\tkmem_cache_destroy(extent_state_cache);\n\textent_state_cache = NULL;\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "tree_fs_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "135-141",
    "snippet": "static inline struct btrfs_fs_info *\ntree_fs_info(struct extent_io_tree *tree)\n{\n\tif (!tree->mapping)\n\t\treturn NULL;\n\treturn btrfs_sb(tree->mapping->host->i_sb);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "tree->mapping->host->i_sb"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline struct btrfs_fs_info *\ntree_fs_info(struct extent_io_tree *tree)\n{\n\tif (!tree->mapping)\n\t\treturn NULL;\n\treturn btrfs_sb(tree->mapping->host->i_sb);\n}"
  },
  {
    "function_name": "__btrfs_debug_check_extent_io_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "87-103",
    "snippet": "static inline void __btrfs_debug_check_extent_io_range(const char *caller,\n\t\tstruct extent_io_tree *tree, u64 start, u64 end)\n{\n\tstruct inode *inode;\n\tu64 isize;\n\n\tif (!tree->mapping)\n\t\treturn;\n\n\tinode = tree->mapping->host;\n\tisize = i_size_read(inode);\n\tif (end >= PAGE_SIZE && (end % 2) == 0 && end != isize - 1) {\n\t\tprintk_ratelimited(KERN_DEBUG\n\t\t    \"BTRFS: %s: ino %llu isize %llu odd range [%llu,%llu]\\n\",\n\t\t\t\tcaller, btrfs_ino(inode), isize, start, end);\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_DEBUG\n\t\t    \"BTRFS: %s: ino %llu isize %llu odd range [%llu,%llu]\\n\"",
            "caller",
            "btrfs_ino(inode)",
            "isize",
            "start",
            "end"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline void __btrfs_debug_check_extent_io_range(const char *caller,\n\t\tstruct extent_io_tree *tree, u64 start, u64 end)\n{\n\tstruct inode *inode;\n\tu64 isize;\n\n\tif (!tree->mapping)\n\t\treturn;\n\n\tinode = tree->mapping->host;\n\tisize = i_size_read(inode);\n\tif (end >= PAGE_SIZE && (end % 2) == 0 && end != isize - 1) {\n\t\tprintk_ratelimited(KERN_DEBUG\n\t\t    \"BTRFS: %s: ino %llu isize %llu odd range [%llu,%llu]\\n\",\n\t\t\t\tcaller, btrfs_ino(inode), isize, start, end);\n\t}\n}"
  },
  {
    "function_name": "btrfs_leak_debug_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "59-83",
    "snippet": "static inline\nvoid btrfs_leak_debug_check(void)\n{\n\tstruct extent_state *state;\n\tstruct extent_buffer *eb;\n\n\twhile (!list_empty(&states)) {\n\t\tstate = list_entry(states.next, struct extent_state, leak_list);\n\t\tpr_err(\"BTRFS: state leak: start %llu end %llu state %u in tree %d refs %d\\n\",\n\t\t       state->start, state->end, state->state,\n\t\t       extent_state_in_tree(state),\n\t\t       atomic_read(&state->refs));\n\t\tlist_del(&state->leak_list);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n\n\twhile (!list_empty(&buffers)) {\n\t\teb = list_entry(buffers.next, struct extent_buffer, leak_list);\n\t\tprintk(KERN_ERR \"BTRFS: buffer leak start %llu len %lu \"\n\t\t       \"refs %d\\n\",\n\t\t       eb->start, eb->len, atomic_read(&eb->refs));\n\t\tlist_del(&eb->leak_list);\n\t\tkmem_cache_free(extent_buffer_cache, eb);\n\t}\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *extent_state_cache;",
      "static struct kmem_cache *extent_buffer_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "extent_buffer_cache",
            "eb"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&eb->leak_list"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: buffer leak start %llu len %lu \"\n\t\t       \"refs %d\\n\"",
            "eb->start",
            "eb->len",
            "atomic_read(&eb->refs)"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&eb->refs"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "buffers.next",
            "structextent_buffer",
            "leak_list"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&buffers"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "extent_state_cache",
            "state"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BTRFS: state leak: start %llu end %llu state %u in tree %d refs %d\\n\"",
            "state->start",
            "state->end",
            "state->state",
            "extent_state_in_tree(state)",
            "atomic_read(&state->refs)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&state->refs"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_state_in_tree",
          "args": [
            "state"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "extent_state_in_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "28-31",
          "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "states.next",
            "structextent_state",
            "leak_list"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\nstatic struct kmem_cache *extent_buffer_cache;\n\nstatic inline\nvoid btrfs_leak_debug_check(void)\n{\n\tstruct extent_state *state;\n\tstruct extent_buffer *eb;\n\n\twhile (!list_empty(&states)) {\n\t\tstate = list_entry(states.next, struct extent_state, leak_list);\n\t\tpr_err(\"BTRFS: state leak: start %llu end %llu state %u in tree %d refs %d\\n\",\n\t\t       state->start, state->end, state->state,\n\t\t       extent_state_in_tree(state),\n\t\t       atomic_read(&state->refs));\n\t\tlist_del(&state->leak_list);\n\t\tkmem_cache_free(extent_state_cache, state);\n\t}\n\n\twhile (!list_empty(&buffers)) {\n\t\teb = list_entry(buffers.next, struct extent_buffer, leak_list);\n\t\tprintk(KERN_ERR \"BTRFS: buffer leak start %llu len %lu \"\n\t\t       \"refs %d\\n\",\n\t\t       eb->start, eb->len, atomic_read(&eb->refs));\n\t\tlist_del(&eb->leak_list);\n\t\tkmem_cache_free(extent_buffer_cache, eb);\n\t}\n}"
  },
  {
    "function_name": "btrfs_leak_debug_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "49-57",
    "snippet": "static inline\nvoid btrfs_leak_debug_del(struct list_head *entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_del(entry);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&leak_lock",
            "flags"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "entry"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&leak_lock",
            "flags"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline\nvoid btrfs_leak_debug_del(struct list_head *entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_del(entry);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}"
  },
  {
    "function_name": "btrfs_leak_debug_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "39-47",
    "snippet": "static inline\nvoid btrfs_leak_debug_add(struct list_head *new, struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_add(new, head);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&leak_lock",
            "flags"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "new",
            "head"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&leak_lock",
            "flags"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline\nvoid btrfs_leak_debug_add(struct list_head *new, struct list_head *head)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&leak_lock, flags);\n\tlist_add(new, head);\n\tspin_unlock_irqrestore(&leak_lock, flags);\n}"
  },
  {
    "function_name": "extent_state_in_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
    "lines": "28-31",
    "snippet": "static inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}",
    "includes": [
      "#include \"backref.h\"",
      "#include \"rcu-string.h\"",
      "#include \"locking.h\"",
      "#include \"check-integrity.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include <linux/cleancache.h>",
      "#include <linux/prefetch.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/page-flags.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/bio.h>",
      "#include <linux/slab.h>",
      "#include <linux/bitops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&state->rb_node"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic inline bool extent_state_in_tree(const struct extent_state *state)\n{\n\treturn !RB_EMPTY_NODE(&state->rb_node);\n}"
  }
]