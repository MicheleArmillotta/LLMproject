[
  {
    "function_name": "bfs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
    "lines": "186-189",
    "snippet": "static sector_t bfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, bfs_get_block);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "bfs_get_block"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic sector_t bfs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping, block, bfs_get_block);\n}"
  },
  {
    "function_name": "bfs_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
    "lines": "172-184",
    "snippet": "static int bfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tbfs_get_block);\n\tif (unlikely(ret))\n\t\tbfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bfs_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
          "lines": "164-170",
          "snippet": "static void bfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic void bfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "bfs_get_block"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int bfs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tbfs_get_block);\n\tif (unlikely(ret))\n\t\tbfs_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bfs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
    "lines": "164-170",
    "snippet": "static void bfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic void bfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size)\n\t\ttruncate_pagecache(inode, inode->i_size);\n}"
  },
  {
    "function_name": "bfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
    "lines": "159-162",
    "snippet": "static int bfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, bfs_get_block);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "bfs_get_block"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int bfs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page, bfs_get_block);\n}"
  },
  {
    "function_name": "bfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
    "lines": "154-157",
    "snippet": "static int bfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, bfs_get_block, wbc);\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "bfs_get_block",
            "wbc"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int bfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, bfs_get_block, wbc);\n}"
  },
  {
    "function_name": "bfs_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
    "lines": "65-152",
    "snippet": "static int bfs_get_block(struct inode *inode, sector_t block,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\tunsigned long phys;\n\tint err;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct bfs_sb_info *info = BFS_SB(sb);\n\tstruct bfs_inode_info *bi = BFS_I(inode);\n\n\tphys = bi->i_sblock + block;\n\tif (!create) {\n\t\tif (phys <= bi->i_eblock) {\n\t\t\tdprintf(\"c=%d, b=%08lx, phys=%09lx (granted)\\n\",\n                                create, (unsigned long)block, phys);\n\t\t\tmap_bh(bh_result, sb, phys);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file is not empty and the requested block is within the\n\t * range of blocks allocated for this file, we can grant it.\n\t */\n\tif (bi->i_sblock && (phys <= bi->i_eblock)) {\n\t\tdprintf(\"c=%d, b=%08lx, phys=%08lx (interim block granted)\\n\", \n\t\t\t\tcreate, (unsigned long)block, phys);\n\t\tmap_bh(bh_result, sb, phys);\n\t\treturn 0;\n\t}\n\n\t/* The file will be extended, so let's see if there is enough space. */\n\tif (phys >= info->si_blocks)\n\t\treturn -ENOSPC;\n\n\t/* The rest has to be protected against itself. */\n\tmutex_lock(&info->bfs_lock);\n\n\t/*\n\t * If the last data block for this file is the last allocated\n\t * block, we can extend the file trivially, without moving it\n\t * anywhere.\n\t */\n\tif (bi->i_eblock == info->si_lf_eblk) {\n\t\tdprintf(\"c=%d, b=%08lx, phys=%08lx (simple extension)\\n\", \n\t\t\t\tcreate, (unsigned long)block, phys);\n\t\tmap_bh(bh_result, sb, phys);\n\t\tinfo->si_freeb -= phys - bi->i_eblock;\n\t\tinfo->si_lf_eblk = bi->i_eblock = phys;\n\t\tmark_inode_dirty(inode);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Ok, we have to move this entire file to the next free block. */\n\tphys = info->si_lf_eblk + 1;\n\tif (phys + block >= info->si_blocks) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tif (bi->i_sblock) {\n\t\terr = bfs_move_blocks(inode->i_sb, bi->i_sblock, \n\t\t\t\t\t\tbi->i_eblock, phys);\n\t\tif (err) {\n\t\t\tdprintf(\"failed to move ino=%08lx -> fs corruption\\n\",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\terr = 0;\n\n\tdprintf(\"c=%d, b=%08lx, phys=%08lx (moved)\\n\",\n                create, (unsigned long)block, phys);\n\tbi->i_sblock = phys;\n\tphys += block;\n\tinfo->si_lf_eblk = bi->i_eblock = phys;\n\n\t/*\n\t * This assumes nothing can write the inode back while we are here\n\t * and thus update inode->i_blocks! (XXX)\n\t */\n\tinfo->si_freeb -= bi->i_eblock - bi->i_sblock + 1 - inode->i_blocks;\n\tmark_inode_dirty(inode);\n\tmap_bh(bh_result, sb, phys);\nout:\n\tmutex_unlock(&info->bfs_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "phys"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"c=%d, b=%08lx, phys=%08lx (moved)\\n\"",
            "create",
            "(unsigned long)block",
            "phys"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"failed to move ino=%08lx -> fs corruption\\n\"",
            "inode->i_ino"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_move_blocks",
          "args": [
            "inode->i_sb",
            "bi->i_sblock",
            "bi->i_eblock",
            "phys"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_move_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
          "lines": "50-63",
          "snippet": "static int bfs_move_blocks(struct super_block *sb, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long where)\n{\n\tunsigned long i;\n\n\tdprintf(\"%08lx-%08lx->%08lx\\n\", start, end, where);\n\tfor (i = start; i <= end; i++)\n\t\tif(bfs_move_block(i, where + i, sb)) {\n\t\t\tdprintf(\"failed to move block %08lx -> %08lx\\n\", i,\n\t\t\t\t\t\t\t\twhere + i);\n\t\t\treturn -EIO;\n\t\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int bfs_move_blocks(struct super_block *sb, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long where)\n{\n\tunsigned long i;\n\n\tdprintf(\"%08lx-%08lx->%08lx\\n\", start, end, where);\n\tfor (i = start; i <= end; i++)\n\t\tif(bfs_move_block(i, where + i, sb)) {\n\t\t\tdprintf(\"failed to move block %08lx -> %08lx\\n\", i,\n\t\t\t\t\t\t\t\twhere + i);\n\t\t\treturn -EIO;\n\t\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "phys"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"c=%d, b=%08lx, phys=%08lx (simple extension)\\n\"",
            "create",
            "(unsigned long)block",
            "phys"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->bfs_lock"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "phys"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"c=%d, b=%08lx, phys=%08lx (interim block granted)\\n\"",
            "create",
            "(unsigned long)block",
            "phys"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "phys"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"c=%d, b=%08lx, phys=%09lx (granted)\\n\"",
            "create",
            "(unsigned long)block",
            "phys"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BFS_I",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "38-41",
          "snippet": "static inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_inode_info *BFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFS_SB",
          "args": [
            "sb"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "BFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/bfs.h",
          "lines": "33-36",
          "snippet": "static inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bfs_fs.h>\n\nstatic inline struct bfs_sb_info *BFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int bfs_get_block(struct inode *inode, sector_t block,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\tunsigned long phys;\n\tint err;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct bfs_sb_info *info = BFS_SB(sb);\n\tstruct bfs_inode_info *bi = BFS_I(inode);\n\n\tphys = bi->i_sblock + block;\n\tif (!create) {\n\t\tif (phys <= bi->i_eblock) {\n\t\t\tdprintf(\"c=%d, b=%08lx, phys=%09lx (granted)\\n\",\n                                create, (unsigned long)block, phys);\n\t\t\tmap_bh(bh_result, sb, phys);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file is not empty and the requested block is within the\n\t * range of blocks allocated for this file, we can grant it.\n\t */\n\tif (bi->i_sblock && (phys <= bi->i_eblock)) {\n\t\tdprintf(\"c=%d, b=%08lx, phys=%08lx (interim block granted)\\n\", \n\t\t\t\tcreate, (unsigned long)block, phys);\n\t\tmap_bh(bh_result, sb, phys);\n\t\treturn 0;\n\t}\n\n\t/* The file will be extended, so let's see if there is enough space. */\n\tif (phys >= info->si_blocks)\n\t\treturn -ENOSPC;\n\n\t/* The rest has to be protected against itself. */\n\tmutex_lock(&info->bfs_lock);\n\n\t/*\n\t * If the last data block for this file is the last allocated\n\t * block, we can extend the file trivially, without moving it\n\t * anywhere.\n\t */\n\tif (bi->i_eblock == info->si_lf_eblk) {\n\t\tdprintf(\"c=%d, b=%08lx, phys=%08lx (simple extension)\\n\", \n\t\t\t\tcreate, (unsigned long)block, phys);\n\t\tmap_bh(bh_result, sb, phys);\n\t\tinfo->si_freeb -= phys - bi->i_eblock;\n\t\tinfo->si_lf_eblk = bi->i_eblock = phys;\n\t\tmark_inode_dirty(inode);\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t/* Ok, we have to move this entire file to the next free block. */\n\tphys = info->si_lf_eblk + 1;\n\tif (phys + block >= info->si_blocks) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tif (bi->i_sblock) {\n\t\terr = bfs_move_blocks(inode->i_sb, bi->i_sblock, \n\t\t\t\t\t\tbi->i_eblock, phys);\n\t\tif (err) {\n\t\t\tdprintf(\"failed to move ino=%08lx -> fs corruption\\n\",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\terr = 0;\n\n\tdprintf(\"c=%d, b=%08lx, phys=%08lx (moved)\\n\",\n                create, (unsigned long)block, phys);\n\tbi->i_sblock = phys;\n\tphys += block;\n\tinfo->si_lf_eblk = bi->i_eblock = phys;\n\n\t/*\n\t * This assumes nothing can write the inode back while we are here\n\t * and thus update inode->i_blocks! (XXX)\n\t */\n\tinfo->si_freeb -= bi->i_eblock - bi->i_sblock + 1 - inode->i_blocks;\n\tmark_inode_dirty(inode);\n\tmap_bh(bh_result, sb, phys);\nout:\n\tmutex_unlock(&info->bfs_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "bfs_move_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
    "lines": "50-63",
    "snippet": "static int bfs_move_blocks(struct super_block *sb, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long where)\n{\n\tunsigned long i;\n\n\tdprintf(\"%08lx-%08lx->%08lx\\n\", start, end, where);\n\tfor (i = start; i <= end; i++)\n\t\tif(bfs_move_block(i, where + i, sb)) {\n\t\t\tdprintf(\"failed to move block %08lx -> %08lx\\n\", i,\n\t\t\t\t\t\t\t\twhere + i);\n\t\t\treturn -EIO;\n\t\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"failed to move block %08lx -> %08lx\\n\"",
            "i",
            "where + i"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bfs_move_block",
          "args": [
            "i",
            "where + i",
            "sb"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "bfs_move_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
          "lines": "34-48",
          "snippet": "static int bfs_move_block(unsigned long from, unsigned long to,\n\t\t\t\t\tstruct super_block *sb)\n{\n\tstruct buffer_head *bh, *new;\n\n\tbh = sb_bread(sb, from);\n\tif (!bh)\n\t\treturn -EIO;\n\tnew = sb_getblk(sb, to);\n\tmemcpy(new->b_data, bh->b_data, bh->b_size);\n\tmark_buffer_dirty(new);\n\tbforget(bh);\n\tbrelse(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"bfs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int bfs_move_block(unsigned long from, unsigned long to,\n\t\t\t\t\tstruct super_block *sb)\n{\n\tstruct buffer_head *bh, *new;\n\n\tbh = sb_bread(sb, from);\n\tif (!bh)\n\t\treturn -EIO;\n\tnew = sb_getblk(sb, to);\n\tmemcpy(new->b_data, bh->b_data, bh->b_size);\n\tmark_buffer_dirty(new);\n\tbforget(bh);\n\tbrelse(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintf",
          "args": [
            "\"%08lx-%08lx->%08lx\\n\"",
            "start",
            "end",
            "where"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int bfs_move_blocks(struct super_block *sb, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long where)\n{\n\tunsigned long i;\n\n\tdprintf(\"%08lx-%08lx->%08lx\\n\", start, end, where);\n\tfor (i = start; i <= end; i++)\n\t\tif(bfs_move_block(i, where + i, sb)) {\n\t\t\tdprintf(\"failed to move block %08lx -> %08lx\\n\", i,\n\t\t\t\t\t\t\t\twhere + i);\n\t\t\treturn -EIO;\n\t\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "bfs_move_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bfs/file.c",
    "lines": "34-48",
    "snippet": "static int bfs_move_block(unsigned long from, unsigned long to,\n\t\t\t\t\tstruct super_block *sb)\n{\n\tstruct buffer_head *bh, *new;\n\n\tbh = sb_bread(sb, from);\n\tif (!bh)\n\t\treturn -EIO;\n\tnew = sb_getblk(sb, to);\n\tmemcpy(new->b_data, bh->b_data, bh->b_size);\n\tmark_buffer_dirty(new);\n\tbforget(bh);\n\tbrelse(new);\n\treturn 0;\n}",
    "includes": [
      "#include \"bfs.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bh"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "new"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->b_data",
            "bh->b_data",
            "bh->b_size"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "to"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "from"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bfs.h\"\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int bfs_move_block(unsigned long from, unsigned long to,\n\t\t\t\t\tstruct super_block *sb)\n{\n\tstruct buffer_head *bh, *new;\n\n\tbh = sb_bread(sb, from);\n\tif (!bh)\n\t\treturn -EIO;\n\tnew = sb_getblk(sb, to);\n\tmemcpy(new->b_data, bh->b_data, bh->b_size);\n\tmark_buffer_dirty(new);\n\tbforget(bh);\n\tbrelse(new);\n\treturn 0;\n}"
  }
]