[
  {
    "function_name": "ocfs2_local_alloc_slide_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "1250-1342",
    "snippet": "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode)\n{\n\tint status = 0;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\n\tocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_SLIDE);\n\n\t/* This will lock the main bitmap for us. */\n\tstatus = ocfs2_local_alloc_reserve_for_window(osb,\n\t\t\t\t\t\t      &ac,\n\t\t\t\t\t\t      &main_bm_inode,\n\t\t\t\t\t\t      &main_bm_bh);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n\t/* We want to clear the local alloc before doing anything\n\t * else, so that if we error later during this operation,\n\t * local alloc shutdown won't try to double free main bitmap\n\t * bits. Make a copy so the sync function knows which bits to\n\t * free. */\n\talloc_copy = kmalloc(osb->local_alloc_bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemcpy(alloc_copy, alloc, osb->local_alloc_bh->b_size);\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_local_alloc_new_window(osb, handle, ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_inc(&osb->alloc_stats.moves);\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tbrelse(main_bm_bh);\n\n\tif (main_bm_inode)\n\t\tiput(main_bm_inode);\n\n\tkfree(alloc_copy);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
      "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);",
      "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
      "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "ac"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "alloc_copy"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "main_bm_inode"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "main_bm_bh"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&osb->alloc_stats.moves"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_new_window",
          "args": [
            "osb",
            "handle",
            "ac"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_new_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "1162-1246",
          "snippet": "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac)\n{\n\tint status = 0;\n\tu32 cluster_off, cluster_count;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_local_alloc_new_window(\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tosb->local_alloc_bits);\n\n\t/* Instruct the allocation code to try the most recently used\n\t * cluster group. We'll re-record the group used this pass\n\t * below. */\n\tac->ac_last_group = osb->la_last_gd;\n\n\t/* we used the generic suballoc reserve function, but we set\n\t * everything up nicely, so there's no reason why we can't use\n\t * the more specific cluster api to claim bits. */\n\tstatus = ocfs2_claim_clusters(handle, ac, osb->local_alloc_bits,\n\t\t\t\t      &cluster_off, &cluster_count);\n\tif (status == -ENOSPC) {\nretry_enospc:\n\t\t/*\n\t\t * Note: We could also try syncing the journal here to\n\t\t * allow use of any free bits which the current\n\t\t * transaction can't give us access to. --Mark\n\t\t */\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_FRAGMENTED) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tac->ac_bits_wanted = osb->local_alloc_bits;\n\t\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t\t      osb->local_alloc_bits,\n\t\t\t\t\t      &cluster_off,\n\t\t\t\t\t      &cluster_count);\n\t\tif (status == -ENOSPC)\n\t\t\tgoto retry_enospc;\n\t\t/*\n\t\t * We only shrunk the *minimum* number of in our\n\t\t * request - it's entirely possible that the allocator\n\t\t * might give us more than we asked for.\n\t\t */\n\t\tif (status == 0) {\n\t\t\tspin_lock(&osb->osb_lock);\n\t\t\tosb->local_alloc_bits = cluster_count;\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->la_last_gd = ac->ac_last_group;\n\n\tla->la_bm_off = cpu_to_le32(cluster_off);\n\talloc->id1.bitmap1.i_total = cpu_to_le32(cluster_count);\n\t/* just in case... In the future when we find space ourselves,\n\t * we don't have to get all contiguous -- but we'll have to\n\t * set all previously used bits in bitmap and update\n\t * la_bits_set before setting the bits in the main bitmap. */\n\talloc->id1.bitmap1.i_used = 0;\n\tmemset(OCFS2_LOCAL_ALLOC(alloc)->la_bitmap, 0,\n\t       le16_to_cpu(la->la_size));\n\n\tocfs2_resmap_restart(&osb->osb_la_resmap, cluster_count,\n\t\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bitmap);\n\n\ttrace_ocfs2_local_alloc_new_window_result(\n\t\tOCFS2_LOCAL_ALLOC(alloc)->la_bm_off,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total));\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\n\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac)\n{\n\tint status = 0;\n\tu32 cluster_off, cluster_count;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_local_alloc_new_window(\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tosb->local_alloc_bits);\n\n\t/* Instruct the allocation code to try the most recently used\n\t * cluster group. We'll re-record the group used this pass\n\t * below. */\n\tac->ac_last_group = osb->la_last_gd;\n\n\t/* we used the generic suballoc reserve function, but we set\n\t * everything up nicely, so there's no reason why we can't use\n\t * the more specific cluster api to claim bits. */\n\tstatus = ocfs2_claim_clusters(handle, ac, osb->local_alloc_bits,\n\t\t\t\t      &cluster_off, &cluster_count);\n\tif (status == -ENOSPC) {\nretry_enospc:\n\t\t/*\n\t\t * Note: We could also try syncing the journal here to\n\t\t * allow use of any free bits which the current\n\t\t * transaction can't give us access to. --Mark\n\t\t */\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_FRAGMENTED) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tac->ac_bits_wanted = osb->local_alloc_bits;\n\t\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t\t      osb->local_alloc_bits,\n\t\t\t\t\t      &cluster_off,\n\t\t\t\t\t      &cluster_count);\n\t\tif (status == -ENOSPC)\n\t\t\tgoto retry_enospc;\n\t\t/*\n\t\t * We only shrunk the *minimum* number of in our\n\t\t * request - it's entirely possible that the allocator\n\t\t * might give us more than we asked for.\n\t\t */\n\t\tif (status == 0) {\n\t\t\tspin_lock(&osb->osb_lock);\n\t\t\tosb->local_alloc_bits = cluster_count;\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->la_last_gd = ac->ac_last_group;\n\n\tla->la_bm_off = cpu_to_le32(cluster_off);\n\talloc->id1.bitmap1.i_total = cpu_to_le32(cluster_count);\n\t/* just in case... In the future when we find space ourselves,\n\t * we don't have to get all contiguous -- but we'll have to\n\t * set all previously used bits in bitmap and update\n\t * la_bits_set before setting the bits in the main bitmap. */\n\talloc->id1.bitmap1.i_used = 0;\n\tmemset(OCFS2_LOCAL_ALLOC(alloc)->la_bitmap, 0,\n\t       le16_to_cpu(la->la_size));\n\n\tocfs2_resmap_restart(&osb->osb_la_resmap, cluster_count,\n\t\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bitmap);\n\n\ttrace_ocfs2_local_alloc_new_window_result(\n\t\tOCFS2_LOCAL_ALLOC(alloc)->la_bm_off,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total));\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sync_local_to_main",
          "args": [
            "osb",
            "handle",
            "alloc_copy",
            "main_bm_inode",
            "main_bm_bh"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_local_to_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "963-1031",
          "snippet": "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = bit_off = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\n\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = bit_off = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "osb->local_alloc_bh"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_local_alloc",
          "args": [
            "alloc"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_local_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "926-936",
          "snippet": "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(local_alloc_inode)",
            "osb->local_alloc_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "local_alloc_inode"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "alloc_copy",
            "alloc",
            "osb->local_alloc_bh->b_size"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "osb->local_alloc_bh->b_size",
            "GFP_NOFS"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_WINDOW_MOVE_CREDITS"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_reserve_for_window",
          "args": [
            "osb",
            "&ac",
            "&main_bm_inode",
            "&main_bm_bh"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_reserve_for_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "1112-1157",
          "snippet": "static int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nretry_enospc:\n\t(*ac)->ac_bits_wanted = osb->local_alloc_bits;\n\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\tif (status == -ENOSPC) {\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_ENOSPC) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tocfs2_free_ac_resource(*ac);\n\t\tmemset(*ac, 0, sizeof(struct ocfs2_alloc_context));\n\t\tgoto retry_enospc;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*bitmap_inode = (*ac)->ac_inode;\n\tigrab(*bitmap_inode);\n\t*bitmap_bh = (*ac)->ac_bh;\n\tget_bh(*bitmap_bh);\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\n\nstatic int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nretry_enospc:\n\t(*ac)->ac_bits_wanted = osb->local_alloc_bits;\n\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\tif (status == -ENOSPC) {\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_ENOSPC) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tocfs2_free_ac_resource(*ac);\n\t\tmemset(*ac, 0, sizeof(struct ocfs2_alloc_context));\n\t\tgoto retry_enospc;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*bitmap_inode = (*ac)->ac_inode;\n\tigrab(*bitmap_inode);\n\t*bitmap_bh = (*ac)->ac_bh;\n\tget_bh(*bitmap_bh);\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recalc_la_window",
          "args": [
            "osb",
            "OCFS2_LA_EVENT_SLIDE"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recalc_la_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "1055-1110",
          "snippet": "static int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * ENOSPC and fragmentation are treated similarly for now.\n\t */\n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t/*\n\t\t * We ran out of contiguous space in the primary\n\t\t * bitmap. Drastically reduce the number of bits used\n\t\t * by local alloc until we have to disable it.\n\t\t */\n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t/*\n\t\t\t * By setting state to THROTTLED, we'll keep\n\t\t\t * the number of local alloc bits used down\n\t\t\t * until an event occurs which would give us\n\t\t\t * reason to assume the bitmap situation might\n\t\t\t * have changed.\n\t\t\t */\n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Don't increase the size of the local alloc window until we\n\t * know we might be able to fulfill the request. Otherwise, we\n\t * risk bouncing around the global bitmap during periods of\n\t * low space.\n\t */\n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)"
          ],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * ENOSPC and fragmentation are treated similarly for now.\n\t */\n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t/*\n\t\t * We ran out of contiguous space in the primary\n\t\t * bitmap. Drastically reduce the number of bits used\n\t\t * by local alloc until we have to disable it.\n\t\t */\n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t/*\n\t\t\t * By setting state to THROTTLED, we'll keep\n\t\t\t * the number of local alloc bits used down\n\t\t\t * until an event occurs which would give us\n\t\t\t * reason to assume the bitmap situation might\n\t\t\t * have changed.\n\t\t\t */\n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Don't increase the size of the local alloc window until we\n\t * know we might be able to fulfill the request. Otherwise, we\n\t * risk bouncing around the global bitmap during periods of\n\t * low space.\n\t */\n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode)\n{\n\tint status = 0;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\n\tocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_SLIDE);\n\n\t/* This will lock the main bitmap for us. */\n\tstatus = ocfs2_local_alloc_reserve_for_window(osb,\n\t\t\t\t\t\t      &ac,\n\t\t\t\t\t\t      &main_bm_inode,\n\t\t\t\t\t\t      &main_bm_bh);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n\t/* We want to clear the local alloc before doing anything\n\t * else, so that if we error later during this operation,\n\t * local alloc shutdown won't try to double free main bitmap\n\t * bits. Make a copy so the sync function knows which bits to\n\t * free. */\n\talloc_copy = kmalloc(osb->local_alloc_bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemcpy(alloc_copy, alloc, osb->local_alloc_bh->b_size);\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_local_alloc_new_window(osb, handle, ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_inc(&osb->alloc_stats.moves);\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tbrelse(main_bm_bh);\n\n\tif (main_bm_inode)\n\t\tiput(main_bm_inode);\n\n\tkfree(alloc_copy);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_local_alloc_new_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "1162-1246",
    "snippet": "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac)\n{\n\tint status = 0;\n\tu32 cluster_off, cluster_count;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_local_alloc_new_window(\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tosb->local_alloc_bits);\n\n\t/* Instruct the allocation code to try the most recently used\n\t * cluster group. We'll re-record the group used this pass\n\t * below. */\n\tac->ac_last_group = osb->la_last_gd;\n\n\t/* we used the generic suballoc reserve function, but we set\n\t * everything up nicely, so there's no reason why we can't use\n\t * the more specific cluster api to claim bits. */\n\tstatus = ocfs2_claim_clusters(handle, ac, osb->local_alloc_bits,\n\t\t\t\t      &cluster_off, &cluster_count);\n\tif (status == -ENOSPC) {\nretry_enospc:\n\t\t/*\n\t\t * Note: We could also try syncing the journal here to\n\t\t * allow use of any free bits which the current\n\t\t * transaction can't give us access to. --Mark\n\t\t */\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_FRAGMENTED) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tac->ac_bits_wanted = osb->local_alloc_bits;\n\t\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t\t      osb->local_alloc_bits,\n\t\t\t\t\t      &cluster_off,\n\t\t\t\t\t      &cluster_count);\n\t\tif (status == -ENOSPC)\n\t\t\tgoto retry_enospc;\n\t\t/*\n\t\t * We only shrunk the *minimum* number of in our\n\t\t * request - it's entirely possible that the allocator\n\t\t * might give us more than we asked for.\n\t\t */\n\t\tif (status == 0) {\n\t\t\tspin_lock(&osb->osb_lock);\n\t\t\tosb->local_alloc_bits = cluster_count;\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->la_last_gd = ac->ac_last_group;\n\n\tla->la_bm_off = cpu_to_le32(cluster_off);\n\talloc->id1.bitmap1.i_total = cpu_to_le32(cluster_count);\n\t/* just in case... In the future when we find space ourselves,\n\t * we don't have to get all contiguous -- but we'll have to\n\t * set all previously used bits in bitmap and update\n\t * la_bits_set before setting the bits in the main bitmap. */\n\talloc->id1.bitmap1.i_used = 0;\n\tmemset(OCFS2_LOCAL_ALLOC(alloc)->la_bitmap, 0,\n\t       le16_to_cpu(la->la_size));\n\n\tocfs2_resmap_restart(&osb->osb_la_resmap, cluster_count,\n\t\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bitmap);\n\n\ttrace_ocfs2_local_alloc_new_window_result(\n\t\tOCFS2_LOCAL_ALLOC(alloc)->la_bm_off,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total));\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
      "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_local_alloc_new_window_result",
          "args": [
            "OCFS2_LOCAL_ALLOC(alloc)->la_bm_off",
            "le32_to_cpu(alloc->id1.bitmap1.i_total)"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "alloc->id1.bitmap1.i_total"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_restart",
          "args": [
            "&osb->osb_la_resmap",
            "cluster_count",
            "OCFS2_LOCAL_ALLOC(alloc)->la_bitmap"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "294-307",
          "snippet": "void ocfs2_resmap_restart(struct ocfs2_reservation_map *resmap,\n\t\t\t  unsigned int clen, char *disk_bitmap)\n{\n\tif (ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tspin_lock(&resv_lock);\n\n\tocfs2_resmap_clear_all_resv(resmap);\n\tresmap->m_bitmap_len = clen;\n\tresmap->m_disk_bitmap = disk_bitmap;\n\n\tspin_unlock(&resv_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nvoid ocfs2_resmap_restart(struct ocfs2_reservation_map *resmap,\n\t\t\t  unsigned int clen, char *disk_bitmap)\n{\n\tif (ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tspin_lock(&resv_lock);\n\n\tocfs2_resmap_clear_all_resv(resmap);\n\tresmap->m_bitmap_len = clen;\n\tresmap->m_disk_bitmap = disk_bitmap;\n\n\tspin_unlock(&resv_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "OCFS2_LOCAL_ALLOC(alloc)->la_bitmap",
            "0",
            "le16_to_cpu(la->la_size)"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "la->la_size"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cluster_count"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cluster_off"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_clusters",
          "args": [
            "handle",
            "ac",
            "osb->local_alloc_bits",
            "&cluster_off",
            "&cluster_count"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2373-2383",
          "snippet": "int ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_clusters(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 min_clusters,\n\t\t\t u32 *cluster_start,\n\t\t\t u32 *num_clusters)\n{\n\tunsigned int bits_wanted = ac->ac_bits_wanted - ac->ac_bits_given;\n\n\treturn __ocfs2_claim_clusters(handle, ac, min_clusters,\n\t\t\t\t      bits_wanted, cluster_start, num_clusters);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recalc_la_window",
          "args": [
            "osb",
            "OCFS2_LA_EVENT_FRAGMENTED"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recalc_la_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "1055-1110",
          "snippet": "static int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * ENOSPC and fragmentation are treated similarly for now.\n\t */\n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t/*\n\t\t * We ran out of contiguous space in the primary\n\t\t * bitmap. Drastically reduce the number of bits used\n\t\t * by local alloc until we have to disable it.\n\t\t */\n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t/*\n\t\t\t * By setting state to THROTTLED, we'll keep\n\t\t\t * the number of local alloc bits used down\n\t\t\t * until an event occurs which would give us\n\t\t\t * reason to assume the bitmap situation might\n\t\t\t * have changed.\n\t\t\t */\n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Don't increase the size of the local alloc window until we\n\t * know we might be able to fulfill the request. Otherwise, we\n\t * risk bouncing around the global bitmap during periods of\n\t * low space.\n\t */\n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)"
          ],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * ENOSPC and fragmentation are treated similarly for now.\n\t */\n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t/*\n\t\t * We ran out of contiguous space in the primary\n\t\t * bitmap. Drastically reduce the number of bits used\n\t\t * by local alloc until we have to disable it.\n\t\t */\n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t/*\n\t\t\t * By setting state to THROTTLED, we'll keep\n\t\t\t * the number of local alloc bits used down\n\t\t\t * until an event occurs which would give us\n\t\t\t * reason to assume the bitmap situation might\n\t\t\t * have changed.\n\t\t\t */\n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Don't increase the size of the local alloc window until we\n\t * know we might be able to fulfill the request. Otherwise, we\n\t * risk bouncing around the global bitmap during periods of\n\t * low space.\n\t */\n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_local_alloc_new_window",
          "args": [
            "le32_to_cpu(alloc->id1.bitmap1.i_total)",
            "osb->local_alloc_bits"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\n\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac)\n{\n\tint status = 0;\n\tu32 cluster_off, cluster_count;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_local_alloc_new_window(\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tosb->local_alloc_bits);\n\n\t/* Instruct the allocation code to try the most recently used\n\t * cluster group. We'll re-record the group used this pass\n\t * below. */\n\tac->ac_last_group = osb->la_last_gd;\n\n\t/* we used the generic suballoc reserve function, but we set\n\t * everything up nicely, so there's no reason why we can't use\n\t * the more specific cluster api to claim bits. */\n\tstatus = ocfs2_claim_clusters(handle, ac, osb->local_alloc_bits,\n\t\t\t\t      &cluster_off, &cluster_count);\n\tif (status == -ENOSPC) {\nretry_enospc:\n\t\t/*\n\t\t * Note: We could also try syncing the journal here to\n\t\t * allow use of any free bits which the current\n\t\t * transaction can't give us access to. --Mark\n\t\t */\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_FRAGMENTED) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tac->ac_bits_wanted = osb->local_alloc_bits;\n\t\tstatus = ocfs2_claim_clusters(handle, ac,\n\t\t\t\t\t      osb->local_alloc_bits,\n\t\t\t\t\t      &cluster_off,\n\t\t\t\t\t      &cluster_count);\n\t\tif (status == -ENOSPC)\n\t\t\tgoto retry_enospc;\n\t\t/*\n\t\t * We only shrunk the *minimum* number of in our\n\t\t * request - it's entirely possible that the allocator\n\t\t * might give us more than we asked for.\n\t\t */\n\t\tif (status == 0) {\n\t\t\tspin_lock(&osb->osb_lock);\n\t\t\tosb->local_alloc_bits = cluster_count;\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->la_last_gd = ac->ac_last_group;\n\n\tla->la_bm_off = cpu_to_le32(cluster_off);\n\talloc->id1.bitmap1.i_total = cpu_to_le32(cluster_count);\n\t/* just in case... In the future when we find space ourselves,\n\t * we don't have to get all contiguous -- but we'll have to\n\t * set all previously used bits in bitmap and update\n\t * la_bits_set before setting the bits in the main bitmap. */\n\talloc->id1.bitmap1.i_used = 0;\n\tmemset(OCFS2_LOCAL_ALLOC(alloc)->la_bitmap, 0,\n\t       le16_to_cpu(la->la_size));\n\n\tocfs2_resmap_restart(&osb->osb_la_resmap, cluster_count,\n\t\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bitmap);\n\n\ttrace_ocfs2_local_alloc_new_window_result(\n\t\tOCFS2_LOCAL_ALLOC(alloc)->la_bm_off,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total));\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_local_alloc_reserve_for_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "1112-1157",
    "snippet": "static int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nretry_enospc:\n\t(*ac)->ac_bits_wanted = osb->local_alloc_bits;\n\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\tif (status == -ENOSPC) {\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_ENOSPC) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tocfs2_free_ac_resource(*ac);\n\t\tmemset(*ac, 0, sizeof(struct ocfs2_alloc_context));\n\t\tgoto retry_enospc;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*bitmap_inode = (*ac)->ac_inode;\n\tigrab(*bitmap_inode);\n\t*bitmap_bh = (*ac)->ac_bh;\n\tget_bh(*bitmap_bh);\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh);",
      "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*ac"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "*bitmap_bh"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "*bitmap_inode"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*ac",
            "0",
            "sizeof(struct ocfs2_alloc_context)"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_ac_resource",
          "args": [
            "*ac"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_ac_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "136-156",
          "snippet": "void ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_ac_resource(struct ocfs2_alloc_context *ac)\n{\n\tstruct inode *inode = ac->ac_inode;\n\n\tif (inode) {\n\t\tif (ac->ac_which != OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\n\t\tmutex_unlock(&inode->i_mutex);\n\n\t\tiput(inode);\n\t\tac->ac_inode = NULL;\n\t}\n\tbrelse(ac->ac_bh);\n\tac->ac_bh = NULL;\n\tac->ac_resv = NULL;\n\tif (ac->ac_find_loc_priv) {\n\t\tkfree(ac->ac_find_loc_priv);\n\t\tac->ac_find_loc_priv = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recalc_la_window",
          "args": [
            "osb",
            "OCFS2_LA_EVENT_ENOSPC"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recalc_la_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "1055-1110",
          "snippet": "static int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * ENOSPC and fragmentation are treated similarly for now.\n\t */\n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t/*\n\t\t * We ran out of contiguous space in the primary\n\t\t * bitmap. Drastically reduce the number of bits used\n\t\t * by local alloc until we have to disable it.\n\t\t */\n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t/*\n\t\t\t * By setting state to THROTTLED, we'll keep\n\t\t\t * the number of local alloc bits used down\n\t\t\t * until an event occurs which would give us\n\t\t\t * reason to assume the bitmap situation might\n\t\t\t * have changed.\n\t\t\t */\n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Don't increase the size of the local alloc window until we\n\t * know we might be able to fulfill the request. Otherwise, we\n\t * risk bouncing around the global bitmap during periods of\n\t * low space.\n\t */\n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)"
          ],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * ENOSPC and fragmentation are treated similarly for now.\n\t */\n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t/*\n\t\t * We ran out of contiguous space in the primary\n\t\t * bitmap. Drastically reduce the number of bits used\n\t\t * by local alloc until we have to disable it.\n\t\t */\n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t/*\n\t\t\t * By setting state to THROTTLED, we'll keep\n\t\t\t * the number of local alloc bits used down\n\t\t\t * until an event occurs which would give us\n\t\t\t * reason to assume the bitmap situation might\n\t\t\t * have changed.\n\t\t\t */\n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Don't increase the size of the local alloc window until we\n\t * know we might be able to fulfill the request. Otherwise, we\n\t * risk bouncing around the global bitmap during periods of\n\t * low space.\n\t */\n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_cluster_bitmap_bits",
          "args": [
            "osb",
            "*ac"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_cluster_bitmap_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1154-1173",
          "snippet": "int ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\n\tac->ac_which = OCFS2_AC_USE_MAIN;\n\tac->ac_group_search = ocfs2_cluster_group_search;\n\n\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t     GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t     OCFS2_INVALID_SLOT, NULL,\n\t\t\t\t\t     ALLOC_NEW_GROUP);\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_cluster_bitmap_bits(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\n\tac->ac_which = OCFS2_AC_USE_MAIN;\n\tac->ac_group_search = ocfs2_cluster_group_search;\n\n\tstatus = ocfs2_reserve_suballoc_bits(osb, ac,\n\t\t\t\t\t     GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t     OCFS2_INVALID_SLOT, NULL,\n\t\t\t\t\t     ALLOC_NEW_GROUP);\n\tif (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_alloc_context)",
            "GFP_KERNEL"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\n\nstatic int ocfs2_local_alloc_reserve_for_window(struct ocfs2_super *osb,\n\t\t\t\t\t\tstruct ocfs2_alloc_context **ac,\n\t\t\t\t\t\tstruct inode **bitmap_inode,\n\t\t\t\t\t\tstruct buffer_head **bitmap_bh)\n{\n\tint status;\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nretry_enospc:\n\t(*ac)->ac_bits_wanted = osb->local_alloc_bits;\n\tstatus = ocfs2_reserve_cluster_bitmap_bits(osb, *ac);\n\tif (status == -ENOSPC) {\n\t\tif (ocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_ENOSPC) ==\n\t\t    OCFS2_LA_DISABLED)\n\t\t\tgoto bail;\n\n\t\tocfs2_free_ac_resource(*ac);\n\t\tmemset(*ac, 0, sizeof(struct ocfs2_alloc_context));\n\t\tgoto retry_enospc;\n\t}\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*bitmap_inode = (*ac)->ac_inode;\n\tigrab(*bitmap_inode);\n\t*bitmap_bh = (*ac)->ac_bh;\n\tget_bh(*bitmap_bh);\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_recalc_la_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "1055-1110",
    "snippet": "static int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * ENOSPC and fragmentation are treated similarly for now.\n\t */\n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t/*\n\t\t * We ran out of contiguous space in the primary\n\t\t * bitmap. Drastically reduce the number of bits used\n\t\t * by local alloc until we have to disable it.\n\t\t */\n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t/*\n\t\t\t * By setting state to THROTTLED, we'll keep\n\t\t\t * the number of local alloc bits used down\n\t\t\t * until an event occurs which would give us\n\t\t\t * reason to assume the bitmap situation might\n\t\t\t * have changed.\n\t\t\t */\n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Don't increase the size of the local alloc window until we\n\t * know we might be able to fulfill the request. Otherwise, we\n\t * risk bouncing around the global bitmap during periods of\n\t * low space.\n\t */\n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)"
    ],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "ocfs2_wq",
            "&osb->la_enable_wq",
            "OCFS2_LA_ENABLE_INTERVAL"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_megabytes_to_clusters",
          "args": [
            "osb->sb",
            "1"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_megabytes_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "842-848",
          "snippet": "static inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int megs)\n{\n\tBUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);\n\n\treturn megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int megs)\n{\n\tBUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);\n\n\treturn megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "osb->local_alloc_state == OCFS2_LA_DISABLED"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_LA_ENABLE_INTERVAL (30 * HZ)\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic int ocfs2_recalc_la_window(struct ocfs2_super *osb,\n\t\t\t\t  enum ocfs2_la_event event)\n{\n\tunsigned int bits;\n\tint state;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED) {\n\t\tWARN_ON_ONCE(osb->local_alloc_state == OCFS2_LA_DISABLED);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * ENOSPC and fragmentation are treated similarly for now.\n\t */\n\tif (event == OCFS2_LA_EVENT_ENOSPC ||\n\t    event == OCFS2_LA_EVENT_FRAGMENTED) {\n\t\t/*\n\t\t * We ran out of contiguous space in the primary\n\t\t * bitmap. Drastically reduce the number of bits used\n\t\t * by local alloc until we have to disable it.\n\t\t */\n\t\tbits = osb->local_alloc_bits >> 1;\n\t\tif (bits > ocfs2_megabytes_to_clusters(osb->sb, 1)) {\n\t\t\t/*\n\t\t\t * By setting state to THROTTLED, we'll keep\n\t\t\t * the number of local alloc bits used down\n\t\t\t * until an event occurs which would give us\n\t\t\t * reason to assume the bitmap situation might\n\t\t\t * have changed.\n\t\t\t */\n\t\t\tosb->local_alloc_state = OCFS2_LA_THROTTLED;\n\t\t\tosb->local_alloc_bits = bits;\n\t\t} else {\n\t\t\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\t\t}\n\t\tqueue_delayed_work(ocfs2_wq, &osb->la_enable_wq,\n\t\t\t\t   OCFS2_LA_ENABLE_INTERVAL);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Don't increase the size of the local alloc window until we\n\t * know we might be able to fulfill the request. Otherwise, we\n\t * risk bouncing around the global bitmap during periods of\n\t * low space.\n\t */\n\tif (osb->local_alloc_state != OCFS2_LA_THROTTLED)\n\t\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n\nout_unlock:\n\tstate = osb->local_alloc_state;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn state;\n}"
  },
  {
    "function_name": "ocfs2_sync_local_to_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "963-1031",
    "snippet": "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = bit_off = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
      "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_release_clusters",
          "args": [
            "handle",
            "main_bm_inode",
            "main_bm_bh",
            "blkno",
            "count"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_release_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2606-2615",
          "snippet": "int ocfs2_release_clusters(handle_t *handle,\n\t\t\t   struct inode *bitmap_inode,\n\t\t\t   struct buffer_head *bitmap_bh,\n\t\t\t   u64 start_blk,\n\t\t\t   unsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_clear_bit);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_release_clusters(handle_t *handle,\n\t\t\t   struct inode *bitmap_inode,\n\t\t\t   struct buffer_head *bitmap_bh,\n\t\t\t   u64 start_blk,\n\t\t\t   unsigned int num_clusters)\n{\n\treturn _ocfs2_free_clusters(handle, bitmap_inode, bitmap_bh,\n\t\t\t\t    start_blk, num_clusters,\n\t\t\t\t    _ocfs2_clear_bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_sync_local_to_main_free",
          "args": [
            "count",
            "start - count",
            "(unsigned long long)la_start_blk",
            "(unsigned long long)blkno"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "osb->sb",
            "start - count"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_zero_bit",
          "args": [
            "bitmap",
            "left",
            "start"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "alloc->id1.bitmap1.i_total"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_sync_local_to_main",
          "args": [
            "le32_to_cpu(alloc->id1.bitmap1.i_total)",
            "le32_to_cpu(alloc->id1.bitmap1.i_used)"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\n\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = bit_off = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_verify_zero_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "940-954",
    "snippet": "static void ocfs2_verify_zero_bits(unsigned long *bitmap,\n\t\t\t\t   unsigned int start,\n\t\t\t\t   unsigned int count)\n{\n\tunsigned int tmp = count;\n\twhile(tmp--) {\n\t\tif (ocfs2_test_bit(start + tmp, bitmap)) {\n\t\t\tprintk(\"ocfs2_verify_zero_bits: start = %u, count = \"\n\t\t\t       \"%u\\n\", start, count);\n\t\t\tprintk(\"ocfs2_verify_zero_bits: bit %u is set!\",\n\t\t\t       start + tmp);\n\t\t\tBUG();\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ocfs2_verify_zero_bits: bit %u is set!\"",
            "start + tmp"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_test_bit",
          "args": [
            "start + tmp",
            "bitmap"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_verify_zero_bits(unsigned long *bitmap,\n\t\t\t\t   unsigned int start,\n\t\t\t\t   unsigned int count)\n{\n\tunsigned int tmp = count;\n\twhile(tmp--) {\n\t\tif (ocfs2_test_bit(start + tmp, bitmap)) {\n\t\t\tprintk(\"ocfs2_verify_zero_bits: start = %u, count = \"\n\t\t\t       \"%u\\n\", start, count);\n\t\t\tprintk(\"ocfs2_verify_zero_bits: bit %u is set!\",\n\t\t\t       start + tmp);\n\t\t\tBUG();\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ocfs2_clear_local_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "926-936",
    "snippet": "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "la->la_size"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}"
  },
  {
    "function_name": "ocfs2_local_alloc_find_clear_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "837-924",
    "snippet": "static int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t     u32 *numbits,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv)\n{\n\tint numfound, bitoff, left, startoff, lastzero;\n\tint local_resv = 0;\n\tstruct ocfs2_alloc_reservation r;\n\tvoid *bitmap = NULL;\n\tstruct ocfs2_reservation_map *resmap = &osb->osb_la_resmap;\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tbitoff = -1;\n\t\tgoto bail;\n\t}\n\n\tif (!resv) {\n\t\tlocal_resv = 1;\n\t\tocfs2_resv_init_once(&r);\n\t\tocfs2_resv_set_type(&r, OCFS2_RESV_FLAG_TMP);\n\t\tresv = &r;\n\t}\n\n\tnumfound = *numbits;\n\tif (ocfs2_resmap_resv_bits(resmap, resv, &bitoff, &numfound) == 0) {\n\t\tif (numfound < *numbits)\n\t\t\t*numbits = numfound;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Code error. While reservations are enabled, local\n\t * allocation should _always_ go through them.\n\t */\n\tBUG_ON(osb->osb_resv_level != 0);\n\n\t/*\n\t * Reservations are disabled. Handle this the old way.\n\t */\n\n\tbitmap = OCFS2_LOCAL_ALLOC(alloc)->la_bitmap;\n\n\tnumfound = bitoff = startoff = 0;\n\tlastzero = -1;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\twhile ((bitoff = ocfs2_find_next_zero_bit(bitmap, left, startoff)) != -1) {\n\t\tif (bitoff == left) {\n\t\t\t/* mlog(0, \"bitoff (%d) == left\", bitoff); */\n\t\t\tbreak;\n\t\t}\n\t\t/* mlog(0, \"Found a zero: bitoff = %d, startoff = %d, \"\n\t\t   \"numfound = %d\\n\", bitoff, startoff, numfound);*/\n\n\t\t/* Ok, we found a zero bit... is it contig. or do we\n\t\t * start over?*/\n\t\tif (bitoff == startoff) {\n\t\t\t/* we found a zero */\n\t\t\tnumfound++;\n\t\t\tstartoff++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tnumfound = 1;\n\t\t\tstartoff = bitoff+1;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (numfound == *numbits) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttrace_ocfs2_local_alloc_find_clear_bits_search_bitmap(bitoff, numfound);\n\n\tif (numfound == *numbits)\n\t\tbitoff = startoff - numfound;\n\telse\n\t\tbitoff = -1;\n\nbail:\n\tif (local_resv)\n\t\tocfs2_resv_discard(resmap, resv);\n\n\ttrace_ocfs2_local_alloc_find_clear_bits(*numbits,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tbitoff, numfound);\n\n\treturn bitoff;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t\t     u32 *numbits,\n\t\t\t\t\t     struct ocfs2_alloc_reservation *resv);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_local_alloc_find_clear_bits",
          "args": [
            "*numbits",
            "le32_to_cpu(alloc->id1.bitmap1.i_total)",
            "bitoff",
            "numfound"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "alloc->id1.bitmap1.i_total"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_discard",
          "args": [
            "resmap",
            "resv"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "270-278",
          "snippet": "void ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nvoid ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_local_alloc_find_clear_bits_search_bitmap",
          "args": [
            "bitoff",
            "numfound"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_zero_bit",
          "args": [
            "bitmap",
            "left",
            "startoff"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "904-916",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "osb->osb_resv_level != 0"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_resv_bits",
          "args": [
            "resmap",
            "resv",
            "&bitoff",
            "&numfound"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_resv_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "727-765",
          "snippet": "int ocfs2_resmap_resv_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t   int *cstart, int *clen)\n{\n\tif (resv == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn -ENOSPC;\n\n\tspin_lock(&resv_lock);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t/*\n\t\t * We don't want to over-allocate for temporary\n\t\t * windows. Otherwise, we run the risk of fragmenting the\n\t\t * allocation space.\n\t\t */\n\t\tunsigned int wanted = ocfs2_resv_window_bits(resmap, resv);\n\n\t\tif ((resv->r_flags & OCFS2_RESV_FLAG_TMP) || wanted < *clen)\n\t\t\twanted = *clen;\n\n\t\t/*\n\t\t * Try to get a window here. If it works, we must fall\n\t\t * through and test the bitmap . This avoids some\n\t\t * ping-ponging of windows due to non-reserved space\n\t\t * being allocation before we initialize a window for\n\t\t * that inode.\n\t\t */\n\t\tocfs2_resv_find_window(resmap, resv, wanted);\n\t\ttrace_ocfs2_resmap_resv_bits(resv->r_start, resv->r_len);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n\n\t*cstart = resv->r_start;\n\t*clen = resv->r_len;\n\n\tspin_unlock(&resv_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nint ocfs2_resmap_resv_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t   struct ocfs2_alloc_reservation *resv,\n\t\t\t   int *cstart, int *clen)\n{\n\tif (resv == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn -ENOSPC;\n\n\tspin_lock(&resv_lock);\n\n\tif (ocfs2_resv_empty(resv)) {\n\t\t/*\n\t\t * We don't want to over-allocate for temporary\n\t\t * windows. Otherwise, we run the risk of fragmenting the\n\t\t * allocation space.\n\t\t */\n\t\tunsigned int wanted = ocfs2_resv_window_bits(resmap, resv);\n\n\t\tif ((resv->r_flags & OCFS2_RESV_FLAG_TMP) || wanted < *clen)\n\t\t\twanted = *clen;\n\n\t\t/*\n\t\t * Try to get a window here. If it works, we must fall\n\t\t * through and test the bitmap . This avoids some\n\t\t * ping-ponging of windows due to non-reserved space\n\t\t * being allocation before we initialize a window for\n\t\t * that inode.\n\t\t */\n\t\tocfs2_resv_find_window(resmap, resv, wanted);\n\t\ttrace_ocfs2_resmap_resv_bits(resv->r_start, resv->r_len);\n\t}\n\n\tBUG_ON(ocfs2_resv_empty(resv));\n\n\t*cstart = resv->r_start;\n\t*clen = resv->r_len;\n\n\tspin_unlock(&resv_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_set_type",
          "args": [
            "&r",
            "OCFS2_RESV_FLAG_TMP"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "206-212",
          "snippet": "void ocfs2_resv_set_type(struct ocfs2_alloc_reservation *resv,\n\t\t\t unsigned int flags)\n{\n\tBUG_ON(flags & ~OCFS2_RESV_TYPES);\n\n\tresv->r_flags |= flags;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resv_set_type(struct ocfs2_alloc_reservation *resv,\n\t\t\t unsigned int flags)\n{\n\tBUG_ON(flags & ~OCFS2_RESV_TYPES);\n\n\tresv->r_flags |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_init_once",
          "args": [
            "&r"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "200-204",
          "snippet": "void ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resv_init_once(struct ocfs2_alloc_reservation *resv)\n{\n\tmemset(resv, 0, sizeof(*resv));\n\tINIT_LIST_HEAD(&resv->r_lru);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t\t     u32 *numbits,\n\t\t\t\t\t     struct ocfs2_alloc_reservation *resv);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t     u32 *numbits,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv)\n{\n\tint numfound, bitoff, left, startoff, lastzero;\n\tint local_resv = 0;\n\tstruct ocfs2_alloc_reservation r;\n\tvoid *bitmap = NULL;\n\tstruct ocfs2_reservation_map *resmap = &osb->osb_la_resmap;\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tbitoff = -1;\n\t\tgoto bail;\n\t}\n\n\tif (!resv) {\n\t\tlocal_resv = 1;\n\t\tocfs2_resv_init_once(&r);\n\t\tocfs2_resv_set_type(&r, OCFS2_RESV_FLAG_TMP);\n\t\tresv = &r;\n\t}\n\n\tnumfound = *numbits;\n\tif (ocfs2_resmap_resv_bits(resmap, resv, &bitoff, &numfound) == 0) {\n\t\tif (numfound < *numbits)\n\t\t\t*numbits = numfound;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Code error. While reservations are enabled, local\n\t * allocation should _always_ go through them.\n\t */\n\tBUG_ON(osb->osb_resv_level != 0);\n\n\t/*\n\t * Reservations are disabled. Handle this the old way.\n\t */\n\n\tbitmap = OCFS2_LOCAL_ALLOC(alloc)->la_bitmap;\n\n\tnumfound = bitoff = startoff = 0;\n\tlastzero = -1;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\twhile ((bitoff = ocfs2_find_next_zero_bit(bitmap, left, startoff)) != -1) {\n\t\tif (bitoff == left) {\n\t\t\t/* mlog(0, \"bitoff (%d) == left\", bitoff); */\n\t\t\tbreak;\n\t\t}\n\t\t/* mlog(0, \"Found a zero: bitoff = %d, startoff = %d, \"\n\t\t   \"numfound = %d\\n\", bitoff, startoff, numfound);*/\n\n\t\t/* Ok, we found a zero bit... is it contig. or do we\n\t\t * start over?*/\n\t\tif (bitoff == startoff) {\n\t\t\t/* we found a zero */\n\t\t\tnumfound++;\n\t\t\tstartoff++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tnumfound = 1;\n\t\t\tstartoff = bitoff+1;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (numfound == *numbits) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttrace_ocfs2_local_alloc_find_clear_bits_search_bitmap(bitoff, numfound);\n\n\tif (numfound == *numbits)\n\t\tbitoff = startoff - numfound;\n\telse\n\t\tbitoff = -1;\n\nbail:\n\tif (local_resv)\n\t\tocfs2_resv_discard(resmap, resv);\n\n\ttrace_ocfs2_local_alloc_find_clear_bits(*numbits,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tbitoff, numfound);\n\n\treturn bitoff;\n}"
  },
  {
    "function_name": "ocfs2_local_alloc_count_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "826-835",
    "snippet": "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc)\n{\n\tu32 count;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\tcount = memweight(la->la_bitmap, le16_to_cpu(la->la_size));\n\n\ttrace_ocfs2_local_alloc_count_bits(count);\n\treturn count;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_local_alloc_count_bits",
          "args": [
            "count"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memweight",
          "args": [
            "la->la_bitmap",
            "le16_to_cpu(la->la_size)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "la->la_size"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc)\n{\n\tu32 count;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\tcount = memweight(la->la_bitmap, le16_to_cpu(la->la_size));\n\n\ttrace_ocfs2_local_alloc_count_bits(count);\n\treturn count;\n}"
  },
  {
    "function_name": "ocfs2_free_local_alloc_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "784-824",
    "snippet": "int ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
      "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
      "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "osb->local_alloc_bh"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&alloc->id1.bitmap1.i_used",
            "-num_bits"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_bit",
          "args": [
            "start++",
            "bitmap"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(local_alloc_inode)",
            "osb->local_alloc_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "local_alloc_inode"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "la->la_bm_off"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_which != OCFS2_AC_USE_LOCAL"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_free_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\thandle_t *handle,\n\t\t\t\tstruct ocfs2_alloc_context *ac,\n\t\t\t\tu32 bit_off,\n\t\t\t\tu32 num_bits)\n{\n\tint status, start;\n\tu32 clear_bits;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tbitmap = la->la_bitmap;\n\tstart = bit_off - le32_to_cpu(la->la_bm_off);\n\tclear_bits = num_bits;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(local_alloc_inode),\n\t\t\tosb->local_alloc_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\twhile (clear_bits--)\n\t\tocfs2_clear_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, -num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_claim_local_alloc_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "728-782",
    "snippet": "int ocfs2_claim_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u32 bits_wanted,\n\t\t\t\t u32 *bit_off,\n\t\t\t\t u32 *num_bits)\n{\n\tint status, start;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tstart = ocfs2_local_alloc_find_clear_bits(osb, alloc, &bits_wanted,\n\t\t\t\t\t\t  ac->ac_resv);\n\tif (start == -1) {\n\t\t/* TODO: Shouldn't we just BUG here? */\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbitmap = la->la_bitmap;\n\t*bit_off = le32_to_cpu(la->la_bm_off) + start;\n\t*num_bits = bits_wanted;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_resmap_claimed_bits(&osb->osb_la_resmap, ac->ac_resv, start,\n\t\t\t\t  bits_wanted);\n\n\twhile(bits_wanted--)\n\t\tocfs2_set_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, *num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
      "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
      "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "osb->local_alloc_bh"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&alloc->id1.bitmap1.i_used",
            "*num_bits"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_bit",
          "args": [
            "start++",
            "bitmap"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_claimed_bits",
          "args": [
            "&osb->osb_la_resmap",
            "ac->ac_resv",
            "start",
            "bits_wanted"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_claimed_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "796-839",
          "snippet": "void ocfs2_resmap_claimed_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t       struct ocfs2_alloc_reservation *resv,\n\t\t\t       u32 cstart, u32 clen)\n{\n\tunsigned int cend = cstart + clen - 1;\n\n\tif (resmap == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tif (resv == NULL)\n\t\treturn;\n\n\tBUG_ON(cstart != resv->r_start);\n\n\tspin_lock(&resv_lock);\n\n\ttrace_ocfs2_resmap_claimed_bits_begin(cstart, cend, clen, resv->r_start,\n\t\t\t\t\t      ocfs2_resv_end(resv), resv->r_len,\n\t\t\t\t\t      resv->r_last_start,\n\t\t\t\t\t      resv->r_last_len);\n\n\tBUG_ON(cstart < resv->r_start);\n\tBUG_ON(cstart > ocfs2_resv_end(resv));\n\tBUG_ON(cend > ocfs2_resv_end(resv));\n\n\tocfs2_adjust_resv_from_alloc(resmap, resv, cstart, cend);\n\tresv->r_last_start = cstart;\n\tresv->r_last_len = clen;\n\n\t/*\n\t * May have been discarded above from\n\t * ocfs2_adjust_resv_from_alloc().\n\t */\n\tif (!ocfs2_resv_empty(resv))\n\t\tocfs2_resv_mark_lru(resmap, resv);\n\n\ttrace_ocfs2_resmap_claimed_bits_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t    resv->r_len, resv->r_last_start,\n\t\t\t\t\t    resv->r_last_len);\n\n\tocfs2_check_resmap(resmap);\n\n\tspin_unlock(&resv_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nvoid ocfs2_resmap_claimed_bits(struct ocfs2_reservation_map *resmap,\n\t\t\t       struct ocfs2_alloc_reservation *resv,\n\t\t\t       u32 cstart, u32 clen)\n{\n\tunsigned int cend = cstart + clen - 1;\n\n\tif (resmap == NULL || ocfs2_resmap_disabled(resmap))\n\t\treturn;\n\n\tif (resv == NULL)\n\t\treturn;\n\n\tBUG_ON(cstart != resv->r_start);\n\n\tspin_lock(&resv_lock);\n\n\ttrace_ocfs2_resmap_claimed_bits_begin(cstart, cend, clen, resv->r_start,\n\t\t\t\t\t      ocfs2_resv_end(resv), resv->r_len,\n\t\t\t\t\t      resv->r_last_start,\n\t\t\t\t\t      resv->r_last_len);\n\n\tBUG_ON(cstart < resv->r_start);\n\tBUG_ON(cstart > ocfs2_resv_end(resv));\n\tBUG_ON(cend > ocfs2_resv_end(resv));\n\n\tocfs2_adjust_resv_from_alloc(resmap, resv, cstart, cend);\n\tresv->r_last_start = cstart;\n\tresv->r_last_len = clen;\n\n\t/*\n\t * May have been discarded above from\n\t * ocfs2_adjust_resv_from_alloc().\n\t */\n\tif (!ocfs2_resv_empty(resv))\n\t\tocfs2_resv_mark_lru(resmap, resv);\n\n\ttrace_ocfs2_resmap_claimed_bits_end(resv->r_start, ocfs2_resv_end(resv),\n\t\t\t\t\t    resv->r_len, resv->r_last_start,\n\t\t\t\t\t    resv->r_last_len);\n\n\tocfs2_check_resmap(resmap);\n\n\tspin_unlock(&resv_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(local_alloc_inode)",
            "osb->local_alloc_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "local_alloc_inode"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "la->la_bm_off"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_find_clear_bits",
          "args": [
            "osb",
            "alloc",
            "&bits_wanted",
            "ac->ac_resv"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_find_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "837-924",
          "snippet": "static int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t     u32 *numbits,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv)\n{\n\tint numfound, bitoff, left, startoff, lastzero;\n\tint local_resv = 0;\n\tstruct ocfs2_alloc_reservation r;\n\tvoid *bitmap = NULL;\n\tstruct ocfs2_reservation_map *resmap = &osb->osb_la_resmap;\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tbitoff = -1;\n\t\tgoto bail;\n\t}\n\n\tif (!resv) {\n\t\tlocal_resv = 1;\n\t\tocfs2_resv_init_once(&r);\n\t\tocfs2_resv_set_type(&r, OCFS2_RESV_FLAG_TMP);\n\t\tresv = &r;\n\t}\n\n\tnumfound = *numbits;\n\tif (ocfs2_resmap_resv_bits(resmap, resv, &bitoff, &numfound) == 0) {\n\t\tif (numfound < *numbits)\n\t\t\t*numbits = numfound;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Code error. While reservations are enabled, local\n\t * allocation should _always_ go through them.\n\t */\n\tBUG_ON(osb->osb_resv_level != 0);\n\n\t/*\n\t * Reservations are disabled. Handle this the old way.\n\t */\n\n\tbitmap = OCFS2_LOCAL_ALLOC(alloc)->la_bitmap;\n\n\tnumfound = bitoff = startoff = 0;\n\tlastzero = -1;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\twhile ((bitoff = ocfs2_find_next_zero_bit(bitmap, left, startoff)) != -1) {\n\t\tif (bitoff == left) {\n\t\t\t/* mlog(0, \"bitoff (%d) == left\", bitoff); */\n\t\t\tbreak;\n\t\t}\n\t\t/* mlog(0, \"Found a zero: bitoff = %d, startoff = %d, \"\n\t\t   \"numfound = %d\\n\", bitoff, startoff, numfound);*/\n\n\t\t/* Ok, we found a zero bit... is it contig. or do we\n\t\t * start over?*/\n\t\tif (bitoff == startoff) {\n\t\t\t/* we found a zero */\n\t\t\tnumfound++;\n\t\t\tstartoff++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tnumfound = 1;\n\t\t\tstartoff = bitoff+1;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (numfound == *numbits) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttrace_ocfs2_local_alloc_find_clear_bits_search_bitmap(bitoff, numfound);\n\n\tif (numfound == *numbits)\n\t\tbitoff = startoff - numfound;\n\telse\n\t\tbitoff = -1;\n\nbail:\n\tif (local_resv)\n\t\tocfs2_resv_discard(resmap, resv);\n\n\ttrace_ocfs2_local_alloc_find_clear_bits(*numbits,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tbitoff, numfound);\n\n\treturn bitoff;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t\t     u32 *numbits,\n\t\t\t\t\t     struct ocfs2_alloc_reservation *resv);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t\t     u32 *numbits,\n\t\t\t\t\t     struct ocfs2_alloc_reservation *resv);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic int ocfs2_local_alloc_find_clear_bits(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_dinode *alloc,\n\t\t\t\t     u32 *numbits,\n\t\t\t\t     struct ocfs2_alloc_reservation *resv)\n{\n\tint numfound, bitoff, left, startoff, lastzero;\n\tint local_resv = 0;\n\tstruct ocfs2_alloc_reservation r;\n\tvoid *bitmap = NULL;\n\tstruct ocfs2_reservation_map *resmap = &osb->osb_la_resmap;\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tbitoff = -1;\n\t\tgoto bail;\n\t}\n\n\tif (!resv) {\n\t\tlocal_resv = 1;\n\t\tocfs2_resv_init_once(&r);\n\t\tocfs2_resv_set_type(&r, OCFS2_RESV_FLAG_TMP);\n\t\tresv = &r;\n\t}\n\n\tnumfound = *numbits;\n\tif (ocfs2_resmap_resv_bits(resmap, resv, &bitoff, &numfound) == 0) {\n\t\tif (numfound < *numbits)\n\t\t\t*numbits = numfound;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Code error. While reservations are enabled, local\n\t * allocation should _always_ go through them.\n\t */\n\tBUG_ON(osb->osb_resv_level != 0);\n\n\t/*\n\t * Reservations are disabled. Handle this the old way.\n\t */\n\n\tbitmap = OCFS2_LOCAL_ALLOC(alloc)->la_bitmap;\n\n\tnumfound = bitoff = startoff = 0;\n\tlastzero = -1;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\twhile ((bitoff = ocfs2_find_next_zero_bit(bitmap, left, startoff)) != -1) {\n\t\tif (bitoff == left) {\n\t\t\t/* mlog(0, \"bitoff (%d) == left\", bitoff); */\n\t\t\tbreak;\n\t\t}\n\t\t/* mlog(0, \"Found a zero: bitoff = %d, startoff = %d, \"\n\t\t   \"numfound = %d\\n\", bitoff, startoff, numfound);*/\n\n\t\t/* Ok, we found a zero bit... is it contig. or do we\n\t\t * start over?*/\n\t\tif (bitoff == startoff) {\n\t\t\t/* we found a zero */\n\t\t\tnumfound++;\n\t\t\tstartoff++;\n\t\t} else {\n\t\t\t/* got a zero after some ones */\n\t\t\tnumfound = 1;\n\t\t\tstartoff = bitoff+1;\n\t\t}\n\t\t/* we got everything we needed */\n\t\tif (numfound == *numbits) {\n\t\t\t/* mlog(0, \"Found it all!\\n\"); */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttrace_ocfs2_local_alloc_find_clear_bits_search_bitmap(bitoff, numfound);\n\n\tif (numfound == *numbits)\n\t\tbitoff = startoff - numfound;\n\telse\n\t\tbitoff = -1;\n\nbail:\n\tif (local_resv)\n\t\tocfs2_resv_discard(resmap, resv);\n\n\ttrace_ocfs2_local_alloc_find_clear_bits(*numbits,\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\tbitoff, numfound);\n\n\treturn bitoff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_which != OCFS2_AC_USE_LOCAL"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_claim_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t handle_t *handle,\n\t\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t\t u32 bits_wanted,\n\t\t\t\t u32 *bit_off,\n\t\t\t\t u32 *num_bits)\n{\n\tint status, start;\n\tstruct inode *local_alloc_inode;\n\tvoid *bitmap;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_local_alloc *la;\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL);\n\n\tlocal_alloc_inode = ac->ac_inode;\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tstart = ocfs2_local_alloc_find_clear_bits(osb, alloc, &bits_wanted,\n\t\t\t\t\t\t  ac->ac_resv);\n\tif (start == -1) {\n\t\t/* TODO: Shouldn't we just BUG here? */\n\t\tstatus = -ENOSPC;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tbitmap = la->la_bitmap;\n\t*bit_off = le32_to_cpu(la->la_bm_off) + start;\n\t*num_bits = bits_wanted;\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_resmap_claimed_bits(&osb->osb_la_resmap, ac->ac_resv, start,\n\t\t\t\t  bits_wanted);\n\n\twhile(bits_wanted--)\n\t\tocfs2_set_bit(start++, bitmap);\n\n\tle32_add_cpu(&alloc->id1.bitmap1.i_used, *num_bits);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_reserve_local_alloc_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "627-726",
    "snippet": "int ocfs2_reserve_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t   u32 bits_wanted,\n\t\t\t\t   struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\tstruct ocfs2_dinode *alloc;\n\tstruct inode *local_alloc_inode;\n\tunsigned int free_bits;\n\n\tBUG_ON(!ac);\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&local_alloc_inode->i_mutex);\n\n\t/*\n\t * We must double check state and allocator bits because\n\t * another process may have changed them while holding i_mutex.\n\t */\n\tspin_lock(&osb->osb_lock);\n\tif (!ocfs2_la_state_enabled(osb) ||\n\t    (bits_wanted > osb->local_alloc_bits)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) !=\n\t    ocfs2_local_alloc_count_bits(alloc)) {\n\t\tocfs2_error(osb->sb, \"local alloc inode %llu says it has \"\n\t\t\t    \"%u free bits, but a count shows %u\",\n\t\t\t    (unsigned long long)le64_to_cpu(alloc->i_blkno),\n\t\t\t    le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t\t    ocfs2_local_alloc_count_bits(alloc));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n#endif\n\n\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\tif (bits_wanted > free_bits) {\n\t\t/* uhoh, window change time. */\n\t\tstatus =\n\t\t\tocfs2_local_alloc_slide_window(osb, local_alloc_inode);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/*\n\t\t * Under certain conditions, the window slide code\n\t\t * might have reduced the number of bits available or\n\t\t * disabled the the local alloc entirely. Re-check\n\t\t * here and return -ENOSPC if necessary.\n\t\t */\n\t\tstatus = -ENOSPC;\n\t\tif (!ocfs2_la_state_enabled(osb))\n\t\t\tgoto bail;\n\n\t\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\t\tif (bits_wanted > free_bits)\n\t\t\tgoto bail;\n\t}\n\n\tac->ac_inode = local_alloc_inode;\n\t/* We should never use localalloc from another slot */\n\tac->ac_alloc_slot = osb->slot_num;\n\tac->ac_which = OCFS2_AC_USE_LOCAL;\n\tget_bh(osb->local_alloc_bh);\n\tac->ac_bh = osb->local_alloc_bh;\n\tstatus = 0;\nbail:\n\tif (status < 0 && local_alloc_inode) {\n\t\tmutex_unlock(&local_alloc_inode->i_mutex);\n\t\tiput(local_alloc_inode);\n\t}\n\n\ttrace_ocfs2_reserve_local_alloc_bits(\n\t\t(unsigned long long)ac->ac_max_block,\n\t\tbits_wanted, osb->slot_num, status);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
      "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
      "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_reserve_local_alloc_bits",
          "args": [
            "(unsigned long long)ac->ac_max_block",
            "bits_wanted",
            "osb->slot_num",
            "status"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "local_alloc_inode"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&local_alloc_inode->i_mutex"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "osb->local_alloc_bh"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "alloc->id1.bitmap1.i_used"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_la_state_enabled",
          "args": [
            "osb"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_la_state_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "222-226",
          "snippet": "static inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)\n{\n\treturn (osb->local_alloc_state == OCFS2_LA_THROTTLED ||\n\t\tosb->local_alloc_state == OCFS2_LA_ENABLED);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)\n{\n\treturn (osb->local_alloc_state == OCFS2_LA_THROTTLED ||\n\t\tosb->local_alloc_state == OCFS2_LA_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_slide_window",
          "args": [
            "osb",
            "local_alloc_inode"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_slide_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "1250-1342",
          "snippet": "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode)\n{\n\tint status = 0;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\n\tocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_SLIDE);\n\n\t/* This will lock the main bitmap for us. */\n\tstatus = ocfs2_local_alloc_reserve_for_window(osb,\n\t\t\t\t\t\t      &ac,\n\t\t\t\t\t\t      &main_bm_inode,\n\t\t\t\t\t\t      &main_bm_bh);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n\t/* We want to clear the local alloc before doing anything\n\t * else, so that if we error later during this operation,\n\t * local alloc shutdown won't try to double free main bitmap\n\t * bits. Make a copy so the sync function knows which bits to\n\t * free. */\n\talloc_copy = kmalloc(osb->local_alloc_bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemcpy(alloc_copy, alloc, osb->local_alloc_bh->b_size);\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_local_alloc_new_window(osb, handle, ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_inc(&osb->alloc_stats.moves);\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tbrelse(main_bm_bh);\n\n\tif (main_bm_inode)\n\t\tiput(main_bm_inode);\n\n\tkfree(alloc_copy);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);",
            "static int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);",
            "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode)\n{\n\tint status = 0;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *alloc;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_alloc_context *ac = NULL;\n\n\tocfs2_recalc_la_window(osb, OCFS2_LA_EVENT_SLIDE);\n\n\t/* This will lock the main bitmap for us. */\n\tstatus = ocfs2_local_alloc_reserve_for_window(osb,\n\t\t\t\t\t\t      &ac,\n\t\t\t\t\t\t      &main_bm_inode,\n\t\t\t\t\t\t      &main_bm_bh);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n\t/* We want to clear the local alloc before doing anything\n\t * else, so that if we error later during this operation,\n\t * local alloc shutdown won't try to double free main bitmap\n\t * bits. Make a copy so the sync function knows which bits to\n\t * free. */\n\talloc_copy = kmalloc(osb->local_alloc_bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tmemcpy(alloc_copy, alloc, osb->local_alloc_bh->b_size);\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t osb->local_alloc_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, osb->local_alloc_bh);\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_local_alloc_new_window(osb, handle, ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tatomic_inc(&osb->alloc_stats.moves);\n\nbail:\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tbrelse(main_bm_bh);\n\n\tif (main_bm_inode)\n\t\tiput(main_bm_inode);\n\n\tkfree(alloc_copy);\n\n\tif (ac)\n\t\tocfs2_free_alloc_context(ac);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "osb->sb",
            "\"local alloc inode %llu says it has \"\n\t\t\t    \"%u free bits, but a count shows %u\"",
            "(unsigned long long)le64_to_cpu(alloc->i_blkno)",
            "le32_to_cpu(alloc->id1.bitmap1.i_used)",
            "ocfs2_local_alloc_count_bits(alloc)"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_count_bits",
          "args": [
            "alloc"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_count_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "826-835",
          "snippet": "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc)\n{\n\tu32 count;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\tcount = memweight(la->la_bitmap, le16_to_cpu(la->la_size));\n\n\ttrace_ocfs2_local_alloc_count_bits(count);\n\treturn count;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc)\n{\n\tu32 count;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\tcount = memweight(la->la_bitmap, le16_to_cpu(la->la_size));\n\n\ttrace_ocfs2_local_alloc_count_bits(count);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "alloc->i_blkno"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&local_alloc_inode->i_mutex"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "LOCAL_ALLOC_SYSTEM_INODE",
            "osb->slot_num"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ac"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_local_alloc_new_window(struct ocfs2_super *osb,\n\t\t\t\t\thandle_t *handle,\n\t\t\t\t\tstruct ocfs2_alloc_context *ac);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nint ocfs2_reserve_local_alloc_bits(struct ocfs2_super *osb,\n\t\t\t\t   u32 bits_wanted,\n\t\t\t\t   struct ocfs2_alloc_context *ac)\n{\n\tint status;\n\tstruct ocfs2_dinode *alloc;\n\tstruct inode *local_alloc_inode;\n\tunsigned int free_bits;\n\n\tBUG_ON(!ac);\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&local_alloc_inode->i_mutex);\n\n\t/*\n\t * We must double check state and allocator bits because\n\t * another process may have changed them while holding i_mutex.\n\t */\n\tspin_lock(&osb->osb_lock);\n\tif (!ocfs2_la_state_enabled(osb) ||\n\t    (bits_wanted > osb->local_alloc_bits)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\tstatus = -ENOSPC;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&osb->osb_lock);\n\n\talloc = (struct ocfs2_dinode *) osb->local_alloc_bh->b_data;\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) !=\n\t    ocfs2_local_alloc_count_bits(alloc)) {\n\t\tocfs2_error(osb->sb, \"local alloc inode %llu says it has \"\n\t\t\t    \"%u free bits, but a count shows %u\",\n\t\t\t    (unsigned long long)le64_to_cpu(alloc->i_blkno),\n\t\t\t    le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t\t    ocfs2_local_alloc_count_bits(alloc));\n\t\tstatus = -EIO;\n\t\tgoto bail;\n\t}\n#endif\n\n\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\tif (bits_wanted > free_bits) {\n\t\t/* uhoh, window change time. */\n\t\tstatus =\n\t\t\tocfs2_local_alloc_slide_window(osb, local_alloc_inode);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/*\n\t\t * Under certain conditions, the window slide code\n\t\t * might have reduced the number of bits available or\n\t\t * disabled the the local alloc entirely. Re-check\n\t\t * here and return -ENOSPC if necessary.\n\t\t */\n\t\tstatus = -ENOSPC;\n\t\tif (!ocfs2_la_state_enabled(osb))\n\t\t\tgoto bail;\n\n\t\tfree_bits = le32_to_cpu(alloc->id1.bitmap1.i_total) -\n\t\t\tle32_to_cpu(alloc->id1.bitmap1.i_used);\n\t\tif (bits_wanted > free_bits)\n\t\t\tgoto bail;\n\t}\n\n\tac->ac_inode = local_alloc_inode;\n\t/* We should never use localalloc from another slot */\n\tac->ac_alloc_slot = osb->slot_num;\n\tac->ac_which = OCFS2_AC_USE_LOCAL;\n\tget_bh(osb->local_alloc_bh);\n\tac->ac_bh = osb->local_alloc_bh;\n\tstatus = 0;\nbail:\n\tif (status < 0 && local_alloc_inode) {\n\t\tmutex_unlock(&local_alloc_inode->i_mutex);\n\t\tiput(local_alloc_inode);\n\t}\n\n\ttrace_ocfs2_reserve_local_alloc_bits(\n\t\t(unsigned long long)ac->ac_max_block,\n\t\tbits_wanted, osb->slot_num, status);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_complete_local_alloc_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "559-618",
    "snippet": "int ocfs2_complete_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_dinode *alloc)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\t/* we want the bitmap change to be recorded on disk asap */\n\thandle->h_sync = 1;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\n\tbrelse(main_bm_bh);\n\n\tiput(main_bm_inode);\n\nout:\n\tif (!status)\n\t\tocfs2_init_steal_slots(osb);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
      "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_steal_slots",
          "args": [
            "osb"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_steal_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "904-908",
          "snippet": "void ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_init_steal_slots(struct ocfs2_super *osb)\n{\n\tocfs2_init_inode_steal_slot(osb);\n\tocfs2_init_meta_steal_slot(osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "main_bm_inode"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "main_bm_bh"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "main_bm_inode",
            "1"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sync_local_to_main",
          "args": [
            "osb",
            "handle",
            "alloc",
            "main_bm_inode",
            "main_bm_bh"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_local_to_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "963-1031",
          "snippet": "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = bit_off = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\n\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = bit_off = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_WINDOW_MOVE_CREDITS"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "main_bm_inode",
            "&main_bm_bh",
            "1"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\n\nint ocfs2_complete_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_dinode *alloc)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\t/* we want the bitmap change to be recorded on disk asap */\n\thandle->h_sync = 1;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\n\tbrelse(main_bm_bh);\n\n\tiput(main_bm_inode);\n\nout:\n\tif (!status)\n\t\tocfs2_init_steal_slots(osb);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_begin_local_alloc_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "489-551",
    "snippet": "int ocfs2_begin_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t     int slot_num,\n\t\t\t\t     struct ocfs2_dinode **alloc_copy)\n{\n\tint status = 0;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *alloc;\n\n\ttrace_ocfs2_begin_local_alloc_recovery(slot_num);\n\n\t*alloc_copy = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*alloc_copy = kmalloc(alloc_bh->b_size, GFP_KERNEL);\n\tif (!(*alloc_copy)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tmemcpy((*alloc_copy), alloc_bh->b_data, alloc_bh->b_size);\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tocfs2_clear_local_alloc(alloc);\n\n\tocfs2_compute_meta_ecc(osb->sb, alloc_bh->b_data, &alloc->i_check);\n\tstatus = ocfs2_write_block(osb, alloc_bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status < 0) {\n\t\tkfree(*alloc_copy);\n\t\t*alloc_copy = NULL;\n\t}\n\n\tbrelse(alloc_bh);\n\n\tif (inode) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "alloc_bh"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*alloc_copy"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_block",
          "args": [
            "osb",
            "alloc_bh",
            "INODE_CACHE(inode)"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "53-99",
          "snippet": "int ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_compute_meta_ecc",
          "args": [
            "osb->sb",
            "alloc_bh->b_data",
            "&alloc->i_check"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_compute_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "606-611",
          "snippet": "void ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_local_alloc",
          "args": [
            "alloc"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_local_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "926-936",
          "snippet": "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*alloc_copy)",
            "alloc_bh->b_data",
            "alloc_bh->b_size"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "alloc_bh->b_size",
            "GFP_KERNEL"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block_full",
          "args": [
            "inode",
            "&alloc_bh",
            "OCFS2_BH_IGNORE_CACHE"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1388-1402",
          "snippet": "int ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "LOCAL_ALLOC_SYSTEM_INODE",
            "slot_num"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_begin_local_alloc_recovery",
          "args": [
            "slot_num"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nint ocfs2_begin_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t     int slot_num,\n\t\t\t\t     struct ocfs2_dinode **alloc_copy)\n{\n\tint status = 0;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *alloc;\n\n\ttrace_ocfs2_begin_local_alloc_recovery(slot_num);\n\n\t*alloc_copy = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*alloc_copy = kmalloc(alloc_bh->b_size, GFP_KERNEL);\n\tif (!(*alloc_copy)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tmemcpy((*alloc_copy), alloc_bh->b_data, alloc_bh->b_size);\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tocfs2_clear_local_alloc(alloc);\n\n\tocfs2_compute_meta_ecc(osb->sb, alloc_bh->b_data, &alloc->i_check);\n\tstatus = ocfs2_write_block(osb, alloc_bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status < 0) {\n\t\tkfree(*alloc_copy);\n\t\t*alloc_copy = NULL;\n\t}\n\n\tbrelse(alloc_bh);\n\n\tif (inode) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_shutdown_local_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "378-480",
    "snippet": "void ocfs2_shutdown_local_alloc(struct ocfs2_super *osb)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *local_alloc_inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_dinode *alloc = NULL;\n\n\tcancel_delayed_work(&osb->la_enable_wq);\n\tflush_workqueue(ocfs2_wq);\n\n\tif (osb->local_alloc_state == OCFS2_LA_UNUSED)\n\t\tgoto out;\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\n\tocfs2_resmap_uninit(&osb->osb_la_resmap);\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\t/* WINDOW_MOVE_CREDITS is a bit heavy... */\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\thandle = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tbh = osb->local_alloc_bh;\n\talloc = (struct ocfs2_dinode *) bh->b_data;\n\n\talloc_copy = kmalloc(bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_commit;\n\t}\n\tmemcpy(alloc_copy, alloc, bh->b_size);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, bh);\n\n\tbrelse(bh);\n\tosb->local_alloc_bh = NULL;\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\n\nout:\n\tif (local_alloc_inode)\n\t\tiput(local_alloc_inode);\n\n\tkfree(alloc_copy);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
      "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);",
      "static int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "alloc_copy"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "local_alloc_inode"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "main_bm_inode",
            "1"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "main_bm_bh"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sync_local_to_main",
          "args": [
            "osb",
            "handle",
            "alloc_copy",
            "main_bm_inode",
            "main_bm_bh"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sync_local_to_main",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "963-1031",
          "snippet": "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = bit_off = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\n\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh)\n{\n\tint status = 0;\n\tint bit_off, left, count, start;\n\tu64 la_start_blk;\n\tu64 blkno;\n\tvoid *bitmap;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\ttrace_ocfs2_sync_local_to_main(\n\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t     le32_to_cpu(alloc->id1.bitmap1.i_used));\n\n\tif (!alloc->id1.bitmap1.i_total) {\n\t\tgoto bail;\n\t}\n\n\tif (le32_to_cpu(alloc->id1.bitmap1.i_used) ==\n\t    le32_to_cpu(alloc->id1.bitmap1.i_total)) {\n\t\tgoto bail;\n\t}\n\n\tla_start_blk = ocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\tle32_to_cpu(la->la_bm_off));\n\tbitmap = la->la_bitmap;\n\tstart = count = bit_off = 0;\n\tleft = le32_to_cpu(alloc->id1.bitmap1.i_total);\n\n\twhile ((bit_off = ocfs2_find_next_zero_bit(bitmap, left, start))\n\t       != -1) {\n\t\tif ((bit_off < left) && (bit_off == start)) {\n\t\t\tcount++;\n\t\t\tstart++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (count) {\n\t\t\tblkno = la_start_blk +\n\t\t\t\tocfs2_clusters_to_blocks(osb->sb,\n\t\t\t\t\t\t\t start - count);\n\n\t\t\ttrace_ocfs2_sync_local_to_main_free(\n\t\t\t     count, start - count,\n\t\t\t     (unsigned long long)la_start_blk,\n\t\t\t     (unsigned long long)blkno);\n\n\t\t\tstatus = ocfs2_release_clusters(handle,\n\t\t\t\t\t\t\tmain_bm_inode,\n\t\t\t\t\t\t\tmain_bm_bh, blkno,\n\t\t\t\t\t\t\tcount);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (bit_off >= left)\n\t\t\tbreak;\n\t\tcount = 1;\n\t\tstart = bit_off + 1;\n\t}\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_local_alloc",
          "args": [
            "alloc"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_local_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "926-936",
          "snippet": "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc)\n{\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\tint i;\n\n\talloc->id1.bitmap1.i_total = 0;\n\talloc->id1.bitmap1.i_used = 0;\n\tla->la_bm_off = 0;\n\tfor(i = 0; i < le16_to_cpu(la->la_size); i++)\n\t\tla->la_bitmap[i] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(local_alloc_inode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "local_alloc_inode"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "alloc_copy",
            "alloc",
            "bh->b_size"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bh->b_size",
            "GFP_NOFS"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(handle)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_WINDOW_MOVE_CREDITS"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "main_bm_inode",
            "&main_bm_bh",
            "1"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_resmap_uninit",
          "args": [
            "&osb->osb_la_resmap"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resmap_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "309-312",
          "snippet": "void ocfs2_resmap_uninit(struct ocfs2_reservation_map *resmap)\n{\n\t/* Does nothing for now. Keep this around for API symmetry */\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_resmap_uninit(struct ocfs2_reservation_map *resmap)\n{\n\t/* Does nothing for now. Keep this around for API symmetry */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "ocfs2_wq"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&osb->la_enable_wq"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\nstatic int ocfs2_local_alloc_slide_window(struct ocfs2_super *osb,\n\t\t\t\t\t  struct inode *local_alloc_inode);\n\nvoid ocfs2_shutdown_local_alloc(struct ocfs2_super *osb)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct inode *local_alloc_inode = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *alloc_copy = NULL;\n\tstruct ocfs2_dinode *alloc = NULL;\n\n\tcancel_delayed_work(&osb->la_enable_wq);\n\tflush_workqueue(ocfs2_wq);\n\n\tif (osb->local_alloc_state == OCFS2_LA_UNUSED)\n\t\tgoto out;\n\n\tlocal_alloc_inode =\n\t\tocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!local_alloc_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tosb->local_alloc_state = OCFS2_LA_DISABLED;\n\n\tocfs2_resmap_uninit(&osb->osb_la_resmap);\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\t/* WINDOW_MOVE_CREDITS is a bit heavy... */\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\thandle = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tbh = osb->local_alloc_bh;\n\talloc = (struct ocfs2_dinode *) bh->b_data;\n\n\talloc_copy = kmalloc(bh->b_size, GFP_NOFS);\n\tif (!alloc_copy) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out_commit;\n\t}\n\tmemcpy(alloc_copy, alloc, bh->b_size);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(local_alloc_inode),\n\t\t\t\t\t bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_clear_local_alloc(alloc);\n\tocfs2_journal_dirty(handle, bh);\n\n\tbrelse(bh);\n\tosb->local_alloc_bh = NULL;\n\tosb->local_alloc_state = OCFS2_LA_UNUSED;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc_copy,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\n\nout:\n\tif (local_alloc_inode)\n\t\tiput(local_alloc_inode);\n\n\tkfree(alloc_copy);\n}"
  },
  {
    "function_name": "ocfs2_load_local_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "284-369",
    "snippet": "int ocfs2_load_local_alloc(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tu32 num_used;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\tif (osb->local_alloc_bits == 0)\n\t\tgoto bail;\n\n\tif (osb->local_alloc_bits >= osb->bitmap_cpg) {\n\t\tmlog(ML_NOTICE, \"Requested local alloc window %d is larger \"\n\t\t     \"than max possible %u. Using defaults.\\n\",\n\t\t     osb->local_alloc_bits, (osb->bitmap_cpg - 1));\n\t\tosb->local_alloc_bits =\n\t\t\tocfs2_megabytes_to_clusters(osb->sb,\n\t\t\t\t\t\t    ocfs2_la_default_mb(osb));\n\t}\n\n\t/* read the alloc off disk */\n\tinode = ocfs2_get_system_file_inode(osb, LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tif (!(le32_to_cpu(alloc->i_flags) &\n\t    (OCFS2_LOCAL_ALLOC_FL|OCFS2_BITMAP_FL))) {\n\t\tmlog(ML_ERROR, \"Invalid local alloc inode, %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif ((la->la_size == 0) ||\n\t    (le16_to_cpu(la->la_size) > ocfs2_local_alloc_size(inode->i_sb))) {\n\t\tmlog(ML_ERROR, \"Local alloc size is invalid (la_size = %u)\\n\",\n\t\t     le16_to_cpu(la->la_size));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t/* do a little verification. */\n\tnum_used = ocfs2_local_alloc_count_bits(alloc);\n\n\t/* hopefully the local alloc has always been recovered before\n\t * we load it. */\n\tif (num_used\n\t    || alloc->id1.bitmap1.i_used\n\t    || alloc->id1.bitmap1.i_total\n\t    || la->la_bm_off)\n\t\tmlog(ML_ERROR, \"Local alloc hasn't been recovered!\\n\"\n\t\t     \"found = %u, set = %u, taken = %u, off = %u\\n\",\n\t\t     num_used, le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bm_off);\n\n\tosb->local_alloc_bh = alloc_bh;\n\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\nbail:\n\tif (status < 0)\n\t\tbrelse(alloc_bh);\n\tif (inode)\n\t\tiput(inode);\n\n\ttrace_ocfs2_load_local_alloc(osb->local_alloc_bits);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_load_local_alloc",
          "args": [
            "osb->local_alloc_bits"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "alloc_bh"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Local alloc hasn't been recovered!\\n\"\n\t\t     \"found = %u, set = %u, taken = %u, off = %u\\n\"",
            "num_used",
            "le32_to_cpu(alloc->id1.bitmap1.i_used)",
            "le32_to_cpu(alloc->id1.bitmap1.i_total)",
            "OCFS2_LOCAL_ALLOC(alloc)->la_bm_off"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "alloc->id1.bitmap1.i_total"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_count_bits",
          "args": [
            "alloc"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_count_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "826-835",
          "snippet": "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc)\n{\n\tu32 count;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\tcount = memweight(la->la_bitmap, le16_to_cpu(la->la_size));\n\n\ttrace_ocfs2_local_alloc_count_bits(count);\n\treturn count;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc)\n{\n\tu32 count;\n\tstruct ocfs2_local_alloc *la = OCFS2_LOCAL_ALLOC(alloc);\n\n\tcount = memweight(la->la_bitmap, le16_to_cpu(la->la_size));\n\n\ttrace_ocfs2_local_alloc_count_bits(count);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Local alloc size is invalid (la_size = %u)\\n\"",
            "le16_to_cpu(la->la_size)"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "la->la_size"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_size",
          "args": [
            "inode->i_sb"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1537-1545",
          "snippet": "static inline int ocfs2_local_alloc_size(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_lab.la_bitmap);\n\n\treturn size;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_local_alloc_size(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_lab.la_bitmap);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_LOCAL_ALLOC",
          "args": [
            "alloc"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block_full",
          "args": [
            "inode",
            "&alloc_bh",
            "OCFS2_BH_IGNORE_CACHE"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1388-1402",
          "snippet": "int ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "LOCAL_ALLOC_SYSTEM_INODE",
            "osb->slot_num"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_megabytes_to_clusters",
          "args": [
            "osb->sb",
            "ocfs2_la_default_mb(osb)"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_megabytes_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "842-848",
          "snippet": "static inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int megs)\n{\n\tBUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);\n\n\treturn megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int megs)\n{\n\tBUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);\n\n\treturn megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_la_default_mb",
          "args": [
            "osb"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_la_default_mb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "117-193",
          "snippet": "unsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t/*\n\t * This takes care of files systems with very small group\n\t * descriptors - 512 byte blocksize at cluster sizes lower\n\t * than 16K and also 1k blocksize with 4k cluster size.\n\t */\n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t/*\n\t * Leave enough room for some block groups and make the final\n\t * value we work from a multiple of 4.\n\t */\n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t/*\n\t * Keep window sizes down to a reasonable default\n\t */\n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t/*\n\t\t * Some clustersize / blocksize combinations will have\n\t\t * given us a larger than OCFS2_LA_MAX_DEFAULT_MB\n\t\t * default size, but get poor distribution when\n\t\t * limited to exactly 256 megabytes.\n\t\t *\n\t\t * As an example, 16K clustersize at 4K blocksize\n\t\t * gives us a cluster group size of 504M. Paring the\n\t\t * local alloc size down to 256 however, would give us\n\t\t * only one window and around 200MB left in the\n\t\t * cluster group. Instead, find the first size below\n\t\t * 256 which would give us an even distribution.\n\t\t *\n\t\t * Larger cluster group sizes actually work out pretty\n\t\t * well when pared to 256, so we don't have to do this\n\t\t * for any group that fits more than two\n\t\t * OCFS2_LA_MAX_DEFAULT_MB windows.\n\t\t */\n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t/* Too many nodes, too few disk clusters. */\n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t/* We can't store more bits than we can in a block. */\n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tOCFS2_LA_OLD_DEFAULT\t8",
            "#define\tOCFS2_LA_MAX_DEFAULT_MB\t256"
          ],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define\tOCFS2_LA_OLD_DEFAULT\t8\n#define\tOCFS2_LA_MAX_DEFAULT_MB\t256\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nunsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t/*\n\t * This takes care of files systems with very small group\n\t * descriptors - 512 byte blocksize at cluster sizes lower\n\t * than 16K and also 1k blocksize with 4k cluster size.\n\t */\n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t/*\n\t * Leave enough room for some block groups and make the final\n\t * value we work from a multiple of 4.\n\t */\n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t/*\n\t * Keep window sizes down to a reasonable default\n\t */\n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t/*\n\t\t * Some clustersize / blocksize combinations will have\n\t\t * given us a larger than OCFS2_LA_MAX_DEFAULT_MB\n\t\t * default size, but get poor distribution when\n\t\t * limited to exactly 256 megabytes.\n\t\t *\n\t\t * As an example, 16K clustersize at 4K blocksize\n\t\t * gives us a cluster group size of 504M. Paring the\n\t\t * local alloc size down to 256 however, would give us\n\t\t * only one window and around 200MB left in the\n\t\t * cluster group. Instead, find the first size below\n\t\t * 256 which would give us an even distribution.\n\t\t *\n\t\t * Larger cluster group sizes actually work out pretty\n\t\t * well when pared to 256, so we don't have to do this\n\t\t * for any group that fits more than two\n\t\t * OCFS2_LA_MAX_DEFAULT_MB windows.\n\t\t */\n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t/* Too many nodes, too few disk clusters. */\n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t/* We can't store more bits than we can in a block. */\n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"Requested local alloc window %d is larger \"\n\t\t     \"than max possible %u. Using defaults.\\n\"",
            "osb->local_alloc_bits",
            "(osb->bitmap_cpg - 1)"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nint ocfs2_load_local_alloc(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *alloc = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tu32 num_used;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_local_alloc *la;\n\n\tif (osb->local_alloc_bits == 0)\n\t\tgoto bail;\n\n\tif (osb->local_alloc_bits >= osb->bitmap_cpg) {\n\t\tmlog(ML_NOTICE, \"Requested local alloc window %d is larger \"\n\t\t     \"than max possible %u. Using defaults.\\n\",\n\t\t     osb->local_alloc_bits, (osb->bitmap_cpg - 1));\n\t\tosb->local_alloc_bits =\n\t\t\tocfs2_megabytes_to_clusters(osb->sb,\n\t\t\t\t\t\t    ocfs2_la_default_mb(osb));\n\t}\n\n\t/* read the alloc off disk */\n\tinode = ocfs2_get_system_file_inode(osb, LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tla = OCFS2_LOCAL_ALLOC(alloc);\n\n\tif (!(le32_to_cpu(alloc->i_flags) &\n\t    (OCFS2_LOCAL_ALLOC_FL|OCFS2_BITMAP_FL))) {\n\t\tmlog(ML_ERROR, \"Invalid local alloc inode, %llu\\n\",\n\t\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif ((la->la_size == 0) ||\n\t    (le16_to_cpu(la->la_size) > ocfs2_local_alloc_size(inode->i_sb))) {\n\t\tmlog(ML_ERROR, \"Local alloc size is invalid (la_size = %u)\\n\",\n\t\t     le16_to_cpu(la->la_size));\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t/* do a little verification. */\n\tnum_used = ocfs2_local_alloc_count_bits(alloc);\n\n\t/* hopefully the local alloc has always been recovered before\n\t * we load it. */\n\tif (num_used\n\t    || alloc->id1.bitmap1.i_used\n\t    || alloc->id1.bitmap1.i_total\n\t    || la->la_bm_off)\n\t\tmlog(ML_ERROR, \"Local alloc hasn't been recovered!\\n\"\n\t\t     \"found = %u, set = %u, taken = %u, off = %u\\n\",\n\t\t     num_used, le32_to_cpu(alloc->id1.bitmap1.i_used),\n\t\t     le32_to_cpu(alloc->id1.bitmap1.i_total),\n\t\t     OCFS2_LOCAL_ALLOC(alloc)->la_bm_off);\n\n\tosb->local_alloc_bh = alloc_bh;\n\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\nbail:\n\tif (status < 0)\n\t\tbrelse(alloc_bh);\n\tif (inode)\n\t\tiput(inode);\n\n\ttrace_ocfs2_load_local_alloc(osb->local_alloc_bits);\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_alloc_should_use_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "258-282",
    "snippet": "int ocfs2_alloc_should_use_local(struct ocfs2_super *osb, u64 bits)\n{\n\tint ret = 0;\n\tint la_bits;\n\n\tspin_lock(&osb->osb_lock);\n\tla_bits = osb->local_alloc_bits;\n\n\tif (!ocfs2_la_state_enabled(osb))\n\t\tgoto bail;\n\n\t/* la_bits should be at least twice the size (in clusters) of\n\t * a new block group. We want to be sure block group\n\t * allocations go through the local alloc, so allow an\n\t * allocation to take up to half the bitmap. */\n\tif (bits > (la_bits / 2))\n\t\tgoto bail;\n\n\tret = 1;\nbail:\n\ttrace_ocfs2_alloc_should_use_local(\n\t     (unsigned long long)bits, osb->local_alloc_state, la_bits, ret);\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_alloc_should_use_local",
          "args": [
            "(unsigned long long)bits",
            "osb->local_alloc_state",
            "la_bits",
            "ret"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_la_state_enabled",
          "args": [
            "osb"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_la_state_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "222-226",
          "snippet": "static inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)\n{\n\treturn (osb->local_alloc_state == OCFS2_LA_THROTTLED ||\n\t\tosb->local_alloc_state == OCFS2_LA_ENABLED);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)\n{\n\treturn (osb->local_alloc_state == OCFS2_LA_THROTTLED ||\n\t\tosb->local_alloc_state == OCFS2_LA_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nint ocfs2_alloc_should_use_local(struct ocfs2_super *osb, u64 bits)\n{\n\tint ret = 0;\n\tint la_bits;\n\n\tspin_lock(&osb->osb_lock);\n\tla_bits = osb->local_alloc_bits;\n\n\tif (!ocfs2_la_state_enabled(osb))\n\t\tgoto bail;\n\n\t/* la_bits should be at least twice the size (in clusters) of\n\t * a new block group. We want to be sure block group\n\t * allocations go through the local alloc, so allow an\n\t * allocation to take up to half the bitmap. */\n\tif (bits > (la_bits / 2))\n\t\tgoto bail;\n\n\tret = 1;\nbail:\n\ttrace_ocfs2_alloc_should_use_local(\n\t     (unsigned long long)bits, osb->local_alloc_state, la_bits, ret);\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_la_enable_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "241-249",
    "snippet": "void ocfs2_la_enable_worker(struct work_struct *work)\n{\n\tstruct ocfs2_super *osb =\n\t\tcontainer_of(work, struct ocfs2_super,\n\t\t\t     la_enable_wq.work);\n\tspin_lock(&osb->osb_lock);\n\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\tspin_unlock(&osb->osb_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structocfs2_super",
            "la_enable_wq.work"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_la_enable_worker(struct work_struct *work)\n{\n\tstruct ocfs2_super *osb =\n\t\tcontainer_of(work, struct ocfs2_super,\n\t\t\t     la_enable_wq.work);\n\tspin_lock(&osb->osb_lock);\n\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\tspin_unlock(&osb->osb_lock);\n}"
  },
  {
    "function_name": "ocfs2_local_alloc_seen_free_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "228-239",
    "snippet": "void ocfs2_local_alloc_seen_free_bits(struct ocfs2_super *osb,\n\t\t\t\t      unsigned int num_clusters)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED ||\n\t    osb->local_alloc_state == OCFS2_LA_THROTTLED)\n\t\tif (num_clusters >= osb->local_alloc_default_bits) {\n\t\t\tcancel_delayed_work(&osb->la_enable_wq);\n\t\t\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\t\t}\n\tspin_unlock(&osb->osb_lock);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&osb->la_enable_wq"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_local_alloc_seen_free_bits(struct ocfs2_super *osb,\n\t\t\t\t      unsigned int num_clusters)\n{\n\tspin_lock(&osb->osb_lock);\n\tif (osb->local_alloc_state == OCFS2_LA_DISABLED ||\n\t    osb->local_alloc_state == OCFS2_LA_THROTTLED)\n\t\tif (num_clusters >= osb->local_alloc_default_bits) {\n\t\t\tcancel_delayed_work(&osb->la_enable_wq);\n\t\t\tosb->local_alloc_state = OCFS2_LA_ENABLED;\n\t\t}\n\tspin_unlock(&osb->osb_lock);\n}"
  },
  {
    "function_name": "ocfs2_la_state_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "222-226",
    "snippet": "static inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)\n{\n\treturn (osb->local_alloc_state == OCFS2_LA_THROTTLED ||\n\t\tosb->local_alloc_state == OCFS2_LA_ENABLED);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_la_state_enabled(struct ocfs2_super *osb)\n{\n\treturn (osb->local_alloc_state == OCFS2_LA_THROTTLED ||\n\t\tosb->local_alloc_state == OCFS2_LA_ENABLED);\n}"
  },
  {
    "function_name": "ocfs2_la_set_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "195-220",
    "snippet": "void ocfs2_la_set_sizes(struct ocfs2_super *osb, int requested_mb)\n{\n\tstruct super_block *sb = osb->sb;\n\tunsigned int la_default_mb = ocfs2_la_default_mb(osb);\n\tunsigned int la_max_mb;\n\n\tla_max_mb = ocfs2_clusters_to_megabytes(sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\n\ttrace_ocfs2_la_set_sizes(requested_mb, la_max_mb, la_default_mb);\n\n\tif (requested_mb == -1) {\n\t\t/* No user request - use defaults */\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_default_mb);\n\t} else if (requested_mb > la_max_mb) {\n\t\t/* Request is too big, we give the maximum available */\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_max_mb);\n\t} else {\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, requested_mb);\n\t}\n\n\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_megabytes_to_clusters",
          "args": [
            "sb",
            "requested_mb"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_megabytes_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "842-848",
          "snippet": "static inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int megs)\n{\n\tBUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);\n\n\treturn megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_megabytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int megs)\n{\n\tBUILD_BUG_ON(OCFS2_MAX_CLUSTERSIZE > 1048576);\n\n\treturn megs << (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_la_set_sizes",
          "args": [
            "requested_mb",
            "la_max_mb",
            "la_default_mb"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_megabytes",
          "args": [
            "sb",
            "ocfs2_local_alloc_size(sb) * 8"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_megabytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "850-854",
          "snippet": "static inline unsigned int ocfs2_clusters_to_megabytes(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int clusters)\n{\n\treturn clusters >> (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_to_megabytes(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int clusters)\n{\n\treturn clusters >> (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_size",
          "args": [
            "sb"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1537-1545",
          "snippet": "static inline int ocfs2_local_alloc_size(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_lab.la_bitmap);\n\n\treturn size;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_local_alloc_size(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_lab.la_bitmap);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_la_default_mb",
          "args": [
            "osb"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_la_default_mb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "117-193",
          "snippet": "unsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t/*\n\t * This takes care of files systems with very small group\n\t * descriptors - 512 byte blocksize at cluster sizes lower\n\t * than 16K and also 1k blocksize with 4k cluster size.\n\t */\n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t/*\n\t * Leave enough room for some block groups and make the final\n\t * value we work from a multiple of 4.\n\t */\n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t/*\n\t * Keep window sizes down to a reasonable default\n\t */\n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t/*\n\t\t * Some clustersize / blocksize combinations will have\n\t\t * given us a larger than OCFS2_LA_MAX_DEFAULT_MB\n\t\t * default size, but get poor distribution when\n\t\t * limited to exactly 256 megabytes.\n\t\t *\n\t\t * As an example, 16K clustersize at 4K blocksize\n\t\t * gives us a cluster group size of 504M. Paring the\n\t\t * local alloc size down to 256 however, would give us\n\t\t * only one window and around 200MB left in the\n\t\t * cluster group. Instead, find the first size below\n\t\t * 256 which would give us an even distribution.\n\t\t *\n\t\t * Larger cluster group sizes actually work out pretty\n\t\t * well when pared to 256, so we don't have to do this\n\t\t * for any group that fits more than two\n\t\t * OCFS2_LA_MAX_DEFAULT_MB windows.\n\t\t */\n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t/* Too many nodes, too few disk clusters. */\n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t/* We can't store more bits than we can in a block. */\n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define\tOCFS2_LA_OLD_DEFAULT\t8",
            "#define\tOCFS2_LA_MAX_DEFAULT_MB\t256"
          ],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define\tOCFS2_LA_OLD_DEFAULT\t8\n#define\tOCFS2_LA_MAX_DEFAULT_MB\t256\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nunsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t/*\n\t * This takes care of files systems with very small group\n\t * descriptors - 512 byte blocksize at cluster sizes lower\n\t * than 16K and also 1k blocksize with 4k cluster size.\n\t */\n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t/*\n\t * Leave enough room for some block groups and make the final\n\t * value we work from a multiple of 4.\n\t */\n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t/*\n\t * Keep window sizes down to a reasonable default\n\t */\n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t/*\n\t\t * Some clustersize / blocksize combinations will have\n\t\t * given us a larger than OCFS2_LA_MAX_DEFAULT_MB\n\t\t * default size, but get poor distribution when\n\t\t * limited to exactly 256 megabytes.\n\t\t *\n\t\t * As an example, 16K clustersize at 4K blocksize\n\t\t * gives us a cluster group size of 504M. Paring the\n\t\t * local alloc size down to 256 however, would give us\n\t\t * only one window and around 200MB left in the\n\t\t * cluster group. Instead, find the first size below\n\t\t * 256 which would give us an even distribution.\n\t\t *\n\t\t * Larger cluster group sizes actually work out pretty\n\t\t * well when pared to 256, so we don't have to do this\n\t\t * for any group that fits more than two\n\t\t * OCFS2_LA_MAX_DEFAULT_MB windows.\n\t\t */\n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t/* Too many nodes, too few disk clusters. */\n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t/* We can't store more bits than we can in a block. */\n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_la_set_sizes(struct ocfs2_super *osb, int requested_mb)\n{\n\tstruct super_block *sb = osb->sb;\n\tunsigned int la_default_mb = ocfs2_la_default_mb(osb);\n\tunsigned int la_max_mb;\n\n\tla_max_mb = ocfs2_clusters_to_megabytes(sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\n\ttrace_ocfs2_la_set_sizes(requested_mb, la_max_mb, la_default_mb);\n\n\tif (requested_mb == -1) {\n\t\t/* No user request - use defaults */\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_default_mb);\n\t} else if (requested_mb > la_max_mb) {\n\t\t/* Request is too big, we give the maximum available */\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, la_max_mb);\n\t} else {\n\t\tosb->local_alloc_default_bits =\n\t\t\tocfs2_megabytes_to_clusters(sb, requested_mb);\n\t}\n\n\tosb->local_alloc_bits = osb->local_alloc_default_bits;\n}"
  },
  {
    "function_name": "ocfs2_la_default_mb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
    "lines": "117-193",
    "snippet": "unsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t/*\n\t * This takes care of files systems with very small group\n\t * descriptors - 512 byte blocksize at cluster sizes lower\n\t * than 16K and also 1k blocksize with 4k cluster size.\n\t */\n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t/*\n\t * Leave enough room for some block groups and make the final\n\t * value we work from a multiple of 4.\n\t */\n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t/*\n\t * Keep window sizes down to a reasonable default\n\t */\n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t/*\n\t\t * Some clustersize / blocksize combinations will have\n\t\t * given us a larger than OCFS2_LA_MAX_DEFAULT_MB\n\t\t * default size, but get poor distribution when\n\t\t * limited to exactly 256 megabytes.\n\t\t *\n\t\t * As an example, 16K clustersize at 4K blocksize\n\t\t * gives us a cluster group size of 504M. Paring the\n\t\t * local alloc size down to 256 however, would give us\n\t\t * only one window and around 200MB left in the\n\t\t * cluster group. Instead, find the first size below\n\t\t * 256 which would give us an even distribution.\n\t\t *\n\t\t * Larger cluster group sizes actually work out pretty\n\t\t * well when pared to 256, so we don't have to do this\n\t\t * for any group that fits more than two\n\t\t * OCFS2_LA_MAX_DEFAULT_MB windows.\n\t\t */\n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t/* Too many nodes, too few disk clusters. */\n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t/* We can't store more bits than we can in a block. */\n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/bitops.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define\tOCFS2_LA_OLD_DEFAULT\t8",
      "#define\tOCFS2_LA_MAX_DEFAULT_MB\t256"
    ],
    "globals_used": [
      "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
      "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_megabytes",
          "args": [
            "osb->sb",
            "ocfs2_local_alloc_size(sb) * 8"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_megabytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "850-854",
          "snippet": "static inline unsigned int ocfs2_clusters_to_megabytes(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int clusters)\n{\n\treturn clusters >> (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_to_megabytes(struct super_block *sb,\n\t\t\t\t\t\t       unsigned int clusters)\n{\n\treturn clusters >> (20 - OCFS2_SB(sb)->s_clustersize_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_local_alloc_size",
          "args": [
            "sb"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_local_alloc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1537-1545",
          "snippet": "static inline int ocfs2_local_alloc_size(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_lab.la_bitmap);\n\n\treturn size;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_local_alloc_size(int blocksize)\n{\n\tint size;\n\n\tsize = blocksize -\n\t\toffsetof(struct ocfs2_dinode, id2.i_lab.la_bitmap);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_group_bitmap_size",
          "args": [
            "sb",
            "0",
            "osb->s_feature_incompat"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_group_bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1547-1565",
          "snippet": "static inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_MAX_BG_BITMAP_SIZE\t256",
            "#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_MAX_BG_BITMAP_SIZE\t256\n#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000\n\nstatic inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define\tOCFS2_LA_OLD_DEFAULT\t8\n#define\tOCFS2_LA_MAX_DEFAULT_MB\t256\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nunsigned int ocfs2_la_default_mb(struct ocfs2_super *osb)\n{\n\tunsigned int la_mb;\n\tunsigned int gd_mb;\n\tunsigned int la_max_mb;\n\tunsigned int megs_per_slot;\n\tstruct super_block *sb = osb->sb;\n\n\tgd_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t8 * ocfs2_group_bitmap_size(sb, 0, osb->s_feature_incompat));\n\n\t/*\n\t * This takes care of files systems with very small group\n\t * descriptors - 512 byte blocksize at cluster sizes lower\n\t * than 16K and also 1k blocksize with 4k cluster size.\n\t */\n\tif ((sb->s_blocksize == 512 && osb->s_clustersize <= 8192)\n\t    || (sb->s_blocksize == 1024 && osb->s_clustersize == 4096))\n\t\treturn OCFS2_LA_OLD_DEFAULT;\n\n\t/*\n\t * Leave enough room for some block groups and make the final\n\t * value we work from a multiple of 4.\n\t */\n\tgd_mb -= 16;\n\tgd_mb &= 0xFFFFFFFB;\n\n\tla_mb = gd_mb;\n\n\t/*\n\t * Keep window sizes down to a reasonable default\n\t */\n\tif (la_mb > OCFS2_LA_MAX_DEFAULT_MB) {\n\t\t/*\n\t\t * Some clustersize / blocksize combinations will have\n\t\t * given us a larger than OCFS2_LA_MAX_DEFAULT_MB\n\t\t * default size, but get poor distribution when\n\t\t * limited to exactly 256 megabytes.\n\t\t *\n\t\t * As an example, 16K clustersize at 4K blocksize\n\t\t * gives us a cluster group size of 504M. Paring the\n\t\t * local alloc size down to 256 however, would give us\n\t\t * only one window and around 200MB left in the\n\t\t * cluster group. Instead, find the first size below\n\t\t * 256 which would give us an even distribution.\n\t\t *\n\t\t * Larger cluster group sizes actually work out pretty\n\t\t * well when pared to 256, so we don't have to do this\n\t\t * for any group that fits more than two\n\t\t * OCFS2_LA_MAX_DEFAULT_MB windows.\n\t\t */\n\t\tif (gd_mb > (2 * OCFS2_LA_MAX_DEFAULT_MB))\n\t\t\tla_mb = 256;\n\t\telse {\n\t\t\tunsigned int gd_mult = gd_mb;\n\n\t\t\twhile (gd_mult > 256)\n\t\t\t\tgd_mult = gd_mult >> 1;\n\n\t\t\tla_mb = gd_mult;\n\t\t}\n\t}\n\n\tmegs_per_slot = osb->osb_clusters_at_boot / osb->max_slots;\n\tmegs_per_slot = ocfs2_clusters_to_megabytes(osb->sb, megs_per_slot);\n\t/* Too many nodes, too few disk clusters. */\n\tif (megs_per_slot < la_mb)\n\t\tla_mb = megs_per_slot;\n\n\t/* We can't store more bits than we can in a block. */\n\tla_max_mb = ocfs2_clusters_to_megabytes(osb->sb,\n\t\t\t\t\t\tocfs2_local_alloc_size(sb) * 8);\n\tif (la_mb > la_max_mb)\n\t\tla_mb = la_max_mb;\n\n\treturn la_mb;\n}"
  }
]