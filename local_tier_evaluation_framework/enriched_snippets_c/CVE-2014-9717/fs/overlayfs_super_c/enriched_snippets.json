[
  {
    "function_name": "ovl_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "1040-1043",
    "snippet": "static void __exit ovl_exit(void)\n{\n\tunregister_filesystem(&ovl_fs_type);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ovl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"overlay\",\n\t.mount\t\t= ovl_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ovl_fs_type"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct file_system_type ovl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"overlay\",\n\t.mount\t\t= ovl_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic void __exit ovl_exit(void)\n{\n\tunregister_filesystem(&ovl_fs_type);\n}"
  },
  {
    "function_name": "ovl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "1035-1038",
    "snippet": "static int __init ovl_init(void)\n{\n\treturn register_filesystem(&ovl_fs_type);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ovl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"overlay\",\n\t.mount\t\t= ovl_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ovl_fs_type"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct file_system_type ovl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"overlay\",\n\t.mount\t\t= ovl_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int __init ovl_init(void)\n{\n\treturn register_filesystem(&ovl_fs_type);\n}"
  },
  {
    "function_name": "ovl_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "1021-1025",
    "snippet": "static struct dentry *ovl_mount(struct file_system_type *fs_type, int flags,\n\t\t\t\tconst char *dev_name, void *raw_data)\n{\n\treturn mount_nodev(fs_type, flags, raw_data, ovl_fill_super);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "fs_type",
            "flags",
            "raw_data",
            "ovl_fill_super"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_mount(struct file_system_type *fs_type, int flags,\n\t\t\t\tconst char *dev_name, void *raw_data)\n{\n\treturn mount_nodev(fs_type, flags, raw_data, ovl_fill_super);\n}"
  },
  {
    "function_name": "ovl_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "817-1019",
    "snippet": "static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct path upperpath = { NULL, NULL };\n\tstruct path workpath = { NULL, NULL };\n\tstruct dentry *root_dentry;\n\tstruct ovl_entry *oe;\n\tstruct ovl_fs *ufs;\n\tstruct path *stack = NULL;\n\tchar *lowertmp;\n\tchar *lower;\n\tunsigned int numlower;\n\tunsigned int stacklen = 0;\n\tunsigned int i;\n\tint err;\n\n\terr = -ENOMEM;\n\tufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);\n\tif (!ufs)\n\t\tgoto out;\n\n\terr = ovl_parse_opt((char *) data, &ufs->config);\n\tif (err)\n\t\tgoto out_free_config;\n\n\terr = -EINVAL;\n\tif (!ufs->config.lowerdir) {\n\t\tpr_err(\"overlayfs: missing 'lowerdir'\\n\");\n\t\tgoto out_free_config;\n\t}\n\n\tsb->s_stack_depth = 0;\n\tif (ufs->config.upperdir) {\n\t\tif (!ufs->config.workdir) {\n\t\t\tpr_err(\"overlayfs: missing 'workdir'\\n\");\n\t\t\tgoto out_free_config;\n\t\t}\n\n\t\terr = ovl_mount_dir(ufs->config.upperdir, &upperpath);\n\t\tif (err)\n\t\t\tgoto out_free_config;\n\n\t\t/* Upper fs should not be r/o */\n\t\tif (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {\n\t\t\tpr_err(\"overlayfs: upper fs is r/o, try multi-lower layers mount\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_upperpath;\n\t\t}\n\n\t\terr = ovl_mount_dir(ufs->config.workdir, &workpath);\n\t\tif (err)\n\t\t\tgoto out_put_upperpath;\n\n\t\terr = -EINVAL;\n\t\tif (upperpath.mnt != workpath.mnt) {\n\t\t\tpr_err(\"overlayfs: workdir and upperdir must reside under the same mount\\n\");\n\t\t\tgoto out_put_workpath;\n\t\t}\n\t\tif (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {\n\t\t\tpr_err(\"overlayfs: workdir and upperdir must be separate subtrees\\n\");\n\t\t\tgoto out_put_workpath;\n\t\t}\n\t\tsb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;\n\t}\n\terr = -ENOMEM;\n\tlowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);\n\tif (!lowertmp)\n\t\tgoto out_put_workpath;\n\n\terr = -EINVAL;\n\tstacklen = ovl_split_lowerdirs(lowertmp);\n\tif (stacklen > OVL_MAX_STACK) {\n\t\tpr_err(\"overlayfs: too many lower directries, limit is %d\\n\",\n\t\t       OVL_MAX_STACK);\n\t\tgoto out_free_lowertmp;\n\t} else if (!ufs->config.upperdir && stacklen == 1) {\n\t\tpr_err(\"overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\\n\");\n\t\tgoto out_free_lowertmp;\n\t}\n\n\tstack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);\n\tif (!stack)\n\t\tgoto out_free_lowertmp;\n\n\tlower = lowertmp;\n\tfor (numlower = 0; numlower < stacklen; numlower++) {\n\t\terr = ovl_lower_dir(lower, &stack[numlower],\n\t\t\t\t    &ufs->lower_namelen, &sb->s_stack_depth);\n\t\tif (err)\n\t\t\tgoto out_put_lowerpath;\n\n\t\tlower = strchr(lower, '\\0') + 1;\n\t}\n\n\terr = -EINVAL;\n\tsb->s_stack_depth++;\n\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n\t\tpr_err(\"overlayfs: maximum fs stacking depth exceeded\\n\");\n\t\tgoto out_put_lowerpath;\n\t}\n\n\tif (ufs->config.upperdir) {\n\t\tufs->upper_mnt = clone_private_mount(&upperpath);\n\t\terr = PTR_ERR(ufs->upper_mnt);\n\t\tif (IS_ERR(ufs->upper_mnt)) {\n\t\t\tpr_err(\"overlayfs: failed to clone upperpath\\n\");\n\t\t\tgoto out_put_lowerpath;\n\t\t}\n\n\t\tufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);\n\t\terr = PTR_ERR(ufs->workdir);\n\t\tif (IS_ERR(ufs->workdir)) {\n\t\t\tpr_err(\"overlayfs: failed to create directory %s/%s\\n\",\n\t\t\t       ufs->config.workdir, OVL_WORKDIR_NAME);\n\t\t\tgoto out_put_upper_mnt;\n\t\t}\n\t}\n\n\terr = -ENOMEM;\n\tufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);\n\tif (ufs->lower_mnt == NULL)\n\t\tgoto out_put_workdir;\n\tfor (i = 0; i < numlower; i++) {\n\t\tstruct vfsmount *mnt = clone_private_mount(&stack[i]);\n\n\t\terr = PTR_ERR(mnt);\n\t\tif (IS_ERR(mnt)) {\n\t\t\tpr_err(\"overlayfs: failed to clone lowerpath\\n\");\n\t\t\tgoto out_put_lower_mnt;\n\t\t}\n\t\t/*\n\t\t * Make lower_mnt R/O.  That way fchmod/fchown on lower file\n\t\t * will fail instead of modifying lower fs.\n\t\t */\n\t\tmnt->mnt_flags |= MNT_READONLY;\n\n\t\tufs->lower_mnt[ufs->numlower] = mnt;\n\t\tufs->numlower++;\n\t}\n\n\t/* If the upper fs is nonexistent, we mark overlayfs r/o too */\n\tif (!ufs->upper_mnt)\n\t\tsb->s_flags |= MS_RDONLY;\n\n\tsb->s_d_op = &ovl_dentry_operations;\n\n\terr = -ENOMEM;\n\toe = ovl_alloc_entry(numlower);\n\tif (!oe)\n\t\tgoto out_put_lower_mnt;\n\n\troot_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe));\n\tif (!root_dentry)\n\t\tgoto out_free_oe;\n\n\tmntput(upperpath.mnt);\n\tfor (i = 0; i < numlower; i++)\n\t\tmntput(stack[i].mnt);\n\tpath_put(&workpath);\n\tkfree(lowertmp);\n\n\toe->__upperdentry = upperpath.dentry;\n\tfor (i = 0; i < numlower; i++) {\n\t\toe->lowerstack[i].dentry = stack[i].dentry;\n\t\toe->lowerstack[i].mnt = ufs->lower_mnt[i];\n\t}\n\n\troot_dentry->d_fsdata = oe;\n\n\tsb->s_magic = OVERLAYFS_SUPER_MAGIC;\n\tsb->s_op = &ovl_super_operations;\n\tsb->s_root = root_dentry;\n\tsb->s_fs_info = ufs;\n\n\treturn 0;\n\nout_free_oe:\n\tkfree(oe);\nout_put_lower_mnt:\n\tfor (i = 0; i < ufs->numlower; i++)\n\t\tmntput(ufs->lower_mnt[i]);\n\tkfree(ufs->lower_mnt);\nout_put_workdir:\n\tdput(ufs->workdir);\nout_put_upper_mnt:\n\tmntput(ufs->upper_mnt);\nout_put_lowerpath:\n\tfor (i = 0; i < numlower; i++)\n\t\tpath_put(&stack[i]);\n\tkfree(stack);\nout_free_lowertmp:\n\tkfree(lowertmp);\nout_put_workpath:\n\tpath_put(&workpath);\nout_put_upperpath:\n\tpath_put(&upperpath);\nout_free_config:\n\tkfree(ufs->config.lowerdir);\n\tkfree(ufs->config.upperdir);\n\tkfree(ufs->config.workdir);\n\tkfree(ufs);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OVL_WORKDIR_NAME \"work\"",
      "#define OVL_MAX_STACK 500",
      "#define OVERLAYFS_SUPER_MAGIC 0x794c7630"
    ],
    "globals_used": [
      "static const struct dentry_operations ovl_dentry_operations = {\n\t.d_release = ovl_dentry_release,\n};",
      "static const struct super_operations ovl_super_operations = {\n\t.put_super\t= ovl_put_super,\n\t.statfs\t\t= ovl_statfs,\n\t.show_options\t= ovl_show_options,\n\t.remount_fs\t= ovl_remount,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs->config.workdir"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs->config.upperdir"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs->config.lowerdir"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&upperpath"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lowertmp"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stack"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "ufs->upper_mnt"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "ufs->workdir"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs->lower_mnt"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oe"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lowertmp"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "ovl_new_inode(sb, S_IFDIR, oe)"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_new_inode",
          "args": [
            "sb",
            "S_IFDIR",
            "oe"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "395-436",
          "snippet": "struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n\t.dentry_open\t= ovl_dentry_open,\n};",
            "static const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.follow_link\t= ovl_follow_link,\n\t.put_link\t= ovl_put_link,\n\t.readlink\t= ovl_readlink,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n\t.dentry_open\t= ovl_dentry_open,\n};\nstatic const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.follow_link\t= ovl_follow_link,\n\t.put_link\t= ovl_put_link,\n\t.readlink\t= ovl_readlink,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};\n\nstruct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_alloc_entry",
          "args": [
            "numlower"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_alloc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "280-289",
          "snippet": "static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)\n{\n\tsize_t size = offsetof(struct ovl_entry, lowerstack[numlower]);\n\tstruct ovl_entry *oe = kzalloc(size, GFP_KERNEL);\n\n\tif (oe)\n\t\toe->numlower = numlower;\n\n\treturn oe;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct ovl_entry *ovl_alloc_entry(unsigned int numlower)\n{\n\tsize_t size = offsetof(struct ovl_entry, lowerstack[numlower]);\n\tstruct ovl_entry *oe = kzalloc(size, GFP_KERNEL);\n\n\tif (oe)\n\t\toe->numlower = numlower;\n\n\treturn oe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: failed to clone lowerpath\\n\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clone_private_mount",
          "args": [
            "&stack[i]"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "clone_private_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1712-1727",
          "snippet": "struct vfsmount *clone_private_mount(struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdown_read(&namespace_sem);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tup_read(&namespace_sem);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\treturn &new_mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(namespace_sem);",
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DECLARE_RWSEM(namespace_sem);\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *clone_private_mount(struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdown_read(&namespace_sem);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tup_read(&namespace_sem);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\treturn &new_mnt->mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "numlower",
            "sizeof(struct vfsmount *)",
            "GFP_KERNEL"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: failed to create directory %s/%s\\n\"",
            "ufs->config.workdir",
            "OVL_WORKDIR_NAME"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ufs->workdir"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ufs->workdir"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_workdir_create",
          "args": [
            "ufs->upper_mnt",
            "workpath.dentry"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_workdir_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "635-682",
          "snippet": "static struct dentry *ovl_workdir_create(struct vfsmount *mnt,\n\t\t\t\t\t struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct dentry *work;\n\tint err;\n\tbool retried = false;\n\n\terr = mnt_want_write(mnt);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\nretry:\n\twork = lookup_one_len(OVL_WORKDIR_NAME, dentry,\n\t\t\t      strlen(OVL_WORKDIR_NAME));\n\n\tif (!IS_ERR(work)) {\n\t\tstruct kstat stat = {\n\t\t\t.mode = S_IFDIR | 0,\n\t\t};\n\n\t\tif (work->d_inode) {\n\t\t\terr = -EEXIST;\n\t\t\tif (retried)\n\t\t\t\tgoto out_dput;\n\n\t\t\tretried = true;\n\t\t\tovl_cleanup(dir, work);\n\t\t\tdput(work);\n\t\t\tgoto retry;\n\t\t}\n\n\t\terr = ovl_create_real(dir, work, &stat, NULL, NULL, true);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\tmnt_drop_write(mnt);\n\n\treturn work;\n\nout_dput:\n\tdput(work);\n\twork = ERR_PTR(err);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OVL_WORKDIR_NAME \"work\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\n#define OVL_WORKDIR_NAME \"work\"\n\nstatic struct dentry *ovl_workdir_create(struct vfsmount *mnt,\n\t\t\t\t\t struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct dentry *work;\n\tint err;\n\tbool retried = false;\n\n\terr = mnt_want_write(mnt);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\nretry:\n\twork = lookup_one_len(OVL_WORKDIR_NAME, dentry,\n\t\t\t      strlen(OVL_WORKDIR_NAME));\n\n\tif (!IS_ERR(work)) {\n\t\tstruct kstat stat = {\n\t\t\t.mode = S_IFDIR | 0,\n\t\t};\n\n\t\tif (work->d_inode) {\n\t\t\terr = -EEXIST;\n\t\t\tif (retried)\n\t\t\t\tgoto out_dput;\n\n\t\t\tretried = true;\n\t\t\tovl_cleanup(dir, work);\n\t\t\tdput(work);\n\t\t\tgoto retry;\n\t\t}\n\n\t\terr = ovl_create_real(dir, work, &stat, NULL, NULL, true);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\tmnt_drop_write(mnt);\n\n\treturn work;\n\nout_dput:\n\tdput(work);\n\twork = ERR_PTR(err);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: failed to clone upperpath\\n\""
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ufs->upper_mnt"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ufs->upper_mnt"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: maximum fs stacking depth exceeded\\n\""
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "lower",
            "'\\0'"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_lower_dir",
          "args": [
            "lower",
            "&stack[numlower]",
            "&ufs->lower_namelen",
            "&sb->s_stack_depth"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lower_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "759-783",
          "snippet": "static int ovl_lower_dir(const char *name, struct path *path, long *namelen,\n\t\t\t int *stack_depth)\n{\n\tint err;\n\tstruct kstatfs statfs;\n\n\terr = ovl_mount_dir_noesc(name, path);\n\tif (err)\n\t\tgoto out;\n\n\terr = vfs_statfs(path, &statfs);\n\tif (err) {\n\t\tpr_err(\"overlayfs: statfs failed on '%s'\\n\", name);\n\t\tgoto out_put;\n\t}\n\t*namelen = max(*namelen, statfs.f_namelen);\n\t*stack_depth = max(*stack_depth, path->mnt->mnt_sb->s_stack_depth);\n\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lower_dir(const char *name, struct path *path, long *namelen,\n\t\t\t int *stack_depth)\n{\n\tint err;\n\tstruct kstatfs statfs;\n\n\terr = ovl_mount_dir_noesc(name, path);\n\tif (err)\n\t\tgoto out;\n\n\terr = vfs_statfs(path, &statfs);\n\tif (err) {\n\t\tpr_err(\"overlayfs: statfs failed on '%s'\\n\", name);\n\t\tgoto out_put;\n\t}\n\t*namelen = max(*namelen, statfs.f_namelen);\n\t*stack_depth = max(*stack_depth, path->mnt->mnt_sb->s_stack_depth);\n\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "stacklen",
            "sizeof(struct path)",
            "GFP_KERNEL"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\\n\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: too many lower directries, limit is %d\\n\"",
            "OVL_MAX_STACK"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_split_lowerdirs",
          "args": [
            "lowertmp"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_split_lowerdirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "797-815",
          "snippet": "static unsigned int ovl_split_lowerdirs(char *str)\n{\n\tunsigned int ctr = 1;\n\tchar *s, *d;\n\n\tfor (s = d = str;; s++, d++) {\n\t\tif (*s == '\\\\') {\n\t\t\ts++;\n\t\t} else if (*s == ':') {\n\t\t\t*d = '\\0';\n\t\t\tctr++;\n\t\t\tcontinue;\n\t\t}\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n\treturn ctr;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic unsigned int ovl_split_lowerdirs(char *str)\n{\n\tunsigned int ctr = 1;\n\tchar *s, *d;\n\n\tfor (s = d = str;; s++, d++) {\n\t\tif (*s == '\\\\') {\n\t\t\ts++;\n\t\t} else if (*s == ':') {\n\t\t\t*d = '\\0';\n\t\t\tctr++;\n\t\t\tcontinue;\n\t\t}\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n\treturn ctr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "ufs->config.lowerdir",
            "GFP_KERNEL"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: workdir and upperdir must be separate subtrees\\n\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_workdir_ok",
          "args": [
            "workpath.dentry",
            "upperpath.dentry"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_workdir_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "786-795",
          "snippet": "static bool ovl_workdir_ok(struct dentry *workdir, struct dentry *upperdir)\n{\n\tbool ok = false;\n\n\tif (workdir != upperdir) {\n\t\tok = (lock_rename(workdir, upperdir) == NULL);\n\t\tunlock_rename(workdir, upperdir);\n\t}\n\treturn ok;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic bool ovl_workdir_ok(struct dentry *workdir, struct dentry *upperdir)\n{\n\tbool ok = false;\n\n\tif (workdir != upperdir) {\n\t\tok = (lock_rename(workdir, upperdir) == NULL);\n\t\tunlock_rename(workdir, upperdir);\n\t}\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: workdir and upperdir must reside under the same mount\\n\""
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_mount_dir",
          "args": [
            "ufs->config.workdir",
            "&workpath"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_mount_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "746-757",
          "snippet": "static int ovl_mount_dir(const char *name, struct path *path)\n{\n\tint err = -ENOMEM;\n\tchar *tmp = kstrdup(name, GFP_KERNEL);\n\n\tif (tmp) {\n\t\tovl_unescape(tmp);\n\t\terr = ovl_mount_dir_noesc(tmp, path);\n\t\tkfree(tmp);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_mount_dir(const char *name, struct path *path)\n{\n\tint err = -ENOMEM;\n\tchar *tmp = kstrdup(name, GFP_KERNEL);\n\n\tif (tmp) {\n\t\tovl_unescape(tmp);\n\t\terr = ovl_mount_dir_noesc(tmp, path);\n\t\tkfree(tmp);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: upper fs is r/o, try multi-lower layers mount\\n\""
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: missing 'workdir'\\n\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: missing 'lowerdir'\\n\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_parse_opt",
          "args": [
            "(char *) data",
            "&ufs->config"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_parse_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "582-631",
          "snippet": "static int ovl_parse_opt(char *opt, struct ovl_config *config)\n{\n\tchar *p;\n\n\twhile ((p = ovl_next_opt(&opt)) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, ovl_tokens, args);\n\t\tswitch (token) {\n\t\tcase OPT_UPPERDIR:\n\t\t\tkfree(config->upperdir);\n\t\t\tconfig->upperdir = match_strdup(&args[0]);\n\t\t\tif (!config->upperdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase OPT_LOWERDIR:\n\t\t\tkfree(config->lowerdir);\n\t\t\tconfig->lowerdir = match_strdup(&args[0]);\n\t\t\tif (!config->lowerdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase OPT_WORKDIR:\n\t\t\tkfree(config->workdir);\n\t\t\tconfig->workdir = match_strdup(&args[0]);\n\t\t\tif (!config->workdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"overlayfs: unrecognized mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Workdir is useless in non-upper mount */\n\tif (!config->upperdir && config->workdir) {\n\t\tpr_info(\"overlayfs: option \\\"workdir=%s\\\" is useless in a non-upper mount, ignore\\n\",\n\t\t\tconfig->workdir);\n\t\tkfree(config->workdir);\n\t\tconfig->workdir = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t ovl_tokens = {\n\t{OPT_LOWERDIR,\t\t\t\"lowerdir=%s\"},\n\t{OPT_UPPERDIR,\t\t\t\"upperdir=%s\"},\n\t{OPT_WORKDIR,\t\t\t\"workdir=%s\"},\n\t{OPT_ERR,\t\t\tNULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic const match_table_t ovl_tokens = {\n\t{OPT_LOWERDIR,\t\t\t\"lowerdir=%s\"},\n\t{OPT_UPPERDIR,\t\t\t\"upperdir=%s\"},\n\t{OPT_WORKDIR,\t\t\t\"workdir=%s\"},\n\t{OPT_ERR,\t\t\tNULL}\n};\n\nstatic int ovl_parse_opt(char *opt, struct ovl_config *config)\n{\n\tchar *p;\n\n\twhile ((p = ovl_next_opt(&opt)) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, ovl_tokens, args);\n\t\tswitch (token) {\n\t\tcase OPT_UPPERDIR:\n\t\t\tkfree(config->upperdir);\n\t\t\tconfig->upperdir = match_strdup(&args[0]);\n\t\t\tif (!config->upperdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase OPT_LOWERDIR:\n\t\t\tkfree(config->lowerdir);\n\t\t\tconfig->lowerdir = match_strdup(&args[0]);\n\t\t\tif (!config->lowerdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase OPT_WORKDIR:\n\t\t\tkfree(config->workdir);\n\t\t\tconfig->workdir = match_strdup(&args[0]);\n\t\t\tif (!config->workdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"overlayfs: unrecognized mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Workdir is useless in non-upper mount */\n\tif (!config->upperdir && config->workdir) {\n\t\tpr_info(\"overlayfs: option \\\"workdir=%s\\\" is useless in a non-upper mount, ignore\\n\",\n\t\t\tconfig->workdir);\n\t\tkfree(config->workdir);\n\t\tconfig->workdir = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ovl_fs)",
            "GFP_KERNEL"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\n#define OVL_WORKDIR_NAME \"work\"\n#define OVL_MAX_STACK 500\n#define OVERLAYFS_SUPER_MAGIC 0x794c7630\n\nstatic const struct dentry_operations ovl_dentry_operations = {\n\t.d_release = ovl_dentry_release,\n};\nstatic const struct super_operations ovl_super_operations = {\n\t.put_super\t= ovl_put_super,\n\t.statfs\t\t= ovl_statfs,\n\t.show_options\t= ovl_show_options,\n\t.remount_fs\t= ovl_remount,\n};\n\nstatic int ovl_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct path upperpath = { NULL, NULL };\n\tstruct path workpath = { NULL, NULL };\n\tstruct dentry *root_dentry;\n\tstruct ovl_entry *oe;\n\tstruct ovl_fs *ufs;\n\tstruct path *stack = NULL;\n\tchar *lowertmp;\n\tchar *lower;\n\tunsigned int numlower;\n\tunsigned int stacklen = 0;\n\tunsigned int i;\n\tint err;\n\n\terr = -ENOMEM;\n\tufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);\n\tif (!ufs)\n\t\tgoto out;\n\n\terr = ovl_parse_opt((char *) data, &ufs->config);\n\tif (err)\n\t\tgoto out_free_config;\n\n\terr = -EINVAL;\n\tif (!ufs->config.lowerdir) {\n\t\tpr_err(\"overlayfs: missing 'lowerdir'\\n\");\n\t\tgoto out_free_config;\n\t}\n\n\tsb->s_stack_depth = 0;\n\tif (ufs->config.upperdir) {\n\t\tif (!ufs->config.workdir) {\n\t\t\tpr_err(\"overlayfs: missing 'workdir'\\n\");\n\t\t\tgoto out_free_config;\n\t\t}\n\n\t\terr = ovl_mount_dir(ufs->config.upperdir, &upperpath);\n\t\tif (err)\n\t\t\tgoto out_free_config;\n\n\t\t/* Upper fs should not be r/o */\n\t\tif (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {\n\t\t\tpr_err(\"overlayfs: upper fs is r/o, try multi-lower layers mount\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_put_upperpath;\n\t\t}\n\n\t\terr = ovl_mount_dir(ufs->config.workdir, &workpath);\n\t\tif (err)\n\t\t\tgoto out_put_upperpath;\n\n\t\terr = -EINVAL;\n\t\tif (upperpath.mnt != workpath.mnt) {\n\t\t\tpr_err(\"overlayfs: workdir and upperdir must reside under the same mount\\n\");\n\t\t\tgoto out_put_workpath;\n\t\t}\n\t\tif (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {\n\t\t\tpr_err(\"overlayfs: workdir and upperdir must be separate subtrees\\n\");\n\t\t\tgoto out_put_workpath;\n\t\t}\n\t\tsb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;\n\t}\n\terr = -ENOMEM;\n\tlowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);\n\tif (!lowertmp)\n\t\tgoto out_put_workpath;\n\n\terr = -EINVAL;\n\tstacklen = ovl_split_lowerdirs(lowertmp);\n\tif (stacklen > OVL_MAX_STACK) {\n\t\tpr_err(\"overlayfs: too many lower directries, limit is %d\\n\",\n\t\t       OVL_MAX_STACK);\n\t\tgoto out_free_lowertmp;\n\t} else if (!ufs->config.upperdir && stacklen == 1) {\n\t\tpr_err(\"overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\\n\");\n\t\tgoto out_free_lowertmp;\n\t}\n\n\tstack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);\n\tif (!stack)\n\t\tgoto out_free_lowertmp;\n\n\tlower = lowertmp;\n\tfor (numlower = 0; numlower < stacklen; numlower++) {\n\t\terr = ovl_lower_dir(lower, &stack[numlower],\n\t\t\t\t    &ufs->lower_namelen, &sb->s_stack_depth);\n\t\tif (err)\n\t\t\tgoto out_put_lowerpath;\n\n\t\tlower = strchr(lower, '\\0') + 1;\n\t}\n\n\terr = -EINVAL;\n\tsb->s_stack_depth++;\n\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n\t\tpr_err(\"overlayfs: maximum fs stacking depth exceeded\\n\");\n\t\tgoto out_put_lowerpath;\n\t}\n\n\tif (ufs->config.upperdir) {\n\t\tufs->upper_mnt = clone_private_mount(&upperpath);\n\t\terr = PTR_ERR(ufs->upper_mnt);\n\t\tif (IS_ERR(ufs->upper_mnt)) {\n\t\t\tpr_err(\"overlayfs: failed to clone upperpath\\n\");\n\t\t\tgoto out_put_lowerpath;\n\t\t}\n\n\t\tufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);\n\t\terr = PTR_ERR(ufs->workdir);\n\t\tif (IS_ERR(ufs->workdir)) {\n\t\t\tpr_err(\"overlayfs: failed to create directory %s/%s\\n\",\n\t\t\t       ufs->config.workdir, OVL_WORKDIR_NAME);\n\t\t\tgoto out_put_upper_mnt;\n\t\t}\n\t}\n\n\terr = -ENOMEM;\n\tufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);\n\tif (ufs->lower_mnt == NULL)\n\t\tgoto out_put_workdir;\n\tfor (i = 0; i < numlower; i++) {\n\t\tstruct vfsmount *mnt = clone_private_mount(&stack[i]);\n\n\t\terr = PTR_ERR(mnt);\n\t\tif (IS_ERR(mnt)) {\n\t\t\tpr_err(\"overlayfs: failed to clone lowerpath\\n\");\n\t\t\tgoto out_put_lower_mnt;\n\t\t}\n\t\t/*\n\t\t * Make lower_mnt R/O.  That way fchmod/fchown on lower file\n\t\t * will fail instead of modifying lower fs.\n\t\t */\n\t\tmnt->mnt_flags |= MNT_READONLY;\n\n\t\tufs->lower_mnt[ufs->numlower] = mnt;\n\t\tufs->numlower++;\n\t}\n\n\t/* If the upper fs is nonexistent, we mark overlayfs r/o too */\n\tif (!ufs->upper_mnt)\n\t\tsb->s_flags |= MS_RDONLY;\n\n\tsb->s_d_op = &ovl_dentry_operations;\n\n\terr = -ENOMEM;\n\toe = ovl_alloc_entry(numlower);\n\tif (!oe)\n\t\tgoto out_put_lower_mnt;\n\n\troot_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe));\n\tif (!root_dentry)\n\t\tgoto out_free_oe;\n\n\tmntput(upperpath.mnt);\n\tfor (i = 0; i < numlower; i++)\n\t\tmntput(stack[i].mnt);\n\tpath_put(&workpath);\n\tkfree(lowertmp);\n\n\toe->__upperdentry = upperpath.dentry;\n\tfor (i = 0; i < numlower; i++) {\n\t\toe->lowerstack[i].dentry = stack[i].dentry;\n\t\toe->lowerstack[i].mnt = ufs->lower_mnt[i];\n\t}\n\n\troot_dentry->d_fsdata = oe;\n\n\tsb->s_magic = OVERLAYFS_SUPER_MAGIC;\n\tsb->s_op = &ovl_super_operations;\n\tsb->s_root = root_dentry;\n\tsb->s_fs_info = ufs;\n\n\treturn 0;\n\nout_free_oe:\n\tkfree(oe);\nout_put_lower_mnt:\n\tfor (i = 0; i < ufs->numlower; i++)\n\t\tmntput(ufs->lower_mnt[i]);\n\tkfree(ufs->lower_mnt);\nout_put_workdir:\n\tdput(ufs->workdir);\nout_put_upper_mnt:\n\tmntput(ufs->upper_mnt);\nout_put_lowerpath:\n\tfor (i = 0; i < numlower; i++)\n\t\tpath_put(&stack[i]);\n\tkfree(stack);\nout_free_lowertmp:\n\tkfree(lowertmp);\nout_put_workpath:\n\tpath_put(&workpath);\nout_put_upperpath:\n\tpath_put(&upperpath);\nout_free_config:\n\tkfree(ufs->config.lowerdir);\n\tkfree(ufs->config.upperdir);\n\tkfree(ufs->config.workdir);\n\tkfree(ufs);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_split_lowerdirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "797-815",
    "snippet": "static unsigned int ovl_split_lowerdirs(char *str)\n{\n\tunsigned int ctr = 1;\n\tchar *s, *d;\n\n\tfor (s = d = str;; s++, d++) {\n\t\tif (*s == '\\\\') {\n\t\t\ts++;\n\t\t} else if (*s == ':') {\n\t\t\t*d = '\\0';\n\t\t\tctr++;\n\t\t\tcontinue;\n\t\t}\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n\treturn ctr;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic unsigned int ovl_split_lowerdirs(char *str)\n{\n\tunsigned int ctr = 1;\n\tchar *s, *d;\n\n\tfor (s = d = str;; s++, d++) {\n\t\tif (*s == '\\\\') {\n\t\t\ts++;\n\t\t} else if (*s == ':') {\n\t\t\t*d = '\\0';\n\t\t\tctr++;\n\t\t\tcontinue;\n\t\t}\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n\treturn ctr;\n}"
  },
  {
    "function_name": "ovl_workdir_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "786-795",
    "snippet": "static bool ovl_workdir_ok(struct dentry *workdir, struct dentry *upperdir)\n{\n\tbool ok = false;\n\n\tif (workdir != upperdir) {\n\t\tok = (lock_rename(workdir, upperdir) == NULL);\n\t\tunlock_rename(workdir, upperdir);\n\t}\n\treturn ok;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2537-2544",
          "snippet": "void unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid unlock_rename(struct dentry *p1, struct dentry *p2)\n{\n\tmutex_unlock(&p1->d_inode->i_mutex);\n\tif (p1 != p2) {\n\t\tmutex_unlock(&p2->d_inode->i_mutex);\n\t\tmutex_unlock(&p1->d_inode->i_sb->s_vfs_rename_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_rename",
          "args": [
            "workdir",
            "upperdir"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lock_rename_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "192-210",
          "snippet": "static int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lock_rename_workdir(struct dentry *workdir,\n\t\t\t\t   struct dentry *upperdir)\n{\n\t/* Workdir should not be the same as upperdir */\n\tif (workdir == upperdir)\n\t\tgoto err;\n\n\t/* Workdir should not be subdir of upperdir and vice versa */\n\tif (lock_rename(workdir, upperdir) != NULL)\n\t\tgoto err_unlock;\n\n\treturn 0;\n\nerr_unlock:\n\tunlock_rename(workdir, upperdir);\nerr:\n\tpr_err(\"overlayfs: failed to lock workdir+upperdir\\n\");\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic bool ovl_workdir_ok(struct dentry *workdir, struct dentry *upperdir)\n{\n\tbool ok = false;\n\n\tif (workdir != upperdir) {\n\t\tok = (lock_rename(workdir, upperdir) == NULL);\n\t\tunlock_rename(workdir, upperdir);\n\t}\n\treturn ok;\n}"
  },
  {
    "function_name": "ovl_lower_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "759-783",
    "snippet": "static int ovl_lower_dir(const char *name, struct path *path, long *namelen,\n\t\t\t int *stack_depth)\n{\n\tint err;\n\tstruct kstatfs statfs;\n\n\terr = ovl_mount_dir_noesc(name, path);\n\tif (err)\n\t\tgoto out;\n\n\terr = vfs_statfs(path, &statfs);\n\tif (err) {\n\t\tpr_err(\"overlayfs: statfs failed on '%s'\\n\", name);\n\t\tgoto out_put;\n\t}\n\t*namelen = max(*namelen, statfs.f_namelen);\n\t*stack_depth = max(*stack_depth, path->mnt->mnt_sb->s_stack_depth);\n\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "path"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "*stack_depth",
            "path->mnt->mnt_sb->s_stack_depth"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "591-636",
          "snippet": "static unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: statfs failed on '%s'\\n\"",
            "name"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_statfs",
          "args": [
            "path",
            "&statfs"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/statfs.c",
          "lines": "66-74",
          "snippet": "int vfs_statfs(struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint vfs_statfs(struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_mount_dir_noesc",
          "args": [
            "name",
            "path"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_mount_dir_noesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "716-744",
          "snippet": "static int ovl_mount_dir_noesc(const char *name, struct path *path)\n{\n\tint err = -EINVAL;\n\n\tif (!*name) {\n\t\tpr_err(\"overlayfs: empty lowerdir\\n\");\n\t\tgoto out;\n\t}\n\terr = kern_path(name, LOOKUP_FOLLOW, path);\n\tif (err) {\n\t\tpr_err(\"overlayfs: failed to resolve '%s': %i\\n\", name, err);\n\t\tgoto out;\n\t}\n\terr = -EINVAL;\n\tif (!ovl_is_allowed_fs_type(path->dentry)) {\n\t\tpr_err(\"overlayfs: filesystem on '%s' not supported\\n\", name);\n\t\tgoto out_put;\n\t}\n\tif (!S_ISDIR(path->dentry->d_inode->i_mode)) {\n\t\tpr_err(\"overlayfs: '%s' not a directory\\n\", name);\n\t\tgoto out_put;\n\t}\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_mount_dir_noesc(const char *name, struct path *path)\n{\n\tint err = -EINVAL;\n\n\tif (!*name) {\n\t\tpr_err(\"overlayfs: empty lowerdir\\n\");\n\t\tgoto out;\n\t}\n\terr = kern_path(name, LOOKUP_FOLLOW, path);\n\tif (err) {\n\t\tpr_err(\"overlayfs: failed to resolve '%s': %i\\n\", name, err);\n\t\tgoto out;\n\t}\n\terr = -EINVAL;\n\tif (!ovl_is_allowed_fs_type(path->dentry)) {\n\t\tpr_err(\"overlayfs: filesystem on '%s' not supported\\n\", name);\n\t\tgoto out_put;\n\t}\n\tif (!S_ISDIR(path->dentry->d_inode->i_mode)) {\n\t\tpr_err(\"overlayfs: '%s' not a directory\\n\", name);\n\t\tgoto out_put;\n\t}\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_lower_dir(const char *name, struct path *path, long *namelen,\n\t\t\t int *stack_depth)\n{\n\tint err;\n\tstruct kstatfs statfs;\n\n\terr = ovl_mount_dir_noesc(name, path);\n\tif (err)\n\t\tgoto out;\n\n\terr = vfs_statfs(path, &statfs);\n\tif (err) {\n\t\tpr_err(\"overlayfs: statfs failed on '%s'\\n\", name);\n\t\tgoto out_put;\n\t}\n\t*namelen = max(*namelen, statfs.f_namelen);\n\t*stack_depth = max(*stack_depth, path->mnt->mnt_sb->s_stack_depth);\n\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_mount_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "746-757",
    "snippet": "static int ovl_mount_dir(const char *name, struct path *path)\n{\n\tint err = -ENOMEM;\n\tchar *tmp = kstrdup(name, GFP_KERNEL);\n\n\tif (tmp) {\n\t\tovl_unescape(tmp);\n\t\terr = ovl_mount_dir_noesc(tmp, path);\n\t\tkfree(tmp);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_mount_dir_noesc",
          "args": [
            "tmp",
            "path"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_mount_dir_noesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "716-744",
          "snippet": "static int ovl_mount_dir_noesc(const char *name, struct path *path)\n{\n\tint err = -EINVAL;\n\n\tif (!*name) {\n\t\tpr_err(\"overlayfs: empty lowerdir\\n\");\n\t\tgoto out;\n\t}\n\terr = kern_path(name, LOOKUP_FOLLOW, path);\n\tif (err) {\n\t\tpr_err(\"overlayfs: failed to resolve '%s': %i\\n\", name, err);\n\t\tgoto out;\n\t}\n\terr = -EINVAL;\n\tif (!ovl_is_allowed_fs_type(path->dentry)) {\n\t\tpr_err(\"overlayfs: filesystem on '%s' not supported\\n\", name);\n\t\tgoto out_put;\n\t}\n\tif (!S_ISDIR(path->dentry->d_inode->i_mode)) {\n\t\tpr_err(\"overlayfs: '%s' not a directory\\n\", name);\n\t\tgoto out_put;\n\t}\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_mount_dir_noesc(const char *name, struct path *path)\n{\n\tint err = -EINVAL;\n\n\tif (!*name) {\n\t\tpr_err(\"overlayfs: empty lowerdir\\n\");\n\t\tgoto out;\n\t}\n\terr = kern_path(name, LOOKUP_FOLLOW, path);\n\tif (err) {\n\t\tpr_err(\"overlayfs: failed to resolve '%s': %i\\n\", name, err);\n\t\tgoto out;\n\t}\n\terr = -EINVAL;\n\tif (!ovl_is_allowed_fs_type(path->dentry)) {\n\t\tpr_err(\"overlayfs: filesystem on '%s' not supported\\n\", name);\n\t\tgoto out_put;\n\t}\n\tif (!S_ISDIR(path->dentry->d_inode->i_mode)) {\n\t\tpr_err(\"overlayfs: '%s' not a directory\\n\", name);\n\t\tgoto out_put;\n\t}\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_unescape",
          "args": [
            "tmp"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "684-695",
          "snippet": "static void ovl_unescape(char *s)\n{\n\tchar *d = s;\n\n\tfor (;; s++, d++) {\n\t\tif (*s == '\\\\')\n\t\t\ts++;\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic void ovl_unescape(char *s)\n{\n\tchar *d = s;\n\n\tfor (;; s++, d++) {\n\t\tif (*s == '\\\\')\n\t\t\ts++;\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_mount_dir(const char *name, struct path *path)\n{\n\tint err = -ENOMEM;\n\tchar *tmp = kstrdup(name, GFP_KERNEL);\n\n\tif (tmp) {\n\t\tovl_unescape(tmp);\n\t\terr = ovl_mount_dir_noesc(tmp, path);\n\t\tkfree(tmp);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_mount_dir_noesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "716-744",
    "snippet": "static int ovl_mount_dir_noesc(const char *name, struct path *path)\n{\n\tint err = -EINVAL;\n\n\tif (!*name) {\n\t\tpr_err(\"overlayfs: empty lowerdir\\n\");\n\t\tgoto out;\n\t}\n\terr = kern_path(name, LOOKUP_FOLLOW, path);\n\tif (err) {\n\t\tpr_err(\"overlayfs: failed to resolve '%s': %i\\n\", name, err);\n\t\tgoto out;\n\t}\n\terr = -EINVAL;\n\tif (!ovl_is_allowed_fs_type(path->dentry)) {\n\t\tpr_err(\"overlayfs: filesystem on '%s' not supported\\n\", name);\n\t\tgoto out_put;\n\t}\n\tif (!S_ISDIR(path->dentry->d_inode->i_mode)) {\n\t\tpr_err(\"overlayfs: '%s' not a directory\\n\", name);\n\t\tgoto out_put;\n\t}\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "path"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: '%s' not a directory\\n\"",
            "name"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "path->dentry->d_inode->i_mode"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: filesystem on '%s' not supported\\n\"",
            "name"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_is_allowed_fs_type",
          "args": [
            "path->dentry"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_is_allowed_fs_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "697-714",
          "snippet": "static bool ovl_is_allowed_fs_type(struct dentry *root)\n{\n\tconst struct dentry_operations *dop = root->d_op;\n\n\t/*\n\t * We don't support:\n\t *  - automount filesystems\n\t *  - filesystems with revalidate (FIXME for lower layer)\n\t *  - filesystems with case insensitive names\n\t */\n\tif (dop &&\n\t    (dop->d_manage || dop->d_automount ||\n\t     dop->d_revalidate || dop->d_weak_revalidate ||\n\t     dop->d_compare || dop->d_hash)) {\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_allowed_fs_type(struct dentry *root)\n{\n\tconst struct dentry_operations *dop = root->d_op;\n\n\t/*\n\t * We don't support:\n\t *  - automount filesystems\n\t *  - filesystems with revalidate (FIXME for lower layer)\n\t *  - filesystems with case insensitive names\n\t */\n\tif (dop &&\n\t    (dop->d_manage || dop->d_automount ||\n\t     dop->d_revalidate || dop->d_weak_revalidate ||\n\t     dop->d_compare || dop->d_hash)) {\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: failed to resolve '%s': %i\\n\"",
            "name",
            "err"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "name",
            "LOOKUP_FOLLOW",
            "path"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: empty lowerdir\\n\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_mount_dir_noesc(const char *name, struct path *path)\n{\n\tint err = -EINVAL;\n\n\tif (!*name) {\n\t\tpr_err(\"overlayfs: empty lowerdir\\n\");\n\t\tgoto out;\n\t}\n\terr = kern_path(name, LOOKUP_FOLLOW, path);\n\tif (err) {\n\t\tpr_err(\"overlayfs: failed to resolve '%s': %i\\n\", name, err);\n\t\tgoto out;\n\t}\n\terr = -EINVAL;\n\tif (!ovl_is_allowed_fs_type(path->dentry)) {\n\t\tpr_err(\"overlayfs: filesystem on '%s' not supported\\n\", name);\n\t\tgoto out_put;\n\t}\n\tif (!S_ISDIR(path->dentry->d_inode->i_mode)) {\n\t\tpr_err(\"overlayfs: '%s' not a directory\\n\", name);\n\t\tgoto out_put;\n\t}\n\treturn 0;\n\nout_put:\n\tpath_put(path);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_is_allowed_fs_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "697-714",
    "snippet": "static bool ovl_is_allowed_fs_type(struct dentry *root)\n{\n\tconst struct dentry_operations *dop = root->d_op;\n\n\t/*\n\t * We don't support:\n\t *  - automount filesystems\n\t *  - filesystems with revalidate (FIXME for lower layer)\n\t *  - filesystems with case insensitive names\n\t */\n\tif (dop &&\n\t    (dop->d_manage || dop->d_automount ||\n\t     dop->d_revalidate || dop->d_weak_revalidate ||\n\t     dop->d_compare || dop->d_hash)) {\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_allowed_fs_type(struct dentry *root)\n{\n\tconst struct dentry_operations *dop = root->d_op;\n\n\t/*\n\t * We don't support:\n\t *  - automount filesystems\n\t *  - filesystems with revalidate (FIXME for lower layer)\n\t *  - filesystems with case insensitive names\n\t */\n\tif (dop &&\n\t    (dop->d_manage || dop->d_automount ||\n\t     dop->d_revalidate || dop->d_weak_revalidate ||\n\t     dop->d_compare || dop->d_hash)) {\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "ovl_unescape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "684-695",
    "snippet": "static void ovl_unescape(char *s)\n{\n\tchar *d = s;\n\n\tfor (;; s++, d++) {\n\t\tif (*s == '\\\\')\n\t\t\ts++;\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic void ovl_unescape(char *s)\n{\n\tchar *d = s;\n\n\tfor (;; s++, d++) {\n\t\tif (*s == '\\\\')\n\t\t\ts++;\n\t\t*d = *s;\n\t\tif (!*s)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ovl_workdir_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "635-682",
    "snippet": "static struct dentry *ovl_workdir_create(struct vfsmount *mnt,\n\t\t\t\t\t struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct dentry *work;\n\tint err;\n\tbool retried = false;\n\n\terr = mnt_want_write(mnt);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\nretry:\n\twork = lookup_one_len(OVL_WORKDIR_NAME, dentry,\n\t\t\t      strlen(OVL_WORKDIR_NAME));\n\n\tif (!IS_ERR(work)) {\n\t\tstruct kstat stat = {\n\t\t\t.mode = S_IFDIR | 0,\n\t\t};\n\n\t\tif (work->d_inode) {\n\t\t\terr = -EEXIST;\n\t\t\tif (retried)\n\t\t\t\tgoto out_dput;\n\n\t\t\tretried = true;\n\t\t\tovl_cleanup(dir, work);\n\t\t\tdput(work);\n\t\t\tgoto retry;\n\t\t}\n\n\t\terr = ovl_create_real(dir, work, &stat, NULL, NULL, true);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\tmnt_drop_write(mnt);\n\n\treturn work;\n\nout_dput:\n\tdput(work);\n\twork = ERR_PTR(err);\n\tgoto out_unlock;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OVL_WORKDIR_NAME \"work\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "work"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "mnt"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->i_mutex"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_create_real",
          "args": [
            "dir",
            "work",
            "&stat",
            "NULL",
            "NULL",
            "true"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_create_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/dir.c",
          "lines": "72-117",
          "snippet": "int ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_create_real(struct inode *dir, struct dentry *newdentry,\n\t\t    struct kstat *stat, const char *link,\n\t\t    struct dentry *hardlink, bool debug)\n{\n\tint err;\n\n\tif (newdentry->d_inode)\n\t\treturn -ESTALE;\n\n\tif (hardlink) {\n\t\terr = ovl_do_link(hardlink, dir, newdentry, debug);\n\t} else {\n\t\tswitch (stat->mode & S_IFMT) {\n\t\tcase S_IFREG:\n\t\t\terr = ovl_do_create(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFDIR:\n\t\t\terr = ovl_do_mkdir(dir, newdentry, stat->mode, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\tcase S_IFSOCK:\n\t\t\terr = ovl_do_mknod(dir, newdentry,\n\t\t\t\t\t   stat->mode, stat->rdev, debug);\n\t\t\tbreak;\n\n\t\tcase S_IFLNK:\n\t\t\terr = ovl_do_symlink(dir, newdentry, link, debug);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -EPERM;\n\t\t}\n\t}\n\tif (!err && WARN_ON(!newdentry->d_inode)) {\n\t\t/*\n\t\t * Not quite sure if non-instantiated dentry is legal or not.\n\t\t * VFS doesn't seem to care so check and warn here.\n\t\t */\n\t\terr = -ENOENT;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_cleanup",
          "args": [
            "dir",
            "work"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cleanup_whiteouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "535-557",
          "snippet": "void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n{\n\tstruct ovl_cache_entry *p;\n\n\tmutex_lock_nested(&upper->d_inode->i_mutex, I_MUTEX_CHILD);\n\tlist_for_each_entry(p, list, l_node) {\n\t\tstruct dentry *dentry;\n\n\t\tif (!p->is_whiteout)\n\t\t\tcontinue;\n\n\t\tdentry = lookup_one_len(p->name, upper, p->len);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tpr_err(\"overlayfs: lookup '%s/%.*s' failed (%i)\\n\",\n\t\t\t       upper->d_name.name, p->len, p->name,\n\t\t\t       (int) PTR_ERR(dentry));\n\t\t\tcontinue;\n\t\t}\n\t\tovl_cleanup(upper->d_inode, dentry);\n\t\tdput(dentry);\n\t}\n\tmutex_unlock(&upper->d_inode->i_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "work"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "OVL_WORKDIR_NAME",
            "dentry",
            "strlen(OVL_WORKDIR_NAME)"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "OVL_WORKDIR_NAME"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "mnt"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\n#define OVL_WORKDIR_NAME \"work\"\n\nstatic struct dentry *ovl_workdir_create(struct vfsmount *mnt,\n\t\t\t\t\t struct dentry *dentry)\n{\n\tstruct inode *dir = dentry->d_inode;\n\tstruct dentry *work;\n\tint err;\n\tbool retried = false;\n\n\terr = mnt_want_write(mnt);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\nretry:\n\twork = lookup_one_len(OVL_WORKDIR_NAME, dentry,\n\t\t\t      strlen(OVL_WORKDIR_NAME));\n\n\tif (!IS_ERR(work)) {\n\t\tstruct kstat stat = {\n\t\t\t.mode = S_IFDIR | 0,\n\t\t};\n\n\t\tif (work->d_inode) {\n\t\t\terr = -EEXIST;\n\t\t\tif (retried)\n\t\t\t\tgoto out_dput;\n\n\t\t\tretried = true;\n\t\t\tovl_cleanup(dir, work);\n\t\t\tdput(work);\n\t\t\tgoto retry;\n\t\t}\n\n\t\terr = ovl_create_real(dir, work, &stat, NULL, NULL, true);\n\t\tif (err)\n\t\t\tgoto out_dput;\n\t}\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\tmnt_drop_write(mnt);\n\n\treturn work;\n\nout_dput:\n\tdput(work);\n\twork = ERR_PTR(err);\n\tgoto out_unlock;\n}"
  },
  {
    "function_name": "ovl_parse_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "582-631",
    "snippet": "static int ovl_parse_opt(char *opt, struct ovl_config *config)\n{\n\tchar *p;\n\n\twhile ((p = ovl_next_opt(&opt)) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, ovl_tokens, args);\n\t\tswitch (token) {\n\t\tcase OPT_UPPERDIR:\n\t\t\tkfree(config->upperdir);\n\t\t\tconfig->upperdir = match_strdup(&args[0]);\n\t\t\tif (!config->upperdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase OPT_LOWERDIR:\n\t\t\tkfree(config->lowerdir);\n\t\t\tconfig->lowerdir = match_strdup(&args[0]);\n\t\t\tif (!config->lowerdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase OPT_WORKDIR:\n\t\t\tkfree(config->workdir);\n\t\t\tconfig->workdir = match_strdup(&args[0]);\n\t\t\tif (!config->workdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"overlayfs: unrecognized mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Workdir is useless in non-upper mount */\n\tif (!config->upperdir && config->workdir) {\n\t\tpr_info(\"overlayfs: option \\\"workdir=%s\\\" is useless in a non-upper mount, ignore\\n\",\n\t\t\tconfig->workdir);\n\t\tkfree(config->workdir);\n\t\tconfig->workdir = NULL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t ovl_tokens = {\n\t{OPT_LOWERDIR,\t\t\t\"lowerdir=%s\"},\n\t{OPT_UPPERDIR,\t\t\t\"upperdir=%s\"},\n\t{OPT_WORKDIR,\t\t\t\"workdir=%s\"},\n\t{OPT_ERR,\t\t\tNULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "config->workdir"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"overlayfs: option \\\"workdir=%s\\\" is useless in a non-upper mount, ignore\\n\"",
            "config->workdir"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"overlayfs: unrecognized mount option \\\"%s\\\" or missing value\\n\"",
            "p"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "config->workdir"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "config->lowerdir"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "config->upperdir"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "ovl_tokens",
            "args"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_next_opt",
          "args": [
            "&opt"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_next_opt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "559-580",
          "snippet": "static char *ovl_next_opt(char **s)\n{\n\tchar *sbegin = *s;\n\tchar *p;\n\n\tif (sbegin == NULL)\n\t\treturn NULL;\n\n\tfor (p = sbegin; *p; p++) {\n\t\tif (*p == '\\\\') {\n\t\t\tp++;\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t} else if (*p == ',') {\n\t\t\t*p = '\\0';\n\t\t\t*s = p + 1;\n\t\t\treturn sbegin;\n\t\t}\n\t}\n\t*s = NULL;\n\treturn sbegin;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic char *ovl_next_opt(char **s)\n{\n\tchar *sbegin = *s;\n\tchar *p;\n\n\tif (sbegin == NULL)\n\t\treturn NULL;\n\n\tfor (p = sbegin; *p; p++) {\n\t\tif (*p == '\\\\') {\n\t\t\tp++;\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t} else if (*p == ',') {\n\t\t\t*p = '\\0';\n\t\t\t*s = p + 1;\n\t\t\treturn sbegin;\n\t\t}\n\t}\n\t*s = NULL;\n\treturn sbegin;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic const match_table_t ovl_tokens = {\n\t{OPT_LOWERDIR,\t\t\t\"lowerdir=%s\"},\n\t{OPT_UPPERDIR,\t\t\t\"upperdir=%s\"},\n\t{OPT_WORKDIR,\t\t\t\"workdir=%s\"},\n\t{OPT_ERR,\t\t\tNULL}\n};\n\nstatic int ovl_parse_opt(char *opt, struct ovl_config *config)\n{\n\tchar *p;\n\n\twhile ((p = ovl_next_opt(&opt)) != NULL) {\n\t\tint token;\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, ovl_tokens, args);\n\t\tswitch (token) {\n\t\tcase OPT_UPPERDIR:\n\t\t\tkfree(config->upperdir);\n\t\t\tconfig->upperdir = match_strdup(&args[0]);\n\t\t\tif (!config->upperdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase OPT_LOWERDIR:\n\t\t\tkfree(config->lowerdir);\n\t\t\tconfig->lowerdir = match_strdup(&args[0]);\n\t\t\tif (!config->lowerdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tcase OPT_WORKDIR:\n\t\t\tkfree(config->workdir);\n\t\t\tconfig->workdir = match_strdup(&args[0]);\n\t\t\tif (!config->workdir)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"overlayfs: unrecognized mount option \\\"%s\\\" or missing value\\n\", p);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Workdir is useless in non-upper mount */\n\tif (!config->upperdir && config->workdir) {\n\t\tpr_info(\"overlayfs: option \\\"workdir=%s\\\" is useless in a non-upper mount, ignore\\n\",\n\t\t\tconfig->workdir);\n\t\tkfree(config->workdir);\n\t\tconfig->workdir = NULL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_next_opt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "559-580",
    "snippet": "static char *ovl_next_opt(char **s)\n{\n\tchar *sbegin = *s;\n\tchar *p;\n\n\tif (sbegin == NULL)\n\t\treturn NULL;\n\n\tfor (p = sbegin; *p; p++) {\n\t\tif (*p == '\\\\') {\n\t\t\tp++;\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t} else if (*p == ',') {\n\t\t\t*p = '\\0';\n\t\t\t*s = p + 1;\n\t\t\treturn sbegin;\n\t\t}\n\t}\n\t*s = NULL;\n\treturn sbegin;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic char *ovl_next_opt(char **s)\n{\n\tchar *sbegin = *s;\n\tchar *p;\n\n\tif (sbegin == NULL)\n\t\treturn NULL;\n\n\tfor (p = sbegin; *p; p++) {\n\t\tif (*p == '\\\\') {\n\t\t\tp++;\n\t\t\tif (!*p)\n\t\t\t\tbreak;\n\t\t} else if (*p == ',') {\n\t\t\t*p = '\\0';\n\t\t\t*s = p + 1;\n\t\t\treturn sbegin;\n\t\t}\n\t}\n\t*s = NULL;\n\treturn sbegin;\n}"
  },
  {
    "function_name": "ovl_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "528-536",
    "snippet": "static int ovl_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct ovl_fs *ufs = sb->s_fs_info;\n\n\tif (!(*flags & MS_RDONLY) && !ufs->upper_mnt)\n\t\treturn -EROFS;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct ovl_fs *ufs = sb->s_fs_info;\n\n\tif (!(*flags & MS_RDONLY) && !ufs->upper_mnt)\n\t\treturn -EROFS;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "515-526",
    "snippet": "static int ovl_show_options(struct seq_file *m, struct dentry *dentry)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ovl_fs *ufs = sb->s_fs_info;\n\n\tseq_printf(m, \",lowerdir=%s\", ufs->config.lowerdir);\n\tif (ufs->config.upperdir) {\n\t\tseq_printf(m, \",upperdir=%s\", ufs->config.upperdir);\n\t\tseq_printf(m, \",workdir=%s\", ufs->config.workdir);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",workdir=%s\"",
            "ufs->config.workdir"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic int ovl_show_options(struct seq_file *m, struct dentry *dentry)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ovl_fs *ufs = sb->s_fs_info;\n\n\tseq_printf(m, \",lowerdir=%s\", ufs->config.lowerdir);\n\tif (ufs->config.upperdir) {\n\t\tseq_printf(m, \",upperdir=%s\", ufs->config.upperdir);\n\t\tseq_printf(m, \",workdir=%s\", ufs->config.workdir);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ovl_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "491-507",
    "snippet": "static int ovl_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct dentry *root_dentry = dentry->d_sb->s_root;\n\tstruct path path;\n\tint err;\n\n\tovl_path_real(root_dentry, &path);\n\n\terr = vfs_statfs(&path, buf);\n\tif (!err) {\n\t\tbuf->f_namelen = max(buf->f_namelen, ofs->lower_namelen);\n\t\tbuf->f_type = OVERLAYFS_SUPER_MAGIC;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OVERLAYFS_SUPER_MAGIC 0x794c7630"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "buf->f_namelen",
            "ofs->lower_namelen"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "591-636",
          "snippet": "static unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_statfs",
          "args": [
            "&path",
            "buf"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/statfs.c",
          "lines": "66-74",
          "snippet": "int vfs_statfs(struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint vfs_statfs(struct path *path, struct kstatfs *buf)\n{\n\tint error;\n\n\terror = statfs_by_dentry(path->dentry, buf);\n\tif (!error)\n\t\tbuf->f_flags = calculate_f_flags(path->mnt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_real",
          "args": [
            "root_dentry",
            "&path"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "105-115",
          "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\n#define OVERLAYFS_SUPER_MAGIC 0x794c7630\n\nstatic int ovl_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct dentry *root_dentry = dentry->d_sb->s_root;\n\tstruct path path;\n\tint err;\n\n\tovl_path_real(root_dentry, &path);\n\n\terr = vfs_statfs(&path, buf);\n\tif (!err) {\n\t\tbuf->f_namelen = max(buf->f_namelen, ofs->lower_namelen);\n\t\tbuf->f_type = OVERLAYFS_SUPER_MAGIC;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "ovl_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "467-481",
    "snippet": "static void ovl_put_super(struct super_block *sb)\n{\n\tstruct ovl_fs *ufs = sb->s_fs_info;\n\tunsigned i;\n\n\tdput(ufs->workdir);\n\tmntput(ufs->upper_mnt);\n\tfor (i = 0; i < ufs->numlower; i++)\n\t\tmntput(ufs->lower_mnt[i]);\n\n\tkfree(ufs->config.lowerdir);\n\tkfree(ufs->config.upperdir);\n\tkfree(ufs->config.workdir);\n\tkfree(ufs);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs->config.workdir"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs->config.upperdir"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ufs->config.lowerdir"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mntput",
          "args": [
            "ufs->lower_mnt[i]"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "mntput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1118-1127",
          "snippet": "void mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mntput(struct vfsmount *mnt)\n{\n\tif (mnt) {\n\t\tstruct mount *m = real_mount(mnt);\n\t\t/* avoid cacheline pingpong, hope gcc doesn't get \"smart\" */\n\t\tif (unlikely(m->mnt_expiry_mark))\n\t\t\tm->mnt_expiry_mark = 0;\n\t\tmntput_no_expire(m);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "ufs->workdir"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic void ovl_put_super(struct super_block *sb)\n{\n\tstruct ovl_fs *ufs = sb->s_fs_info;\n\tunsigned i;\n\n\tdput(ufs->workdir);\n\tmntput(ufs->upper_mnt);\n\tfor (i = 0; i < ufs->numlower; i++)\n\t\tmntput(ufs->lower_mnt[i]);\n\n\tkfree(ufs->config.lowerdir);\n\tkfree(ufs->config.upperdir);\n\tkfree(ufs->config.workdir);\n\tkfree(ufs);\n}"
  },
  {
    "function_name": "ovl_path_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "462-465",
    "snippet": "struct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "path",
            "flags",
            "current_cred()"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_dentry_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "339-370",
          "snippet": "static int ovl_dentry_open(struct dentry *dentry, struct file *file,\n\t\t    const struct cred *cred)\n{\n\tint err;\n\tstruct path realpath;\n\tenum ovl_path_type type;\n\tbool want_write = false;\n\n\ttype = ovl_path_real(dentry, &realpath);\n\tif (ovl_open_need_copy_up(file->f_flags, type, realpath.dentry)) {\n\t\twant_write = true;\n\t\terr = ovl_want_write(dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\terr = ovl_copy_up_last(dentry, NULL, true);\n\t\telse\n\t\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\tovl_path_upper(dentry, &realpath);\n\t}\n\n\terr = vfs_open(&realpath, file, cred);\nout_drop_write:\n\tif (want_write)\n\t\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int ovl_dentry_open(struct dentry *dentry, struct file *file,\n\t\t    const struct cred *cred)\n{\n\tint err;\n\tstruct path realpath;\n\tenum ovl_path_type type;\n\tbool want_write = false;\n\n\ttype = ovl_path_real(dentry, &realpath);\n\tif (ovl_open_need_copy_up(file->f_flags, type, realpath.dentry)) {\n\t\twant_write = true;\n\t\terr = ovl_want_write(dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (file->f_flags & O_TRUNC)\n\t\t\terr = ovl_copy_up_last(dentry, NULL, true);\n\t\telse\n\t\t\terr = ovl_copy_up(dentry);\n\t\tif (err)\n\t\t\tgoto out_drop_write;\n\n\t\tovl_path_upper(dentry, &realpath);\n\t}\n\n\terr = vfs_open(&realpath, file, cred);\nout_drop_write:\n\tif (want_write)\n\t\tovl_drop_write(dentry);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct file *ovl_path_open(struct path *path, int flags)\n{\n\treturn dentry_open(path, flags, current_cred());\n}"
  },
  {
    "function_name": "ovl_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "331-460",
    "snippet": "struct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags)\n{\n\tstruct ovl_entry *oe;\n\tstruct ovl_entry *poe = dentry->d_parent->d_fsdata;\n\tstruct path *stack = NULL;\n\tstruct dentry *upperdir, *upperdentry = NULL;\n\tunsigned int ctr = 0;\n\tstruct inode *inode = NULL;\n\tbool upperopaque = false;\n\tstruct dentry *this, *prev = NULL;\n\tunsigned int i;\n\tint err;\n\n\tupperdir = ovl_upperdentry_dereference(poe);\n\tif (upperdir) {\n\t\tthis = ovl_lookup_real(upperdir, &dentry->d_name);\n\t\terr = PTR_ERR(this);\n\t\tif (IS_ERR(this))\n\t\t\tgoto out;\n\n\t\tif (this) {\n\t\t\tif (ovl_is_whiteout(this)) {\n\t\t\t\tdput(this);\n\t\t\t\tthis = NULL;\n\t\t\t\tupperopaque = true;\n\t\t\t} else if (poe->numlower && ovl_is_opaquedir(this)) {\n\t\t\t\tupperopaque = true;\n\t\t\t}\n\t\t}\n\t\tupperdentry = prev = this;\n\t}\n\n\tif (!upperopaque && poe->numlower) {\n\t\terr = -ENOMEM;\n\t\tstack = kcalloc(poe->numlower, sizeof(struct path), GFP_KERNEL);\n\t\tif (!stack)\n\t\t\tgoto out_put_upper;\n\t}\n\n\tfor (i = 0; !upperopaque && i < poe->numlower; i++) {\n\t\tbool opaque = false;\n\t\tstruct path lowerpath = poe->lowerstack[i];\n\n\t\tthis = ovl_lookup_real(lowerpath.dentry, &dentry->d_name);\n\t\terr = PTR_ERR(this);\n\t\tif (IS_ERR(this)) {\n\t\t\t/*\n\t\t\t * If it's positive, then treat ENAMETOOLONG as ENOENT.\n\t\t\t */\n\t\t\tif (err == -ENAMETOOLONG && (upperdentry || ctr))\n\t\t\t\tcontinue;\n\t\t\tgoto out_put;\n\t\t}\n\t\tif (!this)\n\t\t\tcontinue;\n\t\tif (ovl_is_whiteout(this)) {\n\t\t\tdput(this);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Only makes sense to check opaque dir if this is not the\n\t\t * lowermost layer.\n\t\t */\n\t\tif (i < poe->numlower - 1 && ovl_is_opaquedir(this))\n\t\t\topaque = true;\n\n\t\tif (prev && (!S_ISDIR(prev->d_inode->i_mode) ||\n\t\t\t     !S_ISDIR(this->d_inode->i_mode))) {\n\t\t\t/*\n\t\t\t * FIXME: check for upper-opaqueness maybe better done\n\t\t\t * in remove code.\n\t\t\t */\n\t\t\tif (prev == upperdentry)\n\t\t\t\tupperopaque = true;\n\t\t\tdput(this);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If this is a non-directory then stop here.\n\t\t */\n\t\tif (!S_ISDIR(this->d_inode->i_mode))\n\t\t\topaque = true;\n\n\t\tstack[ctr].dentry = this;\n\t\tstack[ctr].mnt = lowerpath.mnt;\n\t\tctr++;\n\t\tprev = this;\n\t\tif (opaque)\n\t\t\tbreak;\n\t}\n\n\toe = ovl_alloc_entry(ctr);\n\terr = -ENOMEM;\n\tif (!oe)\n\t\tgoto out_put;\n\n\tif (upperdentry || ctr) {\n\t\tstruct dentry *realdentry;\n\n\t\trealdentry = upperdentry ? upperdentry : stack[0].dentry;\n\n\t\terr = -ENOMEM;\n\t\tinode = ovl_new_inode(dentry->d_sb, realdentry->d_inode->i_mode,\n\t\t\t\t      oe);\n\t\tif (!inode)\n\t\t\tgoto out_free_oe;\n\t\tovl_copyattr(realdentry->d_inode, inode);\n\t}\n\n\toe->opaque = upperopaque;\n\toe->__upperdentry = upperdentry;\n\tmemcpy(oe->lowerstack, stack, sizeof(struct path) * ctr);\n\tkfree(stack);\n\tdentry->d_fsdata = oe;\n\td_add(dentry, inode);\n\n\treturn NULL;\n\nout_free_oe:\n\tkfree(oe);\nout_put:\n\tfor (i = 0; i < ctr; i++)\n\t\tdput(stack[i].dentry);\n\tkfree(stack);\nout_put_upper:\n\tdput(upperdentry);\nout:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "upperdentry"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stack"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oe"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stack"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "oe->lowerstack",
            "stack",
            "sizeof(struct path) * ctr"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_copyattr",
          "args": [
            "realdentry->d_inode",
            "inode"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_copyattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/overlayfs.h",
          "lines": "179-183",
          "snippet": "static inline void ovl_copyattr(struct inode *from, struct inode *to)\n{\n\tto->i_uid = from->i_uid;\n\tto->i_gid = from->i_gid;\n}",
          "includes": [
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n\nstatic inline void ovl_copyattr(struct inode *from, struct inode *to)\n{\n\tto->i_uid = from->i_uid;\n\tto->i_gid = from->i_gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_new_inode",
          "args": [
            "dentry->d_sb",
            "realdentry->d_inode->i_mode",
            "oe"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/inode.c",
          "lines": "395-436",
          "snippet": "struct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n\t.dentry_open\t= ovl_dentry_open,\n};",
            "static const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.follow_link\t= ovl_follow_link,\n\t.put_link\t= ovl_put_link,\n\t.readlink\t= ovl_readlink,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations ovl_file_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.permission\t= ovl_permission,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n\t.dentry_open\t= ovl_dentry_open,\n};\nstatic const struct inode_operations ovl_symlink_inode_operations = {\n\t.setattr\t= ovl_setattr,\n\t.follow_link\t= ovl_follow_link,\n\t.put_link\t= ovl_put_link,\n\t.readlink\t= ovl_readlink,\n\t.getattr\t= ovl_getattr,\n\t.setxattr\t= ovl_setxattr,\n\t.getxattr\t= ovl_getxattr,\n\t.listxattr\t= ovl_listxattr,\n\t.removexattr\t= ovl_removexattr,\n};\n\nstruct inode *ovl_new_inode(struct super_block *sb, umode_t mode,\n\t\t\t    struct ovl_entry *oe)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmode &= S_IFMT;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_flags |= S_NOATIME | S_NOCMTIME;\n\n\tswitch (mode) {\n\tcase S_IFDIR:\n\t\tinode->i_private = oe;\n\t\tinode->i_op = &ovl_dir_inode_operations;\n\t\tinode->i_fop = &ovl_dir_operations;\n\t\tbreak;\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &ovl_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFREG:\n\tcase S_IFSOCK:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFIFO:\n\t\tinode->i_op = &ovl_file_inode_operations;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"illegal file type: %i\\n\", mode);\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_alloc_entry",
          "args": [
            "ctr"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_alloc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "280-289",
          "snippet": "static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)\n{\n\tsize_t size = offsetof(struct ovl_entry, lowerstack[numlower]);\n\tstruct ovl_entry *oe = kzalloc(size, GFP_KERNEL);\n\n\tif (oe)\n\t\toe->numlower = numlower;\n\n\treturn oe;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct ovl_entry *ovl_alloc_entry(unsigned int numlower)\n{\n\tsize_t size = offsetof(struct ovl_entry, lowerstack[numlower]);\n\tstruct ovl_entry *oe = kzalloc(size, GFP_KERNEL);\n\n\tif (oe)\n\t\toe->numlower = numlower;\n\n\treturn oe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "this->d_inode->i_mode"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "this->d_inode->i_mode"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "prev->d_inode->i_mode"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_is_opaquedir",
          "args": [
            "this"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_is_opaquedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "246-260",
          "snippet": "static bool ovl_is_opaquedir(struct dentry *dentry)\n{\n\tint res;\n\tchar val;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_op->getxattr)\n\t\treturn false;\n\n\tres = inode->i_op->getxattr(dentry, OVL_XATTR_OPAQUE, &val, 1);\n\tif (res == 1 && val == 'y')\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_opaquedir(struct dentry *dentry)\n{\n\tint res;\n\tchar val;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_op->getxattr)\n\t\treturn false;\n\n\tres = inode->i_op->getxattr(dentry, OVL_XATTR_OPAQUE, &val, 1);\n\tif (res == 1 && val == 'y')\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_is_whiteout",
          "args": [
            "this"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_is_whiteout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "239-244",
          "snippet": "bool ovl_is_whiteout(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\treturn inode && IS_WHITEOUT(inode);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nbool ovl_is_whiteout(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\treturn inode && IS_WHITEOUT(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "this"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "this"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_lookup_real",
          "args": [
            "lowerpath.dentry",
            "&dentry->d_name"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_lookup_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "291-308",
          "snippet": "static inline struct dentry *ovl_lookup_real(struct dentry *dir,\n\t\t\t\t\t     struct qstr *name)\n{\n\tstruct dentry *dentry;\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = lookup_one_len(name->name, dir, name->len);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) == -ENOENT)\n\t\t\tdentry = NULL;\n\t} else if (!dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = NULL;\n\t}\n\treturn dentry;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic inline struct dentry *ovl_lookup_real(struct dentry *dir,\n\t\t\t\t\t     struct qstr *name)\n{\n\tstruct dentry *dentry;\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = lookup_one_len(name->name, dir, name->len);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) == -ENOENT)\n\t\t\tdentry = NULL;\n\t} else if (!dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = NULL;\n\t}\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "poe->numlower",
            "sizeof(struct path)",
            "GFP_KERNEL"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "this"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "this"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_upperdentry_dereference",
          "args": [
            "poe"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_upperdentry_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "91-94",
          "snippet": "static struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t  unsigned int flags)\n{\n\tstruct ovl_entry *oe;\n\tstruct ovl_entry *poe = dentry->d_parent->d_fsdata;\n\tstruct path *stack = NULL;\n\tstruct dentry *upperdir, *upperdentry = NULL;\n\tunsigned int ctr = 0;\n\tstruct inode *inode = NULL;\n\tbool upperopaque = false;\n\tstruct dentry *this, *prev = NULL;\n\tunsigned int i;\n\tint err;\n\n\tupperdir = ovl_upperdentry_dereference(poe);\n\tif (upperdir) {\n\t\tthis = ovl_lookup_real(upperdir, &dentry->d_name);\n\t\terr = PTR_ERR(this);\n\t\tif (IS_ERR(this))\n\t\t\tgoto out;\n\n\t\tif (this) {\n\t\t\tif (ovl_is_whiteout(this)) {\n\t\t\t\tdput(this);\n\t\t\t\tthis = NULL;\n\t\t\t\tupperopaque = true;\n\t\t\t} else if (poe->numlower && ovl_is_opaquedir(this)) {\n\t\t\t\tupperopaque = true;\n\t\t\t}\n\t\t}\n\t\tupperdentry = prev = this;\n\t}\n\n\tif (!upperopaque && poe->numlower) {\n\t\terr = -ENOMEM;\n\t\tstack = kcalloc(poe->numlower, sizeof(struct path), GFP_KERNEL);\n\t\tif (!stack)\n\t\t\tgoto out_put_upper;\n\t}\n\n\tfor (i = 0; !upperopaque && i < poe->numlower; i++) {\n\t\tbool opaque = false;\n\t\tstruct path lowerpath = poe->lowerstack[i];\n\n\t\tthis = ovl_lookup_real(lowerpath.dentry, &dentry->d_name);\n\t\terr = PTR_ERR(this);\n\t\tif (IS_ERR(this)) {\n\t\t\t/*\n\t\t\t * If it's positive, then treat ENAMETOOLONG as ENOENT.\n\t\t\t */\n\t\t\tif (err == -ENAMETOOLONG && (upperdentry || ctr))\n\t\t\t\tcontinue;\n\t\t\tgoto out_put;\n\t\t}\n\t\tif (!this)\n\t\t\tcontinue;\n\t\tif (ovl_is_whiteout(this)) {\n\t\t\tdput(this);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Only makes sense to check opaque dir if this is not the\n\t\t * lowermost layer.\n\t\t */\n\t\tif (i < poe->numlower - 1 && ovl_is_opaquedir(this))\n\t\t\topaque = true;\n\n\t\tif (prev && (!S_ISDIR(prev->d_inode->i_mode) ||\n\t\t\t     !S_ISDIR(this->d_inode->i_mode))) {\n\t\t\t/*\n\t\t\t * FIXME: check for upper-opaqueness maybe better done\n\t\t\t * in remove code.\n\t\t\t */\n\t\t\tif (prev == upperdentry)\n\t\t\t\tupperopaque = true;\n\t\t\tdput(this);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If this is a non-directory then stop here.\n\t\t */\n\t\tif (!S_ISDIR(this->d_inode->i_mode))\n\t\t\topaque = true;\n\n\t\tstack[ctr].dentry = this;\n\t\tstack[ctr].mnt = lowerpath.mnt;\n\t\tctr++;\n\t\tprev = this;\n\t\tif (opaque)\n\t\t\tbreak;\n\t}\n\n\toe = ovl_alloc_entry(ctr);\n\terr = -ENOMEM;\n\tif (!oe)\n\t\tgoto out_put;\n\n\tif (upperdentry || ctr) {\n\t\tstruct dentry *realdentry;\n\n\t\trealdentry = upperdentry ? upperdentry : stack[0].dentry;\n\n\t\terr = -ENOMEM;\n\t\tinode = ovl_new_inode(dentry->d_sb, realdentry->d_inode->i_mode,\n\t\t\t\t      oe);\n\t\tif (!inode)\n\t\t\tgoto out_free_oe;\n\t\tovl_copyattr(realdentry->d_inode, inode);\n\t}\n\n\toe->opaque = upperopaque;\n\toe->__upperdentry = upperdentry;\n\tmemcpy(oe->lowerstack, stack, sizeof(struct path) * ctr);\n\tkfree(stack);\n\tdentry->d_fsdata = oe;\n\td_add(dentry, inode);\n\n\treturn NULL;\n\nout_free_oe:\n\tkfree(oe);\nout_put:\n\tfor (i = 0; i < ctr; i++)\n\t\tdput(stack[i].dentry);\n\tkfree(stack);\nout_put_upper:\n\tdput(upperdentry);\nout:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "ovl_path_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "314-329",
    "snippet": "int ovl_path_next(int idx, struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tBUG_ON(idx < 0);\n\tif (idx == 0) {\n\t\tovl_path_upper(dentry, path);\n\t\tif (path->dentry)\n\t\t\treturn oe->numlower ? 1 : -1;\n\t\tidx++;\n\t}\n\tBUG_ON(idx > oe->numlower);\n\t*path = oe->lowerstack[idx - 1];\n\n\treturn (idx < oe->numlower) ? idx + 1 : -1;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "idx > oe->numlower"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_upper",
          "args": [
            "dentry",
            "path"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "96-103",
          "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "idx < 0"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_path_next(int idx, struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tBUG_ON(idx < 0);\n\tif (idx == 0) {\n\t\tovl_path_upper(dentry, path);\n\t\tif (path->dentry)\n\t\t\treturn oe->numlower ? 1 : -1;\n\t\tidx++;\n\t}\n\tBUG_ON(idx > oe->numlower);\n\t*path = oe->lowerstack[idx - 1];\n\n\treturn (idx < oe->numlower) ? idx + 1 : -1;\n}"
  },
  {
    "function_name": "ovl_lookup_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "291-308",
    "snippet": "static inline struct dentry *ovl_lookup_real(struct dentry *dir,\n\t\t\t\t\t     struct qstr *name)\n{\n\tstruct dentry *dentry;\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = lookup_one_len(name->name, dir, name->len);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) == -ENOENT)\n\t\t\tdentry = NULL;\n\t} else if (!dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = NULL;\n\t}\n\treturn dentry;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name->name",
            "dir",
            "name->len"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic inline struct dentry *ovl_lookup_real(struct dentry *dir,\n\t\t\t\t\t     struct qstr *name)\n{\n\tstruct dentry *dentry;\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = lookup_one_len(name->name, dir, name->len);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) == -ENOENT)\n\t\t\tdentry = NULL;\n\t} else if (!dentry->d_inode) {\n\t\tdput(dentry);\n\t\tdentry = NULL;\n\t}\n\treturn dentry;\n}"
  },
  {
    "function_name": "ovl_alloc_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "280-289",
    "snippet": "static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)\n{\n\tsize_t size = offsetof(struct ovl_entry, lowerstack[numlower]);\n\tstruct ovl_entry *oe = kzalloc(size, GFP_KERNEL);\n\n\tif (oe)\n\t\toe->numlower = numlower;\n\n\treturn oe;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct ovl_entry *ovl_alloc_entry(unsigned int numlower)\n{\n\tsize_t size = offsetof(struct ovl_entry, lowerstack[numlower]);\n\tstruct ovl_entry *oe = kzalloc(size, GFP_KERNEL);\n\n\tif (oe)\n\t\toe->numlower = numlower;\n\n\treturn oe;\n}"
  },
  {
    "function_name": "ovl_dentry_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "262-274",
    "snippet": "static void ovl_dentry_release(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tif (oe) {\n\t\tunsigned int i;\n\n\t\tdput(oe->__upperdentry);\n\t\tfor (i = 0; i < oe->numlower; i++)\n\t\t\tdput(oe->lowerstack[i].dentry);\n\t\tkfree_rcu(oe, rcu);\n\t}\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "oe",
            "rcu"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "oe->lowerstack[i].dentry"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic void ovl_dentry_release(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tif (oe) {\n\t\tunsigned int i;\n\n\t\tdput(oe->__upperdentry);\n\t\tfor (i = 0; i < oe->numlower; i++)\n\t\t\tdput(oe->lowerstack[i].dentry);\n\t\tkfree_rcu(oe, rcu);\n\t}\n}"
  },
  {
    "function_name": "ovl_is_opaquedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "246-260",
    "snippet": "static bool ovl_is_opaquedir(struct dentry *dentry)\n{\n\tint res;\n\tchar val;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_op->getxattr)\n\t\treturn false;\n\n\tres = inode->i_op->getxattr(dentry, OVL_XATTR_OPAQUE, &val, 1);\n\tif (res == 1 && val == 'y')\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode->i_op->getxattr",
          "args": [
            "dentry",
            "OVL_XATTR_OPAQUE",
            "&val",
            "1"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "425-469",
          "snippet": "static ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tvoid *vvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!kvalue) {\n\t\t\tvvalue = vmalloc(size);\n\t\t\tif (!vvalue)\n\t\t\t\treturn -ENOMEM;\n\t\t\tkvalue = vvalue;\n\t\t}\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, size);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\tif (vvalue)\n\t\tvfree(vvalue);\n\telse\n\t\tkfree(kvalue);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic bool ovl_is_opaquedir(struct dentry *dentry)\n{\n\tint res;\n\tchar val;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (!S_ISDIR(inode->i_mode) || !inode->i_op->getxattr)\n\t\treturn false;\n\n\tres = inode->i_op->getxattr(dentry, OVL_XATTR_OPAQUE, &val, 1);\n\tif (res == 1 && val == 'y')\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "ovl_is_whiteout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "239-244",
    "snippet": "bool ovl_is_whiteout(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\treturn inode && IS_WHITEOUT(inode);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_WHITEOUT",
          "args": [
            "inode"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nbool ovl_is_whiteout(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\treturn inode && IS_WHITEOUT(inode);\n}"
  },
  {
    "function_name": "ovl_dentry_version_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "231-237",
    "snippet": "u64 ovl_dentry_version_get(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\treturn oe->version;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&dentry->d_inode->i_mutex)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nu64 ovl_dentry_version_get(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\treturn oe->version;\n}"
  },
  {
    "function_name": "ovl_dentry_version_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "223-229",
    "snippet": "void ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&dentry->d_inode->i_mutex)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&dentry->d_inode->i_mutex"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_version_inc(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&dentry->d_inode->i_mutex));\n\toe->version++;\n}"
  },
  {
    "function_name": "ovl_dentry_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "208-221",
    "snippet": "void ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!upperdentry->d_inode"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "oe->__upperdentry"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&upperdentry->d_parent->d_inode->i_mutex"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_update(struct dentry *dentry, struct dentry *upperdentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tWARN_ON(!mutex_is_locked(&upperdentry->d_parent->d_inode->i_mutex));\n\tWARN_ON(oe->__upperdentry);\n\tBUG_ON(!upperdentry->d_inode);\n\t/*\n\t * Make sure upperdentry is consistent before making it visible to\n\t * ovl_upperdentry_dereference().\n\t */\n\tsmp_wmb();\n\toe->__upperdentry = upperdentry;\n}"
  },
  {
    "function_name": "ovl_dentry_set_opaque",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "202-206",
    "snippet": "void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\toe->opaque = opaque;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_dentry_set_opaque(struct dentry *dentry, bool opaque)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\toe->opaque = opaque;\n}"
  },
  {
    "function_name": "ovl_dentry_is_opaque",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "196-200",
    "snippet": "bool ovl_dentry_is_opaque(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\treturn oe->opaque;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nbool ovl_dentry_is_opaque(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\treturn oe->opaque;\n}"
  },
  {
    "function_name": "ovl_workdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "190-194",
    "snippet": "struct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_workdir(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn ofs->workdir;\n}"
  },
  {
    "function_name": "ovl_drop_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "184-188",
    "snippet": "void ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "ofs->upper_mnt"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_drop_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tmnt_drop_write(ofs->upper_mnt);\n}"
  },
  {
    "function_name": "ovl_want_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "178-182",
    "snippet": "int ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "ofs->upper_mnt"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nint ovl_want_write(struct dentry *dentry)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\treturn mnt_want_write(ofs->upper_mnt);\n}"
  },
  {
    "function_name": "ovl_path_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "171-176",
    "snippet": "void ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\t*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\t*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };\n}"
  },
  {
    "function_name": "ovl_set_dir_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "164-169",
    "snippet": "void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\toe->cache = cache;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\toe->cache = cache;\n}"
  },
  {
    "function_name": "ovl_dir_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "157-162",
    "snippet": "struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn oe->cache;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn oe->cache;\n}"
  },
  {
    "function_name": "ovl_entry_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "143-155",
    "snippet": "struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper)\n{\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (realdentry) {\n\t\t*is_upper = true;\n\t} else {\n\t\trealdentry = __ovl_dentry_lower(oe);\n\t\t*is_upper = false;\n\t}\n\treturn realdentry;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ovl_dentry_lower",
          "args": [
            "oe"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__ovl_dentry_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "65-68",
          "snippet": "static struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)\n{\n\treturn oe->numlower ? oe->lowerstack[0].dentry : NULL;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)\n{\n\treturn oe->numlower ? oe->lowerstack[0].dentry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_upperdentry_dereference",
          "args": [
            "oe"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_upperdentry_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "91-94",
          "snippet": "static struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper)\n{\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (realdentry) {\n\t\t*is_upper = true;\n\t} else {\n\t\trealdentry = __ovl_dentry_lower(oe);\n\t\t*is_upper = false;\n\t}\n\treturn realdentry;\n}"
  },
  {
    "function_name": "ovl_dentry_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "131-141",
    "snippet": "struct dentry *ovl_dentry_real(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (!realdentry)\n\t\trealdentry = __ovl_dentry_lower(oe);\n\n\treturn realdentry;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ovl_dentry_lower",
          "args": [
            "oe"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__ovl_dentry_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "65-68",
          "snippet": "static struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)\n{\n\treturn oe->numlower ? oe->lowerstack[0].dentry : NULL;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)\n{\n\treturn oe->numlower ? oe->lowerstack[0].dentry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_upperdentry_dereference",
          "args": [
            "oe"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_upperdentry_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "91-94",
          "snippet": "static struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_real(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tstruct dentry *realdentry;\n\n\trealdentry = ovl_upperdentry_dereference(oe);\n\tif (!realdentry)\n\t\trealdentry = __ovl_dentry_lower(oe);\n\n\treturn realdentry;\n}"
  },
  {
    "function_name": "ovl_dentry_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "124-129",
    "snippet": "struct dentry *ovl_dentry_lower(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn __ovl_dentry_lower(oe);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ovl_dentry_lower",
          "args": [
            "oe"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__ovl_dentry_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "65-68",
          "snippet": "static struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)\n{\n\treturn oe->numlower ? oe->lowerstack[0].dentry : NULL;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)\n{\n\treturn oe->numlower ? oe->lowerstack[0].dentry : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_lower(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn __ovl_dentry_lower(oe);\n}"
  },
  {
    "function_name": "ovl_dentry_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "117-122",
    "snippet": "struct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_upperdentry_dereference",
          "args": [
            "oe"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_upperdentry_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "91-94",
          "snippet": "static struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstruct dentry *ovl_dentry_upper(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\treturn ovl_upperdentry_dereference(oe);\n}"
  },
  {
    "function_name": "ovl_path_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "105-115",
    "snippet": "enum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_path_upper",
          "args": [
            "dentry",
            "path"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "96-103",
          "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ovl_path_lower",
          "args": [
            "dentry",
            "path"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_lower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "171-176",
          "snippet": "void ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\t*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_lower(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\t*path = oe->numlower ? oe->lowerstack[0] : (struct path) { NULL, NULL };\n}"
        }
      },
      {
        "call_info": {
          "callee": "OVL_TYPE_UPPER",
          "args": [
            "type"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ovl_path_type",
          "args": [
            "dentry"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_path_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "70-89",
          "snippet": "enum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_real(struct dentry *dentry, struct path *path)\n{\n\tenum ovl_path_type type = ovl_path_type(dentry);\n\n\tif (!OVL_TYPE_UPPER(type))\n\t\tovl_path_lower(dentry, path);\n\telse\n\t\tovl_path_upper(dentry, path);\n\n\treturn type;\n}"
  },
  {
    "function_name": "ovl_path_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "96-103",
    "snippet": "void ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovl_upperdentry_dereference",
          "args": [
            "oe"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_upperdentry_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
          "lines": "91-94",
          "snippet": "static struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/statfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nvoid ovl_path_upper(struct dentry *dentry, struct path *path)\n{\n\tstruct ovl_fs *ofs = dentry->d_sb->s_fs_info;\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\n\tpath->mnt = ofs->upper_mnt;\n\tpath->dentry = ovl_upperdentry_dereference(oe);\n}"
  },
  {
    "function_name": "ovl_upperdentry_dereference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "91-94",
    "snippet": "static struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockless_dereference",
          "args": [
            "oe->__upperdentry"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *ovl_upperdentry_dereference(struct ovl_entry *oe)\n{\n\treturn lockless_dereference(oe->__upperdentry);\n}"
  },
  {
    "function_name": "ovl_path_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "70-89",
    "snippet": "enum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dentry->d_inode->i_mode"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nenum ovl_path_type ovl_path_type(struct dentry *dentry)\n{\n\tstruct ovl_entry *oe = dentry->d_fsdata;\n\tenum ovl_path_type type = 0;\n\n\tif (oe->__upperdentry) {\n\t\ttype = __OVL_PATH_UPPER;\n\n\t\tif (oe->numlower) {\n\t\t\tif (S_ISDIR(dentry->d_inode->i_mode))\n\t\t\t\ttype |= __OVL_PATH_MERGE;\n\t\t} else if (!oe->opaque) {\n\t\t\ttype |= __OVL_PATH_PURE;\n\t\t}\n\t} else {\n\t\tif (oe->numlower > 1)\n\t\t\ttype |= __OVL_PATH_MERGE;\n\t}\n\treturn type;\n}"
  },
  {
    "function_name": "__ovl_dentry_lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/super.c",
    "lines": "65-68",
    "snippet": "static struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)\n{\n\treturn oe->numlower ? oe->lowerstack[0].dentry : NULL;\n}",
    "includes": [
      "#include \"overlayfs.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/statfs.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/xattr.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/seq_file.h>\n#include <linux/statfs.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n\nstatic struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)\n{\n\treturn oe->numlower ? oe->lowerstack[0].dentry : NULL;\n}"
  }
]