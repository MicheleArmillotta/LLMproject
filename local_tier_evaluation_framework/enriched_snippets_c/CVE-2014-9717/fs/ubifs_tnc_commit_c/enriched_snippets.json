[
  {
    "function_name": "_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "1043-1071",
    "snippet": "_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->cnext)\n\t\treturn 0;\n\n\terr = return_gap_lebs(c);\n\tif (err)\n\t\treturn err;\n\n\terr = write_index(c);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&c->tnc_mutex);\n\n\tdbg_cmt(\"TNC height is %d\", c->zroot.znode->level + 1);\n\n\tfree_obsolete_znodes(c);\n\n\tc->cnext = NULL;\n\tkfree(c->ilebs);\n\tc->ilebs = NULL;\n\n\tmutex_unlock(&c->tnc_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\n\treturn 0"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s);",
          "args": [
            "->ilebs"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_znodes(c);\n\n\tc->cne",
          "args": [
            "t"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "height",
          "args": [
            "s %d\", c->zroot.zn",
            "e->level + 1);\n\n\tfree_obs"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\n\tdbg_cmt("
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tif (err",
          "args": [],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bs(c);\n\tif (err",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\n_end_commit(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->cnext)\n\t\treturn 0;\n\n\terr = return_gap_lebs(c);\n\tif (err)\n\t\treturn err;\n\n\terr = write_index(c);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&c->tnc_mutex);\n\n\tdbg_cmt(\"TNC height is %d\", c->zroot.znode->level + 1);\n\n\tfree_obsolete_znodes(c);\n\n\tc->cnext = NULL;\n\tkfree(c->ilebs);\n\tc->ilebs = NULL;\n\n\tmutex_unlock(&c->tnc_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bs(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "1017-1035",
    "snippet": "turn_gap_lebs(struct ubifs_info *c)\n{\n\tint *p, err;\n\n\tif (!c->gap_lebs)\n\t\treturn 0;\n\n\tdbg_cmt(\"\");\n\tfor (p = c->gap_lebs; *p != -1; p++) {\n\t\terr = ubifs_change_one_lp(c, *p, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t\t  LPROPS_TAKEN, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tkfree(c->gap_lebs);\n\tc->gap_lebs = NULL;\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lebs)",
          "args": [
            "c->gap_le"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, *p, LPROP",
          "args": [
            "_",
            ",",
            "ROPS_NC,",
            "L",
            "O",
            "0);\n\t\tif (e",
            ")"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for (p",
          "args": [
            "="
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nturn_gap_lebs(struct ubifs_info *c)\n{\n\tint *p, err;\n\n\tif (!c->gap_lebs)\n\t\treturn 0;\n\n\tdbg_cmt(\"\");\n\tfor (p = c->gap_lebs; *p != -1; p++) {\n\t\terr = ubifs_change_one_lp(c, *p, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t\t  LPROPS_TAKEN, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tkfree(c->gap_lebs);\n\tc->gap_lebs = NULL;\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_znodes(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "992-1008",
    "snippet": "ree_obsolete_znodes(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext;\n\n\tcnext = c->cnext;\n\tdo {\n\t\tznode = cnext;\n\t\tcnext = znode->cnext;\n\t\tif (ubifs_zn_obsolete(znode))\n\t\t\tkfree(znode);\n\t\telse {\n\t\t\tznode->cnext = NULL;\n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t}\n\t} while (cnext != c->cnext);\n}\n\n/**\n * retu",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nc(&ubifs_clean",
          "args": [
            "zn_cnt);\n\t\t}\n\t} whi"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->clean_zn",
          "args": [
            "cnt);\n\t\t\tatomic_"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "el",
          "args": [
            "e {"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "erase_deleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/orphan.c",
          "lines": "440-459",
          "snippet": "static void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(!orphan->new);\n\t\tubifs_assert(orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}",
          "includes": [
            "#include \"ubifs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dbg_check_orphans(struct ubifs_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n\nstatic int dbg_check_orphans(struct ubifs_info *c);\n\nstatic void erase_deleted(struct ubifs_info *c)\n{\n\tstruct ubifs_orphan *orphan, *dnext;\n\n\tspin_lock(&c->orphan_lock);\n\tdnext = c->orph_dnext;\n\twhile (dnext) {\n\t\torphan = dnext;\n\t\tdnext = orphan->dnext;\n\t\tubifs_assert(!orphan->new);\n\t\tubifs_assert(orphan->del);\n\t\trb_erase(&orphan->rb, &c->orph_tree);\n\t\tlist_del(&orphan->list);\n\t\tc->tot_orphans -= 1;\n\t\tdbg_gen(\"deleting orphan ino %lu\", (unsigned long)orphan->inum);\n\t\tkfree(orphan);\n\t}\n\tc->orph_dnext = NULL;\n\tspin_unlock(&c->orphan_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lete(znode))\n\t\t\tk",
          "args": [
            "ree(z"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nree_obsolete_znodes(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext;\n\n\tcnext = c->cnext;\n\tdo {\n\t\tznode = cnext;\n\t\tcnext = znode->cnext;\n\t\tif (ubifs_zn_obsolete(znode))\n\t\t\tkfree(znode);\n\t\telse {\n\t\t\tznode->cnext = NULL;\n\t\t\tatomic_long_inc(&c->clean_zn_cnt);\n\t\t\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t}\n\t} while (cnext != c->cnext);\n}\n\n/**\n * retu"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "806-984",
    "snippet": "ite_index(struct ubifs_info *c)\n{\n\tstruct ubifs_idx_node *idx;\n\tstruct ubifs_znode *znode, *cnext;\n\tint i, lnum, offs, len, next_len, buf_len, buf_offs, used;\n\tint avail, wlen, err, lnum_pos = 0, blen, nxt_offs;\n\n\tcnext = c->enext;\n\tif (!cnext)\n\t\treturn 0;\n\n\t/*\n\t * Always write index nodes to the index head so that index nodes and\n\t * other types of nodes are never mixed in the same erase block.\n\t */\n\tlnum = c->ihead_lnum;\n\tbuf_offs = c->ihead_offs;\n\n\t/* Allocate commit buffer */\n\tbuf_len = ALIGN(c->max_idx_node_sz, c->min_io_size);\n\tused = 0;\n\tavail = buf_len;\n\n\t/* Ensure there is enough room for first write */\n\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\tif (buf_offs + next_len > c->leb_size) {\n\t\terr = ubifs_update_one_lp(c, lnum, LPROPS_NC, 0, 0,\n\t\t\t\t\t  LPROPS_TAKEN);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlnum = -1;\n\t}\n\n\twhile (1) {\n\t\tcond_resched();\n\n\t\tznode = cnext;\n\t\tidx = c->cbuf + used;\n\n\t\t/* Make index node */\n\t\tidx->ch.node_type = UBIFS_IDX_NODE;\n\t\tidx->child_cnt = cpu_to_le16(znode->child_cnt);\n\t\tidx->level = cpu_to_le16(znode->level);\n\t\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\t\tstruct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\t\tkey_write_idx(c, &zbr->key, &br->key);\n\t\t\tbr->lnum = cpu_to_le32(zbr->lnum);\n\t\t\tbr->offs = cpu_to_le32(zbr->offs);\n\t\t\tbr->len = cpu_to_le32(zbr->len);\n\t\t\tif (!zbr->lnum || !zbr->len) {\n\t\t\t\tubifs_err(\"bad ref in znode\");\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tif (zbr->znode)\n\t\t\t\t\tubifs_dump_znode(c, zbr->znode);\n\t\t\t}\n\t\t}\n\t\tlen = ubifs_idx_node_sz(c, znode->child_cnt);\n\t\tubifs_prepare_node(c, idx, len, 0);\n\n\t\t/* Determine the index node position */\n\t\tif (lnum == -1) {\n\t\t\tlnum = c->ilebs[lnum_pos++];\n\t\t\tbuf_offs = 0;\n\t\t\tused = 0;\n\t\t\tavail = buf_len;\n\t\t}\n\t\toffs = buf_offs + used;\n\n\t\tif (lnum != znode->lnum || offs != znode->offs ||\n\t\t    len != znode->len) {\n\t\t\tubifs_err(\"inconsistent znode posn\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Grab some stuff from znode while we still can */\n\t\tcnext = znode->cnext;\n\n\t\tubifs_assert(ubifs_zn_dirty(znode));\n\t\tubifs_assert(ubifs_zn_cow(znode));\n\n\t\t/*\n\t\t * It is important that other threads should see %DIRTY_ZNODE\n\t\t * flag cleared before %COW_ZNODE. Specifically, it matters in\n\t\t * the 'dirty_cow_znode()' function. This is the reason for the\n\t\t * first barrier. Also, we want the bit changes to be seen to\n\t\t * other threads ASAP, to avoid unnecesarry copying, which is\n\t\t * the reason for the second barrier.\n\t\t */\n\t\tclear_bit(DIRTY_ZNODE, &znode->flags);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(COW_ZNODE, &znode->flags);\n\t\tsmp_mb__after_atomic();\n\n\t\t/*\n\t\t * We have marked the znode as clean but have not updated the\n\t\t * @c->clean_zn_cnt counter. If this znode becomes dirty again\n\t\t * before 'free_obsolete_znodes()' is called, then\n\t\t * @c->clean_zn_cnt will be decremented before it gets\n\t\t * incremented (resulting in 2 decrements for the same znode).\n\t\t * This means that @c->clean_zn_cnt may become negative for a\n\t\t * while.\n\t\t *\n\t\t * Q: why we cannot increment @c->clean_zn_cnt?\n\t\t * A: because we do not have the @c->tnc_mutex locked, and the\n\t\t *    following code would be racy and buggy:\n\t\t *\n\t\t *    if (!ubifs_zn_obsolete(znode)) {\n\t\t *            atomic_long_inc(&c->clean_zn_cnt);\n\t\t *            atomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t *    }\n\t\t *\n\t\t *    Thus, we just delay the @c->clean_zn_cnt update until we\n\t\t *    have the mutex locked.\n\t\t */\n\n\t\t/* Do not access znode from this point on */\n\n\t\t/* Update buffer positions */\n\t\twlen = used + len;\n\t\tused += ALIGN(len, 8);\n\t\tavail -= ALIGN(len, 8);\n\n\t\t/*\n\t\t * Calculate the next index node length to see if there is\n\t\t * enough room for it\n\t\t */\n\t\tif (cnext == c->cnext)\n\t\t\tnext_len = 0;\n\t\telse\n\t\t\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\n\t\tnxt_offs = buf_offs + used + next_len;\n\t\tif (next_len && nxt_offs <= c->leb_size) {\n\t\t\tif (avail > 0)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tblen = buf_len;\n\t\t} else {\n\t\t\twlen = ALIGN(wlen, 8);\n\t\t\tblen = ALIGN(wlen, c->min_io_size);\n\t\t\tubifs_pad(c, c->cbuf + wlen, blen - wlen);\n\t\t}\n\n\t\t/* The buffer is full or there are no more znodes to do */\n\t\terr = ubifs_leb_write(c, lnum, c->cbuf, buf_offs, blen);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf_offs += blen;\n\t\tif (next_len) {\n\t\t\tif (nxt_offs > c->leb_size) {\n\t\t\t\terr = ubifs_update_one_lp(c, lnum, LPROPS_NC, 0,\n\t\t\t\t\t\t\t  0, LPROPS_TAKEN);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tlnum = -1;\n\t\t\t}\n\t\t\tused -= blen;\n\t\t\tif (used < 0)\n\t\t\t\tused = 0;\n\t\t\tavail = buf_len - used;\n\t\t\tmemmove(c->cbuf, c->cbuf + blen, used);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (lnum != c->dbg->new_ihead_lnum ||\n\t    buf_offs != c->dbg->new_ihead_offs) {\n\t\tubifs_err(\"inconsistent ihead\");\n\t\treturn -EINVAL;\n\t}\n\n\tc->ihead_lnum = lnum;\n\tc->ihead_offs = buf_offs;\n\n\treturn 0;\n}\n\n/**\n * free",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "consisten",
          "args": [
            "ihead\");\n\t\treturn -"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_check_consistency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
          "lines": "390-409",
          "snippet": "static bool cachefiles_check_consistency(struct fscache_operation *op)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"{OBJ%x}\", op->object->debug_id);\n\n\tobject = container_of(op->object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_check_auxdata(object);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic bool cachefiles_check_consistency(struct fscache_operation *op)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"{OBJ%x}\", op->object->debug_id);\n\n\tobject = container_of(op->object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_check_auxdata(object);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uf, c->",
          "args": [
            "buf + b",
            "n, used);\n\t\t\tc",
            "tinu"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum, LPR",
          "args": [
            "P",
            "NC,",
            ",",
            "E",
            ";\n\t\t\t\tif (er"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, lnum, c->",
          "args": [
            "b",
            ", bu",
            "offs, b",
            "n);\n\t\tif",
            "err)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cbuf +",
          "args": [
            "w",
            "n, blen - wlen",
            "}\n\n\t\t/*"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->min",
          "args": [
            "io_s",
            "e);\n\t\t\tubifs_p"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "blen"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, cnext->ch",
          "args": [
            "l",
            "cnt);\n\n\t\tnxt_off"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";",
          "args": [
            "*",
            "*"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\ta",
          "args": [
            "ail",
            "="
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_atomic();\n\n\t\t/*",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ZNODE, &",
          "args": [
            "node->fla",
            ");\n\t\tsmp_mb__"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_atomic();\n\t\tclear_b",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TY_ZNODE,",
          "args": [
            "&znode->fla",
            ");\n\t\tsmp_mb__"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_zn_cow",
          "args": [
            "znode));\n\n\t\t/*\n\t\t *"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode));",
          "args": [
            "*"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_zn_dir",
          "args": [
            "y(znode));\n\t\tubifs_as"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode));\n\t\tu",
          "args": [
            "ifs_a"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, idx, len,",
          "args": [
            "0",
            "* D",
            "e"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, znode->ch",
          "args": [
            "l",
            "cnt);\n\t\tubifs_pr"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, zbr->znod",
          "args": [
            ")",
            "}\n\t\t}"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "f (zb"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d ref in",
          "args": [
            "node\");\n\t\t\t\tubifs_"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->len);",
          "args": [
            "if (!zb"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->offs);",
          "args": [
            "br->len"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->lnum);",
          "args": [
            "br->off"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &zbr->key",
          "args": [
            "r->key);",
            "br->lnu"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nch(c, idx, i);",
          "args": [
            "tru"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->level",
          "args": [
            ";\n\t\tfor (i ="
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->child",
          "args": [
            "cnt);\n\t\tidx->lev"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\tznode",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum, LPR",
          "args": [
            "P",
            "NC,",
            "0,",
            "L",
            "O",
            ";\n\t\tif (err)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, cnext->ch",
          "args": [
            "l",
            "cnt);\n\tif (buf_o"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idx_n",
          "args": [
            "de_sz, c->min_io_s",
            "e);\n\tused = 0;"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nite_index(struct ubifs_info *c)\n{\n\tstruct ubifs_idx_node *idx;\n\tstruct ubifs_znode *znode, *cnext;\n\tint i, lnum, offs, len, next_len, buf_len, buf_offs, used;\n\tint avail, wlen, err, lnum_pos = 0, blen, nxt_offs;\n\n\tcnext = c->enext;\n\tif (!cnext)\n\t\treturn 0;\n\n\t/*\n\t * Always write index nodes to the index head so that index nodes and\n\t * other types of nodes are never mixed in the same erase block.\n\t */\n\tlnum = c->ihead_lnum;\n\tbuf_offs = c->ihead_offs;\n\n\t/* Allocate commit buffer */\n\tbuf_len = ALIGN(c->max_idx_node_sz, c->min_io_size);\n\tused = 0;\n\tavail = buf_len;\n\n\t/* Ensure there is enough room for first write */\n\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\tif (buf_offs + next_len > c->leb_size) {\n\t\terr = ubifs_update_one_lp(c, lnum, LPROPS_NC, 0, 0,\n\t\t\t\t\t  LPROPS_TAKEN);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlnum = -1;\n\t}\n\n\twhile (1) {\n\t\tcond_resched();\n\n\t\tznode = cnext;\n\t\tidx = c->cbuf + used;\n\n\t\t/* Make index node */\n\t\tidx->ch.node_type = UBIFS_IDX_NODE;\n\t\tidx->child_cnt = cpu_to_le16(znode->child_cnt);\n\t\tidx->level = cpu_to_le16(znode->level);\n\t\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\t\tstruct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\t\tkey_write_idx(c, &zbr->key, &br->key);\n\t\t\tbr->lnum = cpu_to_le32(zbr->lnum);\n\t\t\tbr->offs = cpu_to_le32(zbr->offs);\n\t\t\tbr->len = cpu_to_le32(zbr->len);\n\t\t\tif (!zbr->lnum || !zbr->len) {\n\t\t\t\tubifs_err(\"bad ref in znode\");\n\t\t\t\tubifs_dump_znode(c, znode);\n\t\t\t\tif (zbr->znode)\n\t\t\t\t\tubifs_dump_znode(c, zbr->znode);\n\t\t\t}\n\t\t}\n\t\tlen = ubifs_idx_node_sz(c, znode->child_cnt);\n\t\tubifs_prepare_node(c, idx, len, 0);\n\n\t\t/* Determine the index node position */\n\t\tif (lnum == -1) {\n\t\t\tlnum = c->ilebs[lnum_pos++];\n\t\t\tbuf_offs = 0;\n\t\t\tused = 0;\n\t\t\tavail = buf_len;\n\t\t}\n\t\toffs = buf_offs + used;\n\n\t\tif (lnum != znode->lnum || offs != znode->offs ||\n\t\t    len != znode->len) {\n\t\t\tubifs_err(\"inconsistent znode posn\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Grab some stuff from znode while we still can */\n\t\tcnext = znode->cnext;\n\n\t\tubifs_assert(ubifs_zn_dirty(znode));\n\t\tubifs_assert(ubifs_zn_cow(znode));\n\n\t\t/*\n\t\t * It is important that other threads should see %DIRTY_ZNODE\n\t\t * flag cleared before %COW_ZNODE. Specifically, it matters in\n\t\t * the 'dirty_cow_znode()' function. This is the reason for the\n\t\t * first barrier. Also, we want the bit changes to be seen to\n\t\t * other threads ASAP, to avoid unnecesarry copying, which is\n\t\t * the reason for the second barrier.\n\t\t */\n\t\tclear_bit(DIRTY_ZNODE, &znode->flags);\n\t\tsmp_mb__before_atomic();\n\t\tclear_bit(COW_ZNODE, &znode->flags);\n\t\tsmp_mb__after_atomic();\n\n\t\t/*\n\t\t * We have marked the znode as clean but have not updated the\n\t\t * @c->clean_zn_cnt counter. If this znode becomes dirty again\n\t\t * before 'free_obsolete_znodes()' is called, then\n\t\t * @c->clean_zn_cnt will be decremented before it gets\n\t\t * incremented (resulting in 2 decrements for the same znode).\n\t\t * This means that @c->clean_zn_cnt may become negative for a\n\t\t * while.\n\t\t *\n\t\t * Q: why we cannot increment @c->clean_zn_cnt?\n\t\t * A: because we do not have the @c->tnc_mutex locked, and the\n\t\t *    following code would be racy and buggy:\n\t\t *\n\t\t *    if (!ubifs_zn_obsolete(znode)) {\n\t\t *            atomic_long_inc(&c->clean_zn_cnt);\n\t\t *            atomic_long_inc(&ubifs_clean_zn_cnt);\n\t\t *    }\n\t\t *\n\t\t *    Thus, we just delay the @c->clean_zn_cnt update until we\n\t\t *    have the mutex locked.\n\t\t */\n\n\t\t/* Do not access znode from this point on */\n\n\t\t/* Update buffer positions */\n\t\twlen = used + len;\n\t\tused += ALIGN(len, 8);\n\t\tavail -= ALIGN(len, 8);\n\n\t\t/*\n\t\t * Calculate the next index node length to see if there is\n\t\t * enough room for it\n\t\t */\n\t\tif (cnext == c->cnext)\n\t\t\tnext_len = 0;\n\t\telse\n\t\t\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\n\t\tnxt_offs = buf_offs + used + next_len;\n\t\tif (next_len && nxt_offs <= c->leb_size) {\n\t\t\tif (avail > 0)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tblen = buf_len;\n\t\t} else {\n\t\t\twlen = ALIGN(wlen, 8);\n\t\t\tblen = ALIGN(wlen, c->min_io_size);\n\t\t\tubifs_pad(c, c->cbuf + wlen, blen - wlen);\n\t\t}\n\n\t\t/* The buffer is full or there are no more znodes to do */\n\t\terr = ubifs_leb_write(c, lnum, c->cbuf, buf_offs, blen);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbuf_offs += blen;\n\t\tif (next_len) {\n\t\t\tif (nxt_offs > c->leb_size) {\n\t\t\t\terr = ubifs_update_one_lp(c, lnum, LPROPS_NC, 0,\n\t\t\t\t\t\t\t  0, LPROPS_TAKEN);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tlnum = -1;\n\t\t\t}\n\t\t\tused -= blen;\n\t\t\tif (used < 0)\n\t\t\t\tused = 0;\n\t\t\tavail = buf_len - used;\n\t\t\tmemmove(c->cbuf, c->cbuf + blen, used);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (lnum != c->dbg->new_ihead_lnum ||\n\t    buf_offs != c->dbg->new_ihead_offs) {\n\t\tubifs_err(\"inconsistent ihead\");\n\t\treturn -EINVAL;\n\t}\n\n\tc->ihead_lnum = lnum;\n\tc->ihead_offs = buf_offs;\n\n\treturn 0;\n}\n\n/**\n * free"
  },
  {
    "function_name": "rt_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "740-797",
    "snippet": "_start_commit(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tint err = 0, cnt;\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = dbg_check_tnc(c, 1);\n\tif (err)\n\t\tgoto out;\n\tcnt = get_znodes_to_commit(c);\n\tif (cnt != 0) {\n\t\tint no_space = 0;\n\n\t\terr = alloc_idx_lebs(c, cnt);\n\t\tif (err == -ENOSPC)\n\t\t\tno_space = 1;\n\t\telse if (err)\n\t\t\tgoto out_free;\n\t\terr = layout_commit(c, no_space, cnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tubifs_assert(atomic_long_read(&c->dirty_zn_cnt) == 0);\n\t\terr = free_unused_idx_lebs(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tdestroy_old_idx(c);\n\tmemcpy(zroot, &c->zroot, sizeof(struct ubifs_zbranch));\n\n\terr = ubifs_save_dirty_idx_lnums(c);\n\tif (err)\n\t\tgoto out;\n\n\tspin_lock(&c->space_lock);\n\t/*\n\t * Although we have not finished committing yet, update size of the\n\t * committed index ('c->bi.old_idx_sz') and zero out the index growth\n\t * budget. It is OK to do this now, because we've reserved all the\n\t * space which is needed to commit the index, and it is save for the\n\t * budgeting subsystem to assume the index is already committed,\n\t * even though it is not.\n\t */\n\tubifs_assert(c->bi.min_idx_lebs == ubifs_calc_min_idx_lebs(c));\n\tc->bi.old_idx_sz = c->calc_idx_sz;\n\tc->bi.uncommitted_idx = 0;\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tspin_unlock(&c->space_lock);\n\tmutex_unlock(&c->tnc_mutex);\n\n\tdbg_cmt(\"number of index LEBs %d\", c->lst.idx_lebs);\n\tdbg_cmt(\"size of index %llu\", c->calc_idx_sz);\n\treturn err;\n\nout_free:\n\tfree_idx_lebs(c);\nout:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * writ",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c);\nout:\n\tmu",
          "args": [
            "e"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of ind",
          "args": [
            "x %llu\", c->calc_idx",
            "z);\n\treturn er"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "er of i",
          "args": [
            "dex LEBs %d\", c->lst.idx_",
            "bs);\n\tdbg_cmt(\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->tnc_mute",
          "args": [
            ");\n\n\tdbg_cmt("
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\tmutex_unl"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_idx_lebs(c);\n\tspin_un",
          "args": [
            "o"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->bi.min_id",
          "args": [
            "_lebs == ubifs_calc_min_idx_lebs(c));\n\tc->bi.old"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_idx_lebs(c));\n\tc->bi.",
          "args": [
            "l"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\t/*\n\t * Al"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_idx_lnums(c);\n\tif (err",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->z",
          "args": [
            "oot,",
            "zeof(stru",
            "ubifs_zbranch));\n\n\terr = ub"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx(c);\n\tmemcpy(",
          "args": [
            "r"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_lebs(c);\n\t\tif (er",
          "args": [
            ")"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_",
          "args": [
            "ead(&c->dirty_zn_cnt) == 0);\n\t\terr = fr"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_zn",
          "args": [
            "cnt) == 0);\n\t\ter"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, no_space,",
          "args": [
            "c",
            ");\n\t\tif",
            "rr)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s(c, cnt);\n\t\ti",
          "args": [
            "rr"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_commit(c);\n\tif (cnt",
          "args": [
            "!"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, 1);\n\tif (",
          "args": [
            "r"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->tnc_mute",
          "args": [
            ");\n\terr = dbg"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\n_start_commit(struct ubifs_info *c, struct ubifs_zbranch *zroot)\n{\n\tint err = 0, cnt;\n\n\tmutex_lock(&c->tnc_mutex);\n\terr = dbg_check_tnc(c, 1);\n\tif (err)\n\t\tgoto out;\n\tcnt = get_znodes_to_commit(c);\n\tif (cnt != 0) {\n\t\tint no_space = 0;\n\n\t\terr = alloc_idx_lebs(c, cnt);\n\t\tif (err == -ENOSPC)\n\t\t\tno_space = 1;\n\t\telse if (err)\n\t\t\tgoto out_free;\n\t\terr = layout_commit(c, no_space, cnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tubifs_assert(atomic_long_read(&c->dirty_zn_cnt) == 0);\n\t\terr = free_unused_idx_lebs(c);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tdestroy_old_idx(c);\n\tmemcpy(zroot, &c->zroot, sizeof(struct ubifs_zbranch));\n\n\terr = ubifs_save_dirty_idx_lnums(c);\n\tif (err)\n\t\tgoto out;\n\n\tspin_lock(&c->space_lock);\n\t/*\n\t * Although we have not finished committing yet, update size of the\n\t * committed index ('c->bi.old_idx_sz') and zero out the index growth\n\t * budget. It is OK to do this now, because we've reserved all the\n\t * space which is needed to commit the index, and it is save for the\n\t * budgeting subsystem to assume the index is already committed,\n\t * even though it is not.\n\t */\n\tubifs_assert(c->bi.min_idx_lebs == ubifs_calc_min_idx_lebs(c));\n\tc->bi.old_idx_sz = c->calc_idx_sz;\n\tc->bi.uncommitted_idx = 0;\n\tc->bi.min_idx_lebs = ubifs_calc_min_idx_lebs(c);\n\tspin_unlock(&c->space_lock);\n\tmutex_unlock(&c->tnc_mutex);\n\n\tdbg_cmt(\"number of index LEBs %d\", c->lst.idx_lebs);\n\tdbg_cmt(\"size of index %llu\", c->calc_idx_sz);\n\treturn err;\n\nout_free:\n\tfree_idx_lebs(c);\nout:\n\tmutex_unlock(&c->tnc_mutex);\n\treturn err;\n}\n\n/**\n * writ"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "720-728",
    "snippet": "ee_idx_lebs(struct ubifs_info *c)\n{\n\tint err;\n\n\terr = free_unused_idx_lebs(c);\n\tkfree(c->ilebs);\n\tc->ilebs = NULL;\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s);",
          "args": [
            "->ilebs"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx_lebs(c);\n\tkfree(c",
          "args": [
            ">"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nee_idx_lebs(struct ubifs_info *c)\n{\n\tint err;\n\n\terr = free_unused_idx_lebs(c);\n\tkfree(c->ilebs);\n\tc->ilebs = NULL;\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "dx_lebs(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "699-712",
    "snippet": "ee_unused_idx_lebs(struct ubifs_info *c)\n{\n\tint i, err = 0, lnum, er;\n\n\tfor (i = c->ileb_nxt; i < c->ileb_cnt; i++) {\n\t\tlnum = c->ilebs[i];\n\t\tdbg_cmt(\"LEB %d\", lnum);\n\t\ter = ubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t\t LPROPS_INDEX | LPROPS_TAKEN, 0);\n\t\tif (!err)\n\t\t\terr = er;\n\t}\n\treturn err;\n}\n\n/**\n * free",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "one_lp(c, lnum, LPR",
          "args": [
            "P",
            "NC,",
            "ROPS_NC,",
            "LP",
            "P",
            "| LPROPS_TAKEN, 0);\n\t\tif (!",
            "r"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d\", ln",
          "args": [
            "m);\n\t\ter",
            "ubi"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nee_unused_idx_lebs(struct ubifs_info *c)\n{\n\tint i, err = 0, lnum, er;\n\n\tfor (i = c->ileb_nxt; i < c->ileb_cnt; i++) {\n\t\tlnum = c->ilebs[i];\n\t\tdbg_cmt(\"LEB %d\", lnum);\n\t\ter = ubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t\t LPROPS_INDEX | LPROPS_TAKEN, 0);\n\t\tif (!err)\n\t\t\terr = er;\n\t}\n\treturn err;\n}\n\n/**\n * free"
  },
  {
    "function_name": "s(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "665-688",
    "snippet": "loc_idx_lebs(struct ubifs_info *c, int cnt)\n{\n\tint i, leb_cnt, lnum;\n\n\tc->ileb_cnt = 0;\n\tc->ileb_nxt = 0;\n\tleb_cnt = get_leb_cnt(c, cnt);\n\tdbg_cmt(\"need about %d empty LEBS for TNC commit\", leb_cnt);\n\tif (!leb_cnt)\n\t\treturn 0;\n\tc->ilebs = kmalloc(leb_cnt * sizeof(int), GFP_NOFS);\n\tif (!c->ilebs)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < leb_cnt; i++) {\n\t\tlnum = ubifs_find_free_leb_for_idx(c);\n\t\tif (lnum < 0)\n\t\t\treturn lnum;\n\t\tc->ilebs[c->ileb_cnt++] = lnum;\n\t\tdbg_cmt(\"LEB %d\", lnum);\n\t}\n\tif (dbg_is_chk_index(c) && !(prandom_u32() & 7))\n\t\treturn -ENOSPC;\n\treturn 0;\n}\n\n/**\n * free",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "& 7))\n\t\tre",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex(c) && !(pran",
          "args": [
            "o"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d\", ln",
          "args": [
            "m);\n\t}",
            "(db"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee_leb_for_idx(c);\n\t\tif (ln",
          "args": [
            "m"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nt * si",
          "args": [
            "eof(int), GFP_NOFS);",
            "f (!c->i"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "about",
          "args": [
            "d empty LEBS for TNC commit\", leb_cnt);",
            "(!leb_"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", cnt);\n\tdb",
          "args": [
            "_",
            "t(\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nloc_idx_lebs(struct ubifs_info *c, int cnt)\n{\n\tint i, leb_cnt, lnum;\n\n\tc->ileb_cnt = 0;\n\tc->ileb_nxt = 0;\n\tleb_cnt = get_leb_cnt(c, cnt);\n\tdbg_cmt(\"need about %d empty LEBS for TNC commit\", leb_cnt);\n\tif (!leb_cnt)\n\t\treturn 0;\n\tc->ilebs = kmalloc(leb_cnt * sizeof(int), GFP_NOFS);\n\tif (!c->ilebs)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < leb_cnt; i++) {\n\t\tlnum = ubifs_find_free_leb_for_idx(c);\n\t\tif (lnum < 0)\n\t\t\treturn lnum;\n\t\tc->ilebs[c->ileb_cnt++] = lnum;\n\t\tdbg_cmt(\"LEB %d\", lnum);\n\t}\n\tif (dbg_is_chk_index(c) && !(prandom_u32() & 7))\n\t\treturn -ENOSPC;\n\treturn 0;\n}\n\n/**\n * free"
  },
  {
    "function_name": "_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "626-654",
    "snippet": "t_znodes_to_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext;\n\tint cnt = 0;\n\n\tc->cnext = find_first_dirty(c->zroot.znode);\n\tznode = c->enext = c->cnext;\n\tif (!znode) {\n\t\tdbg_cmt(\"no znodes to commit\");\n\t\treturn 0;\n\t}\n\tcnt += 1;\n\twhile (1) {\n\t\tubifs_assert(!ubifs_zn_cow(znode));\n\t\t__set_bit(COW_ZNODE, &znode->flags);\n\t\tznode->alt = 0;\n\t\tcnext = find_next_dirty(znode);\n\t\tif (!cnext) {\n\t\t\tznode->cnext = c->cnext;\n\t\t\tbreak;\n\t\t}\n\t\tznode->cnext = cnext;\n\t\tznode = cnext;\n\t\tcnt += 1;\n\t}\n\tdbg_cmt(\"committing %d znodes\", cnt);\n\tubifs_assert(cnt == atomic_long_read(&c->dirty_zn_cnt));\n\treturn cnt;\n}\n\n/**\n * allo",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cnt == atomi",
          "args": [
            "_long_read(&c->dirty_zn_cnt));\n\treturn cn"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead(&c->dirty_zn",
          "args": [
            "cnt));\n\treturn c"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "itting",
          "args": [
            "d znodes\", cnt);\n\tubif",
            "ass"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_efd_item_committing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extfree_item.c",
          "lines": "458-463",
          "snippet": "STATIC void\nxfs_efd_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_efd_item_committing(\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ty(znode);\n\t\tif",
          "args": [
            "(!cne"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ZNODE, &",
          "args": [
            "node->fla",
            ");\n\t\tznode->a"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!ubifs_zn_co",
          "args": [
            "(znode));\n\t\t__set_bi"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode));\n\t\t_",
          "args": [
            "set_b"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes t",
          "args": [
            "commit\");\n\t\treturn 0"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty(c->zroot.zno",
          "args": [
            "e);\n\tznode = c"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nt_znodes_to_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext;\n\tint cnt = 0;\n\n\tc->cnext = find_first_dirty(c->zroot.znode);\n\tznode = c->enext = c->cnext;\n\tif (!znode) {\n\t\tdbg_cmt(\"no znodes to commit\");\n\t\treturn 0;\n\t}\n\tcnt += 1;\n\twhile (1) {\n\t\tubifs_assert(!ubifs_zn_cow(znode));\n\t\t__set_bit(COW_ZNODE, &znode->flags);\n\t\tznode->alt = 0;\n\t\tcnext = find_next_dirty(znode);\n\t\tif (!cnext) {\n\t\t\tznode->cnext = c->cnext;\n\t\t\tbreak;\n\t\t}\n\t\tznode->cnext = cnext;\n\t\tznode = cnext;\n\t\tcnt += 1;\n\t}\n\tdbg_cmt(\"committing %d znodes\", cnt);\n\tubifs_assert(cnt == atomic_long_read(&c->dirty_zn_cnt));\n\treturn cnt;\n}\n\n/**\n * allo"
  },
  {
    "function_name": "ty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "604-618",
    "snippet": "ubifs_znode *find_next_dirty(struct ubifs_znode *znode)\n{\n\tint n = znode->iip + 1;\n\n\tznode = znode->parent;\n\tif (!znode)\n\t\treturn NULL;\n\tfor (; n < znode->child_cnt; n++) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tif (zbr->znode && ubifs_zn_dirty(zbr->znode))\n\t\t\treturn find_first_dirty(zbr->znode);\n\t}\n\treturn znode;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rty(zbr->znode);",
          "args": [
            "}\n\treturn"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(zbr->znode))",
          "args": [
            "return"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nubifs_znode *find_next_dirty(struct ubifs_znode *znode)\n{\n\tint n = znode->iip + 1;\n\n\tznode = znode->parent;\n\tif (!znode)\n\t\treturn NULL;\n\tfor (; n < znode->child_cnt; n++) {\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[n];\n\n\t\tif (zbr->znode && ubifs_zn_dirty(zbr->znode))\n\t\t\treturn find_first_dirty(zbr->znode);\n\t}\n\treturn znode;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "rty(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "569-598",
    "snippet": "ubifs_znode *find_first_dirty(struct ubifs_znode *znode)\n{\n\tint i, cont;\n\n\tif (!znode)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (znode->level == 0) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\treturn znode;\n\t\t\treturn NULL;\n\t\t}\n\t\tcont = 0;\n\t\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\t\tif (zbr->znode && ubifs_zn_dirty(zbr->znode)) {\n\t\t\t\tznode = zbr->znode;\n\t\t\t\tcont = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!cont) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\treturn znode;\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\n/**\n * find",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y(znode))",
          "args": [
            "eturn"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(zbr->znode))",
          "args": [
            "{\n\t\t\t\tznod"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode))",
          "args": [
            "eturn"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nubifs_znode *find_first_dirty(struct ubifs_znode *znode)\n{\n\tint i, cont;\n\n\tif (!znode)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tif (znode->level == 0) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\treturn znode;\n\t\t\treturn NULL;\n\t\t}\n\t\tcont = 0;\n\t\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\t\tif (zbr->znode && ubifs_zn_dirty(zbr->znode)) {\n\t\t\t\tznode = zbr->znode;\n\t\t\t\tcont = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!cont) {\n\t\t\tif (ubifs_zn_dirty(znode))\n\t\t\t\treturn znode;\n\t\t\treturn NULL;\n\t\t}\n\t}\n}\n\n/**\n * find"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "552-563",
    "snippet": "yout_commit(struct ubifs_info *c, int no_space, int cnt)\n{\n\tint err;\n\n\tif (no_space) {\n\t\terr = layout_in_gaps(c, cnt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = layout_in_empty_space(c);\n\treturn err;\n}\n\n/**\n * find",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ty_space(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s(c, cnt);\n\t\ti",
          "args": [
            "rr)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nyout_commit(struct ubifs_info *c, int no_space, int cnt)\n{\n\tint err;\n\n\tif (no_space) {\n\t\terr = layout_in_gaps(c, cnt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = layout_in_empty_space(c);\n\treturn err;\n}\n\n/**\n * find"
  },
  {
    "function_name": "ty_space(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "413-537",
    "snippet": "yout_in_empty_space(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext, *zp;\n\tint lnum, offs, len, next_len, buf_len, buf_offs, used, avail;\n\tint wlen, blen, err;\n\n\tcnext = c->enext;\n\tif (!cnext)\n\t\treturn 0;\n\n\tlnum = c->ihead_lnum;\n\tbuf_offs = c->ihead_offs;\n\n\tbuf_len = ubifs_idx_node_sz(c, c->fanout);\n\tbuf_len = ALIGN(buf_len, c->min_io_size);\n\tused = 0;\n\tavail = buf_len;\n\n\t/* Ensure there is enough room for first write */\n\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\tif (buf_offs + next_len > c->leb_size)\n\t\tlnum = -1;\n\n\twhile (1) {\n\t\tznode = cnext;\n\n\t\tlen = ubifs_idx_node_sz(c, znode->child_cnt);\n\n\t\t/* Determine the index node position */\n\t\tif (lnum == -1) {\n\t\t\tif (c->ileb_nxt >= c->ileb_cnt) {\n\t\t\t\tubifs_err(\"out of space\");\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\tlnum = c->ilebs[c->ileb_nxt++];\n\t\t\tbuf_offs = 0;\n\t\t\tused = 0;\n\t\t\tavail = buf_len;\n\t\t}\n\n\t\toffs = buf_offs + used;\n\n\t\tznode->lnum = lnum;\n\t\tznode->offs = offs;\n\t\tznode->len = len;\n\n\t\t/* Update the parent */\n\t\tzp = znode->parent;\n\t\tif (zp) {\n\t\t\tstruct ubifs_zbranch *zbr;\n\t\t\tint i;\n\n\t\t\ti = znode->iip;\n\t\t\tzbr = &zp->zbranch[i];\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t} else {\n\t\t\tc->zroot.lnum = lnum;\n\t\t\tc->zroot.offs = offs;\n\t\t\tc->zroot.len = len;\n\t\t}\n\t\tc->calc_idx_sz += ALIGN(len, 8);\n\n\t\t/*\n\t\t * Once lprops is updated, we can decrease the dirty znode count\n\t\t * but it is easier to just do it here.\n\t\t */\n\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\t/*\n\t\t * Calculate the next index node length to see if there is\n\t\t * enough room for it\n\t\t */\n\t\tcnext = znode->cnext;\n\t\tif (cnext == c->cnext)\n\t\t\tnext_len = 0;\n\t\telse\n\t\t\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\n\t\t/* Update buffer positions */\n\t\twlen = used + len;\n\t\tused += ALIGN(len, 8);\n\t\tavail -= ALIGN(len, 8);\n\n\t\tif (next_len != 0 &&\n\t\t    buf_offs + used + next_len <= c->leb_size &&\n\t\t    avail > 0)\n\t\t\tcontinue;\n\n\t\tif (avail <= 0 && next_len &&\n\t\t    buf_offs + used + next_len <= c->leb_size)\n\t\t\tblen = buf_len;\n\t\telse\n\t\t\tblen = ALIGN(wlen, c->min_io_size);\n\n\t\t/* The buffer is full or there are no more znodes to do */\n\t\tbuf_offs += blen;\n\t\tif (next_len) {\n\t\t\tif (buf_offs + next_len > c->leb_size) {\n\t\t\t\terr = ubifs_update_one_lp(c, lnum,\n\t\t\t\t\tc->leb_size - buf_offs, blen - used,\n\t\t\t\t\t0, 0);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tlnum = -1;\n\t\t\t}\n\t\t\tused -= blen;\n\t\t\tif (used < 0)\n\t\t\t\tused = 0;\n\t\t\tavail = buf_len - used;\n\t\t\tcontinue;\n\t\t}\n\t\terr = ubifs_update_one_lp(c, lnum, c->leb_size - buf_offs,\n\t\t\t\t\t  blen - used, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\tc->dbg->new_ihead_lnum = lnum;\n\tc->dbg->new_ihead_offs = buf_offs;\n\n\treturn 0;\n}\n\n/**\n * layo",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "one_lp(c, lnum, c->",
          "args": [
            "e",
            "size",
            "buf_offs,\n\t\t\t\t\t  blen",
            "0, 0);\n\t\tif",
            "e",
            ")"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum,",
          "args": [
            ">leb",
            "buf_offs, blen - used",
            "0, 0);",
            "r"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->min",
          "args": [
            "io_s",
            "e);\n\n\t\t/* The"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": ";",
          "args": [
            "f (",
            "x"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\ta",
          "args": [
            "ail",
            "="
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, cnext->ch",
          "args": [
            "l",
            "cnt);\n\n\t\t/* Upda"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec(&c->dirty_zn",
          "args": [
            "cnt);\n\n\t\t/*\n\t\t *"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";",
          "args": [
            "*",
            "*"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t of spac",
          "args": [
            "\");\n\t\t\t\treturn"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, znode->ch",
          "args": [
            "l",
            "cnt);\n\n\t\t/* Dete"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, cnext->ch",
          "args": [
            "l",
            "cnt);\n\tif (buf_o"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", c->",
          "args": [
            "in_io_s",
            "e);\n\tused = 0;"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, c->fanout",
          "args": [
            ";",
            "buf_len ="
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nyout_in_empty_space(struct ubifs_info *c)\n{\n\tstruct ubifs_znode *znode, *cnext, *zp;\n\tint lnum, offs, len, next_len, buf_len, buf_offs, used, avail;\n\tint wlen, blen, err;\n\n\tcnext = c->enext;\n\tif (!cnext)\n\t\treturn 0;\n\n\tlnum = c->ihead_lnum;\n\tbuf_offs = c->ihead_offs;\n\n\tbuf_len = ubifs_idx_node_sz(c, c->fanout);\n\tbuf_len = ALIGN(buf_len, c->min_io_size);\n\tused = 0;\n\tavail = buf_len;\n\n\t/* Ensure there is enough room for first write */\n\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\tif (buf_offs + next_len > c->leb_size)\n\t\tlnum = -1;\n\n\twhile (1) {\n\t\tznode = cnext;\n\n\t\tlen = ubifs_idx_node_sz(c, znode->child_cnt);\n\n\t\t/* Determine the index node position */\n\t\tif (lnum == -1) {\n\t\t\tif (c->ileb_nxt >= c->ileb_cnt) {\n\t\t\t\tubifs_err(\"out of space\");\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\tlnum = c->ilebs[c->ileb_nxt++];\n\t\t\tbuf_offs = 0;\n\t\t\tused = 0;\n\t\t\tavail = buf_len;\n\t\t}\n\n\t\toffs = buf_offs + used;\n\n\t\tznode->lnum = lnum;\n\t\tznode->offs = offs;\n\t\tznode->len = len;\n\n\t\t/* Update the parent */\n\t\tzp = znode->parent;\n\t\tif (zp) {\n\t\t\tstruct ubifs_zbranch *zbr;\n\t\t\tint i;\n\n\t\t\ti = znode->iip;\n\t\t\tzbr = &zp->zbranch[i];\n\t\t\tzbr->lnum = lnum;\n\t\t\tzbr->offs = offs;\n\t\t\tzbr->len = len;\n\t\t} else {\n\t\t\tc->zroot.lnum = lnum;\n\t\t\tc->zroot.offs = offs;\n\t\t\tc->zroot.len = len;\n\t\t}\n\t\tc->calc_idx_sz += ALIGN(len, 8);\n\n\t\t/*\n\t\t * Once lprops is updated, we can decrease the dirty znode count\n\t\t * but it is easier to just do it here.\n\t\t */\n\t\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\t\t/*\n\t\t * Calculate the next index node length to see if there is\n\t\t * enough room for it\n\t\t */\n\t\tcnext = znode->cnext;\n\t\tif (cnext == c->cnext)\n\t\t\tnext_len = 0;\n\t\telse\n\t\t\tnext_len = ubifs_idx_node_sz(c, cnext->child_cnt);\n\n\t\t/* Update buffer positions */\n\t\twlen = used + len;\n\t\tused += ALIGN(len, 8);\n\t\tavail -= ALIGN(len, 8);\n\n\t\tif (next_len != 0 &&\n\t\t    buf_offs + used + next_len <= c->leb_size &&\n\t\t    avail > 0)\n\t\t\tcontinue;\n\n\t\tif (avail <= 0 && next_len &&\n\t\t    buf_offs + used + next_len <= c->leb_size)\n\t\t\tblen = buf_len;\n\t\telse\n\t\t\tblen = ALIGN(wlen, c->min_io_size);\n\n\t\t/* The buffer is full or there are no more znodes to do */\n\t\tbuf_offs += blen;\n\t\tif (next_len) {\n\t\t\tif (buf_offs + next_len > c->leb_size) {\n\t\t\t\terr = ubifs_update_one_lp(c, lnum,\n\t\t\t\t\tc->leb_size - buf_offs, blen - used,\n\t\t\t\t\t0, 0);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tlnum = -1;\n\t\t\t}\n\t\t\tused -= blen;\n\t\t\tif (used < 0)\n\t\t\t\tused = 0;\n\t\t\tavail = buf_len - used;\n\t\t\tcontinue;\n\t\t}\n\t\terr = ubifs_update_one_lp(c, lnum, c->leb_size - buf_offs,\n\t\t\t\t\t  blen - used, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\tc->dbg->new_ihead_lnum = lnum;\n\tc->dbg->new_ihead_offs = buf_offs;\n\n\treturn 0;\n}\n\n/**\n * layo"
  },
  {
    "function_name": "s(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "361-403",
    "snippet": "yout_in_gaps(struct ubifs_info *c, int cnt)\n{\n\tint err, leb_needed_cnt, written, *p;\n\n\tdbg_gc(\"%d znodes to write\", cnt);\n\n\tc->gap_lebs = kmalloc(sizeof(int) * (c->lst.idx_lebs + 1), GFP_NOFS);\n\tif (!c->gap_lebs)\n\t\treturn -ENOMEM;\n\n\tp = c->gap_lebs;\n\tdo {\n\t\tubifs_assert(p < c->gap_lebs + sizeof(int) * c->lst.idx_lebs);\n\t\twritten = layout_leb_in_gaps(c, p);\n\t\tif (written < 0) {\n\t\t\terr = written;\n\t\t\tif (err != -ENOSPC) {\n\t\t\t\tkfree(c->gap_lebs);\n\t\t\t\tc->gap_lebs = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!dbg_is_chk_index(c)) {\n\t\t\t\t/*\n\t\t\t\t * Do not print scary warnings if the debugging\n\t\t\t\t * option which forces in-the-gaps is enabled.\n\t\t\t\t */\n\t\t\t\tubifs_warn(\"out of space\");\n\t\t\t\tubifs_dump_budg(c, &c->bi);\n\t\t\t\tubifs_dump_lprops(c);\n\t\t\t}\n\t\t\t/* Try to commit anyway */\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t\tcnt -= written;\n\t\tleb_needed_cnt = get_leb_cnt(c, cnt);\n\t\tdbg_gc(\"%d znodes remaining, need %d LEBs, have %d\", cnt,\n\t\t       leb_needed_cnt, c->ileb_cnt);\n\t} while (leb_needed_cnt > c->ileb_cnt);\n\n\t*p = -1;\n\treturn 0;\n}\n\n/**\n * layo",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "odes r",
          "args": [
            "maining, need %d LEBs, have %d\", cnt,",
            "le",
            "t, c->ileb_cnt",
            "} while ("
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", cnt);\n\t\td",
          "args": [
            "g",
            "c(\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c);\n\t\t\t}",
          "args": [
            "*"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dg(c, &c->bi);",
          "args": [
            "ubifs_"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut of spac",
          "args": [
            "\");\n\t\t\t\tubifs_"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dex(c)) {\n\t\t\t\t/*",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lebs)",
          "args": [
            "c->gap"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_gaps(c, p);\n\t\tif",
          "args": [
            "w",
            "t"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p < c->gap_l",
          "args": [
            "bs + sizeof(int) * c->lst.idx_lebs);\n\t\twritten"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(int)",
          "args": [
            "(c->lst.idx_lebs + 1), GFP_NOFS);",
            "f (!c->g"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "odes t",
          "args": [
            "write\", cnt);\n\n\tc->",
            "p_l"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nyout_in_gaps(struct ubifs_info *c, int cnt)\n{\n\tint err, leb_needed_cnt, written, *p;\n\n\tdbg_gc(\"%d znodes to write\", cnt);\n\n\tc->gap_lebs = kmalloc(sizeof(int) * (c->lst.idx_lebs + 1), GFP_NOFS);\n\tif (!c->gap_lebs)\n\t\treturn -ENOMEM;\n\n\tp = c->gap_lebs;\n\tdo {\n\t\tubifs_assert(p < c->gap_lebs + sizeof(int) * c->lst.idx_lebs);\n\t\twritten = layout_leb_in_gaps(c, p);\n\t\tif (written < 0) {\n\t\t\terr = written;\n\t\t\tif (err != -ENOSPC) {\n\t\t\t\tkfree(c->gap_lebs);\n\t\t\t\tc->gap_lebs = NULL;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tif (!dbg_is_chk_index(c)) {\n\t\t\t\t/*\n\t\t\t\t * Do not print scary warnings if the debugging\n\t\t\t\t * option which forces in-the-gaps is enabled.\n\t\t\t\t */\n\t\t\t\tubifs_warn(\"out of space\");\n\t\t\t\tubifs_dump_budg(c, &c->bi);\n\t\t\t\tubifs_dump_lprops(c);\n\t\t\t}\n\t\t\t/* Try to commit anyway */\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t\tcnt -= written;\n\t\tleb_needed_cnt = get_leb_cnt(c, cnt);\n\t\tdbg_gc(\"%d znodes remaining, need %d LEBs, have %d\", cnt,\n\t\t       leb_needed_cnt, c->ileb_cnt);\n\t} while (leb_needed_cnt > c->ileb_cnt);\n\n\t*p = -1;\n\treturn 0;\n}\n\n/**\n * layo"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "339-349",
    "snippet": "t_leb_cnt(struct ubifs_info *c, int cnt)\n{\n\tint d;\n\n\t/* Assume maximum index node size (i.e. overestimate space needed) */\n\tcnt -= (c->leb_size - c->ihead_offs) / c->max_idx_node_sz;\n\tif (cnt < 0)\n\t\tcnt = 0;\n\td = c->leb_size / c->max_idx_node_sz;\n\treturn DIV_ROUND_UP(cnt, d);\n}\n\n/**\n * layo",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cnt, d);\n}",
          "args": [
            "**"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nt_leb_cnt(struct ubifs_info *c, int cnt)\n{\n\tint d;\n\n\t/* Assume maximum index node size (i.e. overestimate space needed) */\n\tcnt -= (c->leb_size - c->ihead_offs) / c->max_idx_node_sz;\n\tif (cnt < 0)\n\t\tcnt = 0;\n\td = c->leb_size / c->max_idx_node_sz;\n\treturn DIV_ROUND_UP(cnt, d);\n}\n\n/**\n * layo"
  },
  {
    "function_name": "_gaps(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "229-328",
    "snippet": "yout_leb_in_gaps(struct ubifs_info *c, int *p)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tint lnum, dirt = 0, gap_start, gap_end, err, written, tot_written;\n\n\ttot_written = 0;\n\t/* Get an index LEB with lots of obsolete index nodes */\n\tlnum = ubifs_find_dirty_idx_leb(c);\n\tif (lnum < 0)\n\t\t/*\n\t\t * There also may be dirt in the index head that could be\n\t\t * filled, however we do not check there at present.\n\t\t */\n\t\treturn lnum; /* Error code */\n\t*p = lnum;\n\tdbg_gc(\"LEB %d\", lnum);\n\t/*\n\t * Scan the index LEB.  We use the generic scan for this even though\n\t * it is more comprehensive and less efficient than is needed for this\n\t * purpose.\n\t */\n\tsleb = ubifs_scan(c, lnum, 0, c->ileb_buf, 0);\n\tc->ileb_len = 0;\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\tgap_start = 0;\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tstruct ubifs_idx_node *idx;\n\t\tint in_use, level;\n\n\t\tubifs_assert(snod->type == UBIFS_IDX_NODE);\n\t\tidx = snod->node;\n\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\tlevel = le16_to_cpu(idx->level);\n\t\t/* Determine if the index node is in use (not obsolete) */\n\t\tin_use = is_idx_node_in_use(c, &snod->key, level, lnum,\n\t\t\t\t\t    snod->offs);\n\t\tif (in_use < 0) {\n\t\t\tubifs_scan_destroy(sleb);\n\t\t\treturn in_use; /* Error code */\n\t\t}\n\t\tif (in_use) {\n\t\t\tif (in_use == 1)\n\t\t\t\tdirt += ALIGN(snod->len, 8);\n\t\t\t/*\n\t\t\t * The obsolete index nodes form gaps that can be\n\t\t\t * overwritten.  This gap has ended because we have\n\t\t\t * found an index node that is still in use\n\t\t\t * i.e. not obsolete\n\t\t\t */\n\t\t\tgap_end = snod->offs;\n\t\t\t/* Try to fill gap */\n\t\t\twritten = fill_gap(c, lnum, gap_start, gap_end, &dirt);\n\t\t\tif (written < 0) {\n\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\treturn written; /* Error code */\n\t\t\t}\n\t\t\ttot_written += written;\n\t\t\tgap_start = ALIGN(snod->offs + snod->len, 8);\n\t\t}\n\t}\n\tubifs_scan_destroy(sleb);\n\tc->ileb_len = c->leb_size;\n\tgap_end = c->leb_size;\n\t/* Try to fill gap */\n\twritten = fill_gap(c, lnum, gap_start, gap_end, &dirt);\n\tif (written < 0)\n\t\treturn written; /* Error code */\n\ttot_written += written;\n\tif (tot_written == 0) {\n\t\tstruct ubifs_lprops lp;\n\n\t\tdbg_gc(\"LEB %d wrote %d index nodes\", lnum, tot_written);\n\t\terr = ubifs_read_one_lp(c, lnum, &lp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (lp.free == c->leb_size) {\n\t\t\t/*\n\t\t\t * We must have snatched this LEB from the idx_gc list\n\t\t\t * so we need to correct the free and dirty space.\n\t\t\t */\n\t\t\terr = ubifs_change_one_lp(c, lnum,\n\t\t\t\t\t\t  c->leb_size - c->ileb_len,\n\t\t\t\t\t\t  dirt, 0, 0, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\terr = ubifs_change_one_lp(c, lnum, c->leb_size - c->ileb_len, dirt,\n\t\t\t\t  0, 0, 0);\n\tif (err)\n\t\treturn err;\n\terr = ubifs_leb_change(c, lnum, c->ileb_buf, c->ileb_len);\n\tif (err)\n\t\treturn err;\n\tdbg_gc(\"LEB %d wrote %d index nodes\", lnum, tot_written);\n\treturn tot_written;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d wrot",
          "args": [
            "%d index nodes\", lnum, tot_w",
            "tten",
            "return to"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum, c->",
          "args": [
            "l",
            "_buf",
            "c->ileb_len",
            "if (err)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum, c->",
          "args": [
            "e",
            "size",
            "c->ileb_len, dirt,",
            ", 0,",
            "r"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum,",
          "args": [
            "c->",
            "c->ileb_len,\n\t\t\t\t\t\t  dir",
            ");",
            "i",
            "(",
            "r"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_lp(c, lnum, &lp",
          "args": [
            ";",
            "if",
            "rr)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d wrot",
          "args": [
            "%d index nodes\", lnum, tot_w",
            "tten",
            "err = ub"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, gap",
          "args": [
            "s",
            "rt,",
            "p_end, &d",
            "t);\n\tif",
            "writt"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tc->i",
          "args": [
            "eb_l"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs +",
          "args": [
            "snod->len, 8);\n\t\t}\n\t}",
            "b"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\t\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num, gap",
          "args": [
            "s",
            "rt,",
            "p_end, &d",
            "t);",
            "(wri"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, 8",
          "args": [
            ";\n\t\t\t/*"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\t\t\tre",
          "args": [
            "urn"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_use(c, &snod->ke",
          "args": [
            ",",
            "evel, lnum",
            "sn",
            "if (in_u"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level);",
          "args": [
            "/* Deter"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bifs_idx",
          "args": [
            "k",
            "(c, idx), &snod->key)",
            "level ="
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, idx), &sn",
          "args": [
            "d",
            "key"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snod->type =",
          "args": [
            "UBIFS_IDX_NODE);\n\t\tidx = sn"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(snod, &sleb-",
          "args": [
            "node",
            "list) {\n\t\ts",
            "uct"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\tgap_",
          "args": [
            "tart"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn P"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lnum, 0,",
          "args": [
            "-",
            "leb_",
            "f",
            "0);\n\tc->ile",
            "l"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d\", ln",
          "args": [
            "m);\n\t/*",
            "* Sc"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_idx_leb(c);\n\tif (lnu",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nyout_leb_in_gaps(struct ubifs_info *c, int *p)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tint lnum, dirt = 0, gap_start, gap_end, err, written, tot_written;\n\n\ttot_written = 0;\n\t/* Get an index LEB with lots of obsolete index nodes */\n\tlnum = ubifs_find_dirty_idx_leb(c);\n\tif (lnum < 0)\n\t\t/*\n\t\t * There also may be dirt in the index head that could be\n\t\t * filled, however we do not check there at present.\n\t\t */\n\t\treturn lnum; /* Error code */\n\t*p = lnum;\n\tdbg_gc(\"LEB %d\", lnum);\n\t/*\n\t * Scan the index LEB.  We use the generic scan for this even though\n\t * it is more comprehensive and less efficient than is needed for this\n\t * purpose.\n\t */\n\tsleb = ubifs_scan(c, lnum, 0, c->ileb_buf, 0);\n\tc->ileb_len = 0;\n\tif (IS_ERR(sleb))\n\t\treturn PTR_ERR(sleb);\n\tgap_start = 0;\n\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\tstruct ubifs_idx_node *idx;\n\t\tint in_use, level;\n\n\t\tubifs_assert(snod->type == UBIFS_IDX_NODE);\n\t\tidx = snod->node;\n\t\tkey_read(c, ubifs_idx_key(c, idx), &snod->key);\n\t\tlevel = le16_to_cpu(idx->level);\n\t\t/* Determine if the index node is in use (not obsolete) */\n\t\tin_use = is_idx_node_in_use(c, &snod->key, level, lnum,\n\t\t\t\t\t    snod->offs);\n\t\tif (in_use < 0) {\n\t\t\tubifs_scan_destroy(sleb);\n\t\t\treturn in_use; /* Error code */\n\t\t}\n\t\tif (in_use) {\n\t\t\tif (in_use == 1)\n\t\t\t\tdirt += ALIGN(snod->len, 8);\n\t\t\t/*\n\t\t\t * The obsolete index nodes form gaps that can be\n\t\t\t * overwritten.  This gap has ended because we have\n\t\t\t * found an index node that is still in use\n\t\t\t * i.e. not obsolete\n\t\t\t */\n\t\t\tgap_end = snod->offs;\n\t\t\t/* Try to fill gap */\n\t\t\twritten = fill_gap(c, lnum, gap_start, gap_end, &dirt);\n\t\t\tif (written < 0) {\n\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\treturn written; /* Error code */\n\t\t\t}\n\t\t\ttot_written += written;\n\t\t\tgap_start = ALIGN(snod->offs + snod->len, 8);\n\t\t}\n\t}\n\tubifs_scan_destroy(sleb);\n\tc->ileb_len = c->leb_size;\n\tgap_end = c->leb_size;\n\t/* Try to fill gap */\n\twritten = fill_gap(c, lnum, gap_start, gap_end, &dirt);\n\tif (written < 0)\n\t\treturn written; /* Error code */\n\ttot_written += written;\n\tif (tot_written == 0) {\n\t\tstruct ubifs_lprops lp;\n\n\t\tdbg_gc(\"LEB %d wrote %d index nodes\", lnum, tot_written);\n\t\terr = ubifs_read_one_lp(c, lnum, &lp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (lp.free == c->leb_size) {\n\t\t\t/*\n\t\t\t * We must have snatched this LEB from the idx_gc list\n\t\t\t * so we need to correct the free and dirty space.\n\t\t\t */\n\t\t\terr = ubifs_change_one_lp(c, lnum,\n\t\t\t\t\t\t  c->leb_size - c->ileb_len,\n\t\t\t\t\t\t  dirt, 0, 0, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\terr = ubifs_change_one_lp(c, lnum, c->leb_size - c->ileb_len, dirt,\n\t\t\t\t  0, 0, 0);\n\tif (err)\n\t\treturn err;\n\terr = ubifs_leb_change(c, lnum, c->ileb_buf, c->ileb_len);\n\tif (err)\n\t\treturn err;\n\tdbg_gc(\"LEB %d wrote %d index nodes\", lnum, tot_written);\n\treturn tot_written;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "n_use(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "203-215",
    "snippet": "_idx_node_in_use(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t      int level, int lnum, int offs)\n{\n\tint ret;\n\n\tret = is_idx_node_in_tnc(c, key, level, lnum, offs);\n\tif (ret < 0)\n\t\treturn ret; /* Error code */\n\tif (ret == 0)\n\t\tif (find_old_idx(c, lnum, offs))\n\t\t\treturn 1;\n\treturn ret;\n}\n\n/**\n * layo",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c, lnum, off",
          "args": [
            ")",
            "r",
            "urn"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_tnc(c, key, leve",
          "args": [
            ",",
            "num",
            "offs)",
            "if",
            "et <"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\n_idx_node_in_use(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t      int level, int lnum, int offs)\n{\n\tint ret;\n\n\tret = is_idx_node_in_tnc(c, key, level, lnum, offs);\n\tif (ret < 0)\n\t\treturn ret; /* Error code */\n\tif (ret == 0)\n\t\tif (find_old_idx(c, lnum, offs))\n\t\t\treturn 1;\n\treturn ret;\n}\n\n/**\n * layo"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "168-188",
    "snippet": "nd_old_idx(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_old_idx *o;\n\tstruct rb_node *p;\n\n\tp = c->old_idx.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_old_idx, rb);\n\t\tif (lnum < o->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > o->lnum)\n\t\t\tp = p->rb_right;\n\t\telse if (offs < o->offs)\n\t\t\tp = p->rb_left;\n\t\telse if (offs > o->offs)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * is_i",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truct ub",
          "args": [
            "f",
            "old_id, rb);\n\t\tif (",
            "um"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
          "lines": "552-563",
          "snippet": "yout_commit(struct ubifs_info *c, int no_space, int cnt)\n{\n\tint err;\n\n\tif (no_space) {\n\t\terr = layout_in_gaps(c, cnt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = layout_in_empty_space(c);\n\treturn err;\n}\n\n/**\n * find",
          "includes": [
            "fs.h\"\n\n/**\n * make_",
            "ux/random.h>\n#include \"ubi"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nyout_commit(struct ubifs_info *c, int no_space, int cnt)\n{\n\tint err;\n\n\tif (no_space) {\n\t\terr = layout_in_gaps(c, cnt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\terr = layout_in_empty_space(c);\n\treturn err;\n}\n\n/**\n * find"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nnd_old_idx(struct ubifs_info *c, int lnum, int offs)\n{\n\tstruct ubifs_old_idx *o;\n\tstruct rb_node *p;\n\n\tp = c->old_idx.rb_node;\n\twhile (p) {\n\t\to = rb_entry(p, struct ubifs_old_idx, rb);\n\t\tif (lnum < o->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > o->lnum)\n\t\t\tp = p->rb_right;\n\t\telse if (offs < o->offs)\n\t\t\tp = p->rb_left;\n\t\telse if (offs > o->offs)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * is_i"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "111-158",
    "snippet": "ll_gap(struct ubifs_info *c, int lnum, int gap_start, int gap_end,\n\t\t    int *dirt)\n{\n\tint len, gap_remains, gap_pos, written, pad_len;\n\n\tubifs_assert((gap_start & 7) == 0);\n\tubifs_assert((gap_end & 7) == 0);\n\tubifs_assert(gap_end >= gap_start);\n\n\tgap_remains = gap_end - gap_start;\n\tif (!gap_remains)\n\t\treturn 0;\n\tgap_pos = gap_start;\n\twritten = 0;\n\twhile (c->enext) {\n\t\tlen = ubifs_idx_node_sz(c, c->enext->child_cnt);\n\t\tif (len < gap_remains) {\n\t\t\tstruct ubifs_znode *znode = c->enext;\n\t\t\tconst int alen = ALIGN(len, 8);\n\t\t\tint err;\n\n\t\t\tubifs_assert(alen <= gap_remains);\n\t\t\terr = make_idx_node(c, c->ileb_buf + gap_pos, znode,\n\t\t\t\t\t    lnum, gap_pos, len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tgap_remains -= alen;\n\t\t\tgap_pos += alen;\n\t\t\tc->enext = znode->cnext;\n\t\t\tif (c->enext == c->cnext)\n\t\t\t\tc->enext = NULL;\n\t\t\twritten += 1;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (gap_end == c->leb_size) {\n\t\tc->ileb_len = ALIGN(gap_pos, c->min_io_size);\n\t\t/* Pad to end of min_io_size */\n\t\tpad_len = c->ileb_len - gap_pos;\n\t} else\n\t\t/* Pad to end of gap */\n\t\tpad_len = gap_remains;\n\tdbg_gc(\"LEB %d:%d to %d len %d nodes written %d wasted bytes %d\",\n\t       lnum, gap_start, gap_end, gap_end - gap_start, written, pad_len);\n\tubifs_pad(c, c->ileb_buf + gap_pos, pad_len);\n\t*dirt += pad_len;\n\treturn written;\n}\n\n/**\n * find",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->ileb_b",
          "args": [
            "f",
            "gap_pos, pad_len);",
            "irt +="
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d t",
          "args": [
            "%d len %d nodes written %d wasted bytes %d\",\n\t       lnu",
            "rt,",
            "p_end, ga",
            "end - g",
            "_start, written, pa",
            "len);",
            "ifs_pad"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", c->",
          "args": [
            "in_io_s",
            "e);\n\t\t/* Pad t"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, c->ileb_b",
          "args": [
            "f",
            "gap_pos, znode,",
            "ln",
            ", le",
            ";\n\t\t\tif",
            "err"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alen <= gap_",
          "args": [
            "emains);\n\t\t\terr = m"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";",
          "args": [
            "nt",
            "r"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_sz(c, c->enext-",
          "args": [
            "c",
            "ld_cnt);\n\t\tif (len"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gap_end >= g",
          "args": [
            "p_start);\n\n\tgap_rema"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(gap_end & 7",
          "args": [
            "== 0);\n\tubifs_ass"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(gap_start &",
          "args": [
            "7) == 0);\n\tubifs_ass"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nll_gap(struct ubifs_info *c, int lnum, int gap_start, int gap_end,\n\t\t    int *dirt)\n{\n\tint len, gap_remains, gap_pos, written, pad_len;\n\n\tubifs_assert((gap_start & 7) == 0);\n\tubifs_assert((gap_end & 7) == 0);\n\tubifs_assert(gap_end >= gap_start);\n\n\tgap_remains = gap_end - gap_start;\n\tif (!gap_remains)\n\t\treturn 0;\n\tgap_pos = gap_start;\n\twritten = 0;\n\twhile (c->enext) {\n\t\tlen = ubifs_idx_node_sz(c, c->enext->child_cnt);\n\t\tif (len < gap_remains) {\n\t\t\tstruct ubifs_znode *znode = c->enext;\n\t\t\tconst int alen = ALIGN(len, 8);\n\t\t\tint err;\n\n\t\t\tubifs_assert(alen <= gap_remains);\n\t\t\terr = make_idx_node(c, c->ileb_buf + gap_pos, znode,\n\t\t\t\t\t    lnum, gap_pos, len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tgap_remains -= alen;\n\t\t\tgap_pos += alen;\n\t\t\tc->enext = znode->cnext;\n\t\t\tif (c->enext == c->cnext)\n\t\t\t\tc->enext = NULL;\n\t\t\twritten += 1;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif (gap_end == c->leb_size) {\n\t\tc->ileb_len = ALIGN(gap_pos, c->min_io_size);\n\t\t/* Pad to end of min_io_size */\n\t\tpad_len = c->ileb_len - gap_pos;\n\t} else\n\t\t/* Pad to end of gap */\n\t\tpad_len = gap_remains;\n\tdbg_gc(\"LEB %d:%d to %d len %d nodes written %d wasted bytes %d\",\n\t       lnum, gap_start, gap_end, gap_end - gap_start, written, pad_len);\n\tubifs_pad(c, c->ileb_buf + gap_pos, pad_len);\n\t*dirt += pad_len;\n\treturn written;\n}\n\n/**\n * find"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_commit.c",
    "lines": "37-99",
    "snippet": "ke_idx_node(struct ubifs_info *c, struct ubifs_idx_node *idx,\n\t\t\t struct ubifs_znode *znode, int lnum, int offs, int len)\n{\n\tstruct ubifs_znode *zp;\n\tint i, err;\n\n\t/* Make index node */\n\tidx->ch.node_type = UBIFS_IDX_NODE;\n\tidx->child_cnt = cpu_to_le16(znode->child_cnt);\n\tidx->level = cpu_to_le16(znode->level);\n\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\tstruct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\tkey_write_idx(c, &zbr->key, &br->key);\n\t\tbr->lnum = cpu_to_le32(zbr->lnum);\n\t\tbr->offs = cpu_to_le32(zbr->offs);\n\t\tbr->len = cpu_to_le32(zbr->len);\n\t\tif (!zbr->lnum || !zbr->len) {\n\t\t\tubifs_err(\"bad ref in znode\");\n\t\t\tubifs_dump_znode(c, znode);\n\t\t\tif (zbr->znode)\n\t\t\t\tubifs_dump_znode(c, zbr->znode);\n\t\t}\n\t}\n\tubifs_prepare_node(c, idx, len, 0);\n\n\tznode->lnum = lnum;\n\tznode->offs = offs;\n\tznode->len = len;\n\n\terr = insert_old_idx_znode(c, znode);\n\n\t/* Update the parent */\n\tzp = znode->parent;\n\tif (zp) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &zp->zbranch[znode->iip];\n\t\tzbr->lnum = lnum;\n\t\tzbr->offs = offs;\n\t\tzbr->len = len;\n\t} else {\n\t\tc->zroot.lnum = lnum;\n\t\tc->zroot.offs = offs;\n\t\tc->zroot.len = len;\n\t}\n\tc->calc_idx_sz += ALIGN(len, 8);\n\n\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\tubifs_assert(ubifs_zn_dirty(znode));\n\tubifs_assert(ubifs_zn_cow(znode));\n\n\t/*\n\t * Note, unlike 'write_index()' we do not add memory barriers here\n\t * because this function is called with @c->tnc_mutex locked.\n\t */\n\t__clear_bit(DIRTY_ZNODE, &znode->flags);\n\t__clear_bit(COW_ZNODE, &znode->flags);\n\n\treturn err;\n}\n\n/**\n * fill",
    "includes": [
      "fs.h\"\n\n/**\n * make_",
      "ux/random.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OW_ZNODE, &",
          "args": [
            "node->fla",
            ");\n\n\treturn e"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRTY_ZNODE,",
          "args": [
            "&znode->fla",
            ");\n\t__clear_b"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_zn_cow",
          "args": [
            "znode));\n\n\t/*\n\t * N"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode));\n\n\t/",
          "args": [
            "*"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_zn_dir",
          "args": [
            "y(znode));\n\tubifs_ass"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(znode));\n\tub",
          "args": [
            "fs_as"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec(&c->dirty_zn",
          "args": [
            "cnt);\n\n\tubifs_as"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\ta",
          "args": [
            "omi",
            "l"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_znode(c, znode);",
          "args": [
            "/",
            "Updat"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, idx, len,",
          "args": [
            "0",
            "ode",
            "l"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, zbr->znod",
          "args": [
            ")",
            "}\n\t}\n\tub"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, znode);",
          "args": [
            "(zbr"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d ref in",
          "args": [
            "node\");\n\t\t\tubifs_d"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->len);",
          "args": [
            "if (!zbr"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->offs);",
          "args": [
            "br->len"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->lnum);",
          "args": [
            "br->offs"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &zbr->key",
          "args": [
            "r->key);",
            "br->lnum"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nch(c, idx, i);",
          "args": [
            "ruc",
            "u"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->level",
          "args": [
            ";\n\tfor (i ="
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->child",
          "args": [
            "cnt);\n\tidx->leve"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * make_\nux/random.h>\n#include \"ubi\n\nke_idx_node(struct ubifs_info *c, struct ubifs_idx_node *idx,\n\t\t\t struct ubifs_znode *znode, int lnum, int offs, int len)\n{\n\tstruct ubifs_znode *zp;\n\tint i, err;\n\n\t/* Make index node */\n\tidx->ch.node_type = UBIFS_IDX_NODE;\n\tidx->child_cnt = cpu_to_le16(znode->child_cnt);\n\tidx->level = cpu_to_le16(znode->level);\n\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\tstruct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\tkey_write_idx(c, &zbr->key, &br->key);\n\t\tbr->lnum = cpu_to_le32(zbr->lnum);\n\t\tbr->offs = cpu_to_le32(zbr->offs);\n\t\tbr->len = cpu_to_le32(zbr->len);\n\t\tif (!zbr->lnum || !zbr->len) {\n\t\t\tubifs_err(\"bad ref in znode\");\n\t\t\tubifs_dump_znode(c, znode);\n\t\t\tif (zbr->znode)\n\t\t\t\tubifs_dump_znode(c, zbr->znode);\n\t\t}\n\t}\n\tubifs_prepare_node(c, idx, len, 0);\n\n\tznode->lnum = lnum;\n\tznode->offs = offs;\n\tznode->len = len;\n\n\terr = insert_old_idx_znode(c, znode);\n\n\t/* Update the parent */\n\tzp = znode->parent;\n\tif (zp) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &zp->zbranch[znode->iip];\n\t\tzbr->lnum = lnum;\n\t\tzbr->offs = offs;\n\t\tzbr->len = len;\n\t} else {\n\t\tc->zroot.lnum = lnum;\n\t\tc->zroot.offs = offs;\n\t\tc->zroot.len = len;\n\t}\n\tc->calc_idx_sz += ALIGN(len, 8);\n\n\tatomic_long_dec(&c->dirty_zn_cnt);\n\n\tubifs_assert(ubifs_zn_dirty(znode));\n\tubifs_assert(ubifs_zn_cow(znode));\n\n\t/*\n\t * Note, unlike 'write_index()' we do not add memory barriers here\n\t * because this function is called with @c->tnc_mutex locked.\n\t */\n\t__clear_bit(DIRTY_ZNODE, &znode->flags);\n\t__clear_bit(COW_ZNODE, &znode->flags);\n\n\treturn err;\n}\n\n/**\n * fill"
  }
]