[
  {
    "function_name": "hfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/dir.c",
    "lines": "282-302",
    "snippet": "static int hfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint res;\n\n\t/* Unlink destination if it already exists */\n\tif (new_dentry->d_inode) {\n\t\tres = hfs_remove(new_dir, new_dentry);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = hfs_cat_move(old_dentry->d_inode->i_ino,\n\t\t\t   old_dir, &old_dentry->d_name,\n\t\t\t   new_dir, &new_dentry->d_name);\n\tif (!res)\n\t\thfs_cat_build_key(old_dir->i_sb,\n\t\t\t\t  (btree_key *)&HFS_I(old_dentry->d_inode)->cat_key,\n\t\t\t\t  new_dir->i_ino, &new_dentry->d_name);\n\treturn res;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_cat_build_key",
          "args": [
            "old_dir->i_sb",
            "(btree_key *)&HFS_I(old_dentry->d_inode)->cat_key",
            "new_dir->i_ino",
            "&new_dentry->d_name"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "23-34",
          "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "old_dentry->d_inode"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_cat_move",
          "args": [
            "old_dentry->d_inode->i_ino",
            "old_dir",
            "&old_dentry->d_name",
            "new_dir",
            "&new_dentry->d_name"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "279-366",
          "snippet": "int hfs_cat_move(u32 cnid, struct inode *src_dir, struct qstr *src_name,\n\t\t struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\tunion hfs_cat_rec entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\tsb = src_dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t    src_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dst_dir);\n\n\t/* finally remove the old entry */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(src_dir);\n\n\ttype = entry.type;\n\tif (type == HFS_CDR_FIL && !(entry.file.Flags & HFS_FIL_THD))\n\t\tgoto out;\n\n\t/* remove old thread entry */\n\thfs_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, type == HFS_CDR_FIL ? HFS_CDR_FTH : HFS_CDR_THD,\n\t\t\t\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_move(u32 cnid, struct inode *src_dir, struct qstr *src_name,\n\t\t struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\tunion hfs_cat_rec entry;\n\tint entry_size, type;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"rename_cat: %u - %lu,%s - %lu,%s\\n\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\tsb = src_dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t/* find the old dir entry and read the data */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t    src_fd.entrylength);\n\n\t/* create new dir entry with the data from the old entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dst_dir);\n\n\t/* finally remove the old entry */\n\thfs_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(src_dir);\n\n\ttype = entry.type;\n\tif (type == HFS_CDR_FIL && !(entry.file.Flags & HFS_FIL_THD))\n\t\tgoto out;\n\n\t/* remove old thread entry */\n\thfs_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t/* create new thread entry */\n\thfs_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, type == HFS_CDR_FIL ? HFS_CDR_FTH : HFS_CDR_THD,\n\t\t\t\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_remove",
          "args": [
            "new_dir",
            "new_dentry"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/dir.c",
          "lines": "254-269",
          "snippet": "static int hfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\tres = hfs_cat_delete(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\treturn res;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfs_delete_inode(inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\tres = hfs_cat_delete(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\treturn res;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfs_delete_inode(inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint res;\n\n\t/* Unlink destination if it already exists */\n\tif (new_dentry->d_inode) {\n\t\tres = hfs_remove(new_dir, new_dentry);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = hfs_cat_move(old_dentry->d_inode->i_ino,\n\t\t\t   old_dir, &old_dentry->d_name,\n\t\t\t   new_dir, &new_dentry->d_name);\n\tif (!res)\n\t\thfs_cat_build_key(old_dir->i_sb,\n\t\t\t\t  (btree_key *)&HFS_I(old_dentry->d_inode)->cat_key,\n\t\t\t\t  new_dir->i_ino, &new_dentry->d_name);\n\treturn res;\n}"
  },
  {
    "function_name": "hfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/dir.c",
    "lines": "254-269",
    "snippet": "static int hfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\tres = hfs_cat_delete(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\treturn res;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfs_delete_inode(inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_delete_inode",
          "args": [
            "inode"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "237-261",
          "snippet": "void hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_delete",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "213-270",
          "snippet": "int hfs_cat_delete(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data fd;\n\tstruct list_head *pos;\n\tint res, type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\tsb = dir->i_sb;\n\tres = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn res;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tres = hfs_brec_find(&fd);\n\tif (res)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u8(fd.bnode, fd.entryoffset);\n\tif (type == HFS_CDR_FIL) {\n\t\tstruct hfs_cat_file file;\n\t\thfs_bnode_read(fd.bnode, &file, fd.entryoffset, sizeof(file));\n\t\tif (be32_to_cpu(file.FlNum) == cnid) {\n#if 0\n\t\t\thfs_free_fork(sb, &file, HFS_FK_DATA);\n#endif\n\t\t\thfs_free_fork(sb, &file, HFS_FK_RSRC);\n\t\t}\n\t}\n\n\tlist_for_each(pos, &HFS_I(dir)->open_dir_list) {\n\t\tstruct hfs_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfs_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\tres = hfs_brec_remove(&fd);\n\tif (res)\n\t\tgoto out;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tres = hfs_brec_find(&fd);\n\tif (!res) {\n\t\tres = hfs_brec_remove(&fd);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\tdir->i_size--;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\tres = 0;\nout:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_delete(u32 cnid, struct inode *dir, struct qstr *str)\n{\n\tstruct super_block *sb;\n\tstruct hfs_find_data fd;\n\tstruct list_head *pos;\n\tint res, type;\n\n\thfs_dbg(CAT_MOD, \"delete_cat: %s,%u\\n\", str ? str->name : NULL, cnid);\n\tsb = dir->i_sb;\n\tres = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn res;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tres = hfs_brec_find(&fd);\n\tif (res)\n\t\tgoto out;\n\n\ttype = hfs_bnode_read_u8(fd.bnode, fd.entryoffset);\n\tif (type == HFS_CDR_FIL) {\n\t\tstruct hfs_cat_file file;\n\t\thfs_bnode_read(fd.bnode, &file, fd.entryoffset, sizeof(file));\n\t\tif (be32_to_cpu(file.FlNum) == cnid) {\n#if 0\n\t\t\thfs_free_fork(sb, &file, HFS_FK_DATA);\n#endif\n\t\t\thfs_free_fork(sb, &file, HFS_FK_RSRC);\n\t\t}\n\t}\n\n\tlist_for_each(pos, &HFS_I(dir)->open_dir_list) {\n\t\tstruct hfs_readdir_data *rd =\n\t\t\tlist_entry(pos, struct hfs_readdir_data, list);\n\t\tif (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)\n\t\t\trd->file->f_pos--;\n\t}\n\n\tres = hfs_brec_remove(&fd);\n\tif (res)\n\t\tgoto out;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tres = hfs_brec_find(&fd);\n\tif (!res) {\n\t\tres = hfs_brec_remove(&fd);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\tdir->i_size--;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\tres = 0;\nout:\n\thfs_find_exit(&fd);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_remove(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint res;\n\n\tif (S_ISDIR(inode->i_mode) && inode->i_size != 2)\n\t\treturn -ENOTEMPTY;\n\tres = hfs_cat_delete(inode->i_ino, dir, &dentry->d_name);\n\tif (res)\n\t\treturn res;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\thfs_delete_inode(inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/dir.c",
    "lines": "222-241",
    "snippet": "static int hfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tint res;\n\n\tinode = hfs_new_inode(dir, &dentry->d_name, S_IFDIR | mode);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tres = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res) {\n\t\tclear_nlink(inode);\n\t\thfs_delete_inode(inode);\n\t\tiput(inode);\n\t\treturn res;\n\t}\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_delete_inode",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "237-261",
          "snippet": "void hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_create",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name",
            "inode"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "82-140",
          "snippet": "int hfs_cat_create(u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\tunion hfs_cat_rec entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\tif (dir->i_size >= HFS_MAX_VALENCE)\n\t\treturn -ENOSPC;\n\n\tsb = dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH,\n\t\t\tdir->i_ino, str);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tentry_size = hfs_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tif (!hfs_brec_find(&fd))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_create(u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\tunion hfs_cat_rec entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\tif (dir->i_size >= HFS_MAX_VALENCE)\n\t\treturn -ENOSPC;\n\n\tsb = dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH,\n\t\t\tdir->i_ino, str);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tentry_size = hfs_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tif (!hfs_brec_find(&fd))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_new_inode",
          "args": [
            "dir",
            "&dentry->d_name",
            "S_IFDIR | mode"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "181-235",
          "snippet": "struct inode *hfs_new_inode(struct inode *dir, struct qstr *name, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\thfs_cat_build_key(sb, (btree_key *)&HFS_I(inode)->cat_key, dir->i_ino, name);\n\tinode->i_ino = HFS_SB(sb)->next_id++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tHFS_I(inode)->fs_blocks = 0;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_size = 2;\n\t\tHFS_SB(sb)->folder_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_dirs++;\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tinode->i_mode |= S_IRWXUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_dir_umask;\n\t} else if (S_ISREG(mode)) {\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n\t\tHFS_SB(sb)->file_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_files++;\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tinode->i_mode |= S_IRUGO|S_IXUGO;\n\t\tif (mode & S_IWUSR)\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_file_umask;\n\t\tHFS_I(inode)->phys_size = 0;\n\t\tHFS_I(inode)->alloc_blocks = 0;\n\t\tHFS_I(inode)->first_blocks = 0;\n\t\tHFS_I(inode)->cached_start = 0;\n\t\tHFS_I(inode)->cached_blocks = 0;\n\t\tmemset(HFS_I(inode)->first_extents, 0, sizeof(hfs_extent_rec));\n\t\tmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\n\t}\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations hfs_file_operations;",
            "static const struct inode_operations hfs_file_inode_operations;",
            "const struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};",
            "static const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};",
            "static const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic const struct file_operations hfs_file_operations;\nstatic const struct inode_operations hfs_file_inode_operations;\nconst struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};\nstatic const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};\nstatic const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};\n\nstruct inode *hfs_new_inode(struct inode *dir, struct qstr *name, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\thfs_cat_build_key(sb, (btree_key *)&HFS_I(inode)->cat_key, dir->i_ino, name);\n\tinode->i_ino = HFS_SB(sb)->next_id++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tHFS_I(inode)->fs_blocks = 0;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_size = 2;\n\t\tHFS_SB(sb)->folder_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_dirs++;\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tinode->i_mode |= S_IRWXUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_dir_umask;\n\t} else if (S_ISREG(mode)) {\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n\t\tHFS_SB(sb)->file_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_files++;\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tinode->i_mode |= S_IRUGO|S_IXUGO;\n\t\tif (mode & S_IWUSR)\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_file_umask;\n\t\tHFS_I(inode)->phys_size = 0;\n\t\tHFS_I(inode)->alloc_blocks = 0;\n\t\tHFS_I(inode)->first_blocks = 0;\n\t\tHFS_I(inode)->cached_start = 0;\n\t\tHFS_I(inode)->cached_blocks = 0;\n\t\tmemset(HFS_I(inode)->first_extents, 0, sizeof(hfs_extent_rec));\n\t\tmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\n\t}\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\tint res;\n\n\tinode = hfs_new_inode(dir, &dentry->d_name, S_IFDIR | mode);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tres = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res) {\n\t\tclear_nlink(inode);\n\t\thfs_delete_inode(inode);\n\t\tiput(inode);\n\t\treturn res;\n\t}\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/dir.c",
    "lines": "192-212",
    "snippet": "static int hfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\tstruct inode *inode;\n\tint res;\n\n\tinode = hfs_new_inode(dir, &dentry->d_name, mode);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tres = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res) {\n\t\tclear_nlink(inode);\n\t\thfs_delete_inode(inode);\n\t\tiput(inode);\n\t\treturn res;\n\t}\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_delete_inode",
          "args": [
            "inode"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_delete_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "237-261",
          "snippet": "void hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nvoid hfs_delete_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\thfs_dbg(INODE, \"delete_inode: %lu\\n\", inode->i_ino);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tHFS_SB(sb)->folder_count--;\n\t\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\t\tHFS_SB(sb)->root_dirs--;\n\t\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\t\thfs_mark_mdb_dirty(sb);\n\t\treturn;\n\t}\n\tHFS_SB(sb)->file_count--;\n\tif (HFS_I(inode)->cat_key.ParID == cpu_to_be32(HFS_ROOT_CNID))\n\t\tHFS_SB(sb)->root_files--;\n\tif (S_ISREG(inode->i_mode)) {\n\t\tif (!inode->i_nlink) {\n\t\t\tinode->i_size = 0;\n\t\t\thfs_file_truncate(inode);\n\t\t}\n\t}\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_create",
          "args": [
            "inode->i_ino",
            "dir",
            "&dentry->d_name",
            "inode"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "82-140",
          "snippet": "int hfs_cat_create(u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\tunion hfs_cat_rec entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\tif (dir->i_size >= HFS_MAX_VALENCE)\n\t\treturn -ENOSPC;\n\n\tsb = dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH,\n\t\t\tdir->i_ino, str);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tentry_size = hfs_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tif (!hfs_brec_find(&fd))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nint hfs_cat_create(u32 cnid, struct inode *dir, struct qstr *str, struct inode *inode)\n{\n\tstruct hfs_find_data fd;\n\tstruct super_block *sb;\n\tunion hfs_cat_rec entry;\n\tint entry_size;\n\tint err;\n\n\thfs_dbg(CAT_MOD, \"create_cat: %s,%u(%d)\\n\",\n\t\tstr->name, cnid, inode->i_nlink);\n\tif (dir->i_size >= HFS_MAX_VALENCE)\n\t\treturn -ENOSPC;\n\n\tsb = dir->i_sb;\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tentry_size = hfs_cat_build_thread(sb, &entry, S_ISDIR(inode->i_mode) ?\n\t\t\tHFS_CDR_THD : HFS_CDR_FTH,\n\t\t\tdir->i_ino, str);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err2;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err2;\n\n\thfs_cat_build_key(sb, fd.search_key, dir->i_ino, str);\n\tentry_size = hfs_cat_build_record(&entry, cnid, inode);\n\terr = hfs_brec_find(&fd);\n\tif (err != -ENOENT) {\n\t\t/* panic? */\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto err1;\n\t}\n\terr = hfs_brec_insert(&fd, &entry, entry_size);\n\tif (err)\n\t\tgoto err1;\n\n\tdir->i_size++;\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(dir);\n\thfs_find_exit(&fd);\n\treturn 0;\n\nerr1:\n\thfs_cat_build_key(sb, fd.search_key, cnid, NULL);\n\tif (!hfs_brec_find(&fd))\n\t\thfs_brec_remove(&fd);\nerr2:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_new_inode",
          "args": [
            "dir",
            "&dentry->d_name",
            "mode"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "181-235",
          "snippet": "struct inode *hfs_new_inode(struct inode *dir, struct qstr *name, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\thfs_cat_build_key(sb, (btree_key *)&HFS_I(inode)->cat_key, dir->i_ino, name);\n\tinode->i_ino = HFS_SB(sb)->next_id++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tHFS_I(inode)->fs_blocks = 0;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_size = 2;\n\t\tHFS_SB(sb)->folder_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_dirs++;\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tinode->i_mode |= S_IRWXUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_dir_umask;\n\t} else if (S_ISREG(mode)) {\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n\t\tHFS_SB(sb)->file_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_files++;\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tinode->i_mode |= S_IRUGO|S_IXUGO;\n\t\tif (mode & S_IWUSR)\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_file_umask;\n\t\tHFS_I(inode)->phys_size = 0;\n\t\tHFS_I(inode)->alloc_blocks = 0;\n\t\tHFS_I(inode)->first_blocks = 0;\n\t\tHFS_I(inode)->cached_start = 0;\n\t\tHFS_I(inode)->cached_blocks = 0;\n\t\tmemset(HFS_I(inode)->first_extents, 0, sizeof(hfs_extent_rec));\n\t\tmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\n\t}\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations hfs_file_operations;",
            "static const struct inode_operations hfs_file_inode_operations;",
            "const struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};",
            "static const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};",
            "static const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstatic const struct file_operations hfs_file_operations;\nstatic const struct inode_operations hfs_file_inode_operations;\nconst struct address_space_operations hfs_aops = {\n\t.readpage\t= hfs_readpage,\n\t.writepage\t= hfs_writepage,\n\t.write_begin\t= hfs_write_begin,\n\t.write_end\t= generic_write_end,\n\t.bmap\t\t= hfs_bmap,\n\t.direct_IO\t= hfs_direct_IO,\n\t.writepages\t= hfs_writepages,\n};\nstatic const struct file_operations hfs_file_operations = {\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= generic_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= generic_file_write_iter,\n\t.mmap\t\t= generic_file_mmap,\n\t.splice_read\t= generic_file_splice_read,\n\t.fsync\t\t= hfs_file_fsync,\n\t.open\t\t= hfs_file_open,\n\t.release\t= hfs_file_release,\n};\nstatic const struct inode_operations hfs_file_inode_operations = {\n\t.lookup\t\t= hfs_file_lookup,\n\t.setattr\t= hfs_inode_setattr,\n\t.setxattr\t= hfs_setxattr,\n\t.getxattr\t= hfs_getxattr,\n\t.listxattr\t= hfs_listxattr,\n};\n\nstruct inode *hfs_new_inode(struct inode *dir, struct qstr *name, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = new_inode(sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tmutex_init(&HFS_I(inode)->extents_lock);\n\tINIT_LIST_HEAD(&HFS_I(inode)->open_dir_list);\n\thfs_cat_build_key(sb, (btree_key *)&HFS_I(inode)->cat_key, dir->i_ino, name);\n\tinode->i_ino = HFS_SB(sb)->next_id++;\n\tinode->i_mode = mode;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tset_nlink(inode, 1);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tHFS_I(inode)->flags = 0;\n\tHFS_I(inode)->rsrc_inode = NULL;\n\tHFS_I(inode)->fs_blocks = 0;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_size = 2;\n\t\tHFS_SB(sb)->folder_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_dirs++;\n\t\tinode->i_op = &hfs_dir_inode_operations;\n\t\tinode->i_fop = &hfs_dir_operations;\n\t\tinode->i_mode |= S_IRWXUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_dir_umask;\n\t} else if (S_ISREG(mode)) {\n\t\tHFS_I(inode)->clump_blocks = HFS_SB(sb)->clumpablks;\n\t\tHFS_SB(sb)->file_count++;\n\t\tif (dir->i_ino == HFS_ROOT_CNID)\n\t\t\tHFS_SB(sb)->root_files++;\n\t\tinode->i_op = &hfs_file_inode_operations;\n\t\tinode->i_fop = &hfs_file_operations;\n\t\tinode->i_mapping->a_ops = &hfs_aops;\n\t\tinode->i_mode |= S_IRUGO|S_IXUGO;\n\t\tif (mode & S_IWUSR)\n\t\t\tinode->i_mode |= S_IWUGO;\n\t\tinode->i_mode &= ~HFS_SB(inode->i_sb)->s_file_umask;\n\t\tHFS_I(inode)->phys_size = 0;\n\t\tHFS_I(inode)->alloc_blocks = 0;\n\t\tHFS_I(inode)->first_blocks = 0;\n\t\tHFS_I(inode)->cached_start = 0;\n\t\tHFS_I(inode)->cached_blocks = 0;\n\t\tmemset(HFS_I(inode)->first_extents, 0, sizeof(hfs_extent_rec));\n\t\tmemset(HFS_I(inode)->cached_extents, 0, sizeof(hfs_extent_rec));\n\t}\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\tset_bit(HFS_FLG_MDB_DIRTY, &HFS_SB(sb)->flags);\n\thfs_mark_mdb_dirty(sb);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\tstruct inode *inode;\n\tint res;\n\n\tinode = hfs_new_inode(dir, &dentry->d_name, mode);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tres = hfs_cat_create(inode->i_ino, dir, &dentry->d_name, inode);\n\tif (res) {\n\t\tclear_nlink(inode);\n\t\thfs_delete_inode(inode);\n\t\tiput(inode);\n\t\treturn res;\n\t}\n\td_instantiate(dentry, inode);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_dir_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/dir.c",
    "lines": "172-182",
    "snippet": "static int hfs_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct hfs_readdir_data *rd = file->private_data;\n\tif (rd) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tlist_del(&rd->list);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tkfree(rd);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rd"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rd->list"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_dir_release(struct inode *inode, struct file *file)\n{\n\tstruct hfs_readdir_data *rd = file->private_data;\n\tif (rd) {\n\t\tmutex_lock(&inode->i_mutex);\n\t\tlist_del(&rd->list);\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tkfree(rd);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/dir.c",
    "lines": "54-170",
    "snippet": "static int hfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFS_MAX_NAMELEN];\n\tunion hfs_cat_rec entry;\n\tstruct hfs_find_data fd;\n\tstruct hfs_readdir_data *rd;\n\tu16 type;\n\n\tif (ctx->pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfs_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tif (ctx->pos == 0) {\n\t\t/* This is completely artificial... */\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto out;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);\n\t\tif (entry.type != HFS_CDR_THD) {\n\t\t\tpr_err(\"bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\t//if (fd.entrylength < HFS_MIN_THREAD_SZ) {\n\t\t//\tpr_err(\"truncated catalog thread\\n\");\n\t\t//\terr = -EIO;\n\t\t//\tgoto out;\n\t\t//}\n\t\tif (!dir_emit(ctx, \"..\", 2,\n\t\t\t    be32_to_cpu(entry.thread.ParID), DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos = 2;\n\t}\n\tif (ctx->pos >= inode->i_size)\n\t\tgoto out;\n\terr = hfs_brec_goto(&fd, ctx->pos - 1);\n\tif (err)\n\t\tgoto out;\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.ParID) != inode->i_ino) {\n\t\t\tpr_err(\"walked past end of dir\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);\n\t\ttype = entry.type;\n\t\tlen = hfs_mac2asc(sb, strbuf, &fd.key->cat.CName);\n\t\tif (type == HFS_CDR_DIR) {\n\t\t\tif (fd.entrylength < sizeof(struct hfs_cat_dir)) {\n\t\t\t\tpr_err(\"small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.dir.DirID), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFS_CDR_FIL) {\n\t\t\tif (fd.entrylength < sizeof(struct hfs_cat_file)) {\n\t\t\t\tpr_err(\"small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.file.FlNum), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_err(\"bad catalog entry type %d\\n\", type);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos++;\n\t\tif (ctx->pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = file->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfs_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfile->private_data = rd;\n\t\trd->file = file;\n\t\tlist_add(&rd->list, &HFS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, &fd.key, sizeof(struct hfs_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&rd->key",
            "&fd.key",
            "sizeof(struct hfs_cat_key)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&rd->list",
            "&HFS_I(inode)->open_dir_list"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_I",
          "args": [
            "inode"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct hfs_readdir_data)",
            "GFP_KERNEL"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_goto",
          "args": [
            "&fd",
            "1"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_goto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "161-224",
          "snippet": "int hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_goto(struct hfs_find_data *fd, int cnt)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tint idx, res = 0;\n\tu16 off, len, keylen;\n\n\tbnode = fd->bnode;\n\ttree = bnode->tree;\n\n\tif (cnt < 0) {\n\t\tcnt = -cnt;\n\t\twhile (cnt > fd->record) {\n\t\t\tcnt -= fd->record + 1;\n\t\t\tfd->record = bnode->num_recs - 1;\n\t\t\tidx = bnode->prev;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record -= cnt;\n\t} else {\n\t\twhile (cnt >= bnode->num_recs - fd->record) {\n\t\t\tcnt -= bnode->num_recs - fd->record;\n\t\t\tfd->record = 0;\n\t\t\tidx = bnode->next;\n\t\t\tif (!idx) {\n\t\t\t\tres = -ENOENT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\thfs_bnode_put(bnode);\n\t\t\tbnode = hfs_bnode_find(tree, idx);\n\t\t\tif (IS_ERR(bnode)) {\n\t\t\t\tres = PTR_ERR(bnode);\n\t\t\t\tbnode = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tfd->record += cnt;\n\t}\n\n\tlen = hfs_brec_lenoff(bnode, fd->record, &off);\n\tkeylen = hfs_brec_keylen(bnode, fd->record);\n\tif (keylen == 0) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\thfs_bnode_read(bnode, fd->key, off, keylen);\nout:\n\tfd->bnode = bnode;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad catalog entry type %d\\n\"",
            "type"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "strbuf",
            "len",
            "be32_to_cpu(entry.file.FlNum)",
            "DT_REG"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.file.FlNum"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"small file entry\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "strbuf",
            "len",
            "be32_to_cpu(entry.dir.DirID)",
            "DT_DIR"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.dir.DirID"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"small dir entry\\n\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_mac2asc",
          "args": [
            "sb",
            "strbuf",
            "&fd.key->cat.CName"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_mac2asc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/trans.c",
          "lines": "33-83",
          "snippet": "int hfs_mac2asc(struct super_block *sb, char *out, const struct hfs_name *in)\n{\n\tstruct nls_table *nls_disk = HFS_SB(sb)->nls_disk;\n\tstruct nls_table *nls_io = HFS_SB(sb)->nls_io;\n\tconst char *src;\n\tchar *dst;\n\tint srclen, dstlen, size;\n\n\tsrc = in->name;\n\tsrclen = in->len;\n\tif (srclen > HFS_NAMELEN)\n\t\tsrclen = HFS_NAMELEN;\n\tdst = out;\n\tdstlen = HFS_MAX_NAMELEN;\n\tif (nls_io) {\n\t\twchar_t ch;\n\n\t\twhile (srclen > 0) {\n\t\t\tif (nls_disk) {\n\t\t\t\tsize = nls_disk->char2uni(src, srclen, &ch);\n\t\t\t\tif (size <= 0) {\n\t\t\t\t\tch = '?';\n\t\t\t\t\tsize = 1;\n\t\t\t\t}\n\t\t\t\tsrc += size;\n\t\t\t\tsrclen -= size;\n\t\t\t} else {\n\t\t\t\tch = *src++;\n\t\t\t\tsrclen--;\n\t\t\t}\n\t\t\tif (ch == '/')\n\t\t\t\tch = ':';\n\t\t\tsize = nls_io->uni2char(ch, dst, dstlen);\n\t\t\tif (size < 0) {\n\t\t\t\tif (size == -ENAMETOOLONG)\n\t\t\t\t\tgoto out;\n\t\t\t\t*dst = '?';\n\t\t\t\tsize = 1;\n\t\t\t}\n\t\t\tdst += size;\n\t\t\tdstlen -= size;\n\t\t}\n\t} else {\n\t\tchar ch;\n\n\t\twhile (--srclen >= 0)\n\t\t\t*dst++ = (ch = *src++) == '/' ? ':' : ch;\n\t}\nout:\n\treturn dst - out;\n}",
          "includes": [
            "#include \"hfs_fs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfs_fs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint hfs_mac2asc(struct super_block *sb, char *out, const struct hfs_name *in)\n{\n\tstruct nls_table *nls_disk = HFS_SB(sb)->nls_disk;\n\tstruct nls_table *nls_io = HFS_SB(sb)->nls_io;\n\tconst char *src;\n\tchar *dst;\n\tint srclen, dstlen, size;\n\n\tsrc = in->name;\n\tsrclen = in->len;\n\tif (srclen > HFS_NAMELEN)\n\t\tsrclen = HFS_NAMELEN;\n\tdst = out;\n\tdstlen = HFS_MAX_NAMELEN;\n\tif (nls_io) {\n\t\twchar_t ch;\n\n\t\twhile (srclen > 0) {\n\t\t\tif (nls_disk) {\n\t\t\t\tsize = nls_disk->char2uni(src, srclen, &ch);\n\t\t\t\tif (size <= 0) {\n\t\t\t\t\tch = '?';\n\t\t\t\t\tsize = 1;\n\t\t\t\t}\n\t\t\t\tsrc += size;\n\t\t\t\tsrclen -= size;\n\t\t\t} else {\n\t\t\t\tch = *src++;\n\t\t\t\tsrclen--;\n\t\t\t}\n\t\t\tif (ch == '/')\n\t\t\t\tch = ':';\n\t\t\tsize = nls_io->uni2char(ch, dst, dstlen);\n\t\t\tif (size < 0) {\n\t\t\t\tif (size == -ENAMETOOLONG)\n\t\t\t\t\tgoto out;\n\t\t\t\t*dst = '?';\n\t\t\t\tsize = 1;\n\t\t\t}\n\t\t\tdst += size;\n\t\t\tdstlen -= size;\n\t\t}\n\t} else {\n\t\tchar ch;\n\n\t\twhile (--srclen >= 0)\n\t\t\t*dst++ = (ch = *src++) == '/' ? ':' : ch;\n\t}\nout:\n\treturn dst - out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd.bnode",
            "&entry",
            "fd.entryoffset",
            "fd.entrylength"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bnode.c",
          "lines": "17-27",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf,\n\t\tint off, int len)\n{\n\tstruct page *page;\n\n\toff += node->page_offset;\n\tpage = node->page[0];\n\n\tmemcpy(buf, kmap(page) + off, len);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"walked past end of dir\\n\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fd.key->cat.ParID"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"..\"",
            "2",
            "be32_to_cpu(entry.thread.ParID)",
            "DT_DIR"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "entry.thread.ParID"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad catalog folder thread\\n\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dot",
          "args": [
            "file",
            "ctx"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "&fd"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "94-146",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t       height, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_key",
          "args": [
            "sb",
            "fd.search_key",
            "inode->i_ino",
            "NULL"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "23-34",
          "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(sb)->cat_tree",
            "&fd"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "sb"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic int hfs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint len, err;\n\tchar strbuf[HFS_MAX_NAMELEN];\n\tunion hfs_cat_rec entry;\n\tstruct hfs_find_data fd;\n\tstruct hfs_readdir_data *rd;\n\tu16 type;\n\n\tif (ctx->pos >= inode->i_size)\n\t\treturn 0;\n\n\terr = hfs_find_init(HFS_SB(sb)->cat_tree, &fd);\n\tif (err)\n\t\treturn err;\n\thfs_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);\n\terr = hfs_brec_find(&fd);\n\tif (err)\n\t\tgoto out;\n\n\tif (ctx->pos == 0) {\n\t\t/* This is completely artificial... */\n\t\tif (!dir_emit_dot(file, ctx))\n\t\t\tgoto out;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);\n\t\tif (entry.type != HFS_CDR_THD) {\n\t\t\tpr_err(\"bad catalog folder thread\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\t//if (fd.entrylength < HFS_MIN_THREAD_SZ) {\n\t\t//\tpr_err(\"truncated catalog thread\\n\");\n\t\t//\terr = -EIO;\n\t\t//\tgoto out;\n\t\t//}\n\t\tif (!dir_emit(ctx, \"..\", 2,\n\t\t\t    be32_to_cpu(entry.thread.ParID), DT_DIR))\n\t\t\tgoto out;\n\t\tctx->pos = 2;\n\t}\n\tif (ctx->pos >= inode->i_size)\n\t\tgoto out;\n\terr = hfs_brec_goto(&fd, ctx->pos - 1);\n\tif (err)\n\t\tgoto out;\n\n\tfor (;;) {\n\t\tif (be32_to_cpu(fd.key->cat.ParID) != inode->i_ino) {\n\t\t\tpr_err(\"walked past end of dir\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset, fd.entrylength);\n\t\ttype = entry.type;\n\t\tlen = hfs_mac2asc(sb, strbuf, &fd.key->cat.CName);\n\t\tif (type == HFS_CDR_DIR) {\n\t\t\tif (fd.entrylength < sizeof(struct hfs_cat_dir)) {\n\t\t\t\tpr_err(\"small dir entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.dir.DirID), DT_DIR))\n\t\t\t\tbreak;\n\t\t} else if (type == HFS_CDR_FIL) {\n\t\t\tif (fd.entrylength < sizeof(struct hfs_cat_file)) {\n\t\t\t\tpr_err(\"small file entry\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!dir_emit(ctx, strbuf, len,\n\t\t\t\t    be32_to_cpu(entry.file.FlNum), DT_REG))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_err(\"bad catalog entry type %d\\n\", type);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tctx->pos++;\n\t\tif (ctx->pos >= inode->i_size)\n\t\t\tgoto out;\n\t\terr = hfs_brec_goto(&fd, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\trd = file->private_data;\n\tif (!rd) {\n\t\trd = kmalloc(sizeof(struct hfs_readdir_data), GFP_KERNEL);\n\t\tif (!rd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tfile->private_data = rd;\n\t\trd->file = file;\n\t\tlist_add(&rd->list, &HFS_I(inode)->open_dir_list);\n\t}\n\tmemcpy(&rd->key, &fd.key, sizeof(struct hfs_cat_key));\nout:\n\thfs_find_exit(&fd);\n\treturn err;\n}"
  },
  {
    "function_name": "hfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/dir.c",
    "lines": "20-49",
    "snippet": "static struct dentry *hfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\thfs_cat_rec rec;\n\tstruct hfs_find_data fd;\n\tstruct inode *inode = NULL;\n\tint res;\n\n\tres = hfs_find_init(HFS_SB(dir->i_sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn ERR_PTR(res);\n\thfs_cat_build_key(dir->i_sb, fd.search_key, dir->i_ino, &dentry->d_name);\n\tres = hfs_brec_read(&fd, &rec, sizeof(rec));\n\tif (res) {\n\t\thfs_find_exit(&fd);\n\t\tif (res == -ENOENT) {\n\t\t\t/* No such entry */\n\t\t\tinode = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\treturn ERR_PTR(res);\n\t}\n\tinode = hfs_iget(dir->i_sb, &fd.search_key->cat, &rec);\n\thfs_find_exit(&fd);\n\tif (!inode)\n\t\treturn ERR_PTR(-EACCES);\ndone:\n\td_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"btree.h\"",
      "#include \"hfs_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "31-39",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_iget",
          "args": [
            "dir->i_sb",
            "&fd.search_key->cat",
            "&rec"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/inode.c",
          "lines": "381-401",
          "snippet": "struct inode *hfs_iget(struct super_block *sb, struct hfs_cat_key *key, hfs_cat_rec *rec)\n{\n\tstruct hfs_iget_data data = { key, rec };\n\tstruct inode *inode;\n\tu32 cnid;\n\n\tswitch (rec->type) {\n\tcase HFS_CDR_DIR:\n\t\tcnid = be32_to_cpu(rec->dir.DirID);\n\t\tbreak;\n\tcase HFS_CDR_FIL:\n\t\tcnid = be32_to_cpu(rec->file.FlNum);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\tinode = iget5_locked(sb, cnid, hfs_test_inode, hfs_read_inode, &data);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\"",
            "#include <linux/aio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n#include <linux/aio.h>\n#include <linux/sched.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n\nstruct inode *hfs_iget(struct super_block *sb, struct hfs_cat_key *key, hfs_cat_rec *rec)\n{\n\tstruct hfs_iget_data data = { key, rec };\n\tstruct inode *inode;\n\tu32 cnid;\n\n\tswitch (rec->type) {\n\tcase HFS_CDR_DIR:\n\t\tcnid = be32_to_cpu(rec->dir.DirID);\n\t\tbreak;\n\tcase HFS_CDR_FIL:\n\t\tcnid = be32_to_cpu(rec->file.FlNum);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\tinode = iget5_locked(sb, cnid, hfs_test_inode, hfs_read_inode, &data);\n\tif (inode && (inode->i_state & I_NEW))\n\t\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "res"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_brec_read",
          "args": [
            "&fd",
            "&rec",
            "sizeof(rec)"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "148-159",
          "snippet": "int hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_brec_read(struct hfs_find_data *fd, void *rec, int rec_len)\n{\n\tint res;\n\n\tres = hfs_brec_find(fd);\n\tif (res)\n\t\treturn res;\n\tif (fd->entrylength > rec_len)\n\t\treturn -EINVAL;\n\thfs_bnode_read(fd->bnode, rec, fd->entryoffset, fd->entrylength);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_cat_build_key",
          "args": [
            "dir->i_sb",
            "fd.search_key",
            "dir->i_ino",
            "&dentry->d_name"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_cat_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/catalog.c",
          "lines": "23-34",
          "snippet": "void hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include \"hfs_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nvoid hfs_cat_build_key(struct super_block *sb, btree_key *key, u32 parent, struct qstr *name)\n{\n\tkey->cat.reserved = 0;\n\tkey->cat.ParID = cpu_to_be32(parent);\n\tif (name) {\n\t\thfs_asc2mac(sb, &key->cat.CName, name);\n\t\tkey->key_len = 6 + key->cat.CName.len;\n\t} else {\n\t\tmemset(&key->cat.CName, 0, sizeof(struct hfs_name));\n\t\tkey->key_len = 6;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "res"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFS_SB(dir->i_sb)->cat_tree",
            "&fd"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfs/bfind.c",
          "lines": "14-29",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"btree.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"btree.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tmutex_lock(&tree->tree_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"btree.h\"\n#include \"hfs_fs.h\"\n\nstatic struct dentry *hfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\thfs_cat_rec rec;\n\tstruct hfs_find_data fd;\n\tstruct inode *inode = NULL;\n\tint res;\n\n\tres = hfs_find_init(HFS_SB(dir->i_sb)->cat_tree, &fd);\n\tif (res)\n\t\treturn ERR_PTR(res);\n\thfs_cat_build_key(dir->i_sb, fd.search_key, dir->i_ino, &dentry->d_name);\n\tres = hfs_brec_read(&fd, &rec, sizeof(rec));\n\tif (res) {\n\t\thfs_find_exit(&fd);\n\t\tif (res == -ENOENT) {\n\t\t\t/* No such entry */\n\t\t\tinode = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\treturn ERR_PTR(res);\n\t}\n\tinode = hfs_iget(dir->i_sb, &fd.search_key->cat, &rec);\n\thfs_find_exit(&fd);\n\tif (!inode)\n\t\treturn ERR_PTR(-EACCES);\ndone:\n\td_add(dentry, inode);\n\treturn NULL;\n}"
  }
]