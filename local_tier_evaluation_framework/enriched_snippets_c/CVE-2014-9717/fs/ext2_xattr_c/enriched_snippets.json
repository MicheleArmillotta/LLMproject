[
  {
    "function_name": "exit_ext2_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "1025-1029",
    "snippet": "void\nexit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mb_cache *ext2_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_destroy",
          "args": [
            "ext2_xattr_cache"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "451-491",
          "snippet": "void\nmb_cache_destroy(struct mb_cache *cache)\n{\n\tLIST_HEAD(free_list);\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_for_each_entry_safe(ce, tmp, &mb_cache_lru_list, e_lru_list) {\n\t\tif (ce->e_cache == cache)\n\t\t\tlist_move_tail(&ce->e_lru_list, &free_list);\n\t}\n\tlist_del(&cache->c_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\tlist_del_init(&ce->e_lru_list);\n\t\t/*\n\t\t * Prevent any find or get operation on the entry.\n\t\t */\n\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n\n\tif (atomic_read(&cache->c_entry_count) > 0) {\n\t\tmb_error(\"cache %s: %d orphaned entries\",\n\t\t\t  cache->c_name,\n\t\t\t  atomic_read(&cache->c_entry_count));\n\t}\n\n\tif (list_empty(&mb_cache_list)) {\n\t\tkmem_cache_destroy(mb_cache_kmem_cache);\n\t\tmb_cache_kmem_cache = NULL;\n\t}\n\tkfree(cache->c_index_hash);\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mb_cache_kmem_cache;",
            "static LIST_HEAD(mb_cache_list);",
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *mb_cache_kmem_cache;\nstatic LIST_HEAD(mb_cache_list);\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nvoid\nmb_cache_destroy(struct mb_cache *cache)\n{\n\tLIST_HEAD(free_list);\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_for_each_entry_safe(ce, tmp, &mb_cache_lru_list, e_lru_list) {\n\t\tif (ce->e_cache == cache)\n\t\t\tlist_move_tail(&ce->e_lru_list, &free_list);\n\t}\n\tlist_del(&cache->c_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\tlist_del_init(&ce->e_lru_list);\n\t\t/*\n\t\t * Prevent any find or get operation on the entry.\n\t\t */\n\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n\n\tif (atomic_read(&cache->c_entry_count) > 0) {\n\t\tmb_error(\"cache %s: %d orphaned entries\",\n\t\t\t  cache->c_name,\n\t\t\t  atomic_read(&cache->c_entry_count));\n\t}\n\n\tif (list_empty(&mb_cache_list)) {\n\t\tkmem_cache_destroy(mb_cache_kmem_cache);\n\t\tmb_cache_kmem_cache = NULL;\n\t}\n\tkfree(cache->c_index_hash);\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic struct mb_cache *ext2_xattr_cache;\n\nvoid\nexit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}"
  },
  {
    "function_name": "init_ext2_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "1016-1023",
    "snippet": "int __init\ninit_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mb_cache *ext2_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_create",
          "args": [
            "\"ext2_xattr\"",
            "6"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "324-383",
          "snippet": "struct mb_cache *\nmb_cache_create(const char *name, int bucket_bits)\n{\n\tint n, bucket_count = 1 << bucket_bits;\n\tstruct mb_cache *cache = NULL;\n\n\tif (!mb_cache_bg_lock) {\n\t\tmb_cache_bg_lock = kmalloc(sizeof(struct blockgroup_lock),\n\t\t\tGFP_KERNEL);\n\t\tif (!mb_cache_bg_lock)\n\t\t\treturn NULL;\n\t\tbgl_lock_init(mb_cache_bg_lock);\n\t}\n\n\tcache = kmalloc(sizeof(struct mb_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->c_name = name;\n\tatomic_set(&cache->c_entry_count, 0);\n\tcache->c_bucket_bits = bucket_bits;\n\tcache->c_block_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_block_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_block_hash[n]);\n\tcache->c_index_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_index_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_index_hash[n]);\n\tif (!mb_cache_kmem_cache) {\n\t\tmb_cache_kmem_cache = kmem_cache_create(name,\n\t\t\tsizeof(struct mb_cache_entry), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\t\tif (!mb_cache_kmem_cache)\n\t\t\tgoto fail2;\n\t}\n\tcache->c_entry_cache = mb_cache_kmem_cache;\n\n\t/*\n\t * Set an upper limit on the number of cache entries so that the hash\n\t * chains won't grow too long.\n\t */\n\tcache->c_max_entries = bucket_count << 4;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_add(&cache->c_cache_list, &mb_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\treturn cache;\n\nfail2:\n\tkfree(cache->c_index_hash);\n\nfail:\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;",
            "static struct kmem_cache *mb_cache_kmem_cache;",
            "static LIST_HEAD(mb_cache_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\nstatic struct kmem_cache *mb_cache_kmem_cache;\nstatic LIST_HEAD(mb_cache_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache *\nmb_cache_create(const char *name, int bucket_bits)\n{\n\tint n, bucket_count = 1 << bucket_bits;\n\tstruct mb_cache *cache = NULL;\n\n\tif (!mb_cache_bg_lock) {\n\t\tmb_cache_bg_lock = kmalloc(sizeof(struct blockgroup_lock),\n\t\t\tGFP_KERNEL);\n\t\tif (!mb_cache_bg_lock)\n\t\t\treturn NULL;\n\t\tbgl_lock_init(mb_cache_bg_lock);\n\t}\n\n\tcache = kmalloc(sizeof(struct mb_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->c_name = name;\n\tatomic_set(&cache->c_entry_count, 0);\n\tcache->c_bucket_bits = bucket_bits;\n\tcache->c_block_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_block_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_block_hash[n]);\n\tcache->c_index_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_index_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_index_hash[n]);\n\tif (!mb_cache_kmem_cache) {\n\t\tmb_cache_kmem_cache = kmem_cache_create(name,\n\t\t\tsizeof(struct mb_cache_entry), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\t\tif (!mb_cache_kmem_cache)\n\t\t\tgoto fail2;\n\t}\n\tcache->c_entry_cache = mb_cache_kmem_cache;\n\n\t/*\n\t * Set an upper limit on the number of cache entries so that the hash\n\t * chains won't grow too long.\n\t */\n\tcache->c_max_entries = bucket_count << 4;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_add(&cache->c_cache_list, &mb_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\treturn cache;\n\nfail2:\n\tkfree(cache->c_index_hash);\n\nfail:\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic struct mb_cache *ext2_xattr_cache;\n\nint __init\ninit_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_xattr_rehash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "992-1012",
    "snippet": "static void ext2_xattr_rehash(struct ext2_xattr_header *header,\n\t\t\t      struct ext2_xattr_entry *entry)\n{\n\tstruct ext2_xattr_entry *here;\n\t__u32 hash = 0;\n\t\n\text2_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT2_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [
      "#define BLOCK_HASH_SHIFT 16"
    ],
    "globals_used": [
      "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
      "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
      "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hash"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "here"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "here->e_hash"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "here"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header+1"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_xattr_hash_entry",
          "args": [
            "header",
            "entry"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "956-980",
          "snippet": "static inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,\n\t\t\t\t\t struct ext2_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [
            "#define VALUE_HASH_SHIFT 16",
            "#define NAME_HASH_SHIFT 5"
          ],
          "globals_used": [
            "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
            "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
            "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\n#define VALUE_HASH_SHIFT 16\n#define NAME_HASH_SHIFT 5\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,\n\t\t\t\t\t struct ext2_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\n#define BLOCK_HASH_SHIFT 16\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *header,\n\t\t\t      struct ext2_xattr_entry *entry)\n{\n\tstruct ext2_xattr_entry *here;\n\t__u32 hash = 0;\n\t\n\text2_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT2_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}"
  },
  {
    "function_name": "ext2_xattr_hash_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "956-980",
    "snippet": "static inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,\n\t\t\t\t\t struct ext2_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [
      "#define VALUE_HASH_SHIFT 16",
      "#define NAME_HASH_SHIFT 5"
    ],
    "globals_used": [
      "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
      "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
      "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hash"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*value++"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\n#define VALUE_HASH_SHIFT 16\n#define NAME_HASH_SHIFT 5\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic inline void ext2_xattr_hash_entry(struct ext2_xattr_header *header,\n\t\t\t\t\t struct ext2_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n=0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT2_XATTR_ROUND) >> EXT2_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}"
  },
  {
    "function_name": "ext2_xattr_cache_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "900-946",
    "snippet": "static struct buffer_head *\next2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
      "static int ext2_xattr_cache_insert(struct buffer_head *);",
      "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
      "static struct mb_cache *ext2_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_entry_find_next",
          "args": [
            "ce",
            "inode->i_sb->s_bdev",
            "hash"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_find_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "823-841",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_find_next(struct mb_cache_entry *prev,\n\t\t\t struct block_device *bdev, unsigned int key)\n{\n\tstruct mb_cache *cache = prev->e_cache;\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\tmb_assert(prev->e_index_hash_p == index_hash_p);\n\thlist_bl_lock(index_hash_p);\n\tmb_assert(!hlist_bl_empty(index_hash_p));\n\tl = prev->e_index.o_list.next;\n\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t__mb_cache_entry_release(prev);\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct mb_cache_entry *\nmb_cache_entry_find_next(struct mb_cache_entry *prev,\n\t\t\t struct block_device *bdev, unsigned int key)\n{\n\tstruct mb_cache *cache = prev->e_cache;\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\tmb_assert(prev->e_index_hash_p == index_hash_p);\n\thlist_bl_lock(index_hash_p);\n\tmb_assert(!hlist_bl_empty(index_hash_p));\n\tl = prev->e_index.o_list.next;\n\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t__mb_cache_entry_release(prev);\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d\"",
            "atomic_read(&(bh->b_count))"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_xattr_cmp",
          "args": [
            "header",
            "HDR(bh)"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "860-890",
          "snippet": "static int\next2_xattr_cmp(struct ext2_xattr_header *header1,\n\t       struct ext2_xattr_header *header2)\n{\n\tstruct ext2_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT2_XATTR_NEXT(entry1);\n\t\tentry2 = EXT2_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
            "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
            "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic int\next2_xattr_cmp(struct ext2_xattr_header *header1,\n\t       struct ext2_xattr_header *header2)\n{\n\tstruct ext2_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT2_XATTR_NEXT(entry1);\n\t\tentry2 = EXT2_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HDR",
          "args": [
            "bh"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"block %ld refcount %d>%d\"",
            "(unsigned long) ce->e_block",
            "le32_to_cpu(HDR(bh)->h_refcount)",
            "EXT2_XATTR_REFCOUNT_MAX"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "HDR(bh)->h_refcount"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "inode->i_sb",
            "\"ext2_xattr_cache_find\"",
            "\"inode %ld: block %ld read error\"",
            "inode->i_ino",
            "(unsigned long) ce->e_block"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "ce->e_block"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ce"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ce"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_find_first",
          "args": [
            "ext2_xattr_cache",
            "inode->i_sb->s_bdev",
            "hash"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_find_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "785-802",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_find_first(struct mb_cache *cache, struct block_device *bdev,\n\t\t\t  unsigned int key)\n{\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce = NULL;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tif (!hlist_bl_empty(index_hash_p)) {\n\t\tl = hlist_bl_first(index_hash_p);\n\t\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t} else\n\t\thlist_bl_unlock(index_hash_p);\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct mb_cache_entry *\nmb_cache_entry_find_first(struct mb_cache *cache, struct block_device *bdev,\n\t\t\t  unsigned int key)\n{\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce = NULL;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tif (!hlist_bl_empty(index_hash_p)) {\n\t\tl = hlist_bl_first(index_hash_p);\n\t\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t} else\n\t\thlist_bl_unlock(index_hash_p);\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"looking for cached blocks [%x]\"",
            "(int)hash"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic struct buffer_head *\next2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext2_xattr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "860-890",
    "snippet": "static int\next2_xattr_cmp(struct ext2_xattr_header *header1,\n\t       struct ext2_xattr_header *header2)\n{\n\tstruct ext2_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT2_XATTR_NEXT(entry1);\n\t\tentry2 = EXT2_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
      "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
      "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry2"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "entry2"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "entry1"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "(char *)header1 + le16_to_cpu(entry1->e_value_offs)",
            "(char *)header2 + le16_to_cpu(entry2->e_value_offs)",
            "le32_to_cpu(entry1->e_value_size)"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry1->e_value_size"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry2->e_value_offs"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "entry1->e_name",
            "entry2->e_name",
            "entry1->e_name_len"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry2"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry1"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header2+1"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header1+1"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic int\next2_xattr_cmp(struct ext2_xattr_header *header1,\n\t       struct ext2_xattr_header *header2)\n{\n\tstruct ext2_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT2_XATTR_NEXT(entry1);\n\t\tentry2 = EXT2_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_xattr_cache_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "826-850",
    "snippet": "static int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_xattr_cache_insert(struct buffer_head *);",
      "static struct mb_cache *ext2_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"inserting [%x] (%d cache entries)\"",
            "(int)hash",
            "atomic_read(&ext2_xattr_cache->c_entry_count)"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ext2_xattr_cache->c_entry_count"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"already in cache (%d cache entries)\"",
            "atomic_read(&ext2_xattr_cache->c_entry_count)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ext2_xattr_cache->c_entry_count"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_insert",
          "args": [
            "ce",
            "bh->b_bdev",
            "bh->b_blocknr",
            "hash"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "578-616",
          "snippet": "int\nmb_cache_entry_insert(struct mb_cache_entry *ce, struct block_device *bdev,\n\t\t      sector_t block, unsigned int key)\n{\n\tstruct mb_cache *cache = ce->e_cache;\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct hlist_bl_head *block_hash_p;\n\tstruct hlist_bl_head *index_hash_p;\n\tstruct mb_cache_entry *lce;\n\n\tmb_assert(ce);\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff), \n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(lce, l, block_hash_p, e_block_list) {\n\t\tif (lce->e_bdev == bdev && lce->e_block == block) {\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tmb_assert(!__mb_cache_entry_is_block_hashed(ce));\n\t__mb_cache_entry_unhash_block(ce);\n\t__mb_cache_entry_unhash_index(ce);\n\tce->e_bdev = bdev;\n\tce->e_block = block;\n\tce->e_block_hash_p = block_hash_p;\n\tce->e_index.o_key = key;\n\thlist_bl_add_head(&ce->e_block_list, block_hash_p);\n\thlist_bl_unlock(block_hash_p);\n\tbucket = hash_long(key, cache->c_bucket_bits);\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tce->e_index_hash_p = index_hash_p;\n\thlist_bl_add_head(&ce->e_index.o_list, index_hash_p);\n\thlist_bl_unlock(index_hash_p);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint\nmb_cache_entry_insert(struct mb_cache_entry *ce, struct block_device *bdev,\n\t\t      sector_t block, unsigned int key)\n{\n\tstruct mb_cache *cache = ce->e_cache;\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct hlist_bl_head *block_hash_p;\n\tstruct hlist_bl_head *index_hash_p;\n\tstruct mb_cache_entry *lce;\n\n\tmb_assert(ce);\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff), \n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(lce, l, block_hash_p, e_block_list) {\n\t\tif (lce->e_bdev == bdev && lce->e_block == block) {\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tmb_assert(!__mb_cache_entry_is_block_hashed(ce));\n\t__mb_cache_entry_unhash_block(ce);\n\t__mb_cache_entry_unhash_index(ce);\n\tce->e_bdev = bdev;\n\tce->e_block = block;\n\tce->e_block_hash_p = block_hash_p;\n\tce->e_index.o_key = key;\n\thlist_bl_add_head(&ce->e_block_list, block_hash_p);\n\thlist_bl_unlock(block_hash_p);\n\tbucket = hash_long(key, cache->c_bucket_bits);\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tce->e_index_hash_p = index_hash_p;\n\thlist_bl_add_head(&ce->e_index.o_list, index_hash_p);\n\thlist_bl_unlock(index_hash_p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_alloc",
          "args": [
            "ext2_xattr_cache",
            "GFP_NOFS"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "501-561",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_alloc(struct mb_cache *cache, gfp_t gfp_flags)\n{\n\tstruct mb_cache_entry *ce;\n\n\tif (atomic_read(&cache->c_entry_count) >= cache->c_max_entries) {\n\t\tstruct list_head *l;\n\n\t\tl = &mb_cache_lru_list;\n\t\tspin_lock(&mb_cache_spinlock);\n\t\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\t\tl = l->next;\n\t\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\t\tif (ce->e_cache == cache) {\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t\t/*\n\t\t\t\t * Prevent any find or get operation on the\n\t\t\t\t * entry.\n\t\t\t\t */\n\t\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmb_assert(list_empty(&ce->e_lru_list));\n\t\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&mb_cache_spinlock);\n\t}\n\n\tce = kmem_cache_alloc(cache->c_entry_cache, gfp_flags);\n\tif (!ce)\n\t\treturn NULL;\n\tatomic_inc(&cache->c_entry_count);\n\tINIT_LIST_HEAD(&ce->e_lru_list);\n\tINIT_HLIST_BL_NODE(&ce->e_block_list);\n\tINIT_HLIST_BL_NODE(&ce->e_index.o_list);\n\tce->e_cache = cache;\n\tce->e_queued = 0;\n\tatomic_set(&ce->e_refcnt, 0);\nfound:\n\tce->e_block_hash_p = &cache->c_block_hash[0];\n\tce->e_index_hash_p = &cache->c_index_hash[0];\n\tce->e_used = 1 + MB_CACHE_WRITER;\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_alloc(struct mb_cache *cache, gfp_t gfp_flags)\n{\n\tstruct mb_cache_entry *ce;\n\n\tif (atomic_read(&cache->c_entry_count) >= cache->c_max_entries) {\n\t\tstruct list_head *l;\n\n\t\tl = &mb_cache_lru_list;\n\t\tspin_lock(&mb_cache_spinlock);\n\t\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\t\tl = l->next;\n\t\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\t\tif (ce->e_cache == cache) {\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t\t/*\n\t\t\t\t * Prevent any find or get operation on the\n\t\t\t\t * entry.\n\t\t\t\t */\n\t\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmb_assert(list_empty(&ce->e_lru_list));\n\t\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&mb_cache_spinlock);\n\t}\n\n\tce = kmem_cache_alloc(cache->c_entry_cache, gfp_flags);\n\tif (!ce)\n\t\treturn NULL;\n\tatomic_inc(&cache->c_entry_count);\n\tINIT_LIST_HEAD(&ce->e_lru_list);\n\tINIT_HLIST_BL_NODE(&ce->e_block_list);\n\tINIT_HLIST_BL_NODE(&ce->e_index.o_list);\n\tce->e_cache = cache;\n\tce->e_queued = 0;\n\tatomic_set(&ce->e_refcnt, 0);\nfound:\n\tce->e_block_hash_p = &cache->c_block_hash[0];\n\tce->e_index_hash_p = &cache->c_index_hash[0];\n\tce->e_used = 1 + MB_CACHE_WRITER;\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "HDR(bh)->h_hash"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HDR",
          "args": [
            "bh"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ext2_xattr_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "811-815",
    "snippet": "void\next2_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_shrink",
          "args": [
            "sb->s_bdev"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "395-441",
          "snippet": "void\nmb_cache_shrink(struct block_device *bdev)\n{\n\tLIST_HEAD(free_list);\n\tstruct list_head *l;\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tl = &mb_cache_lru_list;\n\tspin_lock(&mb_cache_spinlock);\n\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\tl = l->next;\n\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\tif (ce->e_bdev == bdev) {\n\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t/*\n\t\t\t * Prevent any find or get operation on the entry.\n\t\t\t */\n\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\tlist_add_tail(&ce->e_lru_list, &free_list);\n\t\t\tl = &mb_cache_lru_list;\n\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t}\n\t}\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nvoid\nmb_cache_shrink(struct block_device *bdev)\n{\n\tLIST_HEAD(free_list);\n\tstruct list_head *l;\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tl = &mb_cache_lru_list;\n\tspin_lock(&mb_cache_spinlock);\n\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\tl = l->next;\n\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\tif (ce->e_bdev == bdev) {\n\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t/*\n\t\t\t * Prevent any find or get operation on the entry.\n\t\t\t */\n\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\tlist_add_tail(&ce->e_lru_list, &free_list);\n\t\t\tl = &mb_cache_lru_list;\n\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t}\n\t}\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nvoid\next2_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}"
  },
  {
    "function_name": "ext2_xattr_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "754-804",
    "snippet": "void\next2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_xattr_cache_insert(struct buffer_head *);",
      "static struct mb_cache *ext2_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT2_I(inode)->xattr_sem"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "inode",
            "1"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"refcount now=%d\"",
            "le32_to_cpu(HDR(bh)->h_refcount)"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "HDR(bh)->h_refcount"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HDR",
          "args": [
            "bh"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&HDR(bh)->h_refcount",
            "-1"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "bh"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_free_blocks",
          "args": [
            "inode",
            "EXT2_I(inode)->i_file_acl",
            "1"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "476-567",
          "snippet": "void ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_get",
          "args": [
            "ext2_xattr_cache",
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "660-714",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "inode->i_sb",
            "\"ext2_xattr_delete_inode\"",
            "\"inode %ld: bad block %d\"",
            "inode->i_ino",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_XATTR_MAGIC"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d\"",
            "atomic_read(&(bh->b_count))"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT2_I(inode)->xattr_sem"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nvoid\next2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}"
  },
  {
    "function_name": "ext2_xattr_set2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "620-746",
    "snippet": "static int\next2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n\t\tstruct ext2_xattr_header *header)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tint error;\n\n\tif (header) {\n\t\tnew_bh = ext2_xattr_cache_find(inode, header);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == old_bh) {\n\t\t\t\tea_bdebug(new_bh, \"keeping this block\");\n\t\t\t} else {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode.  */\n\t\t\t\tea_bdebug(new_bh, \"reusing block\");\n\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error) {\n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tle32_add_cpu(&HDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(HDR(new_bh)->h_refcount));\n\t\t\t}\n\t\t\tunlock_buffer(new_bh);\n\t\t} else if (old_bh && header == HDR(old_bh)) {\n\t\t\t/* Keep this block. No need to lock the block as we\n\t\t\t   don't need to change the reference count. */\n\t\t\tnew_bh = old_bh;\n\t\t\tget_bh(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text2_fsblk_t goal = ext2_group_first_block_no(sb,\n\t\t\t\t\t\tEXT2_I(inode)->i_block_group);\n\t\t\tint block = ext2_new_block(inode, goal, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\text2_free_blocks(inode, block, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\tmemcpy(new_bh->b_data, header, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t\t\n\t\t\text2_xattr_update_super_block(sb);\n\t\t}\n\t\tmark_buffer_dirty(new_bh);\n\t\tif (IS_SYNC(inode)) {\n\t\t\tsync_dirty_buffer(new_bh);\n\t\t\terror = -EIO;\n\t\t\tif (buffer_req(new_bh) && !buffer_uptodate(new_bh))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode)) {\n\t\terror = sync_inode_metadata(inode, 1);\n\t\t/* In case sync failed due to ENOSPC the inode was actually\n\t\t * written (only some dirty data were not) so we just proceed\n\t\t * as if nothing happened and cleanup the unused block */\n\t\tif (error && error != -ENOSPC) {\n\t\t\tif (new_bh && new_bh != old_bh) {\n\t\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\terror = 0;\n\tif (old_bh && old_bh != new_bh) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/*\n\t\t * If there was an old block and we are no longer using it,\n\t\t * release the old block.\n\t\t */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, old_bh->b_bdev,\n\t\t\t\t\told_bh->b_blocknr);\n\t\tlock_buffer(old_bh);\n\t\tif (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {\n\t\t\t/* Free the old block. */\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\tea_bdebug(old_bh, \"freeing\");\n\t\t\text2_free_blocks(inode, old_bh->b_blocknr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\t/* We let our caller release old_bh, so we\n\t\t\t * need to duplicate the buffer before. */\n\t\t\tget_bh(old_bh);\n\t\t\tbforget(old_bh);\n\t\t} else {\n\t\t\t/* Decrement the refcount only. */\n\t\t\tle32_add_cpu(&HDR(old_bh)->h_refcount, -1);\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmark_buffer_dirty(old_bh);\n\t\t\tea_bdebug(old_bh, \"refcount now=%d\",\n\t\t\t\tle32_to_cpu(HDR(old_bh)->h_refcount));\n\t\t}\n\t\tunlock_buffer(old_bh);\n\t}\n\ncleanup:\n\tbrelse(new_bh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
      "static int ext2_xattr_cache_insert(struct buffer_head *);",
      "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
      "static struct mb_cache *ext2_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "old_bh"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "old_bh",
            "\"refcount now=%d\"",
            "le32_to_cpu(HDR(old_bh)->h_refcount)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "HDR(old_bh)->h_refcount"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HDR",
          "args": [
            "old_bh"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "old_bh"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "inode",
            "1"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&HDR(old_bh)->h_refcount",
            "-1"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bforget",
          "args": [
            "old_bh"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "__bforget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1191-1203",
          "snippet": "void __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __bforget(struct buffer_head *bh)\n{\n\tclear_buffer_dirty(bh);\n\tif (bh->b_assoc_map) {\n\t\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_del_init(&bh->b_assoc_buffers);\n\t\tbh->b_assoc_map = NULL;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\t__brelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "old_bh"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_free_blocks",
          "args": [
            "inode",
            "old_bh->b_blocknr",
            "1"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "476-567",
          "snippet": "void ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_free_blocks (struct inode * inode, unsigned long block,\n\t\t       unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head * bh2;\n\tunsigned long block_group;\n\tunsigned long bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct super_block * sb = inode->i_sb;\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_super_block * es = sbi->s_es;\n\tunsigned freed = 0, group_freed;\n\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = %lu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text2_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT2_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT2_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT2_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\n\tdesc = ext2_get_group_desc (sb, block_group, &bh2);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text2_error (sb, \"ext2_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = %lu, count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\tif (!ext2_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\text2_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block %lu\", block + i);\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\n\tmark_buffer_dirty(bitmap_bh);\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tsync_dirty_buffer(bitmap_bh);\n\n\tgroup_adjust_blocks(sb, block_group, desc, bh2, group_freed);\n\tfreed += group_freed;\n\n\tif (overflow) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\tif (freed) {\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\t\tdquot_free_block_nodirty(inode, freed);\n\t\tmark_inode_dirty(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "old_bh",
            "\"freeing\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_get",
          "args": [
            "ext2_xattr_cache",
            "old_bh->b_bdev",
            "old_bh->b_blocknr"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "660-714",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block_nodirty",
          "args": [
            "inode",
            "1"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_inode_metadata",
          "args": [
            "inode",
            "1"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1513-1521",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "new_bh"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "new_bh"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "new_bh"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_xattr_update_super_block",
          "args": [
            "sb"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_update_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "334-343",
          "snippet": "static void ext2_xattr_update_super_block(struct super_block *sb)\n{\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tEXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic void ext2_xattr_update_super_block(struct super_block *sb)\n{\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tEXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_xattr_cache_insert",
          "args": [
            "new_bh"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "826-850",
          "snippet": "static int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_xattr_cache_insert(struct buffer_head *);",
            "static struct mb_cache *ext2_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_bh->b_data",
            "header",
            "new_bh->b_size"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_bh"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"creating block %d\"",
            "block"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_new_block",
          "args": [
            "inode",
            "goal",
            "&error"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_new_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1430-1435",
          "snippet": "ext2_fsblk_t ext2_new_block(struct inode *inode, unsigned long goal, int *errp)\n{\n\tunsigned long count = 1;\n\n\treturn ext2_new_blocks(inode, goal, &count, errp);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\next2_fsblk_t ext2_new_block(struct inode *inode, unsigned long goal, int *errp)\n{\n\tunsigned long count = 1;\n\n\treturn ext2_new_blocks(inode, goal, &count, errp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "EXT2_I(inode)->i_block_group"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "new_bh"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "new_bh",
            "\"refcount now=%d\"",
            "le32_to_cpu(HDR(new_bh)->h_refcount)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&HDR(new_bh)->h_refcount",
            "1"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "inode",
            "1"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "new_bh",
            "\"reusing block\""
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "new_bh",
            "\"keeping this block\""
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_xattr_cache_find",
          "args": [
            "inode",
            "header"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_cache_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "900-946",
          "snippet": "static struct buffer_head *\next2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
            "static int ext2_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
            "static struct mb_cache *ext2_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic struct buffer_head *\next2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic int\next2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n\t\tstruct ext2_xattr_header *header)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tint error;\n\n\tif (header) {\n\t\tnew_bh = ext2_xattr_cache_find(inode, header);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == old_bh) {\n\t\t\t\tea_bdebug(new_bh, \"keeping this block\");\n\t\t\t} else {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode.  */\n\t\t\t\tea_bdebug(new_bh, \"reusing block\");\n\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error) {\n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tle32_add_cpu(&HDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(HDR(new_bh)->h_refcount));\n\t\t\t}\n\t\t\tunlock_buffer(new_bh);\n\t\t} else if (old_bh && header == HDR(old_bh)) {\n\t\t\t/* Keep this block. No need to lock the block as we\n\t\t\t   don't need to change the reference count. */\n\t\t\tnew_bh = old_bh;\n\t\t\tget_bh(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text2_fsblk_t goal = ext2_group_first_block_no(sb,\n\t\t\t\t\t\tEXT2_I(inode)->i_block_group);\n\t\t\tint block = ext2_new_block(inode, goal, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\text2_free_blocks(inode, block, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\tmemcpy(new_bh->b_data, header, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t\t\n\t\t\text2_xattr_update_super_block(sb);\n\t\t}\n\t\tmark_buffer_dirty(new_bh);\n\t\tif (IS_SYNC(inode)) {\n\t\t\tsync_dirty_buffer(new_bh);\n\t\t\terror = -EIO;\n\t\t\tif (buffer_req(new_bh) && !buffer_uptodate(new_bh))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode)) {\n\t\terror = sync_inode_metadata(inode, 1);\n\t\t/* In case sync failed due to ENOSPC the inode was actually\n\t\t * written (only some dirty data were not) so we just proceed\n\t\t * as if nothing happened and cleanup the unused block */\n\t\tif (error && error != -ENOSPC) {\n\t\t\tif (new_bh && new_bh != old_bh) {\n\t\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\terror = 0;\n\tif (old_bh && old_bh != new_bh) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/*\n\t\t * If there was an old block and we are no longer using it,\n\t\t * release the old block.\n\t\t */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, old_bh->b_bdev,\n\t\t\t\t\told_bh->b_blocknr);\n\t\tlock_buffer(old_bh);\n\t\tif (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {\n\t\t\t/* Free the old block. */\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\tea_bdebug(old_bh, \"freeing\");\n\t\t\text2_free_blocks(inode, old_bh->b_blocknr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\t/* We let our caller release old_bh, so we\n\t\t\t * need to duplicate the buffer before. */\n\t\t\tget_bh(old_bh);\n\t\t\tbforget(old_bh);\n\t\t} else {\n\t\t\t/* Decrement the refcount only. */\n\t\t\tle32_add_cpu(&HDR(old_bh)->h_refcount, -1);\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmark_buffer_dirty(old_bh);\n\t\t\tea_bdebug(old_bh, \"refcount now=%d\",\n\t\t\t\tle32_to_cpu(HDR(old_bh)->h_refcount));\n\t\t}\n\t\tunlock_buffer(old_bh);\n\t}\n\ncleanup:\n\tbrelse(new_bh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext2_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "357-615",
    "snippet": "int\next2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_header *header = NULL;\n\tstruct ext2_xattr_entry *here, *last;\n\tsize_t name_len, free, min_offs = sb->s_blocksize;\n\tint not_found = 1, error;\n\tchar *end;\n\t\n\t/*\n\t * header -- Points either into bh, or to a temporarily\n\t *           allocated buffer.\n\t * here -- The named entry found, or the place for inserting, within\n\t *         the block pointed to by header.\n\t * last -- Points right after the last named entry within the block\n\t *         pointed to by header.\n\t * min_offs -- The offset of the first value (values are aligned\n\t *             towards the end of the block).\n\t * end -- Points right after the block pointed to by header.\n\t */\n\t\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  name_index, name, value, (long)value_len);\n\n\tif (value == NULL)\n\t\tvalue_len = 0;\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255 || value_len > sb->s_blocksize)\n\t\treturn -ERANGE;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (EXT2_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbh = sb_bread(sb, EXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bh->b_count)),\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\theader = HDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tif (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t\t    header->h_blocks != cpu_to_le32(1)) {\nbad_block:\t\text2_error(sb, \"ext2_xattr_set\",\n\t\t\t\t\"inode %ld: bad block %d\", inode->i_ino, \n\t\t\t\t   EXT2_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\there = FIRST_ENTRY(bh);\n\t\twhile (!IS_LAST_ENTRY(here)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(here);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tnot_found = name_index - here->e_name_index;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = name_len - here->e_name_len;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = memcmp(name, here->e_name,name_len);\n\t\t\tif (not_found <= 0)\n\t\t\t\tbreak;\n\t\t\there = next;\n\t\t}\n\t\tlast = here;\n\t\t/* We still need to compute min_offs and last. */\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(last);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tlast = next;\n\t\t}\n\n\t\t/* Check whether we have enough space left. */\n\t\tfree = min_offs - ((char*)last - (char*)header) - sizeof(__u32);\n\t} else {\n\t\t/* We will use a new extended attribute block. */\n\t\tfree = sb->s_blocksize -\n\t\t\tsizeof(struct ext2_xattr_header) - sizeof(__u32);\n\t\there = last = NULL;  /* avoid gcc uninitialized warning. */\n\t}\n\n\tif (not_found) {\n\t\t/* Request to remove a nonexistent attribute? */\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (value == NULL)\n\t\t\tgoto cleanup;\n\t} else {\n\t\t/* Request to create an existing attribute? */\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(here->e_value_size);\n\n\t\t\tif (le16_to_cpu(here->e_value_offs) + size > \n\t\t\t    sb->s_blocksize || size > sb->s_blocksize)\n\t\t\t\tgoto bad_block;\n\t\t\tfree += EXT2_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t/* Here we know that we can set the new attribute. */\n\n\tif (header) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/* assert(header == HDR(bh)); */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n\t\t\t\t\tbh->b_blocknr);\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t/* keep the buffer locked while modifying it. */\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;\n\t\t\there = ENTRY((char *)header + offset);\n\t\t\toffset = (char *)last - bh->b_data;\n\t\t\tlast = ENTRY((char *)header + offset);\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\theader = kzalloc(sb->s_blocksize, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (header == NULL)\n\t\t\tgoto cleanup;\n\t\tend = (char *)header + sb->s_blocksize;\n\t\theader->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);\n\t\theader->h_blocks = header->h_refcount = cpu_to_le32(1);\n\t\tlast = here = ENTRY(header+1);\n\t}\n\n\t/* Iff we are modifying the block in-place, bh is locked here. */\n\n\tif (not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\tsize_t rest = (char *)last - (char *)here;\n\t\tmemmove((char *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, name, name_len);\n\t} else {\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tchar *first_val = (char *)header + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\tchar *val = (char *)header + offs;\n\t\t\tsize_t size = EXT2_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(here->e_value_size));\n\n\t\t\tif (size == EXT2_XATTR_SIZE(value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\there->e_value_size = cpu_to_le32(value_len);\n\t\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t\t       EXT2_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, value, value_len);\n\t\t\t\tgoto skip_replace;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\there->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = ENTRY(header+1);\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT2_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (value == NULL) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((char *)last - size);\n\t\t\tmemmove(here, (char*)here + size,\n\t\t\t\t(char*)last - (char*)here);\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (value != NULL) {\n\t\t/* Insert the new value. */\n\t\there->e_value_size = cpu_to_le32(value_len);\n\t\tif (value_len) {\n\t\t\tsize_t size = EXT2_XATTR_SIZE(value_len);\n\t\t\tchar *val = (char *)header + min_offs - size;\n\t\t\there->e_value_offs =\n\t\t\t\tcpu_to_le16((char *)val - (char *)header);\n\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t       EXT2_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, value, value_len);\n\t\t}\n\t}\n\nskip_replace:\n\tif (IS_LAST_ENTRY(ENTRY(header+1))) {\n\t\t/* This block is now empty. */\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, NULL);\n\t} else {\n\t\text2_xattr_rehash(header, here);\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, header);\n\t}\n\ncleanup:\n\tbrelse(bh);\n\tif (!(bh && header == HDR(bh)))\n\t\tkfree(header);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
      "static int ext2_xattr_cache_insert(struct buffer_head *);",
      "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
      "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);",
      "static struct mb_cache *ext2_xattr_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT2_I(inode)->xattr_sem"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "header"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HDR",
          "args": [
            "bh"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_xattr_set2",
          "args": [
            "inode",
            "bh",
            "header"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_set2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "620-746",
          "snippet": "static int\next2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n\t\tstruct ext2_xattr_header *header)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tint error;\n\n\tif (header) {\n\t\tnew_bh = ext2_xattr_cache_find(inode, header);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == old_bh) {\n\t\t\t\tea_bdebug(new_bh, \"keeping this block\");\n\t\t\t} else {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode.  */\n\t\t\t\tea_bdebug(new_bh, \"reusing block\");\n\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error) {\n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tle32_add_cpu(&HDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(HDR(new_bh)->h_refcount));\n\t\t\t}\n\t\t\tunlock_buffer(new_bh);\n\t\t} else if (old_bh && header == HDR(old_bh)) {\n\t\t\t/* Keep this block. No need to lock the block as we\n\t\t\t   don't need to change the reference count. */\n\t\t\tnew_bh = old_bh;\n\t\t\tget_bh(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text2_fsblk_t goal = ext2_group_first_block_no(sb,\n\t\t\t\t\t\tEXT2_I(inode)->i_block_group);\n\t\t\tint block = ext2_new_block(inode, goal, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\text2_free_blocks(inode, block, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\tmemcpy(new_bh->b_data, header, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t\t\n\t\t\text2_xattr_update_super_block(sb);\n\t\t}\n\t\tmark_buffer_dirty(new_bh);\n\t\tif (IS_SYNC(inode)) {\n\t\t\tsync_dirty_buffer(new_bh);\n\t\t\terror = -EIO;\n\t\t\tif (buffer_req(new_bh) && !buffer_uptodate(new_bh))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode)) {\n\t\terror = sync_inode_metadata(inode, 1);\n\t\t/* In case sync failed due to ENOSPC the inode was actually\n\t\t * written (only some dirty data were not) so we just proceed\n\t\t * as if nothing happened and cleanup the unused block */\n\t\tif (error && error != -ENOSPC) {\n\t\t\tif (new_bh && new_bh != old_bh) {\n\t\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\terror = 0;\n\tif (old_bh && old_bh != new_bh) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/*\n\t\t * If there was an old block and we are no longer using it,\n\t\t * release the old block.\n\t\t */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, old_bh->b_bdev,\n\t\t\t\t\told_bh->b_blocknr);\n\t\tlock_buffer(old_bh);\n\t\tif (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {\n\t\t\t/* Free the old block. */\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\tea_bdebug(old_bh, \"freeing\");\n\t\t\text2_free_blocks(inode, old_bh->b_blocknr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\t/* We let our caller release old_bh, so we\n\t\t\t * need to duplicate the buffer before. */\n\t\t\tget_bh(old_bh);\n\t\t\tbforget(old_bh);\n\t\t} else {\n\t\t\t/* Decrement the refcount only. */\n\t\t\tle32_add_cpu(&HDR(old_bh)->h_refcount, -1);\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmark_buffer_dirty(old_bh);\n\t\t\tea_bdebug(old_bh, \"refcount now=%d\",\n\t\t\t\tle32_to_cpu(HDR(old_bh)->h_refcount));\n\t\t}\n\t\tunlock_buffer(old_bh);\n\t}\n\ncleanup:\n\tbrelse(new_bh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
            "static int ext2_xattr_cache_insert(struct buffer_head *);",
            "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
            "static struct mb_cache *ext2_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic int\next2_xattr_set2(struct inode *inode, struct buffer_head *old_bh,\n\t\tstruct ext2_xattr_header *header)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tint error;\n\n\tif (header) {\n\t\tnew_bh = ext2_xattr_cache_find(inode, header);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == old_bh) {\n\t\t\t\tea_bdebug(new_bh, \"keeping this block\");\n\t\t\t} else {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode.  */\n\t\t\t\tea_bdebug(new_bh, \"reusing block\");\n\n\t\t\t\terror = dquot_alloc_block(inode, 1);\n\t\t\t\tif (error) {\n\t\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tle32_add_cpu(&HDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(HDR(new_bh)->h_refcount));\n\t\t\t}\n\t\t\tunlock_buffer(new_bh);\n\t\t} else if (old_bh && header == HDR(old_bh)) {\n\t\t\t/* Keep this block. No need to lock the block as we\n\t\t\t   don't need to change the reference count. */\n\t\t\tnew_bh = old_bh;\n\t\t\tget_bh(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text2_fsblk_t goal = ext2_group_first_block_no(sb,\n\t\t\t\t\t\tEXT2_I(inode)->i_block_group);\n\t\t\tint block = ext2_new_block(inode, goal, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tea_idebug(inode, \"creating block %d\", block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\text2_free_blocks(inode, block, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\tmemcpy(new_bh->b_data, header, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text2_xattr_cache_insert(new_bh);\n\t\t\t\n\t\t\text2_xattr_update_super_block(sb);\n\t\t}\n\t\tmark_buffer_dirty(new_bh);\n\t\tif (IS_SYNC(inode)) {\n\t\t\tsync_dirty_buffer(new_bh);\n\t\t\terror = -EIO;\n\t\t\tif (buffer_req(new_bh) && !buffer_uptodate(new_bh))\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT2_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tif (IS_SYNC(inode)) {\n\t\terror = sync_inode_metadata(inode, 1);\n\t\t/* In case sync failed due to ENOSPC the inode was actually\n\t\t * written (only some dirty data were not) so we just proceed\n\t\t * as if nothing happened and cleanup the unused block */\n\t\tif (error && error != -ENOSPC) {\n\t\t\tif (new_bh && new_bh != old_bh) {\n\t\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\terror = 0;\n\tif (old_bh && old_bh != new_bh) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/*\n\t\t * If there was an old block and we are no longer using it,\n\t\t * release the old block.\n\t\t */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, old_bh->b_bdev,\n\t\t\t\t\told_bh->b_blocknr);\n\t\tlock_buffer(old_bh);\n\t\tif (HDR(old_bh)->h_refcount == cpu_to_le32(1)) {\n\t\t\t/* Free the old block. */\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\tea_bdebug(old_bh, \"freeing\");\n\t\t\text2_free_blocks(inode, old_bh->b_blocknr, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\t/* We let our caller release old_bh, so we\n\t\t\t * need to duplicate the buffer before. */\n\t\t\tget_bh(old_bh);\n\t\t\tbforget(old_bh);\n\t\t} else {\n\t\t\t/* Decrement the refcount only. */\n\t\t\tle32_add_cpu(&HDR(old_bh)->h_refcount, -1);\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tdquot_free_block_nodirty(inode, 1);\n\t\t\tmark_inode_dirty(inode);\n\t\t\tmark_buffer_dirty(old_bh);\n\t\t\tea_bdebug(old_bh, \"refcount now=%d\",\n\t\t\t\tle32_to_cpu(HDR(old_bh)->h_refcount));\n\t\t}\n\t\tunlock_buffer(old_bh);\n\t}\n\ncleanup:\n\tbrelse(new_bh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_xattr_rehash",
          "args": [
            "header",
            "here"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "992-1012",
          "snippet": "static void ext2_xattr_rehash(struct ext2_xattr_header *header,\n\t\t\t      struct ext2_xattr_entry *entry)\n{\n\tstruct ext2_xattr_entry *here;\n\t__u32 hash = 0;\n\t\n\text2_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT2_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [
            "#define BLOCK_HASH_SHIFT 16"
          ],
          "globals_used": [
            "static int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);",
            "static struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);",
            "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\n#define BLOCK_HASH_SHIFT 16\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *header,\n\t\t\t      struct ext2_xattr_entry *entry)\n{\n\tstruct ext2_xattr_entry *here;\n\t__u32 hash = 0;\n\t\n\text2_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT2_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "ENTRY(header+1)"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header+1"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "value",
            "value_len"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val + size - EXT2_XATTR_PAD",
            "0",
            "EXT2_XATTR_PAD"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(char *)val - (char *)header"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_SIZE",
          "args": [
            "value_len"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "value_len"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "last",
            "0",
            "size"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "here",
            "(char*)here + size",
            "(char*)last - (char*)here"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "(char *)last - size"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "o + size"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "last->e_value_offs"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header+1"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "first_val",
            "0",
            "size"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "first_val + size",
            "first_val",
            "val - first_val"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "value",
            "value_len"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val + size - EXT2_XATTR_PAD",
            "0",
            "EXT2_XATTR_PAD"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "value_len"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_SIZE",
          "args": [
            "value_len"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_SIZE",
          "args": [
            "le32_to_cpu(here->e_value_size)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "here->e_value_size"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "here->e_name",
            "name",
            "name_len"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "here",
            "0",
            "size"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(char *)here + size",
            "here",
            "rest"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header+1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_XATTR_MAGIC"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sb->s_blocksize",
            "GFP_KERNEL"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "(char *)header + offset"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "(char *)header + offset"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "header",
            "HDR(bh)",
            "bh->b_size"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bh->b_size",
            "GFP_KERNEL"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"cloning\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"modifying in-place\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_get",
          "args": [
            "ext2_xattr_cache",
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "660-714",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_SIZE",
          "args": [
            "value_len"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_SIZE",
          "args": [
            "size"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "here->e_name",
            "name_len"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "here"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "here"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIRST_ENTRY",
          "args": [
            "bh"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"ext2_xattr_set\"",
            "\"inode %ld: bad block %d\"",
            "inode->i_ino",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_XATTR_MAGIC"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bh->b_count))",
            "le32_to_cpu(HDR(bh)->h_refcount)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT2_I(inode)->xattr_sem"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"name=%d.%s, value=%p, value_len=%ld\"",
            "name_index",
            "name",
            "value",
            "(long)value_len"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_set2(struct inode *, struct buffer_head *,\n\t\t\t   struct ext2_xattr_header *);\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct buffer_head *ext2_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext2_xattr_header *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nint\next2_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_header *header = NULL;\n\tstruct ext2_xattr_entry *here, *last;\n\tsize_t name_len, free, min_offs = sb->s_blocksize;\n\tint not_found = 1, error;\n\tchar *end;\n\t\n\t/*\n\t * header -- Points either into bh, or to a temporarily\n\t *           allocated buffer.\n\t * here -- The named entry found, or the place for inserting, within\n\t *         the block pointed to by header.\n\t * last -- Points right after the last named entry within the block\n\t *         pointed to by header.\n\t * min_offs -- The offset of the first value (values are aligned\n\t *             towards the end of the block).\n\t * end -- Points right after the block pointed to by header.\n\t */\n\t\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  name_index, name, value, (long)value_len);\n\n\tif (value == NULL)\n\t\tvalue_len = 0;\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255 || value_len > sb->s_blocksize)\n\t\treturn -ERANGE;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (EXT2_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbh = sb_bread(sb, EXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bh->b_count)),\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\theader = HDR(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tif (header->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t\t    header->h_blocks != cpu_to_le32(1)) {\nbad_block:\t\text2_error(sb, \"ext2_xattr_set\",\n\t\t\t\t\"inode %ld: bad block %d\", inode->i_ino, \n\t\t\t\t   EXT2_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\there = FIRST_ENTRY(bh);\n\t\twhile (!IS_LAST_ENTRY(here)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(here);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tnot_found = name_index - here->e_name_index;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = name_len - here->e_name_len;\n\t\t\tif (!not_found)\n\t\t\t\tnot_found = memcmp(name, here->e_name,name_len);\n\t\t\tif (not_found <= 0)\n\t\t\t\tbreak;\n\t\t\there = next;\n\t\t}\n\t\tlast = here;\n\t\t/* We still need to compute min_offs and last. */\n\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(last);\n\t\t\tif ((char *)next >= end)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (offs < min_offs)\n\t\t\t\t\tmin_offs = offs;\n\t\t\t}\n\t\t\tlast = next;\n\t\t}\n\n\t\t/* Check whether we have enough space left. */\n\t\tfree = min_offs - ((char*)last - (char*)header) - sizeof(__u32);\n\t} else {\n\t\t/* We will use a new extended attribute block. */\n\t\tfree = sb->s_blocksize -\n\t\t\tsizeof(struct ext2_xattr_header) - sizeof(__u32);\n\t\there = last = NULL;  /* avoid gcc uninitialized warning. */\n\t}\n\n\tif (not_found) {\n\t\t/* Request to remove a nonexistent attribute? */\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (value == NULL)\n\t\t\tgoto cleanup;\n\t} else {\n\t\t/* Request to create an existing attribute? */\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(here->e_value_size);\n\n\t\t\tif (le16_to_cpu(here->e_value_offs) + size > \n\t\t\t    sb->s_blocksize || size > sb->s_blocksize)\n\t\t\t\tgoto bad_block;\n\t\t\tfree += EXT2_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t/* Here we know that we can set the new attribute. */\n\n\tif (header) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/* assert(header == HDR(bh)); */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n\t\t\t\t\tbh->b_blocknr);\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t/* keep the buffer locked while modifying it. */\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;\n\t\t\there = ENTRY((char *)header + offset);\n\t\t\toffset = (char *)last - bh->b_data;\n\t\t\tlast = ENTRY((char *)header + offset);\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\theader = kzalloc(sb->s_blocksize, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (header == NULL)\n\t\t\tgoto cleanup;\n\t\tend = (char *)header + sb->s_blocksize;\n\t\theader->h_magic = cpu_to_le32(EXT2_XATTR_MAGIC);\n\t\theader->h_blocks = header->h_refcount = cpu_to_le32(1);\n\t\tlast = here = ENTRY(header+1);\n\t}\n\n\t/* Iff we are modifying the block in-place, bh is locked here. */\n\n\tif (not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\tsize_t rest = (char *)last - (char *)here;\n\t\tmemmove((char *)here + size, here, rest);\n\t\tmemset(here, 0, size);\n\t\there->e_name_index = name_index;\n\t\there->e_name_len = name_len;\n\t\tmemcpy(here->e_name, name, name_len);\n\t} else {\n\t\tif (!here->e_value_block && here->e_value_size) {\n\t\t\tchar *first_val = (char *)header + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(here->e_value_offs);\n\t\t\tchar *val = (char *)header + offs;\n\t\t\tsize_t size = EXT2_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(here->e_value_size));\n\n\t\t\tif (size == EXT2_XATTR_SIZE(value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\there->e_value_size = cpu_to_le32(value_len);\n\t\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t\t       EXT2_XATTR_PAD); /* Clear pad bytes. */\n\t\t\t\tmemcpy(val, value, value_len);\n\t\t\t\tgoto skip_replace;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\there->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = ENTRY(header+1);\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT2_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (value == NULL) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT2_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((char *)last - size);\n\t\t\tmemmove(here, (char*)here + size,\n\t\t\t\t(char*)last - (char*)here);\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (value != NULL) {\n\t\t/* Insert the new value. */\n\t\there->e_value_size = cpu_to_le32(value_len);\n\t\tif (value_len) {\n\t\t\tsize_t size = EXT2_XATTR_SIZE(value_len);\n\t\t\tchar *val = (char *)header + min_offs - size;\n\t\t\there->e_value_offs =\n\t\t\t\tcpu_to_le16((char *)val - (char *)header);\n\t\t\tmemset(val + size - EXT2_XATTR_PAD, 0,\n\t\t\t       EXT2_XATTR_PAD); /* Clear the pad bytes. */\n\t\t\tmemcpy(val, value, value_len);\n\t\t}\n\t}\n\nskip_replace:\n\tif (IS_LAST_ENTRY(ENTRY(header+1))) {\n\t\t/* This block is now empty. */\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, NULL);\n\t} else {\n\t\text2_xattr_rehash(header, here);\n\t\tif (bh && header == HDR(bh))\n\t\t\tunlock_buffer(bh);  /* we were modifying in-place. */\n\t\terror = ext2_xattr_set2(inode, bh, header);\n\t}\n\ncleanup:\n\tbrelse(bh);\n\tif (!(bh && header == HDR(bh)))\n\t\tkfree(header);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext2_xattr_update_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "334-343",
    "snippet": "static void ext2_xattr_update_super_block(struct super_block *sb)\n{\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tEXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "EXT2_SB(sb)->s_sbh"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&EXT2_SB(sb)->s_lock"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SET_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT2_FEATURE_COMPAT_EXT_ATTR"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&EXT2_SB(sb)->s_lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT2_FEATURE_COMPAT_EXT_ATTR"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic void ext2_xattr_update_super_block(struct super_block *sb)\n{\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tEXT2_SET_COMPAT_FEATURE(sb, EXT2_FEATURE_COMPAT_EXT_ATTR);\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n}"
  },
  {
    "function_name": "ext2_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "324-328",
    "snippet": "ssize_t\next2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext2_xattr_list(dentry, buffer, size);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_xattr_list",
          "args": [
            "dentry",
            "buffer",
            "size"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "243-317",
          "snippet": "static int\next2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tchar *end;\n\tsize_t rest = buffer_size;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = 0;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_list\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* check the on-disk data structure */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(entry);\n\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\n\t/* list the attribute names */\n\tfor (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);\n\t     entry = EXT2_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text2_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest) {\n\t\t\t\t\terror = -ERANGE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\terror = buffer_size - rest;  /* total size */\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_xattr_cache_insert(struct buffer_head *);",
            "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic int\next2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tchar *end;\n\tsize_t rest = buffer_size;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = 0;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_list\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* check the on-disk data structure */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(entry);\n\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\n\t/* list the attribute names */\n\tfor (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);\n\t     entry = EXT2_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text2_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest) {\n\t\t\t\t\terror = -ERANGE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\terror = buffer_size - rest;  /* total size */\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nssize_t\next2_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext2_xattr_list(dentry, buffer, size);\n}"
  },
  {
    "function_name": "ext2_xattr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "243-317",
    "snippet": "static int\next2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tchar *end;\n\tsize_t rest = buffer_size;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = 0;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_list\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* check the on-disk data structure */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(entry);\n\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\n\t/* list the attribute names */\n\tfor (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);\n\t     entry = EXT2_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text2_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest) {\n\t\t\t\t\terror = -ERANGE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\terror = buffer_size - rest;  /* total size */\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_xattr_cache_insert(struct buffer_head *);",
      "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT2_I(inode)->xattr_sem"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "dentry",
            "buffer",
            "rest",
            "entry->e_name",
            "entry->e_name_len",
            "handler->flags"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_xattr_handler",
          "args": [
            "entry->e_name_index"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "128-136",
          "snippet": "static inline const struct xattr_handler *\next2_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext2_xattr_handler_map))\n\t\thandler = ext2_xattr_handler_map[name_index];\n\treturn handler;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *ext2_xattr_handler_map[] = {\n\t[EXT2_XATTR_INDEX_USER]\t\t     = &ext2_xattr_user_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t[EXT2_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT2_XATTR_INDEX_TRUSTED]\t     = &ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t[EXT2_XATTR_INDEX_SECURITY]\t     = &ext2_xattr_security_handler,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic const struct xattr_handler *ext2_xattr_handler_map[] = {\n\t[EXT2_XATTR_INDEX_USER]\t\t     = &ext2_xattr_user_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t[EXT2_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT2_XATTR_INDEX_TRUSTED]\t     = &ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t[EXT2_XATTR_INDEX_SECURITY]\t     = &ext2_xattr_security_handler,\n#endif\n};\n\nstatic inline const struct xattr_handler *\next2_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext2_xattr_handler_map))\n\t\thandler = ext2_xattr_handler_map[name_index];\n\treturn handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIRST_ENTRY",
          "args": [
            "bh"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"cache insert failed\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_xattr_cache_insert",
          "args": [
            "bh"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "826-850",
          "snippet": "static int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_xattr_cache_insert(struct buffer_head *);",
            "static struct mb_cache *ext2_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIRST_ENTRY",
          "args": [
            "bh"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "inode->i_sb",
            "\"ext2_xattr_list\"",
            "\"inode %ld: bad block %d\"",
            "inode->i_ino",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HDR",
          "args": [
            "bh"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_XATTR_MAGIC"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bh->b_count))",
            "le32_to_cpu(HDR(bh)->h_refcount)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "HDR(bh)->h_refcount"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"reading block %d\"",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT2_I(inode)->xattr_sem"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"buffer=%p, buffer_size=%ld\"",
            "buffer",
            "(long)buffer_size"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nstatic int\next2_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tchar *end;\n\tsize_t rest = buffer_size;\n\tint error;\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = 0;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_list\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* check the on-disk data structure */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next = EXT2_XATTR_NEXT(entry);\n\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\n\t/* list the attribute names */\n\tfor (entry = FIRST_ENTRY(bh); !IS_LAST_ENTRY(entry);\n\t     entry = EXT2_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text2_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest) {\n\t\t\t\t\terror = -ERANGE;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\terror = buffer_size - rest;  /* total size */\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext2_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "148-231",
    "snippet": "int\next2_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tsize_t name_len, size;\n\tchar *end;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = -ENODATA;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* find named attribute */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next =\n\t\t\tEXT2_XATTR_NEXT(entry);\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tif (name_index == entry->e_name_index &&\n\t\t    name_len == entry->e_name_len &&\n\t\t    memcmp(name, entry->e_name, name_len) == 0)\n\t\t\tgoto found;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\terror = -ENODATA;\n\tgoto cleanup;\nfound:\n\t/* check the buffer size */\n\tif (entry->e_value_block != 0)\n\t\tgoto bad_block;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (size > inode->i_sb->s_blocksize ||\n\t    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\n\t\tgoto bad_block;\n\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\t/* return value of attribute */\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t\tsize);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_xattr_cache_insert(struct buffer_head *);",
      "static void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT2_I(inode)->xattr_sem"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "bh->b_data + le16_to_cpu(entry->e_value_offs)",
            "size"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"cache insert failed\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_xattr_cache_insert",
          "args": [
            "bh"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
          "lines": "826-850",
          "snippet": "static int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/security.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_xattr_cache_insert(struct buffer_head *);",
            "static struct mb_cache *ext2_xattr_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic struct mb_cache *ext2_xattr_cache;\n\nstatic int\next2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"cache insert failed\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "entry->e_name",
            "name_len"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIRST_ENTRY",
          "args": [
            "bh"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "inode->i_sb",
            "\"ext2_xattr_get\"",
            "\"inode %ld: bad block %d\"",
            "inode->i_ino",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HDR",
          "args": [
            "bh"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "FF_LAYOUT_FROM_HDR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/flexfilelayout/flexfilelayout.h",
          "lines": "72-76",
          "snippet": "static inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}",
          "includes": [
            "#include \"../pnfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n\nstatic inline struct nfs4_flexfile_layout *\nFF_LAYOUT_FROM_HDR(struct pnfs_layout_hdr *lo)\n{\n\treturn container_of(lo, struct nfs4_flexfile_layout, generic_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_XATTR_MAGIC"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bh->b_count))",
            "le32_to_cpu(HDR(bh)->h_refcount)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"reading block %d\"",
            "EXT2_I(inode)->i_file_acl"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT2_I(inode)->xattr_sem"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"name=%d.%s, buffer=%p, buffer_size=%ld\"",
            "name_index",
            "name",
            "buffer",
            "(long)buffer_size"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic int ext2_xattr_cache_insert(struct buffer_head *);\nstatic void ext2_xattr_rehash(struct ext2_xattr_header *,\n\t\t\t      struct ext2_xattr_entry *);\n\nint\next2_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext2_xattr_entry *entry;\n\tsize_t name_len, size;\n\tchar *end;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tif (name_len > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT2_I(inode)->xattr_sem);\n\terror = -ENODATA;\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %d\", EXT2_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(HDR(bh)->h_refcount));\n\tend = bh->b_data + bh->b_size;\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\nbad_block:\text2_error(inode->i_sb, \"ext2_xattr_get\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\n\t/* find named attribute */\n\tentry = FIRST_ENTRY(bh);\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tstruct ext2_xattr_entry *next =\n\t\t\tEXT2_XATTR_NEXT(entry);\n\t\tif ((char *)next >= end)\n\t\t\tgoto bad_block;\n\t\tif (name_index == entry->e_name_index &&\n\t\t    name_len == entry->e_name_len &&\n\t\t    memcmp(name, entry->e_name, name_len) == 0)\n\t\t\tgoto found;\n\t\tentry = next;\n\t}\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\terror = -ENODATA;\n\tgoto cleanup;\nfound:\n\t/* check the buffer size */\n\tif (entry->e_value_block != 0)\n\t\tgoto bad_block;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (size > inode->i_sb->s_blocksize ||\n\t    le16_to_cpu(entry->e_value_offs) + size > inode->i_sb->s_blocksize)\n\t\tgoto bad_block;\n\n\tif (ext2_xattr_cache_insert(bh))\n\t\tea_idebug(inode, \"cache insert failed\");\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\t/* return value of attribute */\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t\tsize);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\tup_read(&EXT2_I(inode)->xattr_sem);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext2_xattr_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.c",
    "lines": "128-136",
    "snippet": "static inline const struct xattr_handler *\next2_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext2_xattr_handler_map))\n\t\thandler = ext2_xattr_handler_map[name_index];\n\treturn handler;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <linux/security.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xattr_handler *ext2_xattr_handler_map[] = {\n\t[EXT2_XATTR_INDEX_USER]\t\t     = &ext2_xattr_user_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t[EXT2_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT2_XATTR_INDEX_TRUSTED]\t     = &ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t[EXT2_XATTR_INDEX_SECURITY]\t     = &ext2_xattr_security_handler,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ext2_xattr_handler_map"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/security.h>\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/buffer_head.h>\n\nstatic const struct xattr_handler *ext2_xattr_handler_map[] = {\n\t[EXT2_XATTR_INDEX_USER]\t\t     = &ext2_xattr_user_handler,\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t[EXT2_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT2_XATTR_INDEX_TRUSTED]\t     = &ext2_xattr_trusted_handler,\n#ifdef CONFIG_EXT2_FS_SECURITY\n\t[EXT2_XATTR_INDEX_SECURITY]\t     = &ext2_xattr_security_handler,\n#endif\n};\n\nstatic inline const struct xattr_handler *\next2_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext2_xattr_handler_map))\n\t\thandler = ext2_xattr_handler_map[name_index];\n\treturn handler;\n}"
  }
]