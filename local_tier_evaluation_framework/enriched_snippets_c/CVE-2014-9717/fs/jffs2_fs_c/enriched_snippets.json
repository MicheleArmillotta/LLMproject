[
  {
    "function_name": "fs2_flash_cleanup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "746-766",
    "snippet": "id jffs2_flash_cleanup(struct jffs2_sb_info *c) {\n\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\tjffs2_nand_flash_cleanup(c);\n\t}\n\n\t/* and DataFlash */\n\tif (jffs2_dataflash(c)) {\n\t\tjffs2_dataflash_cleanup(c);\n\t}\n\n\t/* and Intel \"Sibley\" flash */\n\tif (jffs2_nor_wbuf_flash(c)) {\n\t\tjffs2_nor_wbuf_flash_cleanup(c);\n\t}\n\n\t/* and an UBI volume */\n\tif (jffs2_ubivol(c)) {\n\t\tjffs2_ubivol_cleanup(c);\n\t}\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_ubivol_cleanup(c",
          "args": [
            ";"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_ubivol(c",
          "args": [
            ")"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_nor_wbuf_flash_cleanup(c",
          "args": [
            ";"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_nor_wbuf_flash(c",
          "args": [
            ")"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dataflash_cleanup(c",
          "args": [
            ";"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dataflash(c",
          "args": [
            ")"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_nand_flash_cleanup(c",
          "args": [
            ";"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_cleanmarker_oob(c",
          "args": [
            ")"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nid jffs2_flash_cleanup(struct jffs2_sb_info *c) {\n\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\tjffs2_nand_flash_cleanup(c);\n\t}\n\n\t/* and DataFlash */\n\tif (jffs2_dataflash(c)) {\n\t\tjffs2_dataflash_cleanup(c);\n\t}\n\n\t/* and Intel \"Sibley\" flash */\n\tif (jffs2_nor_wbuf_flash(c)) {\n\t\tjffs2_nor_wbuf_flash_cleanup(c);\n\t}\n\n\t/* and an UBI volume */\n\tif (jffs2_ubivol(c)) {\n\t\tjffs2_ubivol_cleanup(c);\n\t}\n}"
  },
  {
    "function_name": "fs2_flash_setup(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "712-744",
    "snippet": "atic int jffs2_flash_setup(struct jffs2_sb_info *c) {\n\tint ret = 0;\n\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\t/* NAND flash... do setup accordingly */\n\t\tret = jffs2_nand_flash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* and Dataflash */\n\tif (jffs2_dataflash(c)) {\n\t\tret = jffs2_dataflash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* and Intel \"Sibley\" flash */\n\tif (jffs2_nor_wbuf_flash(c)) {\n\t\tret = jffs2_nor_wbuf_flash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* and an UBI volume */\n\tif (jffs2_ubivol(c)) {\n\t\tret = jffs2_ubivol_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_ubivol_setup(c",
          "args": [
            ";"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_ubivol(c",
          "args": [
            ")"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_nor_wbuf_flash_setup(c",
          "args": [
            ";"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_nor_wbuf_flash(c",
          "args": [
            ")"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dataflash_setup(c",
          "args": [
            ";"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dataflash(c",
          "args": [
            ")"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_nand_flash_setup(c",
          "args": [
            ";"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_cleanmarker_oob(c",
          "args": [
            ")"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c) {\n\tint ret = 0;\n\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\t/* NAND flash... do setup accordingly */\n\t\tret = jffs2_nand_flash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* and Dataflash */\n\tif (jffs2_dataflash(c)) {\n\t\tret = jffs2_dataflash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* and Intel \"Sibley\" flash */\n\tif (jffs2_nor_wbuf_flash(c)) {\n\t\tret = jffs2_nor_wbuf_flash_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* and an UBI volume */\n\tif (jffs2_ubivol(c)) {\n\t\tret = jffs2_ubivol_setup(c);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_gc_release_page(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "702-710",
    "snippet": "id jffs2_gc_release_page(struct jffs2_sb_info *c,\n\t\t\t   unsigned char *ptr,\n\t\t\t   unsigned long *priv)\n{\n\tstruct page *pg = (void *)*priv;\n\n\tkunmap(pg);\n\tpage_cache_release(pg);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ge_cache_release(p",
          "args": [
            ");"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nmap(p",
          "args": [
            ");"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nid jffs2_gc_release_page(struct jffs2_sb_info *c,\n\t\t\t   unsigned char *ptr,\n\t\t\t   unsigned long *priv)\n{\n\tstruct page *pg = (void *)*priv;\n\n\tkunmap(pg);\n\tpage_cache_release(pg);\n}"
  },
  {
    "function_name": "fs2_gc_fetch_page(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "685-700",
    "snippet": "signed char *jffs2_gc_fetch_page(struct jffs2_sb_info *c,\n\t\t\t\t   struct jffs2_inode_info *f,\n\t\t\t\t   unsigned long offset,\n\t\t\t\t   unsigned long *priv)\n{\n\tstruct inode *inode = OFNI_EDONI_2SFFJ(f);\n\tstruct page *pg;\n\n\tpg = read_cache_page(inode->i_mapping, offset >> PAGE_CACHE_SHIFT,\n\t\t\t     (void *)jffs2_do_readpage_unlock, inode);\n\tif (IS_ERR(pg))\n\t\treturn (void *)pg;\n\n\t*priv = (unsigned long)pg;\n\treturn kmap(pg);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ap(p",
          "args": [
            ");"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(p",
          "args": [
            "))"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad_cache_page(i",
          "args": [
            "ode->i_mapping,",
            "fset >> PAGE_CACHE_SHIFT,",
            "oid *)jffs2_do_readpage_unlock,",
            "ode);"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NI_EDONI_2SFFJ(f",
          "args": [
            ";"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nsigned char *jffs2_gc_fetch_page(struct jffs2_sb_info *c,\n\t\t\t\t   struct jffs2_inode_info *f,\n\t\t\t\t   unsigned long offset,\n\t\t\t\t   unsigned long *priv)\n{\n\tstruct inode *inode = OFNI_EDONI_2SFFJ(f);\n\tstruct page *pg;\n\n\tpg = read_cache_page(inode->i_mapping, offset >> PAGE_CACHE_SHIFT,\n\t\t\t     (void *)jffs2_do_readpage_unlock, inode);\n\tif (IS_ERR(pg))\n\t\treturn (void *)pg;\n\n\t*priv = (unsigned long)pg;\n\treturn kmap(pg);\n}"
  },
  {
    "function_name": "fs2_gc_fetch_inode(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "620-683",
    "snippet": "ruct jffs2_inode_info *jffs2_gc_fetch_inode(struct jffs2_sb_info *c,\n\t\t\t\t\t      int inum, int unlinked)\n{\n\tstruct inode *inode;\n\tstruct jffs2_inode_cache *ic;\n\n\tif (unlinked) {\n\t\t/* The inode has zero nlink but its nodes weren't yet marked\n\t\t   obsolete. This has to be because we're still waiting for\n\t\t   the final (close() and) iput() to happen.\n\n\t\t   There's a possibility that the final iput() could have\n\t\t   happened while we were contemplating. In order to ensure\n\t\t   that we don't cause a new read_inode() (which would fail)\n\t\t   for the inode in question, we use ilookup() in this case\n\t\t   instead of iget().\n\n\t\t   The nlink can't _become_ zero at this point because we're\n\t\t   holding the alloc_sem, and jffs2_do_unlink() would also\n\t\t   need that while decrementing nlink on any inode.\n\t\t*/\n\t\tinode = ilookup(OFNI_BS_2SFFJ(c), inum);\n\t\tif (!inode) {\n\t\t\tjffs2_dbg(1, \"ilookup() failed for ino #%u; inode is probably deleted.\\n\",\n\t\t\t\t  inum);\n\n\t\t\tspin_lock(&c->inocache_lock);\n\t\t\tic = jffs2_get_ino_cache(c, inum);\n\t\t\tif (!ic) {\n\t\t\t\tjffs2_dbg(1, \"Inode cache for ino #%u is gone\\n\",\n\t\t\t\t\t  inum);\n\t\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (ic->state != INO_STATE_CHECKEDABSENT) {\n\t\t\t\t/* Wait for progress. Don't just loop */\n\t\t\t\tjffs2_dbg(1, \"Waiting for ino #%u in state %d\\n\",\n\t\t\t\t\t  ic->ino, ic->state);\n\t\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\t}\n\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/* Inode has links to it still; they're not going away because\n\t\t   jffs2_do_unlink() would need the alloc_sem and we have it.\n\t\t   Just iget() it, and if read_inode() is necessary that's OK.\n\t\t*/\n\t\tinode = jffs2_iget(OFNI_BS_2SFFJ(c), inum);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tpr_notice(\"Eep. read_inode() failed for ino #%u. unlinked %d\\n\",\n\t\t\t  inum, unlinked);\n\t\t/* NB. This will happen again. We need to do something appropriate here. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn JFFS2_INODE_INFO(inode);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FS2_INODE_INFO(i",
          "args": [
            "ode);"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_PTR(-",
          "args": [
            "IO);"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut(i",
          "args": [
            "ode);"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "ep. read_inode() failed for ino #%u. unlinked %d\\n\",",
            "um,",
            "linked);"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bad_inode(i",
          "args": [
            "ode))"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_CAST(i",
          "args": [
            "ode);"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(i",
          "args": [
            "ode))"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_iget(O",
          "args": [
            "NI_BS_2SFFJ(c),",
            "um);"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NI_BS_2SFFJ(c",
          "args": [
            ","
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eep_on_spinunlock(&",
          "args": [
            "->inocache_wq,",
            "->inocache_lock);"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "aiting for ino #%u in state %d\\n\",",
            "->ino,",
            "->state);"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "node cache for ino #%u is gone\\n\",",
            "um);"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_get_ino_cache(c",
          "args": [
            "um);"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "lookup() failed for ino #%u; inode is probably deleted.\\n\",",
            "um);"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ookup(O",
          "args": [
            "NI_BS_2SFFJ(c),",
            "um);"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NI_BS_2SFFJ(c",
          "args": [
            ","
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nruct jffs2_inode_info *jffs2_gc_fetch_inode(struct jffs2_sb_info *c,\n\t\t\t\t\t      int inum, int unlinked)\n{\n\tstruct inode *inode;\n\tstruct jffs2_inode_cache *ic;\n\n\tif (unlinked) {\n\t\t/* The inode has zero nlink but its nodes weren't yet marked\n\t\t   obsolete. This has to be because we're still waiting for\n\t\t   the final (close() and) iput() to happen.\n\n\t\t   There's a possibility that the final iput() could have\n\t\t   happened while we were contemplating. In order to ensure\n\t\t   that we don't cause a new read_inode() (which would fail)\n\t\t   for the inode in question, we use ilookup() in this case\n\t\t   instead of iget().\n\n\t\t   The nlink can't _become_ zero at this point because we're\n\t\t   holding the alloc_sem, and jffs2_do_unlink() would also\n\t\t   need that while decrementing nlink on any inode.\n\t\t*/\n\t\tinode = ilookup(OFNI_BS_2SFFJ(c), inum);\n\t\tif (!inode) {\n\t\t\tjffs2_dbg(1, \"ilookup() failed for ino #%u; inode is probably deleted.\\n\",\n\t\t\t\t  inum);\n\n\t\t\tspin_lock(&c->inocache_lock);\n\t\t\tic = jffs2_get_ino_cache(c, inum);\n\t\t\tif (!ic) {\n\t\t\t\tjffs2_dbg(1, \"Inode cache for ino #%u is gone\\n\",\n\t\t\t\t\t  inum);\n\t\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (ic->state != INO_STATE_CHECKEDABSENT) {\n\t\t\t\t/* Wait for progress. Don't just loop */\n\t\t\t\tjffs2_dbg(1, \"Waiting for ino #%u in state %d\\n\",\n\t\t\t\t\t  ic->ino, ic->state);\n\t\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\t}\n\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\t/* Inode has links to it still; they're not going away because\n\t\t   jffs2_do_unlink() would need the alloc_sem and we have it.\n\t\t   Just iget() it, and if read_inode() is necessary that's OK.\n\t\t*/\n\t\tinode = jffs2_iget(OFNI_BS_2SFFJ(c), inum);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tpr_notice(\"Eep. read_inode() failed for ino #%u. unlinked %d\\n\",\n\t\t\t  inum, unlinked);\n\t\t/* NB. This will happen again. We need to do something appropriate here. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn JFFS2_INODE_INFO(inode);\n}"
  },
  {
    "function_name": "fs2_gc_release_inode(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "614-618",
    "snippet": "id jffs2_gc_release_inode(struct jffs2_sb_info *c,\n\t\t\t\t   struct jffs2_inode_info *f)\n{\n\tiput(OFNI_EDONI_2SFFJ(f));\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ut(O",
          "args": [
            "NI_EDONI_2SFFJ(f));"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NI_EDONI_2SFFJ(f",
          "args": [
            ")"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nid jffs2_gc_release_inode(struct jffs2_sb_info *c,\n\t\t\t\t   struct jffs2_inode_info *f)\n{\n\tiput(OFNI_EDONI_2SFFJ(f));\n}"
  },
  {
    "function_name": "fs2_do_fill_super(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "513-612",
    "snippet": "t jffs2_do_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct jffs2_sb_info *c;\n\tstruct inode *root_i;\n\tint ret;\n\tsize_t blocks;\n\n\tc = JFFS2_SB_INFO(sb);\n\n\t/* Do not support the MLC nand */\n\tif (c->mtd->type == MTD_MLCNANDFLASH)\n\t\treturn -EINVAL;\n\n#ifndef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (c->mtd->type == MTD_NANDFLASH) {\n\t\tpr_err(\"Cannot operate on NAND flash unless jffs2 NAND support is compiled in\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (c->mtd->type == MTD_DATAFLASH) {\n\t\tpr_err(\"Cannot operate on DataFlash unless jffs2 DataFlash support is compiled in\\n\");\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tc->flash_size = c->mtd->size;\n\tc->sector_size = c->mtd->erasesize;\n\tblocks = c->flash_size / c->sector_size;\n\n\t/*\n\t * Size alignment check\n\t */\n\tif ((c->sector_size * blocks) != c->flash_size) {\n\t\tc->flash_size = c->sector_size * blocks;\n\t\tpr_info(\"Flash size not aligned to erasesize, reducing to %dKiB\\n\",\n\t\t\tc->flash_size / 1024);\n\t}\n\n\tif (c->flash_size < 5*c->sector_size) {\n\t\tpr_err(\"Too few erase blocks (%d)\\n\",\n\t\t       c->flash_size / c->sector_size);\n\t\treturn -EINVAL;\n\t}\n\n\tc->cleanmarker_size = sizeof(struct jffs2_unknown_node);\n\n\t/* NAND (or other bizarre) flash... do setup accordingly */\n\tret = jffs2_flash_setup(c);\n\tif (ret)\n\t\treturn ret;\n\n\tc->inocache_hashsize = calculate_inocache_hashsize(c->flash_size);\n\tc->inocache_list = kcalloc(c->inocache_hashsize, sizeof(struct jffs2_inode_cache *), GFP_KERNEL);\n\tif (!c->inocache_list) {\n\t\tret = -ENOMEM;\n\t\tgoto out_wbuf;\n\t}\n\n\tjffs2_init_xattr_subsystem(c);\n\n\tif ((ret = jffs2_do_mount_fs(c)))\n\t\tgoto out_inohash;\n\n\tjffs2_dbg(1, \"%s(): Getting root inode\\n\", __func__);\n\troot_i = jffs2_iget(sb, 1);\n\tif (IS_ERR(root_i)) {\n\t\tjffs2_dbg(1, \"get root inode failed\\n\");\n\t\tret = PTR_ERR(root_i);\n\t\tgoto out_root;\n\t}\n\n\tret = -ENOMEM;\n\n\tjffs2_dbg(1, \"%s(): d_make_root()\\n\", __func__);\n\tsb->s_root = d_make_root(root_i);\n\tif (!sb->s_root)\n\t\tgoto out_root;\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = JFFS2_SUPER_MAGIC;\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tjffs2_start_garbage_collect_thread(c);\n\treturn 0;\n\nout_root:\n\tjffs2_free_ino_caches(c);\n\tjffs2_free_raw_node_refs(c);\n\tif (jffs2_blocks_use_vmalloc(c))\n\t\tvfree(c->blocks);\n\telse\n\t\tkfree(c->blocks);\n out_inohash:\n\tjffs2_clear_xattr_subsystem(c);\n\tkfree(c->inocache_list);\n out_wbuf:\n\tjffs2_flash_cleanup(c);\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_flash_cleanup(c",
          "args": [
            ";"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">inocache_list);"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_clear_xattr_subsystem(c",
          "args": [
            ";"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">blocks);"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(c",
          "args": [
            ">blocks);"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_blocks_use_vmalloc(c",
          "args": [
            ")"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_raw_node_refs(c",
          "args": [
            ";"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_ino_caches(c",
          "args": [
            ";"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_start_garbage_collect_thread(c",
          "args": [
            ";"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_root(r",
          "args": [
            "ot_i);"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): d_make_root()\\n\",",
            "func__);"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(r",
          "args": [
            "ot_i);"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "et root inode failed\\n\");"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(r",
          "args": [
            "ot_i))"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_iget(s",
          "args": [
            ",",
            ";"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "fs2_iget(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
          "lines": "250-369",
          "snippet": "ruct inode *jffs2_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_sb_info *c;\n\tstruct jffs2_raw_inode latest_node;\n\tunion jffs2_device_node jdev;\n\tstruct inode *inode;\n\tdev_t rdev = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(): ino == %lu\\n\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tf = JFFS2_INODE_INFO(inode);\n\tc = JFFS2_SB_INFO(inode->i_sb);\n\n\tjffs2_init_inode_info(f);\n\tmutex_lock(&f->sem);\n\n\tret = jffs2_do_read_inode(c, f, inode->i_ino, &latest_node);\n\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tinode->i_mode = jemode_to_cpu(latest_node.mode);\n\ti_uid_write(inode, je16_to_cpu(latest_node.uid));\n\ti_gid_write(inode, je16_to_cpu(latest_node.gid));\n\tinode->i_size = je32_to_cpu(latest_node.isize);\n\tinode->i_atime = ITIME(je32_to_cpu(latest_node.atime));\n\tinode->i_mtime = ITIME(je32_to_cpu(latest_node.mtime));\n\tinode->i_ctime = ITIME(je32_to_cpu(latest_node.ctime));\n\n\tset_nlink(inode, f->inocache->pino_nlink);\n\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &jffs2_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFDIR:\n\t{\n\t\tstruct jffs2_full_dirent *fd;\n\t\tset_nlink(inode, 2); /* parent and '.' */\n\n\t\tfor (fd=f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->type == DT_DIR && fd->ino)\n\t\t\t\tinc_nlink(inode);\n\t\t}\n\t\t/* Root dir gets i_nlink 3 for some reason */\n\t\tif (inode->i_ino == 1)\n\t\t\tinc_nlink(inode);\n\n\t\tinode->i_op = &jffs2_dir_inode_operations;\n\t\tinode->i_fop = &jffs2_dir_operations;\n\t\tbreak;\n\t}\n\tcase S_IFREG:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinode->i_fop = &jffs2_file_operations;\n\t\tinode->i_mapping->a_ops = &jffs2_file_address_operations;\n\t\tinode->i_mapping->nrpages = 0;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\t/* Read the device numbers from the media */\n\t\tif (f->metadata->size != sizeof(jdev.old_id) &&\n\t\t    f->metadata->size != sizeof(jdev.new_id)) {\n\t\t\tpr_notice(\"Device node has strange size %d\\n\",\n\t\t\t\t  f->metadata->size);\n\t\t\tgoto error_io;\n\t\t}\n\t\tjffs2_dbg(1, \"Reading device numbers from flash\\n\");\n\t\tret = jffs2_read_dnode(c, f, f->metadata, (char *)&jdev, 0, f->metadata->size);\n\t\tif (ret < 0) {\n\t\t\t/* Eep */\n\t\t\tpr_notice(\"Read device numbers for inode %lu failed\\n\",\n\t\t\t\t  (unsigned long)inode->i_ino);\n\t\t\tgoto error;\n\t\t}\n\t\tif (f->metadata->size == sizeof(jdev.old_id))\n\t\t\trdev = old_decode_dev(je16_to_cpu(jdev.old_id));\n\t\telse\n\t\t\trdev = new_decode_dev(je32_to_cpu(jdev.new_id));\n\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s(): Bogus i_mode %o for ino %lu\\n\",\n\t\t\t__func__, inode->i_mode, (unsigned long)inode->i_ino);\n\t}\n\n\tmutex_unlock(&f->sem);\n\n\tjffs2_dbg(1, \"jffs2_read_inode() returning\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror_io:\n\tret = -EIO;\nerror:\n\tmutex_unlock(&f->sem);\n\tjffs2_do_clear_inode(c, f);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "nclude \"nodelist.h\"\n\ns",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/vfs.h>\n#i",
            "nclude <linux/vmalloc.h>\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/list.h>\n#i",
            "nclude <linux/fs.h>\n#i",
            "nclude <linux/sched.h>\n#i",
            "nclude <linux/kernel.h>\n#i",
            "nclude <linux/capability.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [
            "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
          ],
          "called_functions": [],
          "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nruct inode *jffs2_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_sb_info *c;\n\tstruct jffs2_raw_inode latest_node;\n\tunion jffs2_device_node jdev;\n\tstruct inode *inode;\n\tdev_t rdev = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(): ino == %lu\\n\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tf = JFFS2_INODE_INFO(inode);\n\tc = JFFS2_SB_INFO(inode->i_sb);\n\n\tjffs2_init_inode_info(f);\n\tmutex_lock(&f->sem);\n\n\tret = jffs2_do_read_inode(c, f, inode->i_ino, &latest_node);\n\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tinode->i_mode = jemode_to_cpu(latest_node.mode);\n\ti_uid_write(inode, je16_to_cpu(latest_node.uid));\n\ti_gid_write(inode, je16_to_cpu(latest_node.gid));\n\tinode->i_size = je32_to_cpu(latest_node.isize);\n\tinode->i_atime = ITIME(je32_to_cpu(latest_node.atime));\n\tinode->i_mtime = ITIME(je32_to_cpu(latest_node.mtime));\n\tinode->i_ctime = ITIME(je32_to_cpu(latest_node.ctime));\n\n\tset_nlink(inode, f->inocache->pino_nlink);\n\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &jffs2_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFDIR:\n\t{\n\t\tstruct jffs2_full_dirent *fd;\n\t\tset_nlink(inode, 2); /* parent and '.' */\n\n\t\tfor (fd=f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->type == DT_DIR && fd->ino)\n\t\t\t\tinc_nlink(inode);\n\t\t}\n\t\t/* Root dir gets i_nlink 3 for some reason */\n\t\tif (inode->i_ino == 1)\n\t\t\tinc_nlink(inode);\n\n\t\tinode->i_op = &jffs2_dir_inode_operations;\n\t\tinode->i_fop = &jffs2_dir_operations;\n\t\tbreak;\n\t}\n\tcase S_IFREG:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinode->i_fop = &jffs2_file_operations;\n\t\tinode->i_mapping->a_ops = &jffs2_file_address_operations;\n\t\tinode->i_mapping->nrpages = 0;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\t/* Read the device numbers from the media */\n\t\tif (f->metadata->size != sizeof(jdev.old_id) &&\n\t\t    f->metadata->size != sizeof(jdev.new_id)) {\n\t\t\tpr_notice(\"Device node has strange size %d\\n\",\n\t\t\t\t  f->metadata->size);\n\t\t\tgoto error_io;\n\t\t}\n\t\tjffs2_dbg(1, \"Reading device numbers from flash\\n\");\n\t\tret = jffs2_read_dnode(c, f, f->metadata, (char *)&jdev, 0, f->metadata->size);\n\t\tif (ret < 0) {\n\t\t\t/* Eep */\n\t\t\tpr_notice(\"Read device numbers for inode %lu failed\\n\",\n\t\t\t\t  (unsigned long)inode->i_ino);\n\t\t\tgoto error;\n\t\t}\n\t\tif (f->metadata->size == sizeof(jdev.old_id))\n\t\t\trdev = old_decode_dev(je16_to_cpu(jdev.old_id));\n\t\telse\n\t\t\trdev = new_decode_dev(je32_to_cpu(jdev.new_id));\n\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s(): Bogus i_mode %o for ino %lu\\n\",\n\t\t\t__func__, inode->i_mode, (unsigned long)inode->i_ino);\n\t}\n\n\tmutex_unlock(&f->sem);\n\n\tjffs2_dbg(1, \"jffs2_read_inode() returning\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror_io:\n\tret = -EIO;\nerror:\n\tmutex_unlock(&f->sem);\n\tjffs2_do_clear_inode(c, f);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): Getting root inode\\n\",",
            "func__);"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_do_mount_fs(c",
          "args": [
            ")"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_init_xattr_subsystem(c",
          "args": [
            ";"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(c",
          "args": [
            ">inocache_hashsize,",
            "zeof(struct jffs2_inode_cache *),",
            "P_KERNEL);"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lculate_inocache_hashsize(c",
          "args": [
            ">flash_size);"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_setup(c",
          "args": [
            ";"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_err(\"",
          "args": [
            "oo few erase blocks (%d)\\n\",",
            ">flash_size / c->sector_size);"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_info(\"",
          "args": [
            "lash size not aligned to erasesize, reducing to %dKiB\\n\",",
            ">flash_size / 1024);"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_err(\"",
          "args": [
            "annot operate on DataFlash unless jffs2 DataFlash support is compiled in\\n\");"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_err(\"",
          "args": [
            "annot operate on NAND flash unless jffs2 NAND support is compiled in\\n\");"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_SB_INFO(s",
          "args": [
            ");"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nt jffs2_do_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct jffs2_sb_info *c;\n\tstruct inode *root_i;\n\tint ret;\n\tsize_t blocks;\n\n\tc = JFFS2_SB_INFO(sb);\n\n\t/* Do not support the MLC nand */\n\tif (c->mtd->type == MTD_MLCNANDFLASH)\n\t\treturn -EINVAL;\n\n#ifndef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (c->mtd->type == MTD_NANDFLASH) {\n\t\tpr_err(\"Cannot operate on NAND flash unless jffs2 NAND support is compiled in\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (c->mtd->type == MTD_DATAFLASH) {\n\t\tpr_err(\"Cannot operate on DataFlash unless jffs2 DataFlash support is compiled in\\n\");\n\t\treturn -EINVAL;\n\t}\n#endif\n\n\tc->flash_size = c->mtd->size;\n\tc->sector_size = c->mtd->erasesize;\n\tblocks = c->flash_size / c->sector_size;\n\n\t/*\n\t * Size alignment check\n\t */\n\tif ((c->sector_size * blocks) != c->flash_size) {\n\t\tc->flash_size = c->sector_size * blocks;\n\t\tpr_info(\"Flash size not aligned to erasesize, reducing to %dKiB\\n\",\n\t\t\tc->flash_size / 1024);\n\t}\n\n\tif (c->flash_size < 5*c->sector_size) {\n\t\tpr_err(\"Too few erase blocks (%d)\\n\",\n\t\t       c->flash_size / c->sector_size);\n\t\treturn -EINVAL;\n\t}\n\n\tc->cleanmarker_size = sizeof(struct jffs2_unknown_node);\n\n\t/* NAND (or other bizarre) flash... do setup accordingly */\n\tret = jffs2_flash_setup(c);\n\tif (ret)\n\t\treturn ret;\n\n\tc->inocache_hashsize = calculate_inocache_hashsize(c->flash_size);\n\tc->inocache_list = kcalloc(c->inocache_hashsize, sizeof(struct jffs2_inode_cache *), GFP_KERNEL);\n\tif (!c->inocache_list) {\n\t\tret = -ENOMEM;\n\t\tgoto out_wbuf;\n\t}\n\n\tjffs2_init_xattr_subsystem(c);\n\n\tif ((ret = jffs2_do_mount_fs(c)))\n\t\tgoto out_inohash;\n\n\tjffs2_dbg(1, \"%s(): Getting root inode\\n\", __func__);\n\troot_i = jffs2_iget(sb, 1);\n\tif (IS_ERR(root_i)) {\n\t\tjffs2_dbg(1, \"get root inode failed\\n\");\n\t\tret = PTR_ERR(root_i);\n\t\tgoto out_root;\n\t}\n\n\tret = -ENOMEM;\n\n\tjffs2_dbg(1, \"%s(): d_make_root()\\n\", __func__);\n\tsb->s_root = d_make_root(root_i);\n\tif (!sb->s_root)\n\t\tgoto out_root;\n\n\tsb->s_maxbytes = 0xFFFFFFFF;\n\tsb->s_blocksize = PAGE_CACHE_SIZE;\n\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\tsb->s_magic = JFFS2_SUPER_MAGIC;\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\tjffs2_start_garbage_collect_thread(c);\n\treturn 0;\n\nout_root:\n\tjffs2_free_ino_caches(c);\n\tjffs2_free_raw_node_refs(c);\n\tif (jffs2_blocks_use_vmalloc(c))\n\t\tvfree(c->blocks);\n\telse\n\t\tkfree(c->blocks);\n out_inohash:\n\tjffs2_clear_xattr_subsystem(c);\n\tkfree(c->inocache_list);\n out_wbuf:\n\tjffs2_flash_cleanup(c);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lculate_inocache_hashsize(u",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "493-511",
    "snippet": "atic int calculate_inocache_hashsize(uint32_t flash_size)\n{\n\t/*\n\t * Pick a inocache hash size based on the size of the medium.\n\t * Count how many megabytes we're dealing with, apply a hashsize twice\n\t * that size, but rounding down to the usual big powers of 2. And keep\n\t * to sensible bounds.\n\t */\n\n\tint size_mb = flash_size / 1024 / 1024;\n\tint hashsize = (size_mb * 2) & ~0x3f;\n\n\tif (hashsize < INOCACHE_HASHSIZE_MIN)\n\t\treturn INOCACHE_HASHSIZE_MIN;\n\tif (hashsize > INOCACHE_HASHSIZE_MAX)\n\t\treturn INOCACHE_HASHSIZE_MAX;\n\n\treturn hashsize;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int calculate_inocache_hashsize(uint32_t flash_size)\n{\n\t/*\n\t * Pick a inocache hash size based on the size of the medium.\n\t * Count how many megabytes we're dealing with, apply a hashsize twice\n\t * that size, but rounding down to the usual big powers of 2. And keep\n\t * to sensible bounds.\n\t */\n\n\tint size_mb = flash_size / 1024 / 1024;\n\tint hashsize = (size_mb * 2) & ~0x3f;\n\n\tif (hashsize < INOCACHE_HASHSIZE_MIN)\n\t\treturn INOCACHE_HASHSIZE_MIN;\n\tif (hashsize > INOCACHE_HASHSIZE_MAX)\n\t\treturn INOCACHE_HASHSIZE_MAX;\n\n\treturn hashsize;\n}"
  },
  {
    "function_name": "fs2_new_inode (",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "422-491",
    "snippet": "ruct inode *jffs2_new_inode (struct inode *dir_i, umode_t mode, struct jffs2_raw_inode *ri)\n{\n\tstruct inode *inode;\n\tstruct super_block *sb = dir_i->i_sb;\n\tstruct jffs2_sb_info *c;\n\tstruct jffs2_inode_info *f;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(): dir_i %ld, mode 0x%x\\n\",\n\t\t  __func__, dir_i->i_ino, mode);\n\n\tc = JFFS2_SB_INFO(sb);\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf = JFFS2_INODE_INFO(inode);\n\tjffs2_init_inode_info(f);\n\tmutex_lock(&f->sem);\n\n\tmemset(ri, 0, sizeof(*ri));\n\t/* Set OS-specific defaults for new inodes */\n\tri->uid = cpu_to_je16(from_kuid(&init_user_ns, current_fsuid()));\n\n\tif (dir_i->i_mode & S_ISGID) {\n\t\tri->gid = cpu_to_je16(i_gid_read(dir_i));\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else {\n\t\tri->gid = cpu_to_je16(from_kgid(&init_user_ns, current_fsgid()));\n\t}\n\n\t/* POSIX ACLs have to be processed now, at least partly.\n\t   The umask is only applied if there's no default ACL */\n\tret = jffs2_init_acl_pre(dir_i, inode, &mode);\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tret = jffs2_do_new_inode (c, f, mode, ri);\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tset_nlink(inode, 1);\n\tinode->i_ino = je32_to_cpu(ri->ino);\n\tinode->i_mode = jemode_to_cpu(ri->mode);\n\ti_gid_write(inode, je16_to_cpu(ri->gid));\n\ti_uid_write(inode, je16_to_cpu(ri->uid));\n\tinode->i_atime = inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tri->atime = ri->mtime = ri->ctime = cpu_to_je32(I_SEC(inode->i_mtime));\n\n\tinode->i_blocks = 0;\n\tinode->i_size = 0;\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "R_PTR(-",
          "args": [
            "INVAL);"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut(i",
          "args": [
            "ode);"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ke_bad_inode(i",
          "args": [
            "ode);"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sert_inode_locked(i",
          "args": [
            "ode)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(I",
          "args": [
            "SEC(inode->i_mtime));"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEC(i",
          "args": [
            "ode->i_mtime))"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_write(i",
          "args": [
            "ode,",
            "16_to_cpu(ri->uid));"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(r",
          "args": [
            "->uid))"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_write(i",
          "args": [
            "ode,",
            "16_to_cpu(ri->gid));"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(r",
          "args": [
            "->gid))"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mode_to_cpu(r",
          "args": [
            "->mode);"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            "->ino);"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_nlink(i",
          "args": [
            "ode,",
            ";"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_PTR(r",
          "args": [
            "t);"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut(i",
          "args": [
            "ode);"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ke_bad_inode(i",
          "args": [
            "ode);"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_do_new_inode (",
          "args": [
            "de,",
            ");"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_PTR(r",
          "args": [
            "t);"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut(i",
          "args": [
            "ode);"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ke_bad_inode(i",
          "args": [
            "ode);"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_init_acl_pre(d",
          "args": [
            "r_i,",
            "ode,",
            "ode);"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(f",
          "args": [
            "om_kgid(&init_user_ns, current_fsgid()));"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om_kgid(&",
          "args": [
            "nit_user_ns,",
            "rrent_fsgid()))"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrent_fsgid()",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISDIR(m",
          "args": [
            "de))"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(i",
          "args": [
            "gid_read(dir_i));"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_read(d",
          "args": [
            "r_i))"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(f",
          "args": [
            "om_kuid(&init_user_ns, current_fsuid()));"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om_kuid(&",
          "args": [
            "nit_user_ns,",
            "rrent_fsuid()))"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrent_fsuid()",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mset(r",
          "args": [
            ",",
            "zeof(*ri));"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->sem);"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_init_inode_info(f",
          "args": [
            ";"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_INODE_INFO(i",
          "args": [
            "ode);"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_PTR(-",
          "args": [
            "NOMEM);"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w_inode(s",
          "args": [
            ");"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_SB_INFO(s",
          "args": [
            ");"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): dir_i %ld, mode 0x%x\\n\",",
            "func__,",
            "r_i->i_ino,",
            "de);"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nruct inode *jffs2_new_inode (struct inode *dir_i, umode_t mode, struct jffs2_raw_inode *ri)\n{\n\tstruct inode *inode;\n\tstruct super_block *sb = dir_i->i_sb;\n\tstruct jffs2_sb_info *c;\n\tstruct jffs2_inode_info *f;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(): dir_i %ld, mode 0x%x\\n\",\n\t\t  __func__, dir_i->i_ino, mode);\n\n\tc = JFFS2_SB_INFO(sb);\n\n\tinode = new_inode(sb);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf = JFFS2_INODE_INFO(inode);\n\tjffs2_init_inode_info(f);\n\tmutex_lock(&f->sem);\n\n\tmemset(ri, 0, sizeof(*ri));\n\t/* Set OS-specific defaults for new inodes */\n\tri->uid = cpu_to_je16(from_kuid(&init_user_ns, current_fsuid()));\n\n\tif (dir_i->i_mode & S_ISGID) {\n\t\tri->gid = cpu_to_je16(i_gid_read(dir_i));\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else {\n\t\tri->gid = cpu_to_je16(from_kgid(&init_user_ns, current_fsgid()));\n\t}\n\n\t/* POSIX ACLs have to be processed now, at least partly.\n\t   The umask is only applied if there's no default ACL */\n\tret = jffs2_init_acl_pre(dir_i, inode, &mode);\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tret = jffs2_do_new_inode (c, f, mode, ri);\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tset_nlink(inode, 1);\n\tinode->i_ino = je32_to_cpu(ri->ino);\n\tinode->i_mode = jemode_to_cpu(ri->mode);\n\ti_gid_write(inode, je16_to_cpu(ri->gid));\n\ti_uid_write(inode, je16_to_cpu(ri->uid));\n\tinode->i_atime = inode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tri->atime = ri->mtime = ri->ctime = cpu_to_je32(I_SEC(inode->i_mtime));\n\n\tinode->i_blocks = 0;\n\tinode->i_size = 0;\n\n\tif (insert_inode_locked(inode) < 0) {\n\t\tmutex_unlock(&f->sem);\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "fs2_do_remount_fs(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "395-418",
    "snippet": "t jffs2_do_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(sb);\n\n\tif (c->flags & JFFS2_SB_FLAG_RO && !(sb->s_flags & MS_RDONLY))\n\t\treturn -EROFS;\n\n\t/* We stop if it was running, then restart if it needs to.\n\t   This also catches the case where it was stopped and this\n\t   is just a remount to restart it.\n\t   Flush the writebuffer, if neccecary, else we loose it */\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tjffs2_stop_garbage_collect_thread(c);\n\t\tmutex_lock(&c->alloc_sem);\n\t\tjffs2_flush_wbuf_pad(c);\n\t\tmutex_unlock(&c->alloc_sem);\n\t}\n\n\tif (!(*flags & MS_RDONLY))\n\t\tjffs2_start_garbage_collect_thread(c);\n\n\t*flags |= MS_NOATIME;\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_start_garbage_collect_thread(c",
          "args": [
            ";"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flush_wbuf_pad(c",
          "args": [
            ";"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_stop_garbage_collect_thread(c",
          "args": [
            ";"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_SB_INFO(s",
          "args": [
            ");"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nt jffs2_do_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(sb);\n\n\tif (c->flags & JFFS2_SB_FLAG_RO && !(sb->s_flags & MS_RDONLY))\n\t\treturn -EROFS;\n\n\t/* We stop if it was running, then restart if it needs to.\n\t   This also catches the case where it was stopped and this\n\t   is just a remount to restart it.\n\t   Flush the writebuffer, if neccecary, else we loose it */\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tjffs2_stop_garbage_collect_thread(c);\n\t\tmutex_lock(&c->alloc_sem);\n\t\tjffs2_flush_wbuf_pad(c);\n\t\tmutex_unlock(&c->alloc_sem);\n\t}\n\n\tif (!(*flags & MS_RDONLY))\n\t\tjffs2_start_garbage_collect_thread(c);\n\n\t*flags |= MS_NOATIME;\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_dirty_inode(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "371-393",
    "snippet": "id jffs2_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct iattr iattr;\n\n\tif (!(inode->i_state & I_DIRTY_DATASYNC)) {\n\t\tjffs2_dbg(2, \"%s(): not calling setattr() for ino #%lu\\n\",\n\t\t\t  __func__, inode->i_ino);\n\t\treturn;\n\t}\n\n\tjffs2_dbg(1, \"%s(): calling setattr() for ino #%lu\\n\",\n\t\t  __func__, inode->i_ino);\n\n\tiattr.ia_valid = ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_MTIME|ATTR_CTIME;\n\tiattr.ia_mode = inode->i_mode;\n\tiattr.ia_uid = inode->i_uid;\n\tiattr.ia_gid = inode->i_gid;\n\tiattr.ia_atime = inode->i_atime;\n\tiattr.ia_mtime = inode->i_mtime;\n\tiattr.ia_ctime = inode->i_ctime;\n\n\tjffs2_do_setattr(inode, &iattr);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_do_setattr(i",
          "args": [
            "ode,",
            "attr);"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): calling setattr() for ino #%lu\\n\",",
            "func__,",
            "ode->i_ino);"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(2",
          "args": [
            "s(): not calling setattr() for ino #%lu\\n\",",
            "func__,",
            "ode->i_ino);"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\nid jffs2_dirty_inode(struct inode *inode, int flags)\n{\n\tstruct iattr iattr;\n\n\tif (!(inode->i_state & I_DIRTY_DATASYNC)) {\n\t\tjffs2_dbg(2, \"%s(): not calling setattr() for ino #%lu\\n\",\n\t\t\t  __func__, inode->i_ino);\n\t\treturn;\n\t}\n\n\tjffs2_dbg(1, \"%s(): calling setattr() for ino #%lu\\n\",\n\t\t  __func__, inode->i_ino);\n\n\tiattr.ia_valid = ATTR_MODE|ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_MTIME|ATTR_CTIME;\n\tiattr.ia_mode = inode->i_mode;\n\tiattr.ia_uid = inode->i_uid;\n\tiattr.ia_gid = inode->i_gid;\n\tiattr.ia_atime = inode->i_atime;\n\tiattr.ia_mtime = inode->i_mtime;\n\tiattr.ia_ctime = inode->i_ctime;\n\n\tjffs2_do_setattr(inode, &iattr);\n}"
  },
  {
    "function_name": "fs2_iget(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "250-369",
    "snippet": "ruct inode *jffs2_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_sb_info *c;\n\tstruct jffs2_raw_inode latest_node;\n\tunion jffs2_device_node jdev;\n\tstruct inode *inode;\n\tdev_t rdev = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(): ino == %lu\\n\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tf = JFFS2_INODE_INFO(inode);\n\tc = JFFS2_SB_INFO(inode->i_sb);\n\n\tjffs2_init_inode_info(f);\n\tmutex_lock(&f->sem);\n\n\tret = jffs2_do_read_inode(c, f, inode->i_ino, &latest_node);\n\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tinode->i_mode = jemode_to_cpu(latest_node.mode);\n\ti_uid_write(inode, je16_to_cpu(latest_node.uid));\n\ti_gid_write(inode, je16_to_cpu(latest_node.gid));\n\tinode->i_size = je32_to_cpu(latest_node.isize);\n\tinode->i_atime = ITIME(je32_to_cpu(latest_node.atime));\n\tinode->i_mtime = ITIME(je32_to_cpu(latest_node.mtime));\n\tinode->i_ctime = ITIME(je32_to_cpu(latest_node.ctime));\n\n\tset_nlink(inode, f->inocache->pino_nlink);\n\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &jffs2_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFDIR:\n\t{\n\t\tstruct jffs2_full_dirent *fd;\n\t\tset_nlink(inode, 2); /* parent and '.' */\n\n\t\tfor (fd=f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->type == DT_DIR && fd->ino)\n\t\t\t\tinc_nlink(inode);\n\t\t}\n\t\t/* Root dir gets i_nlink 3 for some reason */\n\t\tif (inode->i_ino == 1)\n\t\t\tinc_nlink(inode);\n\n\t\tinode->i_op = &jffs2_dir_inode_operations;\n\t\tinode->i_fop = &jffs2_dir_operations;\n\t\tbreak;\n\t}\n\tcase S_IFREG:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinode->i_fop = &jffs2_file_operations;\n\t\tinode->i_mapping->a_ops = &jffs2_file_address_operations;\n\t\tinode->i_mapping->nrpages = 0;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\t/* Read the device numbers from the media */\n\t\tif (f->metadata->size != sizeof(jdev.old_id) &&\n\t\t    f->metadata->size != sizeof(jdev.new_id)) {\n\t\t\tpr_notice(\"Device node has strange size %d\\n\",\n\t\t\t\t  f->metadata->size);\n\t\t\tgoto error_io;\n\t\t}\n\t\tjffs2_dbg(1, \"Reading device numbers from flash\\n\");\n\t\tret = jffs2_read_dnode(c, f, f->metadata, (char *)&jdev, 0, f->metadata->size);\n\t\tif (ret < 0) {\n\t\t\t/* Eep */\n\t\t\tpr_notice(\"Read device numbers for inode %lu failed\\n\",\n\t\t\t\t  (unsigned long)inode->i_ino);\n\t\t\tgoto error;\n\t\t}\n\t\tif (f->metadata->size == sizeof(jdev.old_id))\n\t\t\trdev = old_decode_dev(je16_to_cpu(jdev.old_id));\n\t\telse\n\t\t\trdev = new_decode_dev(je32_to_cpu(jdev.new_id));\n\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s(): Bogus i_mode %o for ino %lu\\n\",\n\t\t\t__func__, inode->i_mode, (unsigned long)inode->i_ino);\n\t}\n\n\tmutex_unlock(&f->sem);\n\n\tjffs2_dbg(1, \"jffs2_read_inode() returning\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror_io:\n\tret = -EIO;\nerror:\n\tmutex_unlock(&f->sem);\n\tjffs2_do_clear_inode(c, f);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "R_PTR(r",
          "args": [
            "t);"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_failed(i",
          "args": [
            "ode);"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_do_clear_inode(c",
          "args": [
            ";"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_new_inode(i",
          "args": [
            "ode);"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ffs2_read_inode() returning\\n\");"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Bogus i_mode %o for ino %lu\\n\",",
            "func__,",
            "ode->i_mode,",
            "nsigned long)inode->i_ino);"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "it_special_inode(i",
          "args": [
            "ode,",
            "ode->i_mode,",
            "ev);"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w_decode_dev(j",
          "args": [
            "32_to_cpu(jdev.new_id));"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(j",
          "args": [
            "ev.new_id))"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_decode_dev(j",
          "args": [
            "16_to_cpu(jdev.old_id));"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(j",
          "args": [
            "ev.old_id))"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "ead device numbers for inode %lu failed\\n\",",
            "nsigned long)inode->i_ino);"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_read_dnode(c",
          "args": [
            ">metadata,",
            "har *)&jdev,",
            ">metadata->size);"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "eading device numbers from flash\\n\");"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "evice node has strange size %d\\n\",",
            ">metadata->size);"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c_nlink(i",
          "args": [
            "ode);"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c_nlink(i",
          "args": [
            "ode);"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_nlink(i",
          "args": [
            "ode,",
            ";"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_nlink(i",
          "args": [
            "ode,",
            ">inocache->pino_nlink);"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IME(j",
          "args": [
            "32_to_cpu(latest_node.ctime));"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(l",
          "args": [
            "test_node.ctime))"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IME(j",
          "args": [
            "32_to_cpu(latest_node.mtime));"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(l",
          "args": [
            "test_node.mtime))"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IME(j",
          "args": [
            "32_to_cpu(latest_node.atime));"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(l",
          "args": [
            "test_node.atime))"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(l",
          "args": [
            "test_node.isize);"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_write(i",
          "args": [
            "ode,",
            "16_to_cpu(latest_node.gid));"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(l",
          "args": [
            "test_node.gid))"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_write(i",
          "args": [
            "ode,",
            "16_to_cpu(latest_node.uid));"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(l",
          "args": [
            "test_node.uid))"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mode_to_cpu(l",
          "args": [
            "test_node.mode);"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_PTR(r",
          "args": [
            "t);"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_failed(i",
          "args": [
            "ode);"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_do_read_inode(c",
          "args": [
            "ode->i_ino,",
            "atest_node);"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->sem);"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_init_inode_info(f",
          "args": [
            ";"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_SB_INFO(i",
          "args": [
            "ode->i_sb);"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_INODE_INFO(i",
          "args": [
            "ode);"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_PTR(-",
          "args": [
            "NOMEM);"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_locked(s",
          "args": [
            ",",
            "o);"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): ino == %lu\\n\",",
            "func__,",
            "o);"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nruct inode *jffs2_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_sb_info *c;\n\tstruct jffs2_raw_inode latest_node;\n\tunion jffs2_device_node jdev;\n\tstruct inode *inode;\n\tdev_t rdev = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(): ino == %lu\\n\", __func__, ino);\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tf = JFFS2_INODE_INFO(inode);\n\tc = JFFS2_SB_INFO(inode->i_sb);\n\n\tjffs2_init_inode_info(f);\n\tmutex_lock(&f->sem);\n\n\tret = jffs2_do_read_inode(c, f, inode->i_ino, &latest_node);\n\n\tif (ret) {\n\t\tmutex_unlock(&f->sem);\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(ret);\n\t}\n\tinode->i_mode = jemode_to_cpu(latest_node.mode);\n\ti_uid_write(inode, je16_to_cpu(latest_node.uid));\n\ti_gid_write(inode, je16_to_cpu(latest_node.gid));\n\tinode->i_size = je32_to_cpu(latest_node.isize);\n\tinode->i_atime = ITIME(je32_to_cpu(latest_node.atime));\n\tinode->i_mtime = ITIME(je32_to_cpu(latest_node.mtime));\n\tinode->i_ctime = ITIME(je32_to_cpu(latest_node.ctime));\n\n\tset_nlink(inode, f->inocache->pino_nlink);\n\n\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\n\tcase S_IFLNK:\n\t\tinode->i_op = &jffs2_symlink_inode_operations;\n\t\tbreak;\n\n\tcase S_IFDIR:\n\t{\n\t\tstruct jffs2_full_dirent *fd;\n\t\tset_nlink(inode, 2); /* parent and '.' */\n\n\t\tfor (fd=f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->type == DT_DIR && fd->ino)\n\t\t\t\tinc_nlink(inode);\n\t\t}\n\t\t/* Root dir gets i_nlink 3 for some reason */\n\t\tif (inode->i_ino == 1)\n\t\t\tinc_nlink(inode);\n\n\t\tinode->i_op = &jffs2_dir_inode_operations;\n\t\tinode->i_fop = &jffs2_dir_operations;\n\t\tbreak;\n\t}\n\tcase S_IFREG:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinode->i_fop = &jffs2_file_operations;\n\t\tinode->i_mapping->a_ops = &jffs2_file_address_operations;\n\t\tinode->i_mapping->nrpages = 0;\n\t\tbreak;\n\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\t/* Read the device numbers from the media */\n\t\tif (f->metadata->size != sizeof(jdev.old_id) &&\n\t\t    f->metadata->size != sizeof(jdev.new_id)) {\n\t\t\tpr_notice(\"Device node has strange size %d\\n\",\n\t\t\t\t  f->metadata->size);\n\t\t\tgoto error_io;\n\t\t}\n\t\tjffs2_dbg(1, \"Reading device numbers from flash\\n\");\n\t\tret = jffs2_read_dnode(c, f, f->metadata, (char *)&jdev, 0, f->metadata->size);\n\t\tif (ret < 0) {\n\t\t\t/* Eep */\n\t\t\tpr_notice(\"Read device numbers for inode %lu failed\\n\",\n\t\t\t\t  (unsigned long)inode->i_ino);\n\t\t\tgoto error;\n\t\t}\n\t\tif (f->metadata->size == sizeof(jdev.old_id))\n\t\t\trdev = old_decode_dev(je16_to_cpu(jdev.old_id));\n\t\telse\n\t\t\trdev = new_decode_dev(je32_to_cpu(jdev.new_id));\n\n\tcase S_IFSOCK:\n\tcase S_IFIFO:\n\t\tinode->i_op = &jffs2_file_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s(): Bogus i_mode %o for ino %lu\\n\",\n\t\t\t__func__, inode->i_mode, (unsigned long)inode->i_ino);\n\t}\n\n\tmutex_unlock(&f->sem);\n\n\tjffs2_dbg(1, \"jffs2_read_inode() returning\\n\");\n\tunlock_new_inode(inode);\n\treturn inode;\n\nerror_io:\n\tret = -EIO;\nerror:\n\tmutex_unlock(&f->sem);\n\tjffs2_do_clear_inode(c, f);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "fs2_evict_inode (",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "235-248",
    "snippet": "id jffs2_evict_inode (struct inode *inode)\n{\n\t/* We can forget about this inode for now - drop all\n\t *  the nodelists associated with it, etc.\n\t */\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\n\tjffs2_dbg(1, \"%s(): ino #%lu mode %o\\n\",\n\t\t  __func__, inode->i_ino, inode->i_mode);\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tjffs2_do_clear_inode(c, f);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_do_clear_inode(c",
          "args": [
            ";"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ear_inode(i",
          "args": [
            "ode);"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uncate_inode_pages_final(&",
          "args": [
            "node->i_data);"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): ino #%lu mode %o\\n\",",
            "func__,",
            "ode->i_ino,",
            "ode->i_mode);"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_INODE_INFO(i",
          "args": [
            "ode);"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_SB_INFO(i",
          "args": [
            "ode->i_sb);"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nid jffs2_evict_inode (struct inode *inode)\n{\n\t/* We can forget about this inode for now - drop all\n\t *  the nodelists associated with it, etc.\n\t */\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\n\tjffs2_dbg(1, \"%s(): ino #%lu mode %o\\n\",\n\t\t  __func__, inode->i_ino, inode->i_mode);\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tjffs2_do_clear_inode(c, f);\n}"
  },
  {
    "function_name": "fs2_statfs(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "207-232",
    "snippet": "t jffs2_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(dentry->d_sb);\n\tunsigned long avail;\n\n\tbuf->f_type = JFFS2_SUPER_MAGIC;\n\tbuf->f_bsize = 1 << PAGE_SHIFT;\n\tbuf->f_blocks = c->flash_size >> PAGE_SHIFT;\n\tbuf->f_files = 0;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = JFFS2_MAX_NAME_LEN;\n\tbuf->f_fsid.val[0] = JFFS2_SUPER_MAGIC;\n\tbuf->f_fsid.val[1] = c->mtd->index;\n\n\tspin_lock(&c->erase_completion_lock);\n\tavail = c->dirty_size + c->free_size;\n\tif (avail > c->sector_size * c->resv_blocks_write)\n\t\tavail -= c->sector_size * c->resv_blocks_write;\n\telse\n\t\tavail = 0;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tbuf->f_bavail = buf->f_bfree = avail >> PAGE_SHIFT;\n\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_SB_INFO(d",
          "args": [
            "ntry->d_sb);"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nt jffs2_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(dentry->d_sb);\n\tunsigned long avail;\n\n\tbuf->f_type = JFFS2_SUPER_MAGIC;\n\tbuf->f_bsize = 1 << PAGE_SHIFT;\n\tbuf->f_blocks = c->flash_size >> PAGE_SHIFT;\n\tbuf->f_files = 0;\n\tbuf->f_ffree = 0;\n\tbuf->f_namelen = JFFS2_MAX_NAME_LEN;\n\tbuf->f_fsid.val[0] = JFFS2_SUPER_MAGIC;\n\tbuf->f_fsid.val[1] = c->mtd->index;\n\n\tspin_lock(&c->erase_completion_lock);\n\tavail = c->dirty_size + c->free_size;\n\tif (avail > c->sector_size * c->resv_blocks_write)\n\t\tavail -= c->sector_size * c->resv_blocks_write;\n\telse\n\t\tavail = 0;\n\tspin_unlock(&c->erase_completion_lock);\n\n\tbuf->f_bavail = buf->f_bfree = avail >> PAGE_SHIFT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_setattr(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "191-205",
    "snippet": "t jffs2_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint rc;\n\n\trc = inode_change_ok(inode, iattr);\n\tif (rc)\n\t\treturn rc;\n\n\trc = jffs2_do_setattr(inode, iattr);\n\tif (!rc && (iattr->ia_valid & ATTR_MODE))\n\t\trc = posix_acl_chmod(inode, inode->i_mode);\n\n\treturn rc;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "six_acl_chmod(i",
          "args": [
            "ode,",
            "ode->i_mode);"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_do_setattr(i",
          "args": [
            "ode,",
            "ttr);"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode_change_ok(i",
          "args": [
            "ode,",
            "ttr);"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\nt jffs2_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint rc;\n\n\trc = inode_change_ok(inode, iattr);\n\tif (rc)\n\t\treturn rc;\n\n\trc = jffs2_do_setattr(inode, iattr);\n\tif (!rc && (iattr->ia_valid & ATTR_MODE))\n\t\trc = posix_acl_chmod(inode, inode->i_mode);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "fs2_do_setattr (",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
    "lines": "30-189",
    "snippet": "t jffs2_do_setattr (struct inode *inode, struct iattr *iattr)\n{\n\tstruct jffs2_full_dnode *old_metadata, *new_metadata;\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_raw_inode *ri;\n\tunion jffs2_device_node dev;\n\tunsigned char *mdata = NULL;\n\tint mdatalen = 0;\n\tunsigned int ivalid;\n\tuint32_t alloclen;\n\tint ret;\n\tint alloc_type = ALLOC_NORMAL;\n\n\tjffs2_dbg(1, \"%s(): ino #%lu\\n\", __func__, inode->i_ino);\n\n\t/* Special cases - we don't want more than one data node\n\t   for these types on the medium at any time. So setattr\n\t   must read the original data associated with the node\n\t   (i.e. the device numbers or the target name) and write\n\t   it out again with the appropriate data attached */\n\tif (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)) {\n\t\t/* For these, we don't actually need to read the old node */\n\t\tmdatalen = jffs2_encode_dev(&dev, inode->i_rdev);\n\t\tmdata = (char *)&dev;\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of kdev_t\\n\",\n\t\t\t  __func__, mdatalen);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tmutex_lock(&f->sem);\n\t\tmdatalen = f->metadata->size;\n\t\tmdata = kmalloc(f->metadata->size, GFP_USER);\n\t\tif (!mdata) {\n\t\t\tmutex_unlock(&f->sem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = jffs2_read_dnode(c, f, f->metadata, mdata, 0, mdatalen);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tkfree(mdata);\n\t\t\treturn ret;\n\t\t}\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of symlink target\\n\",\n\t\t\t  __func__, mdatalen);\n\t}\n\n\tri = jffs2_alloc_raw_inode();\n\tif (!ri) {\n\t\tif (S_ISLNK(inode->i_mode))\n\t\t\tkfree(mdata);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = jffs2_reserve_space(c, sizeof(*ri) + mdatalen, &alloclen,\n\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tjffs2_free_raw_inode(ri);\n\t\tif (S_ISLNK(inode->i_mode))\n\t\t\t kfree(mdata);\n\t\treturn ret;\n\t}\n\tmutex_lock(&f->sem);\n\tivalid = iattr->ia_valid;\n\n\tri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\tri->totlen = cpu_to_je32(sizeof(*ri) + mdatalen);\n\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\n\tri->ino = cpu_to_je32(inode->i_ino);\n\tri->version = cpu_to_je32(++f->highest_version);\n\n\tri->uid = cpu_to_je16((ivalid & ATTR_UID)?\n\t\tfrom_kuid(&init_user_ns, iattr->ia_uid):i_uid_read(inode));\n\tri->gid = cpu_to_je16((ivalid & ATTR_GID)?\n\t\tfrom_kgid(&init_user_ns, iattr->ia_gid):i_gid_read(inode));\n\n\tif (ivalid & ATTR_MODE)\n\t\tri->mode = cpu_to_jemode(iattr->ia_mode);\n\telse\n\t\tri->mode = cpu_to_jemode(inode->i_mode);\n\n\n\tri->isize = cpu_to_je32((ivalid & ATTR_SIZE)?iattr->ia_size:inode->i_size);\n\tri->atime = cpu_to_je32(I_SEC((ivalid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime));\n\tri->mtime = cpu_to_je32(I_SEC((ivalid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime));\n\tri->ctime = cpu_to_je32(I_SEC((ivalid & ATTR_CTIME)?iattr->ia_ctime:inode->i_ctime));\n\n\tri->offset = cpu_to_je32(0);\n\tri->csize = ri->dsize = cpu_to_je32(mdatalen);\n\tri->compr = JFFS2_COMPR_NONE;\n\tif (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {\n\t\t/* It's an extension. Make it a hole node */\n\t\tri->compr = JFFS2_COMPR_ZERO;\n\t\tri->dsize = cpu_to_je32(iattr->ia_size - inode->i_size);\n\t\tri->offset = cpu_to_je32(inode->i_size);\n\t} else if (ivalid & ATTR_SIZE && !iattr->ia_size) {\n\t\t/* For truncate-to-zero, treat it as deletion because\n\t\t   it'll always be obsoleting all previous nodes */\n\t\talloc_type = ALLOC_DELETION;\n\t}\n\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\tif (mdatalen)\n\t\tri->data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));\n\telse\n\t\tri->data_crc = cpu_to_je32(0);\n\n\tnew_metadata = jffs2_write_dnode(c, f, ri, mdata, mdatalen, alloc_type);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(mdata);\n\n\tif (IS_ERR(new_metadata)) {\n\t\tjffs2_complete_reservation(c);\n\t\tjffs2_free_raw_inode(ri);\n\t\tmutex_unlock(&f->sem);\n\t\treturn PTR_ERR(new_metadata);\n\t}\n\t/* It worked. Update the inode */\n\tinode->i_atime = ITIME(je32_to_cpu(ri->atime));\n\tinode->i_ctime = ITIME(je32_to_cpu(ri->ctime));\n\tinode->i_mtime = ITIME(je32_to_cpu(ri->mtime));\n\tinode->i_mode = jemode_to_cpu(ri->mode);\n\ti_uid_write(inode, je16_to_cpu(ri->uid));\n\ti_gid_write(inode, je16_to_cpu(ri->gid));\n\n\n\told_metadata = f->metadata;\n\n\tif (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size)\n\t\tjffs2_truncate_fragtree (c, &f->fragtree, iattr->ia_size);\n\n\tif (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {\n\t\tjffs2_add_full_dnode_to_inode(c, f, new_metadata);\n\t\tinode->i_size = iattr->ia_size;\n\t\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\t\tf->metadata = NULL;\n\t} else {\n\t\tf->metadata = new_metadata;\n\t}\n\tif (old_metadata) {\n\t\tjffs2_mark_node_obsolete(c, old_metadata->raw);\n\t\tjffs2_free_full_dnode(old_metadata);\n\t}\n\tjffs2_free_raw_inode(ri);\n\n\tmutex_unlock(&f->sem);\n\tjffs2_complete_reservation(c);\n\n\t/* We have to do the truncate_setsize() without f->sem held, since\n\t   some pages may be locked and waiting for it in readpage().\n\t   We are protected from a simultaneous write() extending i_size\n\t   back past iattr->ia_size, because do_truncate() holds the\n\t   generic inode semaphore. */\n\tif (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size) {\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\t}\t\n\n\treturn 0;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/vfs.h>\n#i",
      "nclude <linux/vmalloc.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/list.h>\n#i",
      "nclude <linux/fs.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/kernel.h>\n#i",
      "nclude <linux/capability.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_flash_setup(struct jffs2_sb_info *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uncate_setsize(i",
          "args": [
            "ode,",
            "ttr->ia_size);"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_complete_reservation(c",
          "args": [
            ";"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_raw_inode(r",
          "args": [
            ");"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dnode(o",
          "args": [
            "d_metadata);"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            "d_metadata->raw);"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_add_full_dnode_to_inode(c",
          "args": [
            "w_metadata);"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_truncate_fragtree (",
          "args": [
            "->fragtree,",
            "ttr->ia_size);"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_write(i",
          "args": [
            "ode,",
            "16_to_cpu(ri->gid));"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(r",
          "args": [
            "->gid))"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_write(i",
          "args": [
            "ode,",
            "16_to_cpu(ri->uid));"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(r",
          "args": [
            "->uid))"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mode_to_cpu(r",
          "args": [
            "->mode);"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IME(j",
          "args": [
            "32_to_cpu(ri->mtime));"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            "->mtime))"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IME(j",
          "args": [
            "32_to_cpu(ri->ctime));"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            "->ctime))"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IME(j",
          "args": [
            "32_to_cpu(ri->atime));"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            "->atime))"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_metadata);"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_raw_inode(r",
          "args": [
            ");"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_complete_reservation(c",
          "args": [
            ";"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(n",
          "args": [
            "w_metadata))"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(m",
          "args": [
            "ata);"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISLNK(i",
          "args": [
            "ode->i_mode))"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_write_dnode(c",
          "args": [
            ",",
            "ata,",
            "atalen,",
            "loc_type);"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(0",
          "args": [
            ";"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, mdata, mdatalen));"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "ata,",
            "atalen))"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, ri, sizeof(*ri)-8));"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            ",",
            "zeof(*ri)-8))"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(i",
          "args": [
            "ode->i_size);"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(i",
          "args": [
            "ttr->ia_size - inode->i_size);"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(m",
          "args": [
            "atalen);"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(0",
          "args": [
            ";"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(I",
          "args": [
            "SEC((ivalid & ATTR_CTIME)?iattr->ia_ctime:inode->i_ctime));"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEC((",
          "args": [
            "valid & ATTR_CTIME)?iattr->ia_ctime:inode->i_ctime))"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(I",
          "args": [
            "SEC((ivalid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime));"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEC((",
          "args": [
            "valid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime))"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(I",
          "args": [
            "SEC((ivalid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime));"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEC((",
          "args": [
            "valid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime))"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32((",
          "args": [
            "valid & ATTR_SIZE)?iattr->ia_size:inode->i_size);"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_jemode(i",
          "args": [
            "ode->i_mode);"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_jemode(i",
          "args": [
            "ttr->ia_mode);"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16((",
          "args": [
            "valid & ATTR_GID)?\n\t\tfrom_kgid(&init_user_ns, iattr->ia_gid):i_gid_read(inode));"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_read(i",
          "args": [
            "ode))"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om_kgid(&",
          "args": [
            "nit_user_ns,",
            "ttr->ia_gid):"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16((",
          "args": [
            "valid & ATTR_UID)?\n\t\tfrom_kuid(&init_user_ns, iattr->ia_uid):i_uid_read(inode));"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_read(i",
          "args": [
            "ode))"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "om_kuid(&",
          "args": [
            "nit_user_ns,",
            "ttr->ia_uid):"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(+",
          "args": [
            "f->highest_version);"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(i",
          "args": [
            "ode->i_ino);"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, ri, sizeof(struct jffs2_unknown_node)-4));"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            ",",
            "zeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(s",
          "args": [
            "zeof(*ri) + mdatalen);"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_NODETYPE_INODE);"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_MAGIC_BITMASK);"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->sem);"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(m",
          "args": [
            "ata);"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISLNK(i",
          "args": [
            "ode->i_mode))"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_raw_inode(r",
          "args": [
            ");"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_reserve_space(c",
          "args": [
            "zeof(*ri) + mdatalen,",
            "lloclen,",
            "LOC_NORMAL,",
            "FS2_SUMMARY_INODE_SIZE);"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(m",
          "args": [
            "ata);"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISLNK(i",
          "args": [
            "ode->i_mode))"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_alloc_raw_inode()",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): Writing %d bytes of symlink target\\n\",",
            "func__,",
            "atalen);"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(m",
          "args": [
            "ata);"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_read_dnode(c",
          "args": [
            ">metadata,",
            "ata,",
            "atalen);"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(f",
          "args": [
            ">metadata->size,",
            "P_USER);"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->sem);"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISLNK(i",
          "args": [
            "ode->i_mode))"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): Writing %d bytes of kdev_t\\n\",",
            "func__,",
            "atalen);"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_encode_dev(&",
          "args": [
            "ev,",
            "ode->i_rdev);"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISCHR(i",
          "args": [
            "ode->i_mode))"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISBLK(i",
          "args": [
            "ode->i_mode)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): ino #%lu\\n\",",
            "func__,",
            "ode->i_ino);"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_SB_INFO(i",
          "args": [
            "ode->i_sb);"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_INODE_INFO(i",
          "args": [
            "ode);"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int jffs2_flash_setup(struct jffs2_sb_info *c);\n\nt jffs2_do_setattr (struct inode *inode, struct iattr *iattr)\n{\n\tstruct jffs2_full_dnode *old_metadata, *new_metadata;\n\tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n\tstruct jffs2_sb_info *c = JFFS2_SB_INFO(inode->i_sb);\n\tstruct jffs2_raw_inode *ri;\n\tunion jffs2_device_node dev;\n\tunsigned char *mdata = NULL;\n\tint mdatalen = 0;\n\tunsigned int ivalid;\n\tuint32_t alloclen;\n\tint ret;\n\tint alloc_type = ALLOC_NORMAL;\n\n\tjffs2_dbg(1, \"%s(): ino #%lu\\n\", __func__, inode->i_ino);\n\n\t/* Special cases - we don't want more than one data node\n\t   for these types on the medium at any time. So setattr\n\t   must read the original data associated with the node\n\t   (i.e. the device numbers or the target name) and write\n\t   it out again with the appropriate data attached */\n\tif (S_ISBLK(inode->i_mode) || S_ISCHR(inode->i_mode)) {\n\t\t/* For these, we don't actually need to read the old node */\n\t\tmdatalen = jffs2_encode_dev(&dev, inode->i_rdev);\n\t\tmdata = (char *)&dev;\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of kdev_t\\n\",\n\t\t\t  __func__, mdatalen);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tmutex_lock(&f->sem);\n\t\tmdatalen = f->metadata->size;\n\t\tmdata = kmalloc(f->metadata->size, GFP_USER);\n\t\tif (!mdata) {\n\t\t\tmutex_unlock(&f->sem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = jffs2_read_dnode(c, f, f->metadata, mdata, 0, mdatalen);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tkfree(mdata);\n\t\t\treturn ret;\n\t\t}\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of symlink target\\n\",\n\t\t\t  __func__, mdatalen);\n\t}\n\n\tri = jffs2_alloc_raw_inode();\n\tif (!ri) {\n\t\tif (S_ISLNK(inode->i_mode))\n\t\t\tkfree(mdata);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = jffs2_reserve_space(c, sizeof(*ri) + mdatalen, &alloclen,\n\t\t\t\t  ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tjffs2_free_raw_inode(ri);\n\t\tif (S_ISLNK(inode->i_mode))\n\t\t\t kfree(mdata);\n\t\treturn ret;\n\t}\n\tmutex_lock(&f->sem);\n\tivalid = iattr->ia_valid;\n\n\tri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\tri->totlen = cpu_to_je32(sizeof(*ri) + mdatalen);\n\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\n\tri->ino = cpu_to_je32(inode->i_ino);\n\tri->version = cpu_to_je32(++f->highest_version);\n\n\tri->uid = cpu_to_je16((ivalid & ATTR_UID)?\n\t\tfrom_kuid(&init_user_ns, iattr->ia_uid):i_uid_read(inode));\n\tri->gid = cpu_to_je16((ivalid & ATTR_GID)?\n\t\tfrom_kgid(&init_user_ns, iattr->ia_gid):i_gid_read(inode));\n\n\tif (ivalid & ATTR_MODE)\n\t\tri->mode = cpu_to_jemode(iattr->ia_mode);\n\telse\n\t\tri->mode = cpu_to_jemode(inode->i_mode);\n\n\n\tri->isize = cpu_to_je32((ivalid & ATTR_SIZE)?iattr->ia_size:inode->i_size);\n\tri->atime = cpu_to_je32(I_SEC((ivalid & ATTR_ATIME)?iattr->ia_atime:inode->i_atime));\n\tri->mtime = cpu_to_je32(I_SEC((ivalid & ATTR_MTIME)?iattr->ia_mtime:inode->i_mtime));\n\tri->ctime = cpu_to_je32(I_SEC((ivalid & ATTR_CTIME)?iattr->ia_ctime:inode->i_ctime));\n\n\tri->offset = cpu_to_je32(0);\n\tri->csize = ri->dsize = cpu_to_je32(mdatalen);\n\tri->compr = JFFS2_COMPR_NONE;\n\tif (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {\n\t\t/* It's an extension. Make it a hole node */\n\t\tri->compr = JFFS2_COMPR_ZERO;\n\t\tri->dsize = cpu_to_je32(iattr->ia_size - inode->i_size);\n\t\tri->offset = cpu_to_je32(inode->i_size);\n\t} else if (ivalid & ATTR_SIZE && !iattr->ia_size) {\n\t\t/* For truncate-to-zero, treat it as deletion because\n\t\t   it'll always be obsoleting all previous nodes */\n\t\talloc_type = ALLOC_DELETION;\n\t}\n\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\tif (mdatalen)\n\t\tri->data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));\n\telse\n\t\tri->data_crc = cpu_to_je32(0);\n\n\tnew_metadata = jffs2_write_dnode(c, f, ri, mdata, mdatalen, alloc_type);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(mdata);\n\n\tif (IS_ERR(new_metadata)) {\n\t\tjffs2_complete_reservation(c);\n\t\tjffs2_free_raw_inode(ri);\n\t\tmutex_unlock(&f->sem);\n\t\treturn PTR_ERR(new_metadata);\n\t}\n\t/* It worked. Update the inode */\n\tinode->i_atime = ITIME(je32_to_cpu(ri->atime));\n\tinode->i_ctime = ITIME(je32_to_cpu(ri->ctime));\n\tinode->i_mtime = ITIME(je32_to_cpu(ri->mtime));\n\tinode->i_mode = jemode_to_cpu(ri->mode);\n\ti_uid_write(inode, je16_to_cpu(ri->uid));\n\ti_gid_write(inode, je16_to_cpu(ri->gid));\n\n\n\told_metadata = f->metadata;\n\n\tif (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size)\n\t\tjffs2_truncate_fragtree (c, &f->fragtree, iattr->ia_size);\n\n\tif (ivalid & ATTR_SIZE && inode->i_size < iattr->ia_size) {\n\t\tjffs2_add_full_dnode_to_inode(c, f, new_metadata);\n\t\tinode->i_size = iattr->ia_size;\n\t\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\t\tf->metadata = NULL;\n\t} else {\n\t\tf->metadata = new_metadata;\n\t}\n\tif (old_metadata) {\n\t\tjffs2_mark_node_obsolete(c, old_metadata->raw);\n\t\tjffs2_free_full_dnode(old_metadata);\n\t}\n\tjffs2_free_raw_inode(ri);\n\n\tmutex_unlock(&f->sem);\n\tjffs2_complete_reservation(c);\n\n\t/* We have to do the truncate_setsize() without f->sem held, since\n\t   some pages may be locked and waiting for it in readpage().\n\t   We are protected from a simultaneous write() extending i_size\n\t   back past iattr->ia_size, because do_truncate() holds the\n\t   generic inode semaphore. */\n\tif (ivalid & ATTR_SIZE && inode->i_size > iattr->ia_size) {\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\t\tinode->i_blocks = (inode->i_size + 511) >> 9;\n\t}\t\n\n\treturn 0;\n}"
  }
]