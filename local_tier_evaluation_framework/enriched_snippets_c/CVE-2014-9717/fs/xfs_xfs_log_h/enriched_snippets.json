[
  {
    "function_name": "_lsn_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
    "lines": "100-109",
    "snippet": "static inline xfs_lsn_t\t_lsn_cmp(xfs_lsn_t lsn1, xfs_lsn_t lsn2)\n{\n\tif (CYCLE_LSN(lsn1) != CYCLE_LSN(lsn2))\n\t\treturn (CYCLE_LSN(lsn1)<CYCLE_LSN(lsn2))? -999 : 999;\n\n\tif (BLOCK_LSN(lsn1) != BLOCK_LSN(lsn2))\n\t\treturn (BLOCK_LSN(lsn1)<BLOCK_LSN(lsn2))? -999 : 999;\n\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "lsn2"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "lsn1"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "lsn2"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BLOCK_LSN",
          "args": [
            "lsn1"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN",
          "args": [
            "lsn2"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN",
          "args": [
            "lsn1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN",
          "args": [
            "lsn2"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CYCLE_LSN",
          "args": [
            "lsn1"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline xfs_lsn_t\t_lsn_cmp(xfs_lsn_t lsn1, xfs_lsn_t lsn2)\n{\n\tif (CYCLE_LSN(lsn1) != CYCLE_LSN(lsn2))\n\t\treturn (CYCLE_LSN(lsn1)<CYCLE_LSN(lsn2))? -999 : 999;\n\n\tif (BLOCK_LSN(lsn1) != BLOCK_LSN(lsn2))\n\t\treturn (BLOCK_LSN(lsn1)<BLOCK_LSN(lsn2))? -999 : 999;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xlog_copy_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
    "lines": "74-84",
    "snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_finish_iovec",
          "args": [
            "lv",
            "*vecp",
            "len"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_finish_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "66-72",
          "snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "data",
            "len"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_prepare_iovec",
          "args": [
            "lv",
            "vecp",
            "type"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_prepare_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
          "lines": "34-54",
          "snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline void *\nxlog_copy_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type, void *data, int len)\n{\n\tvoid *buf;\n\n\tbuf = xlog_prepare_iovec(lv, vecp, type);\n\tmemcpy(buf, data, len);\n\txlog_finish_iovec(lv, *vecp, len);\n\treturn buf;\n}"
  },
  {
    "function_name": "xlog_finish_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
    "lines": "66-72",
    "snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "len",
            "sizeof(uint64_t)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline void\nxlog_finish_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec *vec, int len)\n{\n\tlv->lv_buf_len += round_up(len, sizeof(uint64_t));\n\tlv->lv_bytes += len;\n\tvec->i_len = len;\n}"
  },
  {
    "function_name": "xlog_prepare_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.h",
    "lines": "34-54",
    "snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t))"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "(unsigned long)vec->i_addr",
            "sizeof(uint64_t)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "vec - lv->lv_iovecp < lv->lv_niovecs"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline void *\nxlog_prepare_iovec(struct xfs_log_vec *lv, struct xfs_log_iovec **vecp,\n\t\tuint type)\n{\n\tstruct xfs_log_iovec *vec = *vecp;\n\n\tif (vec) {\n\t\tASSERT(vec - lv->lv_iovecp < lv->lv_niovecs);\n\t\tvec++;\n\t} else {\n\t\tvec = &lv->lv_iovecp[0];\n\t}\n\n\tvec->i_type = type;\n\tvec->i_addr = lv->lv_buf + lv->lv_buf_len;\n\n\tASSERT(IS_ALIGNED((unsigned long)vec->i_addr, sizeof(uint64_t)));\n\n\t*vecp = vec;\n\treturn vec->i_addr;\n}"
  }
]