[
  {
    "function_name": "dlm_receive_rcom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "548-655",
    "snippet": "void dlm_receive_rcom(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tint lock_size = sizeof(struct dlm_rcom) + sizeof(struct rcom_lock);\n\tint stop, reply = 0, names = 0, lookup = 0, lock = 0;\n\tuint32_t status;\n\tuint64_t seq;\n\n\tswitch (rc->rc_type) {\n\tcase DLM_RCOM_STATUS_REPLY:\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_NAMES:\n\t\tnames = 1;\n\t\tbreak;\n\tcase DLM_RCOM_NAMES_REPLY:\n\t\tnames = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOOKUP:\n\t\tlookup = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOOKUP_REPLY:\n\t\tlookup = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOCK:\n\t\tlock = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOCK_REPLY:\n\t\tlock = 1;\n\t\treply = 1;\n\t\tbreak;\n\t};\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tstop = test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tseq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (stop && (rc->rc_type != DLM_RCOM_STATUS))\n\t\tgoto ignore;\n\n\tif (reply && (rc->rc_seq_reply != seq))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_NODES) && (names || lookup || lock))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_DIR) && (lookup || lock))\n\t\tgoto ignore;\n\n\tswitch (rc->rc_type) {\n\tcase DLM_RCOM_STATUS:\n\t\treceive_rcom_status(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_NAMES:\n\t\treceive_rcom_names(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOOKUP:\n\t\treceive_rcom_lookup(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOCK:\n\t\tif (rc->rc_header.h_length < lock_size)\n\t\t\tgoto Eshort;\n\t\treceive_rcom_lock(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_STATUS_REPLY:\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_NAMES_REPLY:\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOOKUP_REPLY:\n\t\treceive_rcom_lookup_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOCK_REPLY:\n\t\tif (rc->rc_header.h_length < lock_size)\n\t\t\tgoto Eshort;\n\t\tdlm_recover_process_copy(ls, rc);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_rcom bad type %d\", rc->rc_type);\n\t}\n\treturn;\n\nignore:\n\tlog_limit(ls, \"dlm_receive_rcom ignore msg %d \"\n\t\t  \"from %d %llu %llu recover seq %llu sts %x gen %u\",\n\t\t   rc->rc_type,\n\t\t   nodeid,\n\t\t   (unsigned long long)rc->rc_seq,\n\t\t   (unsigned long long)rc->rc_seq_reply,\n\t\t   (unsigned long long)seq,\n\t\t   status, ls->ls_generation);\n\treturn;\nEshort:\n\tlog_error(ls, \"recovery message %d from %d is too short\",\n\t\t  rc->rc_type, nodeid);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"recovery message %d from %d is too short\"",
            "rc->rc_type",
            "nodeid"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_limit",
          "args": [
            "ls",
            "\"dlm_receive_rcom ignore msg %d \"\n\t\t  \"from %d %llu %llu recover seq %llu sts %x gen %u\"",
            "rc->rc_type",
            "nodeid",
            "(unsigned long long)rc->rc_seq",
            "(unsigned long long)rc->rc_seq_reply",
            "(unsigned long long)seq",
            "status",
            "ls->ls_generation"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_rcom bad type %d\"",
            "rc->rc_type"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_recover_process_copy",
          "args": [
            "ls",
            "rc"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_process_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5706-5768",
          "snippet": "int dlm_recover_process_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t lkid, remid;\n\tint error, result;\n\n\tlkid = le32_to_cpu(rl->rl_lkid);\n\tremid = le32_to_cpu(rl->rl_remid);\n\tresult = le32_to_cpu(rl->rl_result);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"dlm_recover_process_copy no %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\treturn error;\n\t}\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\tif (!is_process_copy(lkb)) {\n\t\tlog_error(ls, \"dlm_recover_process_copy bad %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\tdlm_dump_rsb(r);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (result) {\n\tcase -EBADR:\n\t\t/* There's a chance the new master received our lock before\n\t\t   dlm_recover_master_reply(), this wouldn't happen if we did\n\t\t   a barrier between recover_masters and recover_locks. */\n\n\t\tlog_debug(ls, \"dlm_recover_process_copy %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\n\t\tdlm_send_rcom_lock(r, lkb);\n\t\tgoto out;\n\tcase -EEXIST:\n\tcase 0:\n\t\tlkb->lkb_remid = remid;\n\t\tbreak;\n\tdefault:\n\t\tlog_error(ls, \"dlm_recover_process_copy %x remote %d %x %d unk\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t}\n\n\t/* an ack for dlm_recover_locks() which waits for replies from\n\t   all the locks it sends to new masters */\n\tdlm_recovered_lock(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_recover_process_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t lkid, remid;\n\tint error, result;\n\n\tlkid = le32_to_cpu(rl->rl_lkid);\n\tremid = le32_to_cpu(rl->rl_remid);\n\tresult = le32_to_cpu(rl->rl_result);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error) {\n\t\tlog_error(ls, \"dlm_recover_process_copy no %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\treturn error;\n\t}\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\tif (!is_process_copy(lkb)) {\n\t\tlog_error(ls, \"dlm_recover_process_copy bad %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\tdlm_dump_rsb(r);\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t\tdlm_put_lkb(lkb);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (result) {\n\tcase -EBADR:\n\t\t/* There's a chance the new master received our lock before\n\t\t   dlm_recover_master_reply(), this wouldn't happen if we did\n\t\t   a barrier between recover_masters and recover_locks. */\n\n\t\tlog_debug(ls, \"dlm_recover_process_copy %x remote %d %x %d\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t\n\t\tdlm_send_rcom_lock(r, lkb);\n\t\tgoto out;\n\tcase -EEXIST:\n\tcase 0:\n\t\tlkb->lkb_remid = remid;\n\t\tbreak;\n\tdefault:\n\t\tlog_error(ls, \"dlm_recover_process_copy %x remote %d %x %d unk\",\n\t\t\t  lkid, rc->rc_header.h_nodeid, remid, result);\n\t}\n\n\t/* an ack for dlm_recover_locks() which waits for replies from\n\t   all the locks it sends to new masters */\n\tdlm_recovered_lock(r);\n out:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\tdlm_put_lkb(lkb);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_rcom_lookup_reply",
          "args": [
            "ls",
            "rc"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "receive_rcom_lookup_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "382-385",
          "snippet": "static void receive_rcom_lookup_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tdlm_recover_master_reply(ls, rc_in);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_lookup_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tdlm_recover_master_reply(ls, rc_in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_sync_reply",
          "args": [
            "ls",
            "rc"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "receive_sync_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "252-269",
          "snippet": "static void receive_sync_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tif (!test_bit(LSFL_RCOM_WAIT, &ls->ls_flags) ||\n\t    rc_in->rc_id != ls->ls_rcom_seq) {\n\t\tlog_debug(ls, \"reject reply %d from %d seq %llx expect %llx\",\n\t\t\t  rc_in->rc_type, rc_in->rc_header.h_nodeid,\n\t\t\t  (unsigned long long)rc_in->rc_id,\n\t\t\t  (unsigned long long)ls->ls_rcom_seq);\n\t\tgoto out;\n\t}\n\tmemcpy(ls->ls_recover_buf, rc_in, rc_in->rc_header.h_length);\n\tset_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\twake_up(&ls->ls_wait_general);\n out:\n\tspin_unlock(&ls->ls_rcom_spin);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_sync_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tif (!test_bit(LSFL_RCOM_WAIT, &ls->ls_flags) ||\n\t    rc_in->rc_id != ls->ls_rcom_seq) {\n\t\tlog_debug(ls, \"reject reply %d from %d seq %llx expect %llx\",\n\t\t\t  rc_in->rc_type, rc_in->rc_header.h_nodeid,\n\t\t\t  (unsigned long long)rc_in->rc_id,\n\t\t\t  (unsigned long long)ls->ls_rcom_seq);\n\t\tgoto out;\n\t}\n\tmemcpy(ls->ls_recover_buf, rc_in, rc_in->rc_header.h_length);\n\tset_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\twake_up(&ls->ls_wait_general);\n out:\n\tspin_unlock(&ls->ls_rcom_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_rcom_lock",
          "args": [
            "ls",
            "rc"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "receive_rcom_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "442-463",
          "snippet": "static void receive_rcom_lock(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = rc_in->rc_header.h_nodeid;\n\n\tdlm_recover_master_copy(ls, rc_in);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_LOCK_REPLY,\n\t\t\t    sizeof(struct rcom_lock), &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\t/* We send back the same rcom_lock struct we received, but\n\t   dlm_recover_master_copy() has filled in rl_remid and rl_result */\n\n\tmemcpy(rc->rc_buf, rc_in->rc_buf, sizeof(struct rcom_lock));\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tsend_rcom(ls, mh, rc);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_lock(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = rc_in->rc_header.h_nodeid;\n\n\tdlm_recover_master_copy(ls, rc_in);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_LOCK_REPLY,\n\t\t\t    sizeof(struct rcom_lock), &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\t/* We send back the same rcom_lock struct we received, but\n\t   dlm_recover_master_copy() has filled in rl_remid and rl_result */\n\n\tmemcpy(rc->rc_buf, rc_in->rc_buf, sizeof(struct rcom_lock));\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tsend_rcom(ls, mh, rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_rcom_names",
          "args": [
            "ls",
            "rc"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "receive_rcom_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "295-314",
          "snippet": "static void receive_rcom_names(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, inlen, outlen, nodeid;\n\n\tnodeid = rc_in->rc_header.h_nodeid;\n\tinlen = rc_in->rc_header.h_length - sizeof(struct dlm_rcom);\n\toutlen = dlm_config.ci_buffer_size - sizeof(struct dlm_rcom);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES_REPLY, outlen, &rc, &mh);\n\tif (error)\n\t\treturn;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tdlm_copy_master_names(ls, rc_in->rc_buf, inlen, rc->rc_buf, outlen,\n\t\t\t      nodeid);\n\tsend_rcom(ls, mh, rc);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_names(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, inlen, outlen, nodeid;\n\n\tnodeid = rc_in->rc_header.h_nodeid;\n\tinlen = rc_in->rc_header.h_length - sizeof(struct dlm_rcom);\n\toutlen = dlm_config.ci_buffer_size - sizeof(struct dlm_rcom);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES_REPLY, outlen, &rc, &mh);\n\tif (error)\n\t\treturn;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tdlm_copy_master_names(ls, rc_in->rc_buf, inlen, rc->rc_buf, outlen,\n\t\t\t      nodeid);\n\tsend_rcom(ls, mh, rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "receive_rcom_status",
          "args": [
            "ls",
            "rc"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "receive_rcom_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "191-250",
          "snippet": "static void receive_rcom_status(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_status *rs;\n\tuint32_t status;\n\tint nodeid = rc_in->rc_header.h_nodeid;\n\tint len = sizeof(struct rcom_config);\n\tint num_slots = 0;\n\tint error;\n\n\tif (!dlm_slots_version(&rc_in->rc_header)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\trs = (struct rcom_status *)rc_in->rc_buf;\n\n\tif (!(le32_to_cpu(rs->rs_flags) & DLM_RSF_NEED_SLOTS)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tnum_slots = ls->ls_num_slots;\n\tspin_unlock(&ls->ls_recover_lock);\n\tlen += num_slots * sizeof(struct rcom_slot);\n\n do_create:\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS_REPLY,\n\t\t\t    len, &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = status;\n\n\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, num_slots);\n\n\tif (!num_slots)\n\t\tgoto do_send;\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_num_slots != num_slots) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_debug(ls, \"receive_rcom_status num_slots %d to %d\",\n\t\t\t  num_slots, ls->ls_num_slots);\n\t\trc->rc_result = 0;\n\t\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, 0);\n\t\tgoto do_send;\n\t}\n\n\tdlm_slots_copy_out(ls, rc);\n\tspin_unlock(&ls->ls_recover_lock);\n\n do_send:\n\tsend_rcom(ls, mh, rc);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_status(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_status *rs;\n\tuint32_t status;\n\tint nodeid = rc_in->rc_header.h_nodeid;\n\tint len = sizeof(struct rcom_config);\n\tint num_slots = 0;\n\tint error;\n\n\tif (!dlm_slots_version(&rc_in->rc_header)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\trs = (struct rcom_status *)rc_in->rc_buf;\n\n\tif (!(le32_to_cpu(rs->rs_flags) & DLM_RSF_NEED_SLOTS)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tnum_slots = ls->ls_num_slots;\n\tspin_unlock(&ls->ls_recover_lock);\n\tlen += num_slots * sizeof(struct rcom_slot);\n\n do_create:\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS_REPLY,\n\t\t\t    len, &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = status;\n\n\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, num_slots);\n\n\tif (!num_slots)\n\t\tgoto do_send;\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_num_slots != num_slots) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_debug(ls, \"receive_rcom_status num_slots %d to %d\",\n\t\t\t  num_slots, ls->ls_num_slots);\n\t\trc->rc_result = 0;\n\t\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, 0);\n\t\tgoto do_send;\n\t}\n\n\tdlm_slots_copy_out(ls, rc);\n\tspin_unlock(&ls->ls_recover_lock);\n\n do_send:\n\tsend_rcom(ls, mh, rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_RECOVER_STOP",
            "&ls->ls_flags"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_receive_rcom(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tint lock_size = sizeof(struct dlm_rcom) + sizeof(struct rcom_lock);\n\tint stop, reply = 0, names = 0, lookup = 0, lock = 0;\n\tuint32_t status;\n\tuint64_t seq;\n\n\tswitch (rc->rc_type) {\n\tcase DLM_RCOM_STATUS_REPLY:\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_NAMES:\n\t\tnames = 1;\n\t\tbreak;\n\tcase DLM_RCOM_NAMES_REPLY:\n\t\tnames = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOOKUP:\n\t\tlookup = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOOKUP_REPLY:\n\t\tlookup = 1;\n\t\treply = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOCK:\n\t\tlock = 1;\n\t\tbreak;\n\tcase DLM_RCOM_LOCK_REPLY:\n\t\tlock = 1;\n\t\treply = 1;\n\t\tbreak;\n\t};\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tstop = test_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\n\tseq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\tif (stop && (rc->rc_type != DLM_RCOM_STATUS))\n\t\tgoto ignore;\n\n\tif (reply && (rc->rc_seq_reply != seq))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_NODES) && (names || lookup || lock))\n\t\tgoto ignore;\n\n\tif (!(status & DLM_RS_DIR) && (lookup || lock))\n\t\tgoto ignore;\n\n\tswitch (rc->rc_type) {\n\tcase DLM_RCOM_STATUS:\n\t\treceive_rcom_status(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_NAMES:\n\t\treceive_rcom_names(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOOKUP:\n\t\treceive_rcom_lookup(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOCK:\n\t\tif (rc->rc_header.h_length < lock_size)\n\t\t\tgoto Eshort;\n\t\treceive_rcom_lock(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_STATUS_REPLY:\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_NAMES_REPLY:\n\t\treceive_sync_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOOKUP_REPLY:\n\t\treceive_rcom_lookup_reply(ls, rc);\n\t\tbreak;\n\n\tcase DLM_RCOM_LOCK_REPLY:\n\t\tif (rc->rc_header.h_length < lock_size)\n\t\t\tgoto Eshort;\n\t\tdlm_recover_process_copy(ls, rc);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_error(ls, \"receive_rcom bad type %d\", rc->rc_type);\n\t}\n\treturn;\n\nignore:\n\tlog_limit(ls, \"dlm_receive_rcom ignore msg %d \"\n\t\t  \"from %d %llu %llu recover seq %llu sts %x gen %u\",\n\t\t   rc->rc_type,\n\t\t   nodeid,\n\t\t   (unsigned long long)rc->rc_seq,\n\t\t   (unsigned long long)rc->rc_seq_reply,\n\t\t   (unsigned long long)seq,\n\t\t   status, ls->ls_generation);\n\treturn;\nEshort:\n\tlog_error(ls, \"recovery message %d from %d is too short\",\n\t\t  rc->rc_type, nodeid);\n}"
  },
  {
    "function_name": "dlm_send_ls_not_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "468-501",
    "snippet": "int dlm_send_ls_not_ready(int nodeid, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct rcom_config *rf;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + sizeof(struct rcom_config);\n\n\tmh = dlm_lowcomms_get_buffer(nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = rc_in->rc_header.h_lockspace;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = DLM_RCOM_STATUS_REPLY;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = -ESRCH;\n\n\trf = (struct rcom_config *) rc->rc_buf;\n\trf->rf_lvblen = cpu_to_le32(~0U);\n\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lowcomms_commit_buffer",
          "args": [
            "mh"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_commit_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1531-1552",
          "snippet": "void dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_WRITE_PENDING 2"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nvoid dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_rcom_out",
          "args": [
            "rc"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_rcom_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/util.c",
          "lines": "134-143",
          "snippet": "void dlm_rcom_out(struct dlm_rcom *rc)\n{\n\theader_out(&rc->rc_header);\n\n\trc->rc_type\t\t= cpu_to_le32(rc->rc_type);\n\trc->rc_result\t\t= cpu_to_le32(rc->rc_result);\n\trc->rc_id\t\t= cpu_to_le64(rc->rc_id);\n\trc->rc_seq\t\t= cpu_to_le64(rc->rc_seq);\n\trc->rc_seq_reply\t= cpu_to_le64(rc->rc_seq_reply);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"rcom.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"rcom.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_rcom_out(struct dlm_rcom *rc)\n{\n\theader_out(&rc->rc_header);\n\n\trc->rc_type\t\t= cpu_to_le32(rc->rc_type);\n\trc->rc_result\t\t= cpu_to_le32(rc->rc_result);\n\trc->rc_id\t\t= cpu_to_le64(rc->rc_id);\n\trc->rc_seq\t\t= cpu_to_le64(rc->rc_seq);\n\trc->rc_seq_reply\t= cpu_to_le64(rc->rc_seq_reply);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "~0U"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mb",
            "0",
            "mb_len"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lowcomms_get_buffer",
          "args": [
            "nodeid",
            "mb_len",
            "GFP_NOFS",
            "&mb"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_get_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1490-1529",
          "snippet": "void *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nvoid *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_ls_not_ready(int nodeid, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct rcom_config *rf;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + sizeof(struct rcom_config);\n\n\tmh = dlm_lowcomms_get_buffer(nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh)\n\t\treturn -ENOBUFS;\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = rc_in->rc_header.h_lockspace;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = DLM_RCOM_STATUS_REPLY;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = -ESRCH;\n\n\trf = (struct rcom_config *) rc->rc_buf;\n\trf->rf_lvblen = cpu_to_le32(~0U);\n\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "receive_rcom_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "442-463",
    "snippet": "static void receive_rcom_lock(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = rc_in->rc_header.h_nodeid;\n\n\tdlm_recover_master_copy(ls, rc_in);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_LOCK_REPLY,\n\t\t\t    sizeof(struct rcom_lock), &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\t/* We send back the same rcom_lock struct we received, but\n\t   dlm_recover_master_copy() has filled in rl_remid and rl_result */\n\n\tmemcpy(rc->rc_buf, rc_in->rc_buf, sizeof(struct rcom_lock));\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tsend_rcom(ls, mh, rc);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rc->rc_buf",
            "rc_in->rc_buf",
            "sizeof(struct rcom_lock)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "nodeid",
            "DLM_RCOM_LOCK_REPLY",
            "sizeof(struct rcom_lock)",
            "&rc",
            "&mh"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recover_master_copy",
          "args": [
            "ls",
            "rc_in"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_master_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5625-5703",
          "snippet": "int dlm_recover_master_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t remid = 0;\n\tint from_nodeid = rc->rc_header.h_nodeid;\n\tint error;\n\n\tif (rl->rl_parent_lkid) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tremid = le32_to_cpu(rl->rl_lkid);\n\n\t/* In general we expect the rsb returned to be R_MASTER, but we don't\n\t   have to require it.  Recovery of masters on one node can overlap\n\t   recovery of locks on another node, so one node can send us MSTCPY\n\t   locks before we've made ourselves master of this rsb.  We can still\n\t   add new MSTCPY locks that we receive here without any harm; when\n\t   we make ourselves master, dlm_recover_masters() won't touch the\n\t   MSTCPY locks we've received early. */\n\n\terror = find_rsb(ls, rl->rl_name, le16_to_cpu(rl->rl_namelen),\n\t\t\t from_nodeid, R_RECEIVE_RECOVER, &r);\n\tif (error)\n\t\tgoto out;\n\n\tlock_rsb(r);\n\n\tif (dlm_no_directory(ls) && (dlm_dir_nodeid(r) != dlm_our_nodeid())) {\n\t\tlog_error(ls, \"dlm_recover_master_copy remote %d %x not dir\",\n\t\t\t  from_nodeid, remid);\n\t\terror = -EBADR;\n\t\tgoto out_unlock;\n\t}\n\n\tlkb = search_remid(r, from_nodeid, remid);\n\tif (lkb) {\n\t\terror = -EEXIST;\n\t\tgoto out_remid;\n\t}\n\n\terror = create_lkb(ls, &lkb);\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = receive_rcom_lock_args(ls, lkb, r, rc);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out_unlock;\n\t}\n\n\tattach_lkb(r, lkb);\n\tadd_lkb(r, lkb, rl->rl_status);\n\terror = 0;\n\tls->ls_recover_locks_in++;\n\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n out_remid:\n\t/* this is the new value returned to the lock holder for\n\t   saving in its process-copy lkb */\n\trl->rl_remid = cpu_to_le32(lkb->lkb_id);\n\n\tlkb->lkb_recover_seq = ls->ls_recover_seq;\n\n out_unlock:\n\tunlock_rsb(r);\n\tput_rsb(r);\n out:\n\tif (error && error != -EEXIST)\n\t\tlog_rinfo(ls, \"dlm_recover_master_copy remote %d %x error %d\",\n\t\t\t  from_nodeid, remid, error);\n\trl->rl_result = cpu_to_le32(error);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_recover_master_copy(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct rcom_lock *rl = (struct rcom_lock *) rc->rc_buf;\n\tstruct dlm_rsb *r;\n\tstruct dlm_lkb *lkb;\n\tuint32_t remid = 0;\n\tint from_nodeid = rc->rc_header.h_nodeid;\n\tint error;\n\n\tif (rl->rl_parent_lkid) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tremid = le32_to_cpu(rl->rl_lkid);\n\n\t/* In general we expect the rsb returned to be R_MASTER, but we don't\n\t   have to require it.  Recovery of masters on one node can overlap\n\t   recovery of locks on another node, so one node can send us MSTCPY\n\t   locks before we've made ourselves master of this rsb.  We can still\n\t   add new MSTCPY locks that we receive here without any harm; when\n\t   we make ourselves master, dlm_recover_masters() won't touch the\n\t   MSTCPY locks we've received early. */\n\n\terror = find_rsb(ls, rl->rl_name, le16_to_cpu(rl->rl_namelen),\n\t\t\t from_nodeid, R_RECEIVE_RECOVER, &r);\n\tif (error)\n\t\tgoto out;\n\n\tlock_rsb(r);\n\n\tif (dlm_no_directory(ls) && (dlm_dir_nodeid(r) != dlm_our_nodeid())) {\n\t\tlog_error(ls, \"dlm_recover_master_copy remote %d %x not dir\",\n\t\t\t  from_nodeid, remid);\n\t\terror = -EBADR;\n\t\tgoto out_unlock;\n\t}\n\n\tlkb = search_remid(r, from_nodeid, remid);\n\tif (lkb) {\n\t\terror = -EEXIST;\n\t\tgoto out_remid;\n\t}\n\n\terror = create_lkb(ls, &lkb);\n\tif (error)\n\t\tgoto out_unlock;\n\n\terror = receive_rcom_lock_args(ls, lkb, r, rc);\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out_unlock;\n\t}\n\n\tattach_lkb(r, lkb);\n\tadd_lkb(r, lkb, rl->rl_status);\n\terror = 0;\n\tls->ls_recover_locks_in++;\n\n\tif (!list_empty(&r->res_waitqueue) || !list_empty(&r->res_convertqueue))\n\t\trsb_set_flag(r, RSB_RECOVER_GRANT);\n\n out_remid:\n\t/* this is the new value returned to the lock holder for\n\t   saving in its process-copy lkb */\n\trl->rl_remid = cpu_to_le32(lkb->lkb_id);\n\n\tlkb->lkb_recover_seq = ls->ls_recover_seq;\n\n out_unlock:\n\tunlock_rsb(r);\n\tput_rsb(r);\n out:\n\tif (error && error != -EEXIST)\n\t\tlog_rinfo(ls, \"dlm_recover_master_copy remote %d %x error %d\",\n\t\t\t  from_nodeid, remid, error);\n\trl->rl_result = cpu_to_le32(error);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_lock(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, nodeid = rc_in->rc_header.h_nodeid;\n\n\tdlm_recover_master_copy(ls, rc_in);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_LOCK_REPLY,\n\t\t\t    sizeof(struct rcom_lock), &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\t/* We send back the same rcom_lock struct we received, but\n\t   dlm_recover_master_copy() has filled in rl_remid and rl_result */\n\n\tmemcpy(rc->rc_buf, rc_in->rc_buf, sizeof(struct rcom_lock));\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tsend_rcom(ls, mh, rc);\n}"
  },
  {
    "function_name": "dlm_send_rcom_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "417-439",
    "snippet": "int dlm_send_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_lock *rl;\n\tint error, len = sizeof(struct rcom_lock);\n\n\tif (lkb->lkb_lvbptr)\n\t\tlen += ls->ls_lvblen;\n\n\terror = create_rcom(ls, r->res_nodeid, DLM_RCOM_LOCK, len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\trl = (struct rcom_lock *) rc->rc_buf;\n\tpack_rcom_lock(r, lkb, rl);\n\trc->rc_id = (unsigned long) r;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pack_rcom_lock",
          "args": [
            "r",
            "lkb",
            "rl"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "pack_rcom_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "387-415",
          "snippet": "static void pack_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t   struct rcom_lock *rl)\n{\n\tmemset(rl, 0, sizeof(*rl));\n\n\trl->rl_ownpid = cpu_to_le32(lkb->lkb_ownpid);\n\trl->rl_lkid = cpu_to_le32(lkb->lkb_id);\n\trl->rl_exflags = cpu_to_le32(lkb->lkb_exflags);\n\trl->rl_flags = cpu_to_le32(lkb->lkb_flags);\n\trl->rl_lvbseq = cpu_to_le32(lkb->lkb_lvbseq);\n\trl->rl_rqmode = lkb->lkb_rqmode;\n\trl->rl_grmode = lkb->lkb_grmode;\n\trl->rl_status = lkb->lkb_status;\n\trl->rl_wait_type = cpu_to_le16(lkb->lkb_wait_type);\n\n\tif (lkb->lkb_bastfn)\n\t\trl->rl_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\trl->rl_asts |= DLM_CB_CAST;\n\n\trl->rl_namelen = cpu_to_le16(r->res_length);\n\tmemcpy(rl->rl_name, r->res_name, r->res_length);\n\n\t/* FIXME: might we have an lvb without DLM_LKF_VALBLK set ?\n\t   If so, receive_rcom_lock_args() won't take this copy. */\n\n\tif (lkb->lkb_lvbptr)\n\t\tmemcpy(rl->rl_lvb, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void pack_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t   struct rcom_lock *rl)\n{\n\tmemset(rl, 0, sizeof(*rl));\n\n\trl->rl_ownpid = cpu_to_le32(lkb->lkb_ownpid);\n\trl->rl_lkid = cpu_to_le32(lkb->lkb_id);\n\trl->rl_exflags = cpu_to_le32(lkb->lkb_exflags);\n\trl->rl_flags = cpu_to_le32(lkb->lkb_flags);\n\trl->rl_lvbseq = cpu_to_le32(lkb->lkb_lvbseq);\n\trl->rl_rqmode = lkb->lkb_rqmode;\n\trl->rl_grmode = lkb->lkb_grmode;\n\trl->rl_status = lkb->lkb_status;\n\trl->rl_wait_type = cpu_to_le16(lkb->lkb_wait_type);\n\n\tif (lkb->lkb_bastfn)\n\t\trl->rl_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\trl->rl_asts |= DLM_CB_CAST;\n\n\trl->rl_namelen = cpu_to_le16(r->res_length);\n\tmemcpy(rl->rl_name, r->res_name, r->res_length);\n\n\t/* FIXME: might we have an lvb without DLM_LKF_VALBLK set ?\n\t   If so, receive_rcom_lock_args() won't take this copy. */\n\n\tif (lkb->lkb_lvbptr)\n\t\tmemcpy(rl->rl_lvb, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "r->res_nodeid",
            "DLM_RCOM_LOCK",
            "len",
            "&rc",
            "&mh"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls = r->res_ls;\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_lock *rl;\n\tint error, len = sizeof(struct rcom_lock);\n\n\tif (lkb->lkb_lvbptr)\n\t\tlen += ls->ls_lvblen;\n\n\terror = create_rcom(ls, r->res_nodeid, DLM_RCOM_LOCK, len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\trl = (struct rcom_lock *) rc->rc_buf;\n\tpack_rcom_lock(r, lkb, rl);\n\trc->rc_id = (unsigned long) r;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "pack_rcom_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "387-415",
    "snippet": "static void pack_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t   struct rcom_lock *rl)\n{\n\tmemset(rl, 0, sizeof(*rl));\n\n\trl->rl_ownpid = cpu_to_le32(lkb->lkb_ownpid);\n\trl->rl_lkid = cpu_to_le32(lkb->lkb_id);\n\trl->rl_exflags = cpu_to_le32(lkb->lkb_exflags);\n\trl->rl_flags = cpu_to_le32(lkb->lkb_flags);\n\trl->rl_lvbseq = cpu_to_le32(lkb->lkb_lvbseq);\n\trl->rl_rqmode = lkb->lkb_rqmode;\n\trl->rl_grmode = lkb->lkb_grmode;\n\trl->rl_status = lkb->lkb_status;\n\trl->rl_wait_type = cpu_to_le16(lkb->lkb_wait_type);\n\n\tif (lkb->lkb_bastfn)\n\t\trl->rl_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\trl->rl_asts |= DLM_CB_CAST;\n\n\trl->rl_namelen = cpu_to_le16(r->res_length);\n\tmemcpy(rl->rl_name, r->res_name, r->res_length);\n\n\t/* FIXME: might we have an lvb without DLM_LKF_VALBLK set ?\n\t   If so, receive_rcom_lock_args() won't take this copy. */\n\n\tif (lkb->lkb_lvbptr)\n\t\tmemcpy(rl->rl_lvb, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rl->rl_lvb",
            "lkb->lkb_lvbptr",
            "r->res_ls->ls_lvblen"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rl->rl_name",
            "r->res_name",
            "r->res_length"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "r->res_length"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "lkb->lkb_wait_type"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lkb->lkb_lvbseq"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lkb->lkb_flags"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lkb->lkb_exflags"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lkb->lkb_id"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lkb->lkb_ownpid"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rl",
            "0",
            "sizeof(*rl)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void pack_rcom_lock(struct dlm_rsb *r, struct dlm_lkb *lkb,\n\t\t\t   struct rcom_lock *rl)\n{\n\tmemset(rl, 0, sizeof(*rl));\n\n\trl->rl_ownpid = cpu_to_le32(lkb->lkb_ownpid);\n\trl->rl_lkid = cpu_to_le32(lkb->lkb_id);\n\trl->rl_exflags = cpu_to_le32(lkb->lkb_exflags);\n\trl->rl_flags = cpu_to_le32(lkb->lkb_flags);\n\trl->rl_lvbseq = cpu_to_le32(lkb->lkb_lvbseq);\n\trl->rl_rqmode = lkb->lkb_rqmode;\n\trl->rl_grmode = lkb->lkb_grmode;\n\trl->rl_status = lkb->lkb_status;\n\trl->rl_wait_type = cpu_to_le16(lkb->lkb_wait_type);\n\n\tif (lkb->lkb_bastfn)\n\t\trl->rl_asts |= DLM_CB_BAST;\n\tif (lkb->lkb_astfn)\n\t\trl->rl_asts |= DLM_CB_CAST;\n\n\trl->rl_namelen = cpu_to_le16(r->res_length);\n\tmemcpy(rl->rl_name, r->res_name, r->res_length);\n\n\t/* FIXME: might we have an lvb without DLM_LKF_VALBLK set ?\n\t   If so, receive_rcom_lock_args() won't take this copy. */\n\n\tif (lkb->lkb_lvbptr)\n\t\tmemcpy(rl->rl_lvb, lkb->lkb_lvbptr, r->res_ls->ls_lvblen);\n}"
  },
  {
    "function_name": "receive_rcom_lookup_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "382-385",
    "snippet": "static void receive_rcom_lookup_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tdlm_recover_master_reply(ls, rc_in);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_recover_master_reply",
          "args": [
            "ls",
            "rc_in"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_master_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "564-594",
          "snippet": "int dlm_recover_master_reply(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_rsb *r;\n\tint ret_nodeid, new_master;\n\n\tr = recover_idr_find(ls, rc->rc_id);\n\tif (!r) {\n\t\tlog_error(ls, \"dlm_recover_master_reply no id %llx\",\n\t\t\t  (unsigned long long)rc->rc_id);\n\t\tgoto out;\n\t}\n\n\tret_nodeid = rc->rc_result;\n\n\tif (ret_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\telse\n\t\tnew_master = ret_nodeid;\n\n\tlock_rsb(r);\n\tr->res_master_nodeid = ret_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\tunlock_rsb(r);\n\trecover_idr_del(r);\n\n\tif (recover_idr_empty(ls))\n\t\twake_up(&ls->ls_wait_general);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_recover_master_reply(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_rsb *r;\n\tint ret_nodeid, new_master;\n\n\tr = recover_idr_find(ls, rc->rc_id);\n\tif (!r) {\n\t\tlog_error(ls, \"dlm_recover_master_reply no id %llx\",\n\t\t\t  (unsigned long long)rc->rc_id);\n\t\tgoto out;\n\t}\n\n\tret_nodeid = rc->rc_result;\n\n\tif (ret_nodeid == dlm_our_nodeid())\n\t\tnew_master = 0;\n\telse\n\t\tnew_master = ret_nodeid;\n\n\tlock_rsb(r);\n\tr->res_master_nodeid = ret_nodeid;\n\tr->res_nodeid = new_master;\n\tset_new_master(r);\n\tunlock_rsb(r);\n\trecover_idr_del(r);\n\n\tif (recover_idr_empty(ls))\n\t\twake_up(&ls->ls_wait_general);\n out:\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_lookup_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tdlm_recover_master_reply(ls, rc_in);\n}"
  },
  {
    "function_name": "receive_rcom_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "354-380",
    "snippet": "static void receive_rcom_lookup(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, ret_nodeid, nodeid = rc_in->rc_header.h_nodeid;\n\tint len = rc_in->rc_header.h_length - sizeof(struct dlm_rcom);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_LOOKUP_REPLY, 0, &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\tif (rc_in->rc_id == 0xFFFFFFFF) {\n\t\tlog_error(ls, \"receive_rcom_lookup dump from %d\", nodeid);\n\t\tdlm_dump_rsb_name(ls, rc_in->rc_buf, len);\n\t\treturn;\n\t}\n\n\terror = dlm_master_lookup(ls, nodeid, rc_in->rc_buf, len,\n\t\t\t\t  DLM_LU_RECOVER_MASTER, &ret_nodeid, NULL);\n\tif (error)\n\t\tret_nodeid = error;\n\trc->rc_result = ret_nodeid;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tsend_rcom(ls, mh, rc);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_master_lookup",
          "args": [
            "ls",
            "nodeid",
            "rc_in->rc_buf",
            "len",
            "DLM_LU_RECOVER_MASTER",
            "&ret_nodeid",
            "NULL"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_master_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "912-1084",
          "snippet": "int dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\n\t\t      unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error, toss_list = 0;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t/* because the rsb is active, we need to lock_rsb before\n\t\t   checking/changing re_master_nodeid */\n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\t\tgoto found;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t/* because the rsb is inactive (on toss list), it's not refcounted\n\t   and lock_rsb is not used, but is protected by the rsbtbl lock */\n\n\ttoss_list = 1;\n found:\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t/* should not happen, but may as well fix it and carry on */\n\t\tlog_error(ls, \"dlm_master_lookup res_dir %d our %d %s\",\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t/* Recovery uses this function to set a new master when\n\t\t   the previous master failed.  Setting NEW_MASTER will\n\t\t   force dlm_recover_masters to call recover_master on this\n\t\t   rsb even though the res_nodeid is no longer removed. */\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t/* I don't think we should ever find it on toss list. */\n\t\t\tlog_error(ls, \"dlm_master_lookup fix_master on toss\");\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t/* this will happen if from_nodeid became master during\n\t\t   a previous recovery cycle, and we aborted the previous\n\t\t   cycle before recovering this master value */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_nodeid,\n\t\t\t  r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tdlm_send_rcom_lookup_dump(r, from_nodeid);\n\t\t\tgoto out_found;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t/* this will happen if recovery happens while we're looking\n\t\t   up the master for this rsb */\n\n\t\tlog_debug(ls, \"dlm_master_lookup master 0 to %d first %x %s\",\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t/* this can happen when the master sends remove, the dir node\n\t\t   finds the rsb on the keep list and ignores the remove,\n\t\t   and the former master sends a lookup */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\", from_nodeid, flags,\n\t\t\t  r->res_first_lkid, r->res_name);\n\t}\n\n out_found:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n\n\tif (toss_list) {\n\t\tr->res_toss_time = jiffies;\n\t\t/* the rsb was inactive (on toss list) */\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t} else {\n\t\t/* the rsb was active */\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t}\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t/* should never happen */\n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n\terror = 0;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nint dlm_master_lookup(struct dlm_ls *ls, int from_nodeid, char *name, int len,\n\t\t      unsigned int flags, int *r_nodeid, int *result)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint from_master = (flags & DLM_LU_RECOVER_DIR);\n\tint fix_master = (flags & DLM_LU_RECOVER_MASTER);\n\tint our_nodeid = dlm_our_nodeid();\n\tint dir_nodeid, error, toss_list = 0;\n\n\tif (len > DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tif (from_nodeid == our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from our_nodeid %d flags %x\",\n\t\t\t  our_nodeid, flags);\n\t\treturn -EINVAL;\n\t}\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tdir_nodeid = dlm_hash2nodeid(ls, hash);\n\tif (dir_nodeid != our_nodeid) {\n\t\tlog_error(ls, \"dlm_master_lookup from %d dir %d our %d h %x %d\",\n\t\t\t  from_nodeid, dir_nodeid, our_nodeid, hash,\n\t\t\t  ls->ls_num_nodes);\n\t\t*r_nodeid = -1;\n\t\treturn -EINVAL;\n\t}\n\n retry:\n\terror = pre_rsb_struct(ls);\n\tif (error < 0)\n\t\treturn error;\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error) {\n\t\t/* because the rsb is active, we need to lock_rsb before\n\t\t   checking/changing re_master_nodeid */\n\n\t\thold_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tlock_rsb(r);\n\t\tgoto found;\n\t}\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto not_found;\n\n\t/* because the rsb is inactive (on toss list), it's not refcounted\n\t   and lock_rsb is not used, but is protected by the rsbtbl lock */\n\n\ttoss_list = 1;\n found:\n\tif (r->res_dir_nodeid != our_nodeid) {\n\t\t/* should not happen, but may as well fix it and carry on */\n\t\tlog_error(ls, \"dlm_master_lookup res_dir %d our %d %s\",\n\t\t\t  r->res_dir_nodeid, our_nodeid, r->res_name);\n\t\tr->res_dir_nodeid = our_nodeid;\n\t}\n\n\tif (fix_master && dlm_is_removed(ls, r->res_master_nodeid)) {\n\t\t/* Recovery uses this function to set a new master when\n\t\t   the previous master failed.  Setting NEW_MASTER will\n\t\t   force dlm_recover_masters to call recover_master on this\n\t\t   rsb even though the res_nodeid is no longer removed. */\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\n\t\tif (toss_list) {\n\t\t\t/* I don't think we should ever find it on toss list. */\n\t\t\tlog_error(ls, \"dlm_master_lookup fix_master on toss\");\n\t\t\tdlm_dump_rsb(r);\n\t\t}\n\t}\n\n\tif (from_master && (r->res_master_nodeid != from_nodeid)) {\n\t\t/* this will happen if from_nodeid became master during\n\t\t   a previous recovery cycle, and we aborted the previous\n\t\t   cycle before recovering this master value */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from_master %d \"\n\t\t\t  \"master_nodeid %d res_nodeid %d first %x %s\",\n\t\t\t  from_nodeid, r->res_master_nodeid, r->res_nodeid,\n\t\t\t  r->res_first_lkid, r->res_name);\n\n\t\tif (r->res_master_nodeid == our_nodeid) {\n\t\t\tlog_error(ls, \"from_master %d our_master\", from_nodeid);\n\t\t\tdlm_dump_rsb(r);\n\t\t\tdlm_send_rcom_lookup_dump(r, from_nodeid);\n\t\t\tgoto out_found;\n\t\t}\n\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t\trsb_set_flag(r, RSB_NEW_MASTER);\n\t}\n\n\tif (!r->res_master_nodeid) {\n\t\t/* this will happen if recovery happens while we're looking\n\t\t   up the master for this rsb */\n\n\t\tlog_debug(ls, \"dlm_master_lookup master 0 to %d first %x %s\",\n\t\t\t  from_nodeid, r->res_first_lkid, r->res_name);\n\t\tr->res_master_nodeid = from_nodeid;\n\t\tr->res_nodeid = from_nodeid;\n\t}\n\n\tif (!from_master && !fix_master &&\n\t    (r->res_master_nodeid == from_nodeid)) {\n\t\t/* this can happen when the master sends remove, the dir node\n\t\t   finds the rsb on the keep list and ignores the remove,\n\t\t   and the former master sends a lookup */\n\n\t\tlog_limit(ls, \"dlm_master_lookup from master %d flags %x \"\n\t\t\t  \"first %x %s\", from_nodeid, flags,\n\t\t\t  r->res_first_lkid, r->res_name);\n\t}\n\n out_found:\n\t*r_nodeid = r->res_master_nodeid;\n\tif (result)\n\t\t*result = DLM_LU_MATCH;\n\n\tif (toss_list) {\n\t\tr->res_toss_time = jiffies;\n\t\t/* the rsb was inactive (on toss list) */\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t} else {\n\t\t/* the rsb was active */\n\t\tunlock_rsb(r);\n\t\tput_rsb(r);\n\t}\n\treturn 0;\n\n not_found:\n\terror = get_rsb_struct(ls, name, len, &r);\n\tif (error == -EAGAIN) {\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\tif (error)\n\t\tgoto out_unlock;\n\n\tr->res_hash = hash;\n\tr->res_bucket = b;\n\tr->res_dir_nodeid = our_nodeid;\n\tr->res_master_nodeid = from_nodeid;\n\tr->res_nodeid = from_nodeid;\n\tkref_init(&r->res_ref);\n\tr->res_toss_time = jiffies;\n\n\terror = rsb_insert(r, &ls->ls_rsbtbl[b].toss);\n\tif (error) {\n\t\t/* should never happen */\n\t\tdlm_free_rsb(r);\n\t\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\t\tgoto retry;\n\t}\n\n\tif (result)\n\t\t*result = DLM_LU_ADD;\n\t*r_nodeid = from_nodeid;\n\terror = 0;\n out_unlock:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_dump_rsb_name",
          "args": [
            "ls",
            "rc_in->rc_buf",
            "len"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dump_rsb_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1103-1124",
          "snippet": "void dlm_dump_rsb_name(struct dlm_ls *ls, char *name, int len)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint error;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error)\n\t\tgoto out_dump;\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto out;\n out_dump:\n\tdlm_dump_rsb(r);\n out:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_remove(struct dlm_rsb *r);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_remove(struct dlm_rsb *r);\n\nvoid dlm_dump_rsb_name(struct dlm_ls *ls, char *name, int len)\n{\n\tstruct dlm_rsb *r = NULL;\n\tuint32_t hash, b;\n\tint error;\n\n\thash = jhash(name, len, 0);\n\tb = hash & (ls->ls_rsbtbl_size - 1);\n\n\tspin_lock(&ls->ls_rsbtbl[b].lock);\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].keep, name, len, &r);\n\tif (!error)\n\t\tgoto out_dump;\n\n\terror = dlm_search_rsb_tree(&ls->ls_rsbtbl[b].toss, name, len, &r);\n\tif (error)\n\t\tgoto out;\n out_dump:\n\tdlm_dump_rsb(r);\n out:\n\tspin_unlock(&ls->ls_rsbtbl[b].lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"receive_rcom_lookup dump from %d\"",
            "nodeid"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "nodeid",
            "DLM_RCOM_LOOKUP_REPLY",
            "0",
            "&rc",
            "&mh"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_lookup(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, ret_nodeid, nodeid = rc_in->rc_header.h_nodeid;\n\tint len = rc_in->rc_header.h_length - sizeof(struct dlm_rcom);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_LOOKUP_REPLY, 0, &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\tif (rc_in->rc_id == 0xFFFFFFFF) {\n\t\tlog_error(ls, \"receive_rcom_lookup dump from %d\", nodeid);\n\t\tdlm_dump_rsb_name(ls, rc_in->rc_buf, len);\n\t\treturn;\n\t}\n\n\terror = dlm_master_lookup(ls, nodeid, rc_in->rc_buf, len,\n\t\t\t\t  DLM_LU_RECOVER_MASTER, &ret_nodeid, NULL);\n\tif (error)\n\t\tret_nodeid = error;\n\trc->rc_result = ret_nodeid;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tsend_rcom(ls, mh, rc);\n}"
  },
  {
    "function_name": "dlm_send_rcom_lookup_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "335-352",
    "snippet": "int dlm_send_rcom_lookup_dump(struct dlm_rsb *r, int to_nodeid)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, to_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = 0xFFFFFFFF;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rc->rc_buf",
            "r->res_name",
            "r->res_length"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "to_nodeid",
            "DLM_RCOM_LOOKUP",
            "r->res_length",
            "&rc",
            "&mh"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_rcom_lookup_dump(struct dlm_rsb *r, int to_nodeid)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, to_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = 0xFFFFFFFF;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_send_rcom_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "316-333",
    "snippet": "int dlm_send_rcom_lookup(struct dlm_rsb *r, int dir_nodeid)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, dir_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = (unsigned long) r->res_id;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rc->rc_buf",
            "r->res_name",
            "r->res_length"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "dir_nodeid",
            "DLM_RCOM_LOOKUP",
            "r->res_length",
            "&rc",
            "&mh"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_send_rcom_lookup(struct dlm_rsb *r, int dir_nodeid)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct dlm_ls *ls = r->res_ls;\n\tint error;\n\n\terror = create_rcom(ls, dir_nodeid, DLM_RCOM_LOOKUP, r->res_length,\n\t\t\t    &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, r->res_name, r->res_length);\n\trc->rc_id = (unsigned long) r->res_id;\n\n\tsend_rcom(ls, mh, rc);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "receive_rcom_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "295-314",
    "snippet": "static void receive_rcom_names(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, inlen, outlen, nodeid;\n\n\tnodeid = rc_in->rc_header.h_nodeid;\n\tinlen = rc_in->rc_header.h_length - sizeof(struct dlm_rcom);\n\toutlen = dlm_config.ci_buffer_size - sizeof(struct dlm_rcom);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES_REPLY, outlen, &rc, &mh);\n\tif (error)\n\t\treturn;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tdlm_copy_master_names(ls, rc_in->rc_buf, inlen, rc->rc_buf, outlen,\n\t\t\t      nodeid);\n\tsend_rcom(ls, mh, rc);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_copy_master_names",
          "args": [
            "ls",
            "rc_in->rc_buf",
            "inlen",
            "rc->rc_buf",
            "outlen",
            "nodeid"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_copy_master_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/dir.c",
          "lines": "236-307",
          "snippet": "void dlm_copy_master_names(struct dlm_ls *ls, char *inbuf, int inlen,\n \t\t\t   char *outbuf, int outlen, int nodeid)\n{\n\tstruct list_head *list;\n\tstruct dlm_rsb *r;\n\tint offset = 0, dir_nodeid;\n\t__be16 be_namelen;\n\n\tdown_read(&ls->ls_root_sem);\n\n\tif (inlen > 1) {\n\t\tr = find_rsb_root(ls, inbuf, inlen);\n\t\tif (!r) {\n\t\t\tinbuf[inlen - 1] = '\\0';\n\t\t\tlog_error(ls, \"copy_master_names from %d start %d %s\",\n\t\t\t\t  nodeid, inlen, inbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tlist = r->res_root_list.next;\n\t} else {\n\t\tlist = ls->ls_root_list.next;\n\t}\n\n\tfor (offset = 0; list != &ls->ls_root_list; list = list->next) {\n\t\tr = list_entry(list, struct dlm_rsb, res_root_list);\n\t\tif (r->res_nodeid)\n\t\t\tcontinue;\n\n\t\tdir_nodeid = dlm_dir_nodeid(r);\n\t\tif (dir_nodeid != nodeid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The block ends when we can't fit the following in the\n\t\t * remaining buffer space:\n\t\t * namelen (uint16_t) +\n\t\t * name (r->res_length) +\n\t\t * end-of-block record 0x0000 (uint16_t)\n\t\t */\n\n\t\tif (offset + sizeof(uint16_t)*2 + r->res_length > outlen) {\n\t\t\t/* Write end-of-block record */\n\t\t\tbe_namelen = cpu_to_be16(0);\n\t\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\t\toffset += sizeof(__be16);\n\t\t\tls->ls_recover_dir_sent_msg++;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbe_namelen = cpu_to_be16(r->res_length);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tmemcpy(outbuf + offset, r->res_name, r->res_length);\n\t\toffset += r->res_length;\n\t\tls->ls_recover_dir_sent_res++;\n\t}\n\n\t/*\n\t * If we've reached the end of the list (and there's room) write a\n\t * terminating record.\n\t */\n\n\tif ((list == &ls->ls_root_list) &&\n\t    (offset + sizeof(uint16_t) <= outlen)) {\n\t\tbe_namelen = cpu_to_be16(0xFFFF);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tls->ls_recover_dir_sent_msg++;\n\t}\n out:\n\tup_read(&ls->ls_root_sem);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"lock.h\"",
            "#include \"util.h\"",
            "#include \"recover.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"lock.h\"\n#include \"util.h\"\n#include \"recover.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_copy_master_names(struct dlm_ls *ls, char *inbuf, int inlen,\n \t\t\t   char *outbuf, int outlen, int nodeid)\n{\n\tstruct list_head *list;\n\tstruct dlm_rsb *r;\n\tint offset = 0, dir_nodeid;\n\t__be16 be_namelen;\n\n\tdown_read(&ls->ls_root_sem);\n\n\tif (inlen > 1) {\n\t\tr = find_rsb_root(ls, inbuf, inlen);\n\t\tif (!r) {\n\t\t\tinbuf[inlen - 1] = '\\0';\n\t\t\tlog_error(ls, \"copy_master_names from %d start %d %s\",\n\t\t\t\t  nodeid, inlen, inbuf);\n\t\t\tgoto out;\n\t\t}\n\t\tlist = r->res_root_list.next;\n\t} else {\n\t\tlist = ls->ls_root_list.next;\n\t}\n\n\tfor (offset = 0; list != &ls->ls_root_list; list = list->next) {\n\t\tr = list_entry(list, struct dlm_rsb, res_root_list);\n\t\tif (r->res_nodeid)\n\t\t\tcontinue;\n\n\t\tdir_nodeid = dlm_dir_nodeid(r);\n\t\tif (dir_nodeid != nodeid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * The block ends when we can't fit the following in the\n\t\t * remaining buffer space:\n\t\t * namelen (uint16_t) +\n\t\t * name (r->res_length) +\n\t\t * end-of-block record 0x0000 (uint16_t)\n\t\t */\n\n\t\tif (offset + sizeof(uint16_t)*2 + r->res_length > outlen) {\n\t\t\t/* Write end-of-block record */\n\t\t\tbe_namelen = cpu_to_be16(0);\n\t\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\t\toffset += sizeof(__be16);\n\t\t\tls->ls_recover_dir_sent_msg++;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbe_namelen = cpu_to_be16(r->res_length);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tmemcpy(outbuf + offset, r->res_name, r->res_length);\n\t\toffset += r->res_length;\n\t\tls->ls_recover_dir_sent_res++;\n\t}\n\n\t/*\n\t * If we've reached the end of the list (and there's room) write a\n\t * terminating record.\n\t */\n\n\tif ((list == &ls->ls_root_list) &&\n\t    (offset + sizeof(uint16_t) <= outlen)) {\n\t\tbe_namelen = cpu_to_be16(0xFFFF);\n\t\tmemcpy(outbuf + offset, &be_namelen, sizeof(__be16));\n\t\toffset += sizeof(__be16);\n\t\tls->ls_recover_dir_sent_msg++;\n\t}\n out:\n\tup_read(&ls->ls_root_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "nodeid",
            "DLM_RCOM_NAMES_REPLY",
            "outlen",
            "&rc",
            "&mh"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_names(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error, inlen, outlen, nodeid;\n\n\tnodeid = rc_in->rc_header.h_nodeid;\n\tinlen = rc_in->rc_header.h_length - sizeof(struct dlm_rcom);\n\toutlen = dlm_config.ci_buffer_size - sizeof(struct dlm_rcom);\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES_REPLY, outlen, &rc, &mh);\n\tif (error)\n\t\treturn;\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\n\tdlm_copy_master_names(ls, rc_in->rc_buf, inlen, rc->rc_buf, outlen,\n\t\t\t      nodeid);\n\tsend_rcom(ls, mh, rc);\n}"
  },
  {
    "function_name": "dlm_rcom_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "271-293",
    "snippet": "int dlm_rcom_names(struct dlm_ls *ls, int nodeid, char *last_name, int last_len)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES, last_len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, last_name, last_len);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disallow_sync_reply",
          "args": [
            "ls"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "disallow_sync_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "125-131",
          "snippet": "static void disallow_sync_reply(struct dlm_ls *ls)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void disallow_sync_reply(struct dlm_ls *ls)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_function",
          "args": [
            "ls",
            "&rcom_response"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "44-62",
          "snippet": "int dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_recover_buf",
            "0",
            "dlm_config.ci_buffer_size"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_sync_reply",
          "args": [
            "ls",
            "&rc->rc_id"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "allow_sync_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "117-123",
          "snippet": "static void allow_sync_reply(struct dlm_ls *ls, uint64_t *new_seq)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\t*new_seq = ++ls->ls_rcom_seq;\n\tset_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void allow_sync_reply(struct dlm_ls *ls, uint64_t *new_seq)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\t*new_seq = ++ls->ls_rcom_seq;\n\tset_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rc->rc_buf",
            "last_name",
            "last_len"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "nodeid",
            "DLM_RCOM_NAMES",
            "last_len",
            "&rc",
            "&mh"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_rcom_names(struct dlm_ls *ls, int nodeid, char *last_name, int last_len)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_NAMES, last_len, &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\tmemcpy(rc->rc_buf, last_name, last_len);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "receive_sync_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "252-269",
    "snippet": "static void receive_sync_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tif (!test_bit(LSFL_RCOM_WAIT, &ls->ls_flags) ||\n\t    rc_in->rc_id != ls->ls_rcom_seq) {\n\t\tlog_debug(ls, \"reject reply %d from %d seq %llx expect %llx\",\n\t\t\t  rc_in->rc_type, rc_in->rc_header.h_nodeid,\n\t\t\t  (unsigned long long)rc_in->rc_id,\n\t\t\t  (unsigned long long)ls->ls_rcom_seq);\n\t\tgoto out;\n\t}\n\tmemcpy(ls->ls_recover_buf, rc_in, rc_in->rc_header.h_length);\n\tset_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\twake_up(&ls->ls_wait_general);\n out:\n\tspin_unlock(&ls->ls_rcom_spin);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rcom_spin"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&ls->ls_wait_general"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "LSFL_RCOM_WAIT",
            "&ls->ls_flags"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_RCOM_READY",
            "&ls->ls_flags"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ls->ls_recover_buf",
            "rc_in",
            "rc_in->rc_header.h_length"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"reject reply %d from %d seq %llx expect %llx\"",
            "rc_in->rc_type",
            "rc_in->rc_header.h_nodeid",
            "(unsigned long long)rc_in->rc_id",
            "(unsigned long long)ls->ls_rcom_seq"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_RCOM_WAIT",
            "&ls->ls_flags"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rcom_spin"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_sync_reply(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tif (!test_bit(LSFL_RCOM_WAIT, &ls->ls_flags) ||\n\t    rc_in->rc_id != ls->ls_rcom_seq) {\n\t\tlog_debug(ls, \"reject reply %d from %d seq %llx expect %llx\",\n\t\t\t  rc_in->rc_type, rc_in->rc_header.h_nodeid,\n\t\t\t  (unsigned long long)rc_in->rc_id,\n\t\t\t  (unsigned long long)ls->ls_rcom_seq);\n\t\tgoto out;\n\t}\n\tmemcpy(ls->ls_recover_buf, rc_in, rc_in->rc_header.h_length);\n\tset_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\twake_up(&ls->ls_wait_general);\n out:\n\tspin_unlock(&ls->ls_rcom_spin);\n}"
  },
  {
    "function_name": "receive_rcom_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "191-250",
    "snippet": "static void receive_rcom_status(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_status *rs;\n\tuint32_t status;\n\tint nodeid = rc_in->rc_header.h_nodeid;\n\tint len = sizeof(struct rcom_config);\n\tint num_slots = 0;\n\tint error;\n\n\tif (!dlm_slots_version(&rc_in->rc_header)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\trs = (struct rcom_status *)rc_in->rc_buf;\n\n\tif (!(le32_to_cpu(rs->rs_flags) & DLM_RSF_NEED_SLOTS)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tnum_slots = ls->ls_num_slots;\n\tspin_unlock(&ls->ls_recover_lock);\n\tlen += num_slots * sizeof(struct rcom_slot);\n\n do_create:\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS_REPLY,\n\t\t\t    len, &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = status;\n\n\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, num_slots);\n\n\tif (!num_slots)\n\t\tgoto do_send;\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_num_slots != num_slots) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_debug(ls, \"receive_rcom_status num_slots %d to %d\",\n\t\t\t  num_slots, ls->ls_num_slots);\n\t\trc->rc_result = 0;\n\t\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, 0);\n\t\tgoto do_send;\n\t}\n\n\tdlm_slots_copy_out(ls, rc);\n\tspin_unlock(&ls->ls_recover_lock);\n\n do_send:\n\tsend_rcom(ls, mh, rc);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_slots_copy_out",
          "args": [
            "ls",
            "rc"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_slots_copy_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "41-59",
          "snippet": "void dlm_slots_copy_out(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_slot *slot;\n\tstruct rcom_slot *ro;\n\tint i;\n\n\tro = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\t/* ls_slots array is sparse, but not rcom_slots */\n\n\tfor (i = 0; i < ls->ls_slots_size; i++) {\n\t\tslot = &ls->ls_slots[i];\n\t\tif (!slot->nodeid)\n\t\t\tcontinue;\n\t\tro->ro_nodeid = cpu_to_le32(slot->nodeid);\n\t\tro->ro_slot = cpu_to_le16(slot->slot);\n\t\tro++;\n\t}\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_slots_copy_out(struct dlm_ls *ls, struct dlm_rcom *rc)\n{\n\tstruct dlm_slot *slot;\n\tstruct rcom_slot *ro;\n\tint i;\n\n\tro = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\n\n\t/* ls_slots array is sparse, but not rcom_slots */\n\n\tfor (i = 0; i < ls->ls_slots_size; i++) {\n\t\tslot = &ls->ls_slots[i];\n\t\tif (!slot->nodeid)\n\t\t\tcontinue;\n\t\tro->ro_nodeid = cpu_to_le32(slot->nodeid);\n\t\tro->ro_slot = cpu_to_le16(slot->slot);\n\t\tro++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rcom_config",
          "args": [
            "ls",
            "(struct rcom_config *)rc->rc_buf",
            "0"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "set_rcom_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "84-93",
          "snippet": "static void set_rcom_config(struct dlm_ls *ls, struct rcom_config *rf,\n\t\t\t    uint32_t num_slots)\n{\n\trf->rf_lvblen = cpu_to_le32(ls->ls_lvblen);\n\trf->rf_lsflags = cpu_to_le32(ls->ls_exflags);\n\n\trf->rf_our_slot = cpu_to_le16(ls->ls_slot);\n\trf->rf_num_slots = cpu_to_le16(num_slots);\n\trf->rf_generation =  cpu_to_le32(ls->ls_generation);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_rcom_config(struct dlm_ls *ls, struct rcom_config *rf,\n\t\t\t    uint32_t num_slots)\n{\n\trf->rf_lvblen = cpu_to_le32(ls->ls_lvblen);\n\trf->rf_lsflags = cpu_to_le32(ls->ls_exflags);\n\n\trf->rf_our_slot = cpu_to_le16(ls->ls_slot);\n\trf->rf_num_slots = cpu_to_le16(num_slots);\n\trf->rf_generation =  cpu_to_le32(ls->ls_generation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"receive_rcom_status num_slots %d to %d\"",
            "num_slots",
            "ls->ls_num_slots"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "nodeid",
            "DLM_RCOM_STATUS_REPLY",
            "len",
            "&rc",
            "&mh"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recover_status",
          "args": [
            "ls"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "72-79",
          "snippet": "uint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nuint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rs->rs_flags"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_slots_version",
          "args": [
            "&rc_in->rc_header"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_slots_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/member.c",
          "lines": "22-27",
          "snippet": "int dlm_slots_version(struct dlm_header *h)\n{\n\tif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include \"rcom.h\"",
            "#include \"recover.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include \"rcom.h\"\n#include \"recover.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_slots_version(struct dlm_header *h)\n{\n\tif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void receive_rcom_status(struct dlm_ls *ls, struct dlm_rcom *rc_in)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tstruct rcom_status *rs;\n\tuint32_t status;\n\tint nodeid = rc_in->rc_header.h_nodeid;\n\tint len = sizeof(struct rcom_config);\n\tint num_slots = 0;\n\tint error;\n\n\tif (!dlm_slots_version(&rc_in->rc_header)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\trs = (struct rcom_status *)rc_in->rc_buf;\n\n\tif (!(le32_to_cpu(rs->rs_flags) & DLM_RSF_NEED_SLOTS)) {\n\t\tstatus = dlm_recover_status(ls);\n\t\tgoto do_create;\n\t}\n\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tnum_slots = ls->ls_num_slots;\n\tspin_unlock(&ls->ls_recover_lock);\n\tlen += num_slots * sizeof(struct rcom_slot);\n\n do_create:\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS_REPLY,\n\t\t\t    len, &rc, &mh);\n\tif (error)\n\t\treturn;\n\n\trc->rc_id = rc_in->rc_id;\n\trc->rc_seq_reply = rc_in->rc_seq;\n\trc->rc_result = status;\n\n\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, num_slots);\n\n\tif (!num_slots)\n\t\tgoto do_send;\n\n\tspin_lock(&ls->ls_recover_lock);\n\tif (ls->ls_num_slots != num_slots) {\n\t\tspin_unlock(&ls->ls_recover_lock);\n\t\tlog_debug(ls, \"receive_rcom_status num_slots %d to %d\",\n\t\t\t  num_slots, ls->ls_num_slots);\n\t\trc->rc_result = 0;\n\t\tset_rcom_config(ls, (struct rcom_config *)rc->rc_buf, 0);\n\t\tgoto do_send;\n\t}\n\n\tdlm_slots_copy_out(ls, rc);\n\tspin_unlock(&ls->ls_recover_lock);\n\n do_send:\n\tsend_rcom(ls, mh, rc);\n}"
  },
  {
    "function_name": "dlm_rcom_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "144-189",
    "snippet": "int dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == -ESRCH) {\n\t\t/* we pretend the remote lockspace exists with 0 status */\n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t/* the caller looks at rc_result for the remote recovery status */\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_rcom_config",
          "args": [
            "ls",
            "rc",
            "nodeid"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "check_rcom_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "95-115",
          "snippet": "static int check_rcom_config(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tstruct rcom_config *rf = (struct rcom_config *) rc->rc_buf;\n\n\tif ((rc->rc_header.h_version & 0xFFFF0000) != DLM_HEADER_MAJOR) {\n\t\tlog_error(ls, \"version mismatch: %x nodeid %d: %x\",\n\t\t\t  DLM_HEADER_MAJOR | DLM_HEADER_MINOR, nodeid,\n\t\t\t  rc->rc_header.h_version);\n\t\treturn -EPROTO;\n\t}\n\n\tif (le32_to_cpu(rf->rf_lvblen) != ls->ls_lvblen ||\n\t    le32_to_cpu(rf->rf_lsflags) != ls->ls_exflags) {\n\t\tlog_error(ls, \"config mismatch: %d,%x nodeid %d: %d,%x\",\n\t\t\t  ls->ls_lvblen, ls->ls_exflags, nodeid,\n\t\t\t  le32_to_cpu(rf->rf_lvblen),\n\t\t\t  le32_to_cpu(rf->rf_lsflags));\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int check_rcom_config(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tstruct rcom_config *rf = (struct rcom_config *) rc->rc_buf;\n\n\tif ((rc->rc_header.h_version & 0xFFFF0000) != DLM_HEADER_MAJOR) {\n\t\tlog_error(ls, \"version mismatch: %x nodeid %d: %x\",\n\t\t\t  DLM_HEADER_MAJOR | DLM_HEADER_MINOR, nodeid,\n\t\t\t  rc->rc_header.h_version);\n\t\treturn -EPROTO;\n\t}\n\n\tif (le32_to_cpu(rf->rf_lvblen) != ls->ls_lvblen ||\n\t    le32_to_cpu(rf->rf_lsflags) != ls->ls_exflags) {\n\t\tlog_error(ls, \"config mismatch: %d,%x nodeid %d: %d,%x\",\n\t\t\t  ls->ls_lvblen, ls->ls_exflags, nodeid,\n\t\t\t  le32_to_cpu(rf->rf_lvblen),\n\t\t\t  le32_to_cpu(rf->rf_lsflags));\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_debug",
          "args": [
            "ls",
            "\"remote node %d not ready\"",
            "nodeid"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disallow_sync_reply",
          "args": [
            "ls"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "disallow_sync_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "125-131",
          "snippet": "static void disallow_sync_reply(struct dlm_ls *ls)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void disallow_sync_reply(struct dlm_ls *ls)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_function",
          "args": [
            "ls",
            "&rcom_response"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "44-62",
          "snippet": "int dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_wait_function(struct dlm_ls *ls, int (*testfn) (struct dlm_ls *ls))\n{\n\tint error = 0;\n\tint rv;\n\n\twhile (1) {\n\t\trv = wait_event_timeout(ls->ls_wait_general,\n\t\t\t\t\ttestfn(ls) || dlm_recovery_stopped(ls),\n\t\t\t\t\tdlm_config.ci_recover_timer * HZ);\n\t\tif (rv)\n\t\t\tbreak;\n\t}\n\n\tif (dlm_recovery_stopped(ls)) {\n\t\tlog_debug(ls, \"dlm_wait_function aborted\");\n\t\terror = -EINTR;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_rcom",
          "args": [
            "ls",
            "mh",
            "rc"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "send_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "67-72",
          "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_recover_buf",
            "0",
            "dlm_config.ci_buffer_size"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_sync_reply",
          "args": [
            "ls",
            "&rc->rc_id"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "allow_sync_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "117-123",
          "snippet": "static void allow_sync_reply(struct dlm_ls *ls, uint64_t *new_seq)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\t*new_seq = ++ls->ls_rcom_seq;\n\tset_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void allow_sync_reply(struct dlm_ls *ls, uint64_t *new_seq)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\t*new_seq = ++ls->ls_rcom_seq;\n\tset_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_rcom_status",
          "args": [
            "ls",
            "(struct rcom_status *)rc->rc_buf",
            "status_flags"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "set_rcom_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "74-78",
          "snippet": "static void set_rcom_status(struct dlm_ls *ls, struct rcom_status *rs,\n\t\t\t    uint32_t flags)\n{\n\trs->rs_flags = cpu_to_le32(flags);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_rcom_status(struct dlm_ls *ls, struct rcom_status *rs,\n\t\t\t    uint32_t flags)\n{\n\trs->rs_flags = cpu_to_le32(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_rcom",
          "args": [
            "ls",
            "nodeid",
            "DLM_RCOM_STATUS",
            "sizeof(struct rcom_status)",
            "&rc",
            "&mh"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "create_rcom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
          "lines": "32-65",
          "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_recover_status",
          "args": [
            "ls"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_recover_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "72-79",
          "snippet": "uint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nuint32_t dlm_recover_status(struct dlm_ls *ls)\n{\n\tuint32_t status;\n\tspin_lock(&ls->ls_recover_lock);\n\tstatus = ls->ls_recover_status;\n\tspin_unlock(&ls->ls_recover_lock);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nint dlm_rcom_status(struct dlm_ls *ls, int nodeid, uint32_t status_flags)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tint error = 0;\n\n\tls->ls_recover_nodeid = nodeid;\n\n\tif (nodeid == dlm_our_nodeid()) {\n\t\trc = ls->ls_recover_buf;\n\t\trc->rc_result = dlm_recover_status(ls);\n\t\tgoto out;\n\t}\n\n\terror = create_rcom(ls, nodeid, DLM_RCOM_STATUS,\n\t\t\t    sizeof(struct rcom_status), &rc, &mh);\n\tif (error)\n\t\tgoto out;\n\n\tset_rcom_status(ls, (struct rcom_status *)rc->rc_buf, status_flags);\n\n\tallow_sync_reply(ls, &rc->rc_id);\n\tmemset(ls->ls_recover_buf, 0, dlm_config.ci_buffer_size);\n\n\tsend_rcom(ls, mh, rc);\n\n\terror = dlm_wait_function(ls, &rcom_response);\n\tdisallow_sync_reply(ls);\n\tif (error)\n\t\tgoto out;\n\n\trc = ls->ls_recover_buf;\n\n\tif (rc->rc_result == -ESRCH) {\n\t\t/* we pretend the remote lockspace exists with 0 status */\n\t\tlog_debug(ls, \"remote node %d not ready\", nodeid);\n\t\trc->rc_result = 0;\n\t\terror = 0;\n\t} else {\n\t\terror = check_rcom_config(ls, rc, nodeid);\n\t}\n\n\t/* the caller looks at rc_result for the remote recovery status */\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "disallow_sync_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "125-131",
    "snippet": "static void disallow_sync_reply(struct dlm_ls *ls)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rcom_spin"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "LSFL_RCOM_READY",
            "&ls->ls_flags"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rcom_spin"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void disallow_sync_reply(struct dlm_ls *ls)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\tclear_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tclear_bit(LSFL_RCOM_READY, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}"
  },
  {
    "function_name": "allow_sync_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "117-123",
    "snippet": "static void allow_sync_reply(struct dlm_ls *ls, uint64_t *new_seq)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\t*new_seq = ++ls->ls_rcom_seq;\n\tset_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_rcom_spin"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "LSFL_RCOM_WAIT",
            "&ls->ls_flags"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_rcom_spin"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void allow_sync_reply(struct dlm_ls *ls, uint64_t *new_seq)\n{\n\tspin_lock(&ls->ls_rcom_spin);\n\t*new_seq = ++ls->ls_rcom_seq;\n\tset_bit(LSFL_RCOM_WAIT, &ls->ls_flags);\n\tspin_unlock(&ls->ls_rcom_spin);\n}"
  },
  {
    "function_name": "check_rcom_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "95-115",
    "snippet": "static int check_rcom_config(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tstruct rcom_config *rf = (struct rcom_config *) rc->rc_buf;\n\n\tif ((rc->rc_header.h_version & 0xFFFF0000) != DLM_HEADER_MAJOR) {\n\t\tlog_error(ls, \"version mismatch: %x nodeid %d: %x\",\n\t\t\t  DLM_HEADER_MAJOR | DLM_HEADER_MINOR, nodeid,\n\t\t\t  rc->rc_header.h_version);\n\t\treturn -EPROTO;\n\t}\n\n\tif (le32_to_cpu(rf->rf_lvblen) != ls->ls_lvblen ||\n\t    le32_to_cpu(rf->rf_lsflags) != ls->ls_exflags) {\n\t\tlog_error(ls, \"config mismatch: %d,%x nodeid %d: %d,%x\",\n\t\t\t  ls->ls_lvblen, ls->ls_exflags, nodeid,\n\t\t\t  le32_to_cpu(rf->rf_lvblen),\n\t\t\t  le32_to_cpu(rf->rf_lsflags));\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"config mismatch: %d,%x nodeid %d: %d,%x\"",
            "ls->ls_lvblen",
            "ls->ls_exflags",
            "nodeid",
            "le32_to_cpu(rf->rf_lvblen)",
            "le32_to_cpu(rf->rf_lsflags)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rf->rf_lsflags"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "ls",
            "\"version mismatch: %x nodeid %d: %x\"",
            "DLM_HEADER_MAJOR | DLM_HEADER_MINOR",
            "nodeid",
            "rc->rc_header.h_version"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int check_rcom_config(struct dlm_ls *ls, struct dlm_rcom *rc, int nodeid)\n{\n\tstruct rcom_config *rf = (struct rcom_config *) rc->rc_buf;\n\n\tif ((rc->rc_header.h_version & 0xFFFF0000) != DLM_HEADER_MAJOR) {\n\t\tlog_error(ls, \"version mismatch: %x nodeid %d: %x\",\n\t\t\t  DLM_HEADER_MAJOR | DLM_HEADER_MINOR, nodeid,\n\t\t\t  rc->rc_header.h_version);\n\t\treturn -EPROTO;\n\t}\n\n\tif (le32_to_cpu(rf->rf_lvblen) != ls->ls_lvblen ||\n\t    le32_to_cpu(rf->rf_lsflags) != ls->ls_exflags) {\n\t\tlog_error(ls, \"config mismatch: %d,%x nodeid %d: %d,%x\",\n\t\t\t  ls->ls_lvblen, ls->ls_exflags, nodeid,\n\t\t\t  le32_to_cpu(rf->rf_lvblen),\n\t\t\t  le32_to_cpu(rf->rf_lsflags));\n\t\treturn -EPROTO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_rcom_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "84-93",
    "snippet": "static void set_rcom_config(struct dlm_ls *ls, struct rcom_config *rf,\n\t\t\t    uint32_t num_slots)\n{\n\trf->rf_lvblen = cpu_to_le32(ls->ls_lvblen);\n\trf->rf_lsflags = cpu_to_le32(ls->ls_exflags);\n\n\trf->rf_our_slot = cpu_to_le16(ls->ls_slot);\n\trf->rf_num_slots = cpu_to_le16(num_slots);\n\trf->rf_generation =  cpu_to_le32(ls->ls_generation);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ls->ls_generation"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_slots"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ls->ls_slot"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ls->ls_exflags"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ls->ls_lvblen"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_rcom_config(struct dlm_ls *ls, struct rcom_config *rf,\n\t\t\t    uint32_t num_slots)\n{\n\trf->rf_lvblen = cpu_to_le32(ls->ls_lvblen);\n\trf->rf_lsflags = cpu_to_le32(ls->ls_exflags);\n\n\trf->rf_our_slot = cpu_to_le16(ls->ls_slot);\n\trf->rf_num_slots = cpu_to_le16(num_slots);\n\trf->rf_generation =  cpu_to_le32(ls->ls_generation);\n}"
  },
  {
    "function_name": "set_rcom_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "74-78",
    "snippet": "static void set_rcom_status(struct dlm_ls *ls, struct rcom_status *rs,\n\t\t\t    uint32_t flags)\n{\n\trs->rs_flags = cpu_to_le32(flags);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void set_rcom_status(struct dlm_ls *ls, struct rcom_status *rs,\n\t\t\t    uint32_t flags)\n{\n\trs->rs_flags = cpu_to_le32(flags);\n}"
  },
  {
    "function_name": "send_rcom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "67-72",
    "snippet": "static void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lowcomms_commit_buffer",
          "args": [
            "mh"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_commit_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1531-1552",
          "snippet": "void dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [
            "#define CF_WRITE_PENDING 2"
          ],
          "globals_used": [
            "static struct workqueue_struct *send_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\n#define CF_WRITE_PENDING 2\n\nstatic struct workqueue_struct *send_workqueue;\n\nvoid dlm_lowcomms_commit_buffer(void *mh)\n{\n\tstruct writequeue_entry *e = (struct writequeue_entry *)mh;\n\tstruct connection *con = e->con;\n\tint users;\n\n\tspin_lock(&con->writequeue_lock);\n\tusers = --e->users;\n\tif (users)\n\t\tgoto out;\n\te->len = e->end - e->offset;\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\n\t\tqueue_work(send_workqueue, &con->swork);\n\t}\n\treturn;\n\nout:\n\tspin_unlock(&con->writequeue_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_rcom_out",
          "args": [
            "rc"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_rcom_out",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/util.c",
          "lines": "134-143",
          "snippet": "void dlm_rcom_out(struct dlm_rcom *rc)\n{\n\theader_out(&rc->rc_header);\n\n\trc->rc_type\t\t= cpu_to_le32(rc->rc_type);\n\trc->rc_result\t\t= cpu_to_le32(rc->rc_result);\n\trc->rc_id\t\t= cpu_to_le64(rc->rc_id);\n\trc->rc_seq\t\t= cpu_to_le64(rc->rc_seq);\n\trc->rc_seq_reply\t= cpu_to_le64(rc->rc_seq_reply);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"rcom.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"rcom.h\"\n#include \"dlm_internal.h\"\n\nvoid dlm_rcom_out(struct dlm_rcom *rc)\n{\n\theader_out(&rc->rc_header);\n\n\trc->rc_type\t\t= cpu_to_le32(rc->rc_type);\n\trc->rc_result\t\t= cpu_to_le32(rc->rc_result);\n\trc->rc_id\t\t= cpu_to_le64(rc->rc_id);\n\trc->rc_seq\t\t= cpu_to_le64(rc->rc_seq);\n\trc->rc_seq_reply\t= cpu_to_le64(rc->rc_seq_reply);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic void send_rcom(struct dlm_ls *ls, struct dlm_mhandle *mh,\n\t\t      struct dlm_rcom *rc)\n{\n\tdlm_rcom_out(rc);\n\tdlm_lowcomms_commit_buffer(mh);\n}"
  },
  {
    "function_name": "create_rcom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "32-65",
    "snippet": "static int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_lock"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mb",
            "0",
            "mb_len"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"create_rcom to %d type %d len %d ENOBUFS\"",
            "to_nodeid",
            "type",
            "len"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lowcomms_get_buffer",
          "args": [
            "to_nodeid",
            "mb_len",
            "GFP_NOFS",
            "&mb"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lowcomms_get_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lowcomms.c",
          "lines": "1490-1529",
          "snippet": "void *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"midcomms.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\"",
            "#include <net/ipv6.h>",
            "#include <net/sctp/sctp.h>",
            "#include <linux/slab.h>",
            "#include <linux/sctp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <net/tcp.h>",
            "#include <net/sock.h>",
            "#include <asm/ioctls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n#include <net/ipv6.h>\n#include <net/sctp/sctp.h>\n#include <linux/slab.h>\n#include <linux/sctp.h>\n#include <linux/mutex.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <net/tcp.h>\n#include <net/sock.h>\n#include <asm/ioctls.h>\n\nvoid *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\n{\n\tstruct connection *con;\n\tstruct writequeue_entry *e;\n\tint offset = 0;\n\n\tcon = nodeid2con(nodeid, allocation);\n\tif (!con)\n\t\treturn NULL;\n\n\tspin_lock(&con->writequeue_lock);\n\te = list_entry(con->writequeue.prev, struct writequeue_entry, list);\n\tif ((&e->list == &con->writequeue) ||\n\t    (PAGE_CACHE_SIZE - e->end < len)) {\n\t\te = NULL;\n\t} else {\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t}\n\tspin_unlock(&con->writequeue_lock);\n\n\tif (e) {\n\tgot_one:\n\t\t*ppc = page_address(e->page) + offset;\n\t\treturn e;\n\t}\n\n\te = new_writequeue_entry(con, allocation);\n\tif (e) {\n\t\tspin_lock(&con->writequeue_lock);\n\t\toffset = e->end;\n\t\te->end += len;\n\t\te->users++;\n\t\tlist_add_tail(&e->list, &con->writequeue);\n\t\tspin_unlock(&con->writequeue_lock);\n\t\tgoto got_one;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int create_rcom(struct dlm_ls *ls, int to_nodeid, int type, int len,\n\t\t       struct dlm_rcom **rc_ret, struct dlm_mhandle **mh_ret)\n{\n\tstruct dlm_rcom *rc;\n\tstruct dlm_mhandle *mh;\n\tchar *mb;\n\tint mb_len = sizeof(struct dlm_rcom) + len;\n\n\tmh = dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, &mb);\n\tif (!mh) {\n\t\tlog_print(\"create_rcom to %d type %d len %d ENOBUFS\",\n\t\t\t  to_nodeid, type, len);\n\t\treturn -ENOBUFS;\n\t}\n\tmemset(mb, 0, mb_len);\n\n\trc = (struct dlm_rcom *) mb;\n\n\trc->rc_header.h_version = (DLM_HEADER_MAJOR | DLM_HEADER_MINOR);\n\trc->rc_header.h_lockspace = ls->ls_global_id;\n\trc->rc_header.h_nodeid = dlm_our_nodeid();\n\trc->rc_header.h_length = mb_len;\n\trc->rc_header.h_cmd = DLM_RCOM;\n\n\trc->rc_type = type;\n\n\tspin_lock(&ls->ls_recover_lock);\n\trc->rc_seq = ls->ls_recover_seq;\n\tspin_unlock(&ls->ls_recover_lock);\n\n\t*mh_ret = mh;\n\t*rc_ret = rc;\n\treturn 0;\n}"
  },
  {
    "function_name": "rcom_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/rcom.c",
    "lines": "27-30",
    "snippet": "static int rcom_response(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RCOM_READY, &ls->ls_flags);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"lock.h\"",
      "#include \"memory.h\"",
      "#include \"config.h\"",
      "#include \"dir.h\"",
      "#include \"recover.h\"",
      "#include \"rcom.h\"",
      "#include \"midcomms.h\"",
      "#include \"lowcomms.h\"",
      "#include \"member.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "LSFL_RCOM_READY",
            "&ls->ls_flags"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"midcomms.h\"\n#include \"lowcomms.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int rcom_response(struct dlm_ls *ls)\n{\n\treturn test_bit(LSFL_RCOM_READY, &ls->ls_flags);\n}"
  }
]