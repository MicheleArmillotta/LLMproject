[
  {
    "function_name": "squashfs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "453-498",
    "snippet": "static int squashfs_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint index = page->index >> (msblk->block_log - PAGE_CACHE_SHIFT);\n\tint file_end = i_size_read(inode) >> msblk->block_log;\n\tint res;\n\tvoid *pageaddr;\n\n\tTRACE(\"Entered squashfs_readpage, page index %lx, start block %llx\\n\",\n\t\t\t\tpage->index, squashfs_i(inode)->start);\n\n\tif (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>\n\t\t\t\t\tPAGE_CACHE_SHIFT))\n\t\tgoto out;\n\n\tif (index < file_end || squashfs_i(inode)->fragment_block ==\n\t\t\t\t\tSQUASHFS_INVALID_BLK) {\n\t\tu64 block = 0;\n\t\tint bsize = read_blocklist(inode, index, &block);\n\t\tif (bsize < 0)\n\t\t\tgoto error_out;\n\n\t\tif (bsize == 0)\n\t\t\tres = squashfs_readpage_sparse(page, index, file_end);\n\t\telse\n\t\t\tres = squashfs_readpage_block(page, block, bsize);\n\t} else\n\t\tres = squashfs_readpage_fragment(page);\n\n\tif (!res)\n\t\treturn 0;\n\nerror_out:\n\tSetPageError(page);\nout:\n\tpageaddr = kmap_atomic(page);\n\tmemset(pageaddr, 0, PAGE_CACHE_SIZE);\n\tkunmap_atomic(pageaddr);\n\tflush_dcache_page(page);\n\tif (!PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "pageaddr"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pageaddr",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_readpage_fragment",
          "args": [
            "page"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_readpage_fragment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "419-439",
          "snippet": "static int squashfs_readpage_fragment(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_fragment(inode->i_sb,\n\t\tsquashfs_i(inode)->fragment_block,\n\t\tsquashfs_i(inode)->fragment_size);\n\tint res = buffer->error;\n\n\tif (res)\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\",\n\t\t\tsquashfs_i(inode)->fragment_block,\n\t\t\tsquashfs_i(inode)->fragment_size);\n\telse\n\t\tsquashfs_copy_cache(page, buffer, i_size_read(inode) &\n\t\t\t(msblk->block_size - 1),\n\t\t\tsquashfs_i(inode)->fragment_offset);\n\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_readpage_fragment(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_fragment(inode->i_sb,\n\t\tsquashfs_i(inode)->fragment_block,\n\t\tsquashfs_i(inode)->fragment_size);\n\tint res = buffer->error;\n\n\tif (res)\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\",\n\t\t\tsquashfs_i(inode)->fragment_block,\n\t\t\tsquashfs_i(inode)->fragment_size);\n\telse\n\t\tsquashfs_copy_cache(page, buffer, i_size_read(inode) &\n\t\t\t(msblk->block_size - 1),\n\t\t\tsquashfs_i(inode)->fragment_offset);\n\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_readpage_block",
          "args": [
            "page",
            "block",
            "bsize"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_readpage_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file_direct.c",
          "lines": "27-137",
          "snippet": "int squashfs_readpage_block(struct page *target_page, u64 block, int bsize)\n\n{\n\tstruct inode *inode = target_page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\n\tint file_end = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\tint mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = target_page->index & ~mask;\n\tint end_index = start_index | mask;\n\tint i, n, pages, missing_pages, bytes, res = -ENOMEM;\n\tstruct page **page;\n\tstruct squashfs_page_actor *actor;\n\tvoid *pageaddr;\n\n\tif (end_index > file_end)\n\t\tend_index = file_end;\n\n\tpages = end_index - start_index + 1;\n\n\tpage = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tif (page == NULL)\n\t\treturn res;\n\n\t/*\n\t * Create a \"page actor\" which will kmap and kunmap the\n\t * page cache pages appropriately within the decompressor\n\t */\n\tactor = squashfs_page_actor_init_special(page, pages, 0);\n\tif (actor == NULL)\n\t\tgoto out;\n\n\t/* Try to grab all the pages covered by the Squashfs block */\n\tfor (missing_pages = 0, i = 0, n = start_index; i < pages; i++, n++) {\n\t\tpage[i] = (n == target_page->index) ? target_page :\n\t\t\tgrab_cache_page_nowait(target_page->mapping, n);\n\n\t\tif (page[i] == NULL) {\n\t\t\tmissing_pages++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageUptodate(page[i])) {\n\t\t\tunlock_page(page[i]);\n\t\t\tpage_cache_release(page[i]);\n\t\t\tpage[i] = NULL;\n\t\t\tmissing_pages++;\n\t\t}\n\t}\n\n\tif (missing_pages) {\n\t\t/*\n\t\t * Couldn't get one or more pages, this page has either\n\t\t * been VM reclaimed, but others are still in the page cache\n\t\t * and uptodate, or we're racing with another thread in\n\t\t * squashfs_readpage also trying to grab them.  Fall back to\n\t\t * using an intermediate buffer.\n\t\t */\n\t\tres = squashfs_read_cache(target_page, block, bsize, pages,\n\t\t\t\t\t\t\t\tpage);\n\t\tif (res < 0)\n\t\t\tgoto mark_errored;\n\n\t\tgoto out;\n\t}\n\n\t/* Decompress directly into the page cache buffers */\n\tres = squashfs_read_data(inode->i_sb, block, bsize, NULL, actor);\n\tif (res < 0)\n\t\tgoto mark_errored;\n\n\t/* Last page may have trailing bytes not filled */\n\tbytes = res % PAGE_CACHE_SIZE;\n\tif (bytes) {\n\t\tpageaddr = kmap_atomic(page[pages - 1]);\n\t\tmemset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);\n\t\tkunmap_atomic(pageaddr);\n\t}\n\n\t/* Mark pages as uptodate, unlock and release */\n\tfor (i = 0; i < pages; i++) {\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageUptodate(page[i]);\n\t\tunlock_page(page[i]);\n\t\tif (page[i] != target_page)\n\t\t\tpage_cache_release(page[i]);\n\t}\n\n\tkfree(actor);\n\tkfree(page);\n\n\treturn 0;\n\nmark_errored:\n\t/* Decompression failed, mark pages as errored.  Target_page is\n\t * dealt with by the caller\n\t */\n\tfor (i = 0; i < pages; i++) {\n\t\tif (page[i] == NULL || page[i] == target_page)\n\t\t\tcontinue;\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageError(page[i]);\n\t\tunlock_page(page[i]);\n\t\tpage_cache_release(page[i]);\n\t}\n\nout:\n\tkfree(actor);\n\tkfree(page);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_read_cache(struct page *target_page, u64 block, int bsize,\n\tint pages, struct page **page);\n\nint squashfs_readpage_block(struct page *target_page, u64 block, int bsize)\n\n{\n\tstruct inode *inode = target_page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\n\tint file_end = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\tint mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = target_page->index & ~mask;\n\tint end_index = start_index | mask;\n\tint i, n, pages, missing_pages, bytes, res = -ENOMEM;\n\tstruct page **page;\n\tstruct squashfs_page_actor *actor;\n\tvoid *pageaddr;\n\n\tif (end_index > file_end)\n\t\tend_index = file_end;\n\n\tpages = end_index - start_index + 1;\n\n\tpage = kmalloc_array(pages, sizeof(void *), GFP_KERNEL);\n\tif (page == NULL)\n\t\treturn res;\n\n\t/*\n\t * Create a \"page actor\" which will kmap and kunmap the\n\t * page cache pages appropriately within the decompressor\n\t */\n\tactor = squashfs_page_actor_init_special(page, pages, 0);\n\tif (actor == NULL)\n\t\tgoto out;\n\n\t/* Try to grab all the pages covered by the Squashfs block */\n\tfor (missing_pages = 0, i = 0, n = start_index; i < pages; i++, n++) {\n\t\tpage[i] = (n == target_page->index) ? target_page :\n\t\t\tgrab_cache_page_nowait(target_page->mapping, n);\n\n\t\tif (page[i] == NULL) {\n\t\t\tmissing_pages++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageUptodate(page[i])) {\n\t\t\tunlock_page(page[i]);\n\t\t\tpage_cache_release(page[i]);\n\t\t\tpage[i] = NULL;\n\t\t\tmissing_pages++;\n\t\t}\n\t}\n\n\tif (missing_pages) {\n\t\t/*\n\t\t * Couldn't get one or more pages, this page has either\n\t\t * been VM reclaimed, but others are still in the page cache\n\t\t * and uptodate, or we're racing with another thread in\n\t\t * squashfs_readpage also trying to grab them.  Fall back to\n\t\t * using an intermediate buffer.\n\t\t */\n\t\tres = squashfs_read_cache(target_page, block, bsize, pages,\n\t\t\t\t\t\t\t\tpage);\n\t\tif (res < 0)\n\t\t\tgoto mark_errored;\n\n\t\tgoto out;\n\t}\n\n\t/* Decompress directly into the page cache buffers */\n\tres = squashfs_read_data(inode->i_sb, block, bsize, NULL, actor);\n\tif (res < 0)\n\t\tgoto mark_errored;\n\n\t/* Last page may have trailing bytes not filled */\n\tbytes = res % PAGE_CACHE_SIZE;\n\tif (bytes) {\n\t\tpageaddr = kmap_atomic(page[pages - 1]);\n\t\tmemset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);\n\t\tkunmap_atomic(pageaddr);\n\t}\n\n\t/* Mark pages as uptodate, unlock and release */\n\tfor (i = 0; i < pages; i++) {\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageUptodate(page[i]);\n\t\tunlock_page(page[i]);\n\t\tif (page[i] != target_page)\n\t\t\tpage_cache_release(page[i]);\n\t}\n\n\tkfree(actor);\n\tkfree(page);\n\n\treturn 0;\n\nmark_errored:\n\t/* Decompression failed, mark pages as errored.  Target_page is\n\t * dealt with by the caller\n\t */\n\tfor (i = 0; i < pages; i++) {\n\t\tif (page[i] == NULL || page[i] == target_page)\n\t\t\tcontinue;\n\t\tflush_dcache_page(page[i]);\n\t\tSetPageError(page[i]);\n\t\tunlock_page(page[i]);\n\t\tpage_cache_release(page[i]);\n\t}\n\nout:\n\tkfree(actor);\n\tkfree(page);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_readpage_sparse",
          "args": [
            "page",
            "index",
            "file_end"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_readpage_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "441-451",
          "snippet": "static int squashfs_readpage_sparse(struct page *page, int index, int file_end)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint bytes = index == file_end ?\n\t\t\t(i_size_read(inode) & (msblk->block_size - 1)) :\n\t\t\t msblk->block_size;\n\n\tsquashfs_copy_cache(page, NULL, bytes, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_readpage_sparse(struct page *page, int index, int file_end)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint bytes = index == file_end ?\n\t\t\t(i_size_read(inode) & (msblk->block_size - 1)) :\n\t\t\t msblk->block_size;\n\n\tsquashfs_copy_cache(page, NULL, bytes, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_blocklist",
          "args": [
            "inode",
            "index",
            "&block"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "read_blocklist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "335-371",
          "snippet": "static int read_blocklist(struct inode *inode, int index, u64 *block)\n{\n\tu64 start;\n\tlong long blks;\n\tint offset;\n\t__le32 size;\n\tint res = fill_meta_index(inode, index, &start, &offset, block);\n\n\tTRACE(\"read_blocklist: res %d, index %d, start 0x%llx, offset\"\n\t\t       \" 0x%x, block 0x%llx\\n\", res, index, start, offset,\n\t\t\t*block);\n\n\tif (res < 0)\n\t\treturn res;\n\n\t/*\n\t * res contains the index of the mapping returned by fill_meta_index(),\n\t * this will likely be less than the desired index (because the\n\t * meta_index cache works at a higher granularity).  Read any\n\t * extra block indexes needed.\n\t */\n\tif (res < index) {\n\t\tblks = read_indexes(inode->i_sb, index - res, &start, &offset);\n\t\tif (blks < 0)\n\t\t\treturn (int) blks;\n\t\t*block += blks;\n\t}\n\n\t/*\n\t * Read length of block specified by index.\n\t */\n\tres = squashfs_read_metadata(inode->i_sb, &size, &start, &offset,\n\t\t\tsizeof(size));\n\tif (res < 0)\n\t\treturn res;\n\treturn le32_to_cpu(size);\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int read_blocklist(struct inode *inode, int index, u64 *block)\n{\n\tu64 start;\n\tlong long blks;\n\tint offset;\n\t__le32 size;\n\tint res = fill_meta_index(inode, index, &start, &offset, block);\n\n\tTRACE(\"read_blocklist: res %d, index %d, start 0x%llx, offset\"\n\t\t       \" 0x%x, block 0x%llx\\n\", res, index, start, offset,\n\t\t\t*block);\n\n\tif (res < 0)\n\t\treturn res;\n\n\t/*\n\t * res contains the index of the mapping returned by fill_meta_index(),\n\t * this will likely be less than the desired index (because the\n\t * meta_index cache works at a higher granularity).  Read any\n\t * extra block indexes needed.\n\t */\n\tif (res < index) {\n\t\tblks = read_indexes(inode->i_sb, index - res, &start, &offset);\n\t\tif (blks < 0)\n\t\t\treturn (int) blks;\n\t\t*block += blks;\n\t}\n\n\t/*\n\t * Read length of block specified by index.\n\t */\n\tres = squashfs_read_metadata(inode->i_sb, &size, &start, &offset,\n\t\t\tsizeof(size));\n\tif (res < 0)\n\t\treturn res;\n\treturn le32_to_cpu(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_readpage, page index %lx, start block %llx\\n\"",
            "page->index",
            "squashfs_i(inode)->start"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint index = page->index >> (msblk->block_log - PAGE_CACHE_SHIFT);\n\tint file_end = i_size_read(inode) >> msblk->block_log;\n\tint res;\n\tvoid *pageaddr;\n\n\tTRACE(\"Entered squashfs_readpage, page index %lx, start block %llx\\n\",\n\t\t\t\tpage->index, squashfs_i(inode)->start);\n\n\tif (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>\n\t\t\t\t\tPAGE_CACHE_SHIFT))\n\t\tgoto out;\n\n\tif (index < file_end || squashfs_i(inode)->fragment_block ==\n\t\t\t\t\tSQUASHFS_INVALID_BLK) {\n\t\tu64 block = 0;\n\t\tint bsize = read_blocklist(inode, index, &block);\n\t\tif (bsize < 0)\n\t\t\tgoto error_out;\n\n\t\tif (bsize == 0)\n\t\t\tres = squashfs_readpage_sparse(page, index, file_end);\n\t\telse\n\t\t\tres = squashfs_readpage_block(page, block, bsize);\n\t} else\n\t\tres = squashfs_readpage_fragment(page);\n\n\tif (!res)\n\t\treturn 0;\n\nerror_out:\n\tSetPageError(page);\nout:\n\tpageaddr = kmap_atomic(page);\n\tmemset(pageaddr, 0, PAGE_CACHE_SIZE);\n\tkunmap_atomic(pageaddr);\n\tflush_dcache_page(page);\n\tif (!PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "squashfs_readpage_sparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "441-451",
    "snippet": "static int squashfs_readpage_sparse(struct page *page, int index, int file_end)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint bytes = index == file_end ?\n\t\t\t(i_size_read(inode) & (msblk->block_size - 1)) :\n\t\t\t msblk->block_size;\n\n\tsquashfs_copy_cache(page, NULL, bytes, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_copy_cache",
          "args": [
            "page",
            "NULL",
            "bytes",
            "0"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_copy_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "374-416",
          "snippet": "void squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tvoid *pageaddr;\n\tint i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t/*\n\t * Loop copying datablock into pages.  As the datablock likely covers\n\t * many PAGE_CACHE_SIZE pages (default block size is 128 KiB) explicitly\n\t * grab the pages from the page cache, except for the page that we've\n\t * been called to fill.\n\t */\n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tpageaddr = kmap_atomic(push_page);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(push_page);\n\t\tSetPageUptodate(push_page);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tpage_cache_release(push_page);\n\t}\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tvoid *pageaddr;\n\tint i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t/*\n\t * Loop copying datablock into pages.  As the datablock likely covers\n\t * many PAGE_CACHE_SIZE pages (default block size is 128 KiB) explicitly\n\t * grab the pages from the page cache, except for the page that we've\n\t * been called to fill.\n\t */\n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tpageaddr = kmap_atomic(push_page);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(push_page);\n\t\tSetPageUptodate(push_page);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tpage_cache_release(push_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_readpage_sparse(struct page *page, int index, int file_end)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint bytes = index == file_end ?\n\t\t\t(i_size_read(inode) & (msblk->block_size - 1)) :\n\t\t\t msblk->block_size;\n\n\tsquashfs_copy_cache(page, NULL, bytes, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "squashfs_readpage_fragment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "419-439",
    "snippet": "static int squashfs_readpage_fragment(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_fragment(inode->i_sb,\n\t\tsquashfs_i(inode)->fragment_block,\n\t\tsquashfs_i(inode)->fragment_size);\n\tint res = buffer->error;\n\n\tif (res)\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\",\n\t\t\tsquashfs_i(inode)->fragment_block,\n\t\t\tsquashfs_i(inode)->fragment_size);\n\telse\n\t\tsquashfs_copy_cache(page, buffer, i_size_read(inode) &\n\t\t\t(msblk->block_size - 1),\n\t\t\tsquashfs_i(inode)->fragment_offset);\n\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_cache_put",
          "args": [
            "buffer"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "186-205",
          "snippet": "void squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_cache_put(struct squashfs_cache_entry *entry)\n{\n\tstruct squashfs_cache *cache = entry->cache;\n\n\tspin_lock(&cache->lock);\n\tentry->refcount--;\n\tif (entry->refcount == 0) {\n\t\tcache->unused++;\n\t\t/*\n\t\t * If there's any processes waiting for a block to become\n\t\t * available, wake one up.\n\t\t */\n\t\tif (cache->num_waiters) {\n\t\t\tspin_unlock(&cache->lock);\n\t\t\twake_up(&cache->wait_queue);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&cache->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_copy_cache",
          "args": [
            "page",
            "buffer",
            "i_size_read(inode) &\n\t\t\t(msblk->block_size - 1)",
            "squashfs_i(inode)->fragment_offset"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_copy_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "374-416",
          "snippet": "void squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tvoid *pageaddr;\n\tint i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t/*\n\t * Loop copying datablock into pages.  As the datablock likely covers\n\t * many PAGE_CACHE_SIZE pages (default block size is 128 KiB) explicitly\n\t * grab the pages from the page cache, except for the page that we've\n\t * been called to fill.\n\t */\n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tpageaddr = kmap_atomic(push_page);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(push_page);\n\t\tSetPageUptodate(push_page);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tpage_cache_release(push_page);\n\t}\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tvoid *pageaddr;\n\tint i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t/*\n\t * Loop copying datablock into pages.  As the datablock likely covers\n\t * many PAGE_CACHE_SIZE pages (default block size is 128 KiB) explicitly\n\t * grab the pages from the page cache, except for the page that we've\n\t * been called to fill.\n\t */\n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tpageaddr = kmap_atomic(push_page);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(push_page);\n\t\tSetPageUptodate(push_page);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tpage_cache_release(push_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read page, block %llx, size %x\\n\"",
            "squashfs_i(inode)->fragment_block",
            "squashfs_i(inode)->fragment_size"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_get_fragment",
          "args": [
            "inode->i_sb",
            "squashfs_i(inode)->fragment_block",
            "squashfs_i(inode)->fragment_size"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_get_fragment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "389-396",
          "snippet": "struct squashfs_cache_entry *squashfs_get_fragment(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->fragment_cache, start_block,\n\t\tlength);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct squashfs_cache_entry *squashfs_get_fragment(struct super_block *sb,\n\t\t\t\tu64 start_block, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\n\treturn squashfs_cache_get(sb, msblk->fragment_cache, start_block,\n\t\tlength);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_readpage_fragment(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct squashfs_cache_entry *buffer = squashfs_get_fragment(inode->i_sb,\n\t\tsquashfs_i(inode)->fragment_block,\n\t\tsquashfs_i(inode)->fragment_size);\n\tint res = buffer->error;\n\n\tif (res)\n\t\tERROR(\"Unable to read page, block %llx, size %x\\n\",\n\t\t\tsquashfs_i(inode)->fragment_block,\n\t\t\tsquashfs_i(inode)->fragment_size);\n\telse\n\t\tsquashfs_copy_cache(page, buffer, i_size_read(inode) &\n\t\t\t(msblk->block_size - 1),\n\t\t\tsquashfs_i(inode)->fragment_offset);\n\n\tsquashfs_cache_put(buffer);\n\treturn res;\n}"
  },
  {
    "function_name": "squashfs_copy_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "374-416",
    "snippet": "void squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tvoid *pageaddr;\n\tint i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t/*\n\t * Loop copying datablock into pages.  As the datablock likely covers\n\t * many PAGE_CACHE_SIZE pages (default block size is 128 KiB) explicitly\n\t * grab the pages from the page cache, except for the page that we've\n\t * been called to fill.\n\t */\n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tpageaddr = kmap_atomic(push_page);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(push_page);\n\t\tSetPageUptodate(push_page);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tpage_cache_release(push_page);\n\t}\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "push_page"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "push_page"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "push_page"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "push_page"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "pageaddr"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pageaddr + avail",
            "0",
            "PAGE_CACHE_SIZE - avail"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_copy_data",
          "args": [
            "pageaddr",
            "buffer",
            "offset",
            "avail"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_copy_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "306-335",
          "snippet": "int squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_copy_data(void *buffer, struct squashfs_cache_entry *entry,\n\t\tint offset, int length)\n{\n\tint remaining = length;\n\n\tif (length == 0)\n\t\treturn 0;\n\telse if (buffer == NULL)\n\t\treturn min(length, entry->length - offset);\n\n\twhile (offset < entry->length) {\n\t\tvoid *buff = entry->data[offset / PAGE_CACHE_SIZE]\n\t\t\t\t+ (offset % PAGE_CACHE_SIZE);\n\t\tint bytes = min_t(int, entry->length - offset,\n\t\t\t\tPAGE_CACHE_SIZE - (offset % PAGE_CACHE_SIZE));\n\n\t\tif (bytes >= remaining) {\n\t\t\tmemcpy(buffer, buff, remaining);\n\t\t\tremaining = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(buffer, buff, bytes);\n\t\tbuffer += bytes;\n\t\tremaining -= bytes;\n\t\toffset += bytes;\n\t}\n\n\treturn length - remaining;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "push_page"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "push_page"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page_nowait",
          "args": [
            "page->mapping",
            "i"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"bytes %d, i %d, available_bytes %d\\n\"",
            "bytes",
            "i",
            "avail"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "bytes",
            "PAGE_CACHE_SIZE"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid squashfs_copy_cache(struct page *page, struct squashfs_cache_entry *buffer,\n\tint bytes, int offset)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tvoid *pageaddr;\n\tint i, mask = (1 << (msblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n\tint start_index = page->index & ~mask, end_index = start_index | mask;\n\n\t/*\n\t * Loop copying datablock into pages.  As the datablock likely covers\n\t * many PAGE_CACHE_SIZE pages (default block size is 128 KiB) explicitly\n\t * grab the pages from the page cache, except for the page that we've\n\t * been called to fill.\n\t */\n\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n\t\t\tbytes -= PAGE_CACHE_SIZE, offset += PAGE_CACHE_SIZE) {\n\t\tstruct page *push_page;\n\t\tint avail = buffer ? min_t(int, bytes, PAGE_CACHE_SIZE) : 0;\n\n\t\tTRACE(\"bytes %d, i %d, available_bytes %d\\n\", bytes, i, avail);\n\n\t\tpush_page = (i == page->index) ? page :\n\t\t\tgrab_cache_page_nowait(page->mapping, i);\n\n\t\tif (!push_page)\n\t\t\tcontinue;\n\n\t\tif (PageUptodate(push_page))\n\t\t\tgoto skip_page;\n\n\t\tpageaddr = kmap_atomic(push_page);\n\t\tsquashfs_copy_data(pageaddr, buffer, offset, avail);\n\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n\t\tkunmap_atomic(pageaddr);\n\t\tflush_dcache_page(push_page);\n\t\tSetPageUptodate(push_page);\nskip_page:\n\t\tunlock_page(push_page);\n\t\tif (i != page->index)\n\t\t\tpage_cache_release(push_page);\n\t}\n}"
  },
  {
    "function_name": "read_blocklist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "335-371",
    "snippet": "static int read_blocklist(struct inode *inode, int index, u64 *block)\n{\n\tu64 start;\n\tlong long blks;\n\tint offset;\n\t__le32 size;\n\tint res = fill_meta_index(inode, index, &start, &offset, block);\n\n\tTRACE(\"read_blocklist: res %d, index %d, start 0x%llx, offset\"\n\t\t       \" 0x%x, block 0x%llx\\n\", res, index, start, offset,\n\t\t\t*block);\n\n\tif (res < 0)\n\t\treturn res;\n\n\t/*\n\t * res contains the index of the mapping returned by fill_meta_index(),\n\t * this will likely be less than the desired index (because the\n\t * meta_index cache works at a higher granularity).  Read any\n\t * extra block indexes needed.\n\t */\n\tif (res < index) {\n\t\tblks = read_indexes(inode->i_sb, index - res, &start, &offset);\n\t\tif (blks < 0)\n\t\t\treturn (int) blks;\n\t\t*block += blks;\n\t}\n\n\t/*\n\t * Read length of block specified by index.\n\t */\n\tres = squashfs_read_metadata(inode->i_sb, &size, &start, &offset,\n\t\t\tsizeof(size));\n\tif (res < 0)\n\t\treturn res;\n\treturn le32_to_cpu(size);\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "size"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "inode->i_sb",
            "&size",
            "&start",
            "&offset",
            "sizeof(size)"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_indexes",
          "args": [
            "inode->i_sb",
            "index - res",
            "&start",
            "&offset"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "read_indexes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "173-209",
          "snippet": "static long long read_indexes(struct super_block *sb, int n,\n\t\t\t\tu64 *start_block, int *offset)\n{\n\tint err, i;\n\tlong long block = 0;\n\t__le32 *blist = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\n\tif (blist == NULL) {\n\t\tERROR(\"read_indexes: Failed to allocate block_list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (n) {\n\t\tint blocks = min_t(int, n, PAGE_CACHE_SIZE >> 2);\n\n\t\terr = squashfs_read_metadata(sb, blist, start_block,\n\t\t\t\toffset, blocks << 2);\n\t\tif (err < 0) {\n\t\t\tERROR(\"read_indexes: reading block [%llx:%x]\\n\",\n\t\t\t\t*start_block, *offset);\n\t\t\tgoto failure;\n\t\t}\n\n\t\tfor (i = 0; i < blocks; i++) {\n\t\t\tint size = le32_to_cpu(blist[i]);\n\t\t\tblock += SQUASHFS_COMPRESSED_SIZE_BLOCK(size);\n\t\t}\n\t\tn -= blocks;\n\t}\n\n\tkfree(blist);\n\treturn block;\n\nfailure:\n\tkfree(blist);\n\treturn err;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic long long read_indexes(struct super_block *sb, int n,\n\t\t\t\tu64 *start_block, int *offset)\n{\n\tint err, i;\n\tlong long block = 0;\n\t__le32 *blist = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\n\tif (blist == NULL) {\n\t\tERROR(\"read_indexes: Failed to allocate block_list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (n) {\n\t\tint blocks = min_t(int, n, PAGE_CACHE_SIZE >> 2);\n\n\t\terr = squashfs_read_metadata(sb, blist, start_block,\n\t\t\t\toffset, blocks << 2);\n\t\tif (err < 0) {\n\t\t\tERROR(\"read_indexes: reading block [%llx:%x]\\n\",\n\t\t\t\t*start_block, *offset);\n\t\t\tgoto failure;\n\t\t}\n\n\t\tfor (i = 0; i < blocks; i++) {\n\t\t\tint size = le32_to_cpu(blist[i]);\n\t\t\tblock += SQUASHFS_COMPRESSED_SIZE_BLOCK(size);\n\t\t}\n\t\tn -= blocks;\n\t}\n\n\tkfree(blist);\n\treturn block;\n\nfailure:\n\tkfree(blist);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"read_blocklist: res %d, index %d, start 0x%llx, offset\"\n\t\t       \" 0x%x, block 0x%llx\\n\"",
            "res",
            "index",
            "start",
            "offset",
            "*block"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_meta_index",
          "args": [
            "inode",
            "index",
            "&start",
            "&offset",
            "block"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "fill_meta_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "236-328",
          "snippet": "static int fill_meta_index(struct inode *inode, int index,\n\t\tu64 *index_block, int *index_offset, u64 *data_block)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint skip = calculate_skip(i_size_read(inode) >> msblk->block_log);\n\tint offset = 0;\n\tstruct meta_index *meta;\n\tstruct meta_entry *meta_entry;\n\tu64 cur_index_block = squashfs_i(inode)->block_list_start;\n\tint cur_offset = squashfs_i(inode)->offset;\n\tu64 cur_data_block = squashfs_i(inode)->start;\n\tint err, i;\n\n\t/*\n\t * Scale index to cache index (cache slot entry)\n\t */\n\tindex /= SQUASHFS_META_INDEXES * skip;\n\n\twhile (offset < index) {\n\t\tmeta = locate_meta_index(inode, offset + 1, index);\n\n\t\tif (meta == NULL) {\n\t\t\tmeta = empty_meta_index(inode, offset + 1, skip);\n\t\t\tif (meta == NULL)\n\t\t\t\tgoto all_done;\n\t\t} else {\n\t\t\toffset = index < meta->offset + meta->entries ? index :\n\t\t\t\tmeta->offset + meta->entries - 1;\n\t\t\tmeta_entry = &meta->meta_entry[offset - meta->offset];\n\t\t\tcur_index_block = meta_entry->index_block +\n\t\t\t\tmsblk->inode_table;\n\t\t\tcur_offset = meta_entry->offset;\n\t\t\tcur_data_block = meta_entry->data_block;\n\t\t\tTRACE(\"get_meta_index: offset %d, meta->offset %d, \"\n\t\t\t\t\"meta->entries %d\\n\", offset, meta->offset,\n\t\t\t\tmeta->entries);\n\t\t\tTRACE(\"get_meta_index: index_block 0x%llx, offset 0x%x\"\n\t\t\t\t\" data_block 0x%llx\\n\", cur_index_block,\n\t\t\t\tcur_offset, cur_data_block);\n\t\t}\n\n\t\t/*\n\t\t * If necessary grow cache slot by reading block list.  Cache\n\t\t * slot is extended up to index or to the end of the slot, in\n\t\t * which case further slots will be used.\n\t\t */\n\t\tfor (i = meta->offset + meta->entries; i <= index &&\n\t\t\t\ti < meta->offset + SQUASHFS_META_ENTRIES; i++) {\n\t\t\tint blocks = skip * SQUASHFS_META_INDEXES;\n\t\t\tlong long res = read_indexes(inode->i_sb, blocks,\n\t\t\t\t\t&cur_index_block, &cur_offset);\n\n\t\t\tif (res < 0) {\n\t\t\t\tif (meta->entries == 0)\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't leave an empty slot on read\n\t\t\t\t\t * error allocated to this inode...\n\t\t\t\t\t */\n\t\t\t\t\tmeta->inode_number = 0;\n\t\t\t\terr = res;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tcur_data_block += res;\n\t\t\tmeta_entry = &meta->meta_entry[i - meta->offset];\n\t\t\tmeta_entry->index_block = cur_index_block -\n\t\t\t\tmsblk->inode_table;\n\t\t\tmeta_entry->offset = cur_offset;\n\t\t\tmeta_entry->data_block = cur_data_block;\n\t\t\tmeta->entries++;\n\t\t\toffset++;\n\t\t}\n\n\t\tTRACE(\"get_meta_index: meta->offset %d, meta->entries %d\\n\",\n\t\t\t\tmeta->offset, meta->entries);\n\n\t\trelease_meta_index(inode, meta);\n\t}\n\nall_done:\n\t*index_block = cur_index_block;\n\t*index_offset = cur_offset;\n\t*data_block = cur_data_block;\n\n\t/*\n\t * Scale cache index (cache slot entry) to index\n\t */\n\treturn offset * SQUASHFS_META_INDEXES * skip;\n\nfailed:\n\trelease_meta_index(inode, meta);\n\treturn err;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int fill_meta_index(struct inode *inode, int index,\n\t\tu64 *index_block, int *index_offset, u64 *data_block)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint skip = calculate_skip(i_size_read(inode) >> msblk->block_log);\n\tint offset = 0;\n\tstruct meta_index *meta;\n\tstruct meta_entry *meta_entry;\n\tu64 cur_index_block = squashfs_i(inode)->block_list_start;\n\tint cur_offset = squashfs_i(inode)->offset;\n\tu64 cur_data_block = squashfs_i(inode)->start;\n\tint err, i;\n\n\t/*\n\t * Scale index to cache index (cache slot entry)\n\t */\n\tindex /= SQUASHFS_META_INDEXES * skip;\n\n\twhile (offset < index) {\n\t\tmeta = locate_meta_index(inode, offset + 1, index);\n\n\t\tif (meta == NULL) {\n\t\t\tmeta = empty_meta_index(inode, offset + 1, skip);\n\t\t\tif (meta == NULL)\n\t\t\t\tgoto all_done;\n\t\t} else {\n\t\t\toffset = index < meta->offset + meta->entries ? index :\n\t\t\t\tmeta->offset + meta->entries - 1;\n\t\t\tmeta_entry = &meta->meta_entry[offset - meta->offset];\n\t\t\tcur_index_block = meta_entry->index_block +\n\t\t\t\tmsblk->inode_table;\n\t\t\tcur_offset = meta_entry->offset;\n\t\t\tcur_data_block = meta_entry->data_block;\n\t\t\tTRACE(\"get_meta_index: offset %d, meta->offset %d, \"\n\t\t\t\t\"meta->entries %d\\n\", offset, meta->offset,\n\t\t\t\tmeta->entries);\n\t\t\tTRACE(\"get_meta_index: index_block 0x%llx, offset 0x%x\"\n\t\t\t\t\" data_block 0x%llx\\n\", cur_index_block,\n\t\t\t\tcur_offset, cur_data_block);\n\t\t}\n\n\t\t/*\n\t\t * If necessary grow cache slot by reading block list.  Cache\n\t\t * slot is extended up to index or to the end of the slot, in\n\t\t * which case further slots will be used.\n\t\t */\n\t\tfor (i = meta->offset + meta->entries; i <= index &&\n\t\t\t\ti < meta->offset + SQUASHFS_META_ENTRIES; i++) {\n\t\t\tint blocks = skip * SQUASHFS_META_INDEXES;\n\t\t\tlong long res = read_indexes(inode->i_sb, blocks,\n\t\t\t\t\t&cur_index_block, &cur_offset);\n\n\t\t\tif (res < 0) {\n\t\t\t\tif (meta->entries == 0)\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't leave an empty slot on read\n\t\t\t\t\t * error allocated to this inode...\n\t\t\t\t\t */\n\t\t\t\t\tmeta->inode_number = 0;\n\t\t\t\terr = res;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tcur_data_block += res;\n\t\t\tmeta_entry = &meta->meta_entry[i - meta->offset];\n\t\t\tmeta_entry->index_block = cur_index_block -\n\t\t\t\tmsblk->inode_table;\n\t\t\tmeta_entry->offset = cur_offset;\n\t\t\tmeta_entry->data_block = cur_data_block;\n\t\t\tmeta->entries++;\n\t\t\toffset++;\n\t\t}\n\n\t\tTRACE(\"get_meta_index: meta->offset %d, meta->entries %d\\n\",\n\t\t\t\tmeta->offset, meta->entries);\n\n\t\trelease_meta_index(inode, meta);\n\t}\n\nall_done:\n\t*index_block = cur_index_block;\n\t*index_offset = cur_offset;\n\t*data_block = cur_data_block;\n\n\t/*\n\t * Scale cache index (cache slot entry) to index\n\t */\n\treturn offset * SQUASHFS_META_INDEXES * skip;\n\nfailed:\n\trelease_meta_index(inode, meta);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int read_blocklist(struct inode *inode, int index, u64 *block)\n{\n\tu64 start;\n\tlong long blks;\n\tint offset;\n\t__le32 size;\n\tint res = fill_meta_index(inode, index, &start, &offset, block);\n\n\tTRACE(\"read_blocklist: res %d, index %d, start 0x%llx, offset\"\n\t\t       \" 0x%x, block 0x%llx\\n\", res, index, start, offset,\n\t\t\t*block);\n\n\tif (res < 0)\n\t\treturn res;\n\n\t/*\n\t * res contains the index of the mapping returned by fill_meta_index(),\n\t * this will likely be less than the desired index (because the\n\t * meta_index cache works at a higher granularity).  Read any\n\t * extra block indexes needed.\n\t */\n\tif (res < index) {\n\t\tblks = read_indexes(inode->i_sb, index - res, &start, &offset);\n\t\tif (blks < 0)\n\t\t\treturn (int) blks;\n\t\t*block += blks;\n\t}\n\n\t/*\n\t * Read length of block specified by index.\n\t */\n\tres = squashfs_read_metadata(inode->i_sb, &size, &start, &offset,\n\t\t\tsizeof(size));\n\tif (res < 0)\n\t\treturn res;\n\treturn le32_to_cpu(size);\n}"
  },
  {
    "function_name": "fill_meta_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "236-328",
    "snippet": "static int fill_meta_index(struct inode *inode, int index,\n\t\tu64 *index_block, int *index_offset, u64 *data_block)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint skip = calculate_skip(i_size_read(inode) >> msblk->block_log);\n\tint offset = 0;\n\tstruct meta_index *meta;\n\tstruct meta_entry *meta_entry;\n\tu64 cur_index_block = squashfs_i(inode)->block_list_start;\n\tint cur_offset = squashfs_i(inode)->offset;\n\tu64 cur_data_block = squashfs_i(inode)->start;\n\tint err, i;\n\n\t/*\n\t * Scale index to cache index (cache slot entry)\n\t */\n\tindex /= SQUASHFS_META_INDEXES * skip;\n\n\twhile (offset < index) {\n\t\tmeta = locate_meta_index(inode, offset + 1, index);\n\n\t\tif (meta == NULL) {\n\t\t\tmeta = empty_meta_index(inode, offset + 1, skip);\n\t\t\tif (meta == NULL)\n\t\t\t\tgoto all_done;\n\t\t} else {\n\t\t\toffset = index < meta->offset + meta->entries ? index :\n\t\t\t\tmeta->offset + meta->entries - 1;\n\t\t\tmeta_entry = &meta->meta_entry[offset - meta->offset];\n\t\t\tcur_index_block = meta_entry->index_block +\n\t\t\t\tmsblk->inode_table;\n\t\t\tcur_offset = meta_entry->offset;\n\t\t\tcur_data_block = meta_entry->data_block;\n\t\t\tTRACE(\"get_meta_index: offset %d, meta->offset %d, \"\n\t\t\t\t\"meta->entries %d\\n\", offset, meta->offset,\n\t\t\t\tmeta->entries);\n\t\t\tTRACE(\"get_meta_index: index_block 0x%llx, offset 0x%x\"\n\t\t\t\t\" data_block 0x%llx\\n\", cur_index_block,\n\t\t\t\tcur_offset, cur_data_block);\n\t\t}\n\n\t\t/*\n\t\t * If necessary grow cache slot by reading block list.  Cache\n\t\t * slot is extended up to index or to the end of the slot, in\n\t\t * which case further slots will be used.\n\t\t */\n\t\tfor (i = meta->offset + meta->entries; i <= index &&\n\t\t\t\ti < meta->offset + SQUASHFS_META_ENTRIES; i++) {\n\t\t\tint blocks = skip * SQUASHFS_META_INDEXES;\n\t\t\tlong long res = read_indexes(inode->i_sb, blocks,\n\t\t\t\t\t&cur_index_block, &cur_offset);\n\n\t\t\tif (res < 0) {\n\t\t\t\tif (meta->entries == 0)\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't leave an empty slot on read\n\t\t\t\t\t * error allocated to this inode...\n\t\t\t\t\t */\n\t\t\t\t\tmeta->inode_number = 0;\n\t\t\t\terr = res;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tcur_data_block += res;\n\t\t\tmeta_entry = &meta->meta_entry[i - meta->offset];\n\t\t\tmeta_entry->index_block = cur_index_block -\n\t\t\t\tmsblk->inode_table;\n\t\t\tmeta_entry->offset = cur_offset;\n\t\t\tmeta_entry->data_block = cur_data_block;\n\t\t\tmeta->entries++;\n\t\t\toffset++;\n\t\t}\n\n\t\tTRACE(\"get_meta_index: meta->offset %d, meta->entries %d\\n\",\n\t\t\t\tmeta->offset, meta->entries);\n\n\t\trelease_meta_index(inode, meta);\n\t}\n\nall_done:\n\t*index_block = cur_index_block;\n\t*index_offset = cur_offset;\n\t*data_block = cur_data_block;\n\n\t/*\n\t * Scale cache index (cache slot entry) to index\n\t */\n\treturn offset * SQUASHFS_META_INDEXES * skip;\n\nfailed:\n\trelease_meta_index(inode, meta);\n\treturn err;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_meta_index",
          "args": [
            "inode",
            "meta"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "release_meta_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "160-166",
          "snippet": "static void release_meta_index(struct inode *inode, struct meta_index *meta)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tmutex_lock(&msblk->meta_index_mutex);\n\tmeta->locked = 0;\n\tmutex_unlock(&msblk->meta_index_mutex);\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic void release_meta_index(struct inode *inode, struct meta_index *meta)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tmutex_lock(&msblk->meta_index_mutex);\n\tmeta->locked = 0;\n\tmutex_unlock(&msblk->meta_index_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"get_meta_index: meta->offset %d, meta->entries %d\\n\"",
            "meta->offset",
            "meta->entries"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_indexes",
          "args": [
            "inode->i_sb",
            "blocks",
            "&cur_index_block",
            "&cur_offset"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "read_indexes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "173-209",
          "snippet": "static long long read_indexes(struct super_block *sb, int n,\n\t\t\t\tu64 *start_block, int *offset)\n{\n\tint err, i;\n\tlong long block = 0;\n\t__le32 *blist = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\n\tif (blist == NULL) {\n\t\tERROR(\"read_indexes: Failed to allocate block_list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (n) {\n\t\tint blocks = min_t(int, n, PAGE_CACHE_SIZE >> 2);\n\n\t\terr = squashfs_read_metadata(sb, blist, start_block,\n\t\t\t\toffset, blocks << 2);\n\t\tif (err < 0) {\n\t\t\tERROR(\"read_indexes: reading block [%llx:%x]\\n\",\n\t\t\t\t*start_block, *offset);\n\t\t\tgoto failure;\n\t\t}\n\n\t\tfor (i = 0; i < blocks; i++) {\n\t\t\tint size = le32_to_cpu(blist[i]);\n\t\t\tblock += SQUASHFS_COMPRESSED_SIZE_BLOCK(size);\n\t\t}\n\t\tn -= blocks;\n\t}\n\n\tkfree(blist);\n\treturn block;\n\nfailure:\n\tkfree(blist);\n\treturn err;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic long long read_indexes(struct super_block *sb, int n,\n\t\t\t\tu64 *start_block, int *offset)\n{\n\tint err, i;\n\tlong long block = 0;\n\t__le32 *blist = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\n\tif (blist == NULL) {\n\t\tERROR(\"read_indexes: Failed to allocate block_list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (n) {\n\t\tint blocks = min_t(int, n, PAGE_CACHE_SIZE >> 2);\n\n\t\terr = squashfs_read_metadata(sb, blist, start_block,\n\t\t\t\toffset, blocks << 2);\n\t\tif (err < 0) {\n\t\t\tERROR(\"read_indexes: reading block [%llx:%x]\\n\",\n\t\t\t\t*start_block, *offset);\n\t\t\tgoto failure;\n\t\t}\n\n\t\tfor (i = 0; i < blocks; i++) {\n\t\t\tint size = le32_to_cpu(blist[i]);\n\t\t\tblock += SQUASHFS_COMPRESSED_SIZE_BLOCK(size);\n\t\t}\n\t\tn -= blocks;\n\t}\n\n\tkfree(blist);\n\treturn block;\n\nfailure:\n\tkfree(blist);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"get_meta_index: index_block 0x%llx, offset 0x%x\"\n\t\t\t\t\" data_block 0x%llx\\n\"",
            "cur_index_block",
            "cur_offset",
            "cur_data_block"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"get_meta_index: offset %d, meta->offset %d, \"\n\t\t\t\t\"meta->entries %d\\n\"",
            "offset",
            "meta->offset",
            "meta->entries"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "empty_meta_index",
          "args": [
            "inode",
            "offset + 1",
            "skip"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "empty_meta_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "99-157",
          "snippet": "static struct meta_index *empty_meta_index(struct inode *inode, int offset,\n\t\t\t\tint skip)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct meta_index *meta = NULL;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"empty_meta_index: offset %d, skip %d\\n\", offset, skip);\n\n\tif (msblk->meta_index == NULL) {\n\t\t/*\n\t\t * First time cache index has been used, allocate and\n\t\t * initialise.  The cache index could be allocated at\n\t\t * mount time but doing it here means it is allocated only\n\t\t * if a 'large' file is read.\n\t\t */\n\t\tmsblk->meta_index = kcalloc(SQUASHFS_META_SLOTS,\n\t\t\tsizeof(*(msblk->meta_index)), GFP_KERNEL);\n\t\tif (msblk->meta_index == NULL) {\n\t\t\tERROR(\"Failed to allocate meta_index\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\t\tmsblk->meta_index[i].inode_number = 0;\n\t\t\tmsblk->meta_index[i].locked = 0;\n\t\t}\n\t\tmsblk->next_meta_index = 0;\n\t}\n\n\tfor (i = SQUASHFS_META_SLOTS; i &&\n\t\t\tmsblk->meta_index[msblk->next_meta_index].locked; i--)\n\t\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tif (i == 0) {\n\t\tTRACE(\"empty_meta_index: failed!\\n\");\n\t\tgoto failed;\n\t}\n\n\tTRACE(\"empty_meta_index: returned meta entry %d, %p\\n\",\n\t\t\tmsblk->next_meta_index,\n\t\t\t&msblk->meta_index[msblk->next_meta_index]);\n\n\tmeta = &msblk->meta_index[msblk->next_meta_index];\n\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tmeta->inode_number = inode->i_ino;\n\tmeta->offset = offset;\n\tmeta->skip = skip;\n\tmeta->entries = 0;\n\tmeta->locked = 1;\n\nfailed:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\treturn meta;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct meta_index *empty_meta_index(struct inode *inode, int offset,\n\t\t\t\tint skip)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct meta_index *meta = NULL;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"empty_meta_index: offset %d, skip %d\\n\", offset, skip);\n\n\tif (msblk->meta_index == NULL) {\n\t\t/*\n\t\t * First time cache index has been used, allocate and\n\t\t * initialise.  The cache index could be allocated at\n\t\t * mount time but doing it here means it is allocated only\n\t\t * if a 'large' file is read.\n\t\t */\n\t\tmsblk->meta_index = kcalloc(SQUASHFS_META_SLOTS,\n\t\t\tsizeof(*(msblk->meta_index)), GFP_KERNEL);\n\t\tif (msblk->meta_index == NULL) {\n\t\t\tERROR(\"Failed to allocate meta_index\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\t\tmsblk->meta_index[i].inode_number = 0;\n\t\t\tmsblk->meta_index[i].locked = 0;\n\t\t}\n\t\tmsblk->next_meta_index = 0;\n\t}\n\n\tfor (i = SQUASHFS_META_SLOTS; i &&\n\t\t\tmsblk->meta_index[msblk->next_meta_index].locked; i--)\n\t\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tif (i == 0) {\n\t\tTRACE(\"empty_meta_index: failed!\\n\");\n\t\tgoto failed;\n\t}\n\n\tTRACE(\"empty_meta_index: returned meta entry %d, %p\\n\",\n\t\t\tmsblk->next_meta_index,\n\t\t\t&msblk->meta_index[msblk->next_meta_index]);\n\n\tmeta = &msblk->meta_index[msblk->next_meta_index];\n\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tmeta->inode_number = inode->i_ino;\n\tmeta->offset = offset;\n\tmeta->skip = skip;\n\tmeta->entries = 0;\n\tmeta->locked = 1;\n\nfailed:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\treturn meta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locate_meta_index",
          "args": [
            "inode",
            "offset + 1",
            "index"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "locate_meta_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "60-93",
          "snippet": "static struct meta_index *locate_meta_index(struct inode *inode, int offset,\n\t\t\t\tint index)\n{\n\tstruct meta_index *meta = NULL;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"locate_meta_index: index %d, offset %d\\n\", index, offset);\n\n\tif (msblk->meta_index == NULL)\n\t\tgoto not_allocated;\n\n\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\tif (msblk->meta_index[i].inode_number == inode->i_ino &&\n\t\t\t\tmsblk->meta_index[i].offset >= offset &&\n\t\t\t\tmsblk->meta_index[i].offset <= index &&\n\t\t\t\tmsblk->meta_index[i].locked == 0) {\n\t\t\tTRACE(\"locate_meta_index: entry %d, offset %d\\n\", i,\n\t\t\t\t\tmsblk->meta_index[i].offset);\n\t\t\tmeta = &msblk->meta_index[i];\n\t\t\toffset = meta->offset;\n\t\t}\n\t}\n\n\tif (meta)\n\t\tmeta->locked = 1;\n\nnot_allocated:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\n\treturn meta;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct meta_index *locate_meta_index(struct inode *inode, int offset,\n\t\t\t\tint index)\n{\n\tstruct meta_index *meta = NULL;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"locate_meta_index: index %d, offset %d\\n\", index, offset);\n\n\tif (msblk->meta_index == NULL)\n\t\tgoto not_allocated;\n\n\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\tif (msblk->meta_index[i].inode_number == inode->i_ino &&\n\t\t\t\tmsblk->meta_index[i].offset >= offset &&\n\t\t\t\tmsblk->meta_index[i].offset <= index &&\n\t\t\t\tmsblk->meta_index[i].locked == 0) {\n\t\t\tTRACE(\"locate_meta_index: entry %d, offset %d\\n\", i,\n\t\t\t\t\tmsblk->meta_index[i].offset);\n\t\t\tmeta = &msblk->meta_index[i];\n\t\t\toffset = meta->offset;\n\t\t}\n\t}\n\n\tif (meta)\n\t\tmeta->locked = 1;\n\nnot_allocated:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\n\treturn meta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calculate_skip",
          "args": [
            "i_size_read(inode) >> msblk->block_log"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "calculate_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
          "lines": "223-228",
          "snippet": "static inline int calculate_skip(int blocks)\n{\n\tint skip = blocks / ((SQUASHFS_META_ENTRIES + 1)\n\t\t * SQUASHFS_META_INDEXES);\n\treturn min(SQUASHFS_CACHED_BLKS - 1, skip + 1);\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic inline int calculate_skip(int blocks)\n{\n\tint skip = blocks / ((SQUASHFS_META_ENTRIES + 1)\n\t\t * SQUASHFS_META_INDEXES);\n\treturn min(SQUASHFS_CACHED_BLKS - 1, skip + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int fill_meta_index(struct inode *inode, int index,\n\t\tu64 *index_block, int *index_offset, u64 *data_block)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint skip = calculate_skip(i_size_read(inode) >> msblk->block_log);\n\tint offset = 0;\n\tstruct meta_index *meta;\n\tstruct meta_entry *meta_entry;\n\tu64 cur_index_block = squashfs_i(inode)->block_list_start;\n\tint cur_offset = squashfs_i(inode)->offset;\n\tu64 cur_data_block = squashfs_i(inode)->start;\n\tint err, i;\n\n\t/*\n\t * Scale index to cache index (cache slot entry)\n\t */\n\tindex /= SQUASHFS_META_INDEXES * skip;\n\n\twhile (offset < index) {\n\t\tmeta = locate_meta_index(inode, offset + 1, index);\n\n\t\tif (meta == NULL) {\n\t\t\tmeta = empty_meta_index(inode, offset + 1, skip);\n\t\t\tif (meta == NULL)\n\t\t\t\tgoto all_done;\n\t\t} else {\n\t\t\toffset = index < meta->offset + meta->entries ? index :\n\t\t\t\tmeta->offset + meta->entries - 1;\n\t\t\tmeta_entry = &meta->meta_entry[offset - meta->offset];\n\t\t\tcur_index_block = meta_entry->index_block +\n\t\t\t\tmsblk->inode_table;\n\t\t\tcur_offset = meta_entry->offset;\n\t\t\tcur_data_block = meta_entry->data_block;\n\t\t\tTRACE(\"get_meta_index: offset %d, meta->offset %d, \"\n\t\t\t\t\"meta->entries %d\\n\", offset, meta->offset,\n\t\t\t\tmeta->entries);\n\t\t\tTRACE(\"get_meta_index: index_block 0x%llx, offset 0x%x\"\n\t\t\t\t\" data_block 0x%llx\\n\", cur_index_block,\n\t\t\t\tcur_offset, cur_data_block);\n\t\t}\n\n\t\t/*\n\t\t * If necessary grow cache slot by reading block list.  Cache\n\t\t * slot is extended up to index or to the end of the slot, in\n\t\t * which case further slots will be used.\n\t\t */\n\t\tfor (i = meta->offset + meta->entries; i <= index &&\n\t\t\t\ti < meta->offset + SQUASHFS_META_ENTRIES; i++) {\n\t\t\tint blocks = skip * SQUASHFS_META_INDEXES;\n\t\t\tlong long res = read_indexes(inode->i_sb, blocks,\n\t\t\t\t\t&cur_index_block, &cur_offset);\n\n\t\t\tif (res < 0) {\n\t\t\t\tif (meta->entries == 0)\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't leave an empty slot on read\n\t\t\t\t\t * error allocated to this inode...\n\t\t\t\t\t */\n\t\t\t\t\tmeta->inode_number = 0;\n\t\t\t\terr = res;\n\t\t\t\tgoto failed;\n\t\t\t}\n\n\t\t\tcur_data_block += res;\n\t\t\tmeta_entry = &meta->meta_entry[i - meta->offset];\n\t\t\tmeta_entry->index_block = cur_index_block -\n\t\t\t\tmsblk->inode_table;\n\t\t\tmeta_entry->offset = cur_offset;\n\t\t\tmeta_entry->data_block = cur_data_block;\n\t\t\tmeta->entries++;\n\t\t\toffset++;\n\t\t}\n\n\t\tTRACE(\"get_meta_index: meta->offset %d, meta->entries %d\\n\",\n\t\t\t\tmeta->offset, meta->entries);\n\n\t\trelease_meta_index(inode, meta);\n\t}\n\nall_done:\n\t*index_block = cur_index_block;\n\t*index_offset = cur_offset;\n\t*data_block = cur_data_block;\n\n\t/*\n\t * Scale cache index (cache slot entry) to index\n\t */\n\treturn offset * SQUASHFS_META_INDEXES * skip;\n\nfailed:\n\trelease_meta_index(inode, meta);\n\treturn err;\n}"
  },
  {
    "function_name": "calculate_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "223-228",
    "snippet": "static inline int calculate_skip(int blocks)\n{\n\tint skip = blocks / ((SQUASHFS_META_ENTRIES + 1)\n\t\t * SQUASHFS_META_INDEXES);\n\treturn min(SQUASHFS_CACHED_BLKS - 1, skip + 1);\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "SQUASHFS_CACHED_BLKS - 1",
            "skip + 1"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "minix_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/file.c",
          "lines": "26-48",
          "snippet": "static int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tminix_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic inline int calculate_skip(int blocks)\n{\n\tint skip = blocks / ((SQUASHFS_META_ENTRIES + 1)\n\t\t * SQUASHFS_META_INDEXES);\n\treturn min(SQUASHFS_CACHED_BLKS - 1, skip + 1);\n}"
  },
  {
    "function_name": "read_indexes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "173-209",
    "snippet": "static long long read_indexes(struct super_block *sb, int n,\n\t\t\t\tu64 *start_block, int *offset)\n{\n\tint err, i;\n\tlong long block = 0;\n\t__le32 *blist = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\n\tif (blist == NULL) {\n\t\tERROR(\"read_indexes: Failed to allocate block_list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (n) {\n\t\tint blocks = min_t(int, n, PAGE_CACHE_SIZE >> 2);\n\n\t\terr = squashfs_read_metadata(sb, blist, start_block,\n\t\t\t\toffset, blocks << 2);\n\t\tif (err < 0) {\n\t\t\tERROR(\"read_indexes: reading block [%llx:%x]\\n\",\n\t\t\t\t*start_block, *offset);\n\t\t\tgoto failure;\n\t\t}\n\n\t\tfor (i = 0; i < blocks; i++) {\n\t\t\tint size = le32_to_cpu(blist[i]);\n\t\t\tblock += SQUASHFS_COMPRESSED_SIZE_BLOCK(size);\n\t\t}\n\t\tn -= blocks;\n\t}\n\n\tkfree(blist);\n\treturn block;\n\nfailure:\n\tkfree(blist);\n\treturn err;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "blist"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "blist"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_COMPRESSED_SIZE_BLOCK",
          "args": [
            "size"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "blist[i]"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"read_indexes: reading block [%llx:%x]\\n\"",
            "*start_block",
            "*offset"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "sb",
            "blist",
            "start_block",
            "offset",
            "blocks << 2"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "n",
            "PAGE_CACHE_SIZE >> 2"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"read_indexes: Failed to allocate block_list\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_CACHE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic long long read_indexes(struct super_block *sb, int n,\n\t\t\t\tu64 *start_block, int *offset)\n{\n\tint err, i;\n\tlong long block = 0;\n\t__le32 *blist = kmalloc(PAGE_CACHE_SIZE, GFP_KERNEL);\n\n\tif (blist == NULL) {\n\t\tERROR(\"read_indexes: Failed to allocate block_list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (n) {\n\t\tint blocks = min_t(int, n, PAGE_CACHE_SIZE >> 2);\n\n\t\terr = squashfs_read_metadata(sb, blist, start_block,\n\t\t\t\toffset, blocks << 2);\n\t\tif (err < 0) {\n\t\t\tERROR(\"read_indexes: reading block [%llx:%x]\\n\",\n\t\t\t\t*start_block, *offset);\n\t\t\tgoto failure;\n\t\t}\n\n\t\tfor (i = 0; i < blocks; i++) {\n\t\t\tint size = le32_to_cpu(blist[i]);\n\t\t\tblock += SQUASHFS_COMPRESSED_SIZE_BLOCK(size);\n\t\t}\n\t\tn -= blocks;\n\t}\n\n\tkfree(blist);\n\treturn block;\n\nfailure:\n\tkfree(blist);\n\treturn err;\n}"
  },
  {
    "function_name": "release_meta_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "160-166",
    "snippet": "static void release_meta_index(struct inode *inode, struct meta_index *meta)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tmutex_lock(&msblk->meta_index_mutex);\n\tmeta->locked = 0;\n\tmutex_unlock(&msblk->meta_index_mutex);\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&msblk->meta_index_mutex"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&msblk->meta_index_mutex"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic void release_meta_index(struct inode *inode, struct meta_index *meta)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tmutex_lock(&msblk->meta_index_mutex);\n\tmeta->locked = 0;\n\tmutex_unlock(&msblk->meta_index_mutex);\n}"
  },
  {
    "function_name": "empty_meta_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "99-157",
    "snippet": "static struct meta_index *empty_meta_index(struct inode *inode, int offset,\n\t\t\t\tint skip)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct meta_index *meta = NULL;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"empty_meta_index: offset %d, skip %d\\n\", offset, skip);\n\n\tif (msblk->meta_index == NULL) {\n\t\t/*\n\t\t * First time cache index has been used, allocate and\n\t\t * initialise.  The cache index could be allocated at\n\t\t * mount time but doing it here means it is allocated only\n\t\t * if a 'large' file is read.\n\t\t */\n\t\tmsblk->meta_index = kcalloc(SQUASHFS_META_SLOTS,\n\t\t\tsizeof(*(msblk->meta_index)), GFP_KERNEL);\n\t\tif (msblk->meta_index == NULL) {\n\t\t\tERROR(\"Failed to allocate meta_index\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\t\tmsblk->meta_index[i].inode_number = 0;\n\t\t\tmsblk->meta_index[i].locked = 0;\n\t\t}\n\t\tmsblk->next_meta_index = 0;\n\t}\n\n\tfor (i = SQUASHFS_META_SLOTS; i &&\n\t\t\tmsblk->meta_index[msblk->next_meta_index].locked; i--)\n\t\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tif (i == 0) {\n\t\tTRACE(\"empty_meta_index: failed!\\n\");\n\t\tgoto failed;\n\t}\n\n\tTRACE(\"empty_meta_index: returned meta entry %d, %p\\n\",\n\t\t\tmsblk->next_meta_index,\n\t\t\t&msblk->meta_index[msblk->next_meta_index]);\n\n\tmeta = &msblk->meta_index[msblk->next_meta_index];\n\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tmeta->inode_number = inode->i_ino;\n\tmeta->offset = offset;\n\tmeta->skip = skip;\n\tmeta->entries = 0;\n\tmeta->locked = 1;\n\nfailed:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\treturn meta;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&msblk->meta_index_mutex"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"empty_meta_index: returned meta entry %d, %p\\n\"",
            "msblk->next_meta_index",
            "&msblk->meta_index[msblk->next_meta_index]"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"empty_meta_index: failed!\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Failed to allocate meta_index\\n\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "SQUASHFS_META_SLOTS",
            "sizeof(*(msblk->meta_index))",
            "GFP_KERNEL"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"empty_meta_index: offset %d, skip %d\\n\"",
            "offset",
            "skip"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&msblk->meta_index_mutex"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct meta_index *empty_meta_index(struct inode *inode, int offset,\n\t\t\t\tint skip)\n{\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tstruct meta_index *meta = NULL;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"empty_meta_index: offset %d, skip %d\\n\", offset, skip);\n\n\tif (msblk->meta_index == NULL) {\n\t\t/*\n\t\t * First time cache index has been used, allocate and\n\t\t * initialise.  The cache index could be allocated at\n\t\t * mount time but doing it here means it is allocated only\n\t\t * if a 'large' file is read.\n\t\t */\n\t\tmsblk->meta_index = kcalloc(SQUASHFS_META_SLOTS,\n\t\t\tsizeof(*(msblk->meta_index)), GFP_KERNEL);\n\t\tif (msblk->meta_index == NULL) {\n\t\t\tERROR(\"Failed to allocate meta_index\\n\");\n\t\t\tgoto failed;\n\t\t}\n\t\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\t\tmsblk->meta_index[i].inode_number = 0;\n\t\t\tmsblk->meta_index[i].locked = 0;\n\t\t}\n\t\tmsblk->next_meta_index = 0;\n\t}\n\n\tfor (i = SQUASHFS_META_SLOTS; i &&\n\t\t\tmsblk->meta_index[msblk->next_meta_index].locked; i--)\n\t\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tif (i == 0) {\n\t\tTRACE(\"empty_meta_index: failed!\\n\");\n\t\tgoto failed;\n\t}\n\n\tTRACE(\"empty_meta_index: returned meta entry %d, %p\\n\",\n\t\t\tmsblk->next_meta_index,\n\t\t\t&msblk->meta_index[msblk->next_meta_index]);\n\n\tmeta = &msblk->meta_index[msblk->next_meta_index];\n\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n\t\t\tSQUASHFS_META_SLOTS;\n\n\tmeta->inode_number = inode->i_ino;\n\tmeta->offset = offset;\n\tmeta->skip = skip;\n\tmeta->entries = 0;\n\tmeta->locked = 1;\n\nfailed:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\treturn meta;\n}"
  },
  {
    "function_name": "locate_meta_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/file.c",
    "lines": "60-93",
    "snippet": "static struct meta_index *locate_meta_index(struct inode *inode, int offset,\n\t\t\t\tint index)\n{\n\tstruct meta_index *meta = NULL;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"locate_meta_index: index %d, offset %d\\n\", index, offset);\n\n\tif (msblk->meta_index == NULL)\n\t\tgoto not_allocated;\n\n\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\tif (msblk->meta_index[i].inode_number == inode->i_ino &&\n\t\t\t\tmsblk->meta_index[i].offset >= offset &&\n\t\t\t\tmsblk->meta_index[i].offset <= index &&\n\t\t\t\tmsblk->meta_index[i].locked == 0) {\n\t\t\tTRACE(\"locate_meta_index: entry %d, offset %d\\n\", i,\n\t\t\t\t\tmsblk->meta_index[i].offset);\n\t\t\tmeta = &msblk->meta_index[i];\n\t\t\toffset = meta->offset;\n\t\t}\n\t}\n\n\tif (meta)\n\t\tmeta->locked = 1;\n\nnot_allocated:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\n\treturn meta;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&msblk->meta_index_mutex"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"locate_meta_index: entry %d, offset %d\\n\"",
            "i",
            "msblk->meta_index[i].offset"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"locate_meta_index: index %d, offset %d\\n\"",
            "index",
            "offset"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&msblk->meta_index_mutex"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/mutex.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic struct meta_index *locate_meta_index(struct inode *inode, int offset,\n\t\t\t\tint index)\n{\n\tstruct meta_index *meta = NULL;\n\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n\tint i;\n\n\tmutex_lock(&msblk->meta_index_mutex);\n\n\tTRACE(\"locate_meta_index: index %d, offset %d\\n\", index, offset);\n\n\tif (msblk->meta_index == NULL)\n\t\tgoto not_allocated;\n\n\tfor (i = 0; i < SQUASHFS_META_SLOTS; i++) {\n\t\tif (msblk->meta_index[i].inode_number == inode->i_ino &&\n\t\t\t\tmsblk->meta_index[i].offset >= offset &&\n\t\t\t\tmsblk->meta_index[i].offset <= index &&\n\t\t\t\tmsblk->meta_index[i].locked == 0) {\n\t\t\tTRACE(\"locate_meta_index: entry %d, offset %d\\n\", i,\n\t\t\t\t\tmsblk->meta_index[i].offset);\n\t\t\tmeta = &msblk->meta_index[i];\n\t\t\toffset = meta->offset;\n\t\t}\n\t}\n\n\tif (meta)\n\t\tmeta->locked = 1;\n\nnot_allocated:\n\tmutex_unlock(&msblk->meta_index_mutex);\n\n\treturn meta;\n}"
  }
]