[
  {
    "function_name": "ufs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
    "lines": "171-353",
    "snippet": "struct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED): err %d\\n\"",
            "err"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED): err %d\\n\"",
            "err"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"allocating inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "CURRENT_TIME.tv_nsec"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs64",
          "args": [
            "sb",
            "CURRENT_TIME.tv_sec"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "34-41",
          "snippet": "static inline __fs64\ncpu_to_fs64(struct super_block *sbp, u64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force __fs64)cpu_to_be64(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs64\ncpu_to_fs64(struct super_block *sbp, u64 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs64)cpu_to_le64(n);\n\telse\n\t\treturn (__force __fs64)cpu_to_be64(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_inotofsbo",
          "args": [
            "inode->i_ino"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "sb",
            "\"ufs_read_inode\"",
            "\"unable to read inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "uspi->s_sbbase + ufs_inotofsba(inode->i_ino)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inotofsba",
          "args": [
            "inode->i_ino"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_locked",
          "args": [
            "inode"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1323-1362",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ufsi->i_u1",
            "0",
            "sizeof(ufsi->i_u1)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "dir"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "732-744",
          "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_add",
          "args": [
            "sb",
            "&sbi->fs_cs(cg).cs_ndir",
            "1"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "61-68",
          "snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sbi->fs_cs",
          "args": [
            "cg"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_sub",
          "args": [
            "sb",
            "&sbi->fs_cs(cg).cs_nifree",
            "1"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "70-77",
          "snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sbi->fs_cs",
          "args": [
            "cg"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs2_init_inodes_chunk",
          "args": [
            "sb",
            "ucpi",
            "ucg"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "ufs2_init_inodes_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
          "lines": "128-159",
          "snippet": "static void ufs2_init_inodes_chunk(struct super_block *sb,\n\t\t\t\t   struct ufs_cg_private_info *ucpi,\n\t\t\t\t   struct ufs_cylinder_group *ucg)\n{\n\tstruct buffer_head *bh;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tsector_t beg = uspi->s_sbbase +\n\t\tufs_inotofsba(ucpi->c_cgx * uspi->s_ipg +\n\t\t\t      fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk));\n\tsector_t end = beg + uspi->s_fpb;\n\n\tUFSD(\"ENTER cgno %d\\n\", ucpi->c_cgx);\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tfs32_add(sb, &ucg->cg_u.cg_u2.cg_initediblk, uspi->s_inopb);\n\tubh_mark_buffer_dirty(UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ufs2_init_inodes_chunk(struct super_block *sb,\n\t\t\t\t   struct ufs_cg_private_info *ucpi,\n\t\t\t\t   struct ufs_cylinder_group *ucg)\n{\n\tstruct buffer_head *bh;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tsector_t beg = uspi->s_sbbase +\n\t\tufs_inotofsba(ucpi->c_cgx * uspi->s_ipg +\n\t\t\t      fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk));\n\tsector_t end = beg + uspi->s_fpb;\n\n\tUFSD(\"ENTER cgno %d\\n\", ucpi->c_cgx);\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tfs32_add(sb, &ucg->cg_u.cg_u2.cg_initediblk, uspi->s_inopb);\n\tubh_mark_buffer_dirty(UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "ucg->cg_u.cg_u2.cg_niblk"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_new_inode\"",
            "\"internal error\""
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_setbit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_iusedoff",
            "bit"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_isclr",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_iusedoff",
            "bit"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"start = %u, bit = %u, ipg = %u\\n\"",
            "start",
            "bit",
            "uspi->s_ipg"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_new_inode\"",
            "\"cylinder group %u corrupted - error in inode bitmap\\n\"",
            "cg"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_find_first_zero_bit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_iusedoff",
            "start"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_find_next_zero_bit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_iusedoff",
            "uspi->s_ipg",
            "start"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cg_chkmagic",
          "args": [
            "sb",
            "ucg"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_ucg",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_load_cylinder",
          "args": [
            "sb",
            "cg"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_load_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "126-201",
          "snippet": "struct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "sbi->fs_cs",
          "args": [
            "i"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inotocg",
          "args": [
            "dir->i_ino"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sbi->fs_cs",
          "args": [
            "i"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sbi->fs_cs",
          "args": [
            "i"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inotocg",
          "args": [
            "dir->i_ino"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER\\n\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct inode *ufs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_info * sbi;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tstruct inode * inode;\n\tunsigned cg, bit, i, j, start;\n\tstruct ufs_inode_info *ufsi;\n\tint err = -ENOSPC;\n\n\tUFSD(\"ENTER\\n\");\n\t\n\t/* Cannot create files in a deleted directory */\n\tif (!dir || !dir->i_nlink)\n\t\treturn ERR_PTR(-EPERM);\n\tsb = dir->i_sb;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tufsi = UFS_I(inode);\n\tsbi = UFS_SB(sb);\n\tuspi = sbi->s_uspi;\n\n\tlock_ufs(sb);\n\n\t/*\n\t * Try to place the inode in its parent directory\n\t */\n\ti = ufs_inotocg(dir->i_ino);\n\tif (sbi->fs_cs(i).cs_nifree) {\n\t\tcg = i;\n\t\tgoto cg_found;\n\t}\n\n\t/*\n\t * Use a quadratic hash to find a group with a free inode\n\t */\n\tfor ( j = 1; j < uspi->s_ncg; j <<= 1 ) {\n\t\ti += j;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti -= uspi->s_ncg;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\t/*\n\t * That failed: try linear search for a free inode\n\t */\n\ti = ufs_inotocg(dir->i_ino) + 1;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\ti++;\n\t\tif (i >= uspi->s_ncg)\n\t\t\ti = 0;\n\t\tif (sbi->fs_cs(i).cs_nifree) {\n\t\t\tcg = i;\n\t\t\tgoto cg_found;\n\t\t}\n\t}\n\n\tgoto failed;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error, bad cg magic number\");\n\n\tstart = ucpi->c_irotor;\n\tbit = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, uspi->s_ipg, start);\n\tif (!(bit < uspi->s_ipg)) {\n\t\tbit = ubh_find_first_zero_bit (UCPI_UBH(ucpi), ucpi->c_iusedoff, start);\n\t\tif (!(bit < start)) {\n\t\t\tufs_error (sb, \"ufs_new_inode\",\n\t\t\t    \"cylinder group %u corrupted - error in inode bitmap\\n\", cg);\n\t\t\terr = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tUFSD(\"start = %u, bit = %u, ipg = %u\\n\", start, bit, uspi->s_ipg);\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\telse {\n\t\tufs_panic (sb, \"ufs_new_inode\", \"internal error\");\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tu32 initediblk = fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk);\n\n\t\tif (bit + uspi->s_inopb > initediblk &&\n\t\t    initediblk < fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_niblk))\n\t\t\tufs2_init_inodes_chunk(sb, ucpi, ucg);\n\t}\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nifree, 1);\n\tuspi->cs_total.cs_nifree--;\n\tfs32_sub(sb, &sbi->fs_cs(cg).cs_nifree, 1);\n\t\n\tif (S_ISDIR(mode)) {\n\t\tfs32_add(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\tuspi->cs_total.cs_ndir++;\n\t\tfs32_add(sb, &sbi->fs_cs(cg).cs_ndir, 1);\n\t}\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tinode->i_ino = cg * uspi->s_ipg + bit;\n\tinode_init_owner(inode, dir, mode);\n\tinode->i_blocks = 0;\n\tinode->i_generation = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tufsi->i_flags = UFS_I(dir)->i_flags;\n\tufsi->i_lastfrag = 0;\n\tufsi->i_shadow = 0;\n\tufsi->i_osync = 0;\n\tufsi->i_oeftflag = 0;\n\tufsi->i_dir_start_lookup = 0;\n\tmemset(&ufsi->i_u1, 0, sizeof(ufsi->i_u1));\n\tif (insert_inode_locked(inode) < 0) {\n\t\terr = -EIO;\n\t\tgoto failed;\n\t}\n\tmark_inode_dirty(inode);\n\n\tif (uspi->fs_magic == UFS2_MAGIC) {\n\t\tstruct buffer_head *bh;\n\t\tstruct ufs2_inode *ufs2_inode;\n\n\t\t/*\n\t\t * setup birth date, we do it here because of there is no sense\n\t\t * to hold it in struct ufs_inode_info, and lose 64 bit\n\t\t */\n\t\tbh = sb_bread(sb, uspi->s_sbbase + ufs_inotofsba(inode->i_ino));\n\t\tif (!bh) {\n\t\t\tufs_warning(sb, \"ufs_read_inode\",\n\t\t\t\t    \"unable to read inode %lu\\n\",\n\t\t\t\t    inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_remove_inode;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tufs2_inode = (struct ufs2_inode *)bh->b_data;\n\t\tufs2_inode += ufs_inotofsbo(inode->i_ino);\n\t\tufs2_inode->ui_birthtime = cpu_to_fs64(sb, CURRENT_TIME.tv_sec);\n\t\tufs2_inode->ui_birthnsec = cpu_to_fs32(sb, CURRENT_TIME.tv_nsec);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\tunlock_ufs(sb);\n\n\tUFSD(\"allocating inode %lu\\n\", inode->i_ino);\n\tUFSD(\"EXIT\\n\");\n\treturn inode;\n\nfail_remove_inode:\n\tunlock_ufs(sb);\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\nfailed:\n\tunlock_ufs(sb);\n\tmake_bad_inode(inode);\n\tiput (inode);\n\tUFSD(\"EXIT (FAILED): err %d\\n\", err);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "ufs2_init_inodes_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
    "lines": "128-159",
    "snippet": "static void ufs2_init_inodes_chunk(struct super_block *sb,\n\t\t\t\t   struct ufs_cg_private_info *ucpi,\n\t\t\t\t   struct ufs_cylinder_group *ucg)\n{\n\tstruct buffer_head *bh;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tsector_t beg = uspi->s_sbbase +\n\t\tufs_inotofsba(ucpi->c_cgx * uspi->s_ipg +\n\t\t\t      fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk));\n\tsector_t end = beg + uspi->s_fpb;\n\n\tUFSD(\"ENTER cgno %d\\n\", ucpi->c_cgx);\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tfs32_add(sb, &ucg->cg_u.cg_u2.cg_initediblk, uspi->s_inopb);\n\tubh_mark_buffer_dirty(UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tUFSD(\"EXIT\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_add",
          "args": [
            "sb",
            "&ucg->cg_u.cg_u2.cg_initediblk",
            "uspi->s_inopb"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "61-68",
          "snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "sb->s_blocksize"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "beg"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER cgno %d\\n\"",
            "ucpi->c_cgx"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inotofsba",
          "args": [
            "ucpi->c_cgx * uspi->s_ipg +\n\t\t\t      fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "ucg->cg_u.cg_u2.cg_initediblk"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic void ufs2_init_inodes_chunk(struct super_block *sb,\n\t\t\t\t   struct ufs_cg_private_info *ucpi,\n\t\t\t\t   struct ufs_cylinder_group *ucg)\n{\n\tstruct buffer_head *bh;\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tsector_t beg = uspi->s_sbbase +\n\t\tufs_inotofsba(ucpi->c_cgx * uspi->s_ipg +\n\t\t\t      fs32_to_cpu(sb, ucg->cg_u.cg_u2.cg_initediblk));\n\tsector_t end = beg + uspi->s_fpb;\n\n\tUFSD(\"ENTER cgno %d\\n\", ucpi->c_cgx);\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tfs32_add(sb, &ucg->cg_u.cg_u2.cg_initediblk, uspi->s_inopb);\n\tubh_mark_buffer_dirty(UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tUFSD(\"EXIT\\n\");\n}"
  },
  {
    "function_name": "ufs_free_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/ialloc.c",
    "lines": "56-120",
    "snippet": "void ufs_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tint is_directory;\n\tunsigned ino, cg, bit;\n\t\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tino = inode->i_ino;\n\n\tlock_ufs(sb);\n\n\tif (!((ino > 1) && (ino < (uspi->s_ncg * uspi->s_ipg )))) {\n\t\tufs_warning(sb, \"ufs_free_inode\", \"reserved inode or nonexistent inode %u\\n\", ino);\n\t\tunlock_ufs(sb);\n\t\treturn;\n\t}\n\t\n\tcg = ufs_inotocg (ino);\n\tbit = ufs_inotocgoff (ino);\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\tunlock_ufs(sb);\n\t\treturn;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg))\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad cg magic number\");\n\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tufs_error(sb, \"ufs_free_inode\", \"bit already cleared for inode %u\", ino);\n\telse {\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\t\tif (ino < ucpi->c_irotor)\n\t\t\tucpi->c_irotor = ino;\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nifree, 1);\n\t\tuspi->cs_total.cs_nifree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cg).cs_nifree, 1);\n\n\t\tif (is_directory) {\n\t\t\tfs32_sub(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\t\tuspi->cs_total.cs_ndir--;\n\t\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cg).cs_ndir, 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\t\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "732-744",
          "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_sub",
          "args": [
            "sb",
            "&UFS_SB(sb)->fs_cs(cg).cs_ndir",
            "1"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "70-77",
          "snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cg"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_add",
          "args": [
            "sb",
            "&UFS_SB(sb)->fs_cs(cg).cs_nifree",
            "1"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "61-68",
          "snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cg"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_clrbit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_iusedoff",
            "bit"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_free_inode\"",
            "\"bit already cleared for inode %u\"",
            "ino"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_isclr",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_iusedoff",
            "bit"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "get_seconds()"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_free_fragments\"",
            "\"internal error, bad cg magic number\""
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_cg_chkmagic",
          "args": [
            "sb",
            "ucg"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_ucg",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_load_cylinder",
          "args": [
            "sb",
            "cg"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_load_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "126-201",
          "snippet": "struct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_inotocgoff",
          "args": [
            "ino"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inotocg",
          "args": [
            "ino"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "sb",
            "\"ufs_free_inode\"",
            "\"reserved inode or nonexistent inode %u\\n\"",
            "ino"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nvoid ufs_free_inode (struct inode * inode)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tint is_directory;\n\tunsigned ino, cg, bit;\n\t\n\tUFSD(\"ENTER, ino %lu\\n\", inode->i_ino);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tino = inode->i_ino;\n\n\tlock_ufs(sb);\n\n\tif (!((ino > 1) && (ino < (uspi->s_ncg * uspi->s_ipg )))) {\n\t\tufs_warning(sb, \"ufs_free_inode\", \"reserved inode or nonexistent inode %u\\n\", ino);\n\t\tunlock_ufs(sb);\n\t\treturn;\n\t}\n\t\n\tcg = ufs_inotocg (ino);\n\tbit = ufs_inotocgoff (ino);\n\tucpi = ufs_load_cylinder (sb, cg);\n\tif (!ucpi) {\n\t\tunlock_ufs(sb);\n\t\treturn;\n\t}\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg))\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad cg magic number\");\n\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\n\tis_directory = S_ISDIR(inode->i_mode);\n\n\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit))\n\t\tufs_error(sb, \"ufs_free_inode\", \"bit already cleared for inode %u\", ino);\n\telse {\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_iusedoff, bit);\n\t\tif (ino < ucpi->c_irotor)\n\t\t\tucpi->c_irotor = ino;\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nifree, 1);\n\t\tuspi->cs_total.cs_nifree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cg).cs_nifree, 1);\n\n\t\tif (is_directory) {\n\t\t\tfs32_sub(sb, &ucg->cg_cs.cs_ndir, 1);\n\t\t\tuspi->cs_total.cs_ndir--;\n\t\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cg).cs_ndir, 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\t\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n}"
  }
]