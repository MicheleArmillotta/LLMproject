[
  {
    "function_name": "r5_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
    "lines": "167-177",
    "snippet": "u32 r5_hash(const signed char *msg, int len)\n{\n\tu32 a = 0;\n\twhile (*msg) {\n\t\ta += *msg << 4;\n\t\ta += *msg >> 4;\n\t\ta *= 11;\n\t\tmsg++;\n\t}\n\treturn a;\n}",
    "includes": [
      "#include <asm/types.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\nu32 r5_hash(const signed char *msg, int len)\n{\n\tu32 a = 0;\n\twhile (*msg) {\n\t\ta += *msg << 4;\n\t\ta += *msg >> 4;\n\t\ta *= 11;\n\t\tmsg++;\n\t}\n\treturn a;\n}"
  },
  {
    "function_name": "yura_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
    "lines": "128-165",
    "snippet": "u32 yura_hash(const signed char *msg, int len)\n{\n\tint j, pow;\n\tu32 a, c;\n\tint i;\n\n\tfor (pow = 1, i = 1; i < len; i++)\n\t\tpow = pow * 10;\n\n\tif (len == 1)\n\t\ta = msg[0] - 48;\n\telse\n\t\ta = (msg[0] - 48) * pow;\n\n\tfor (i = 1; i < len; i++) {\n\t\tc = msg[i] - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 40; i++) {\n\t\tc = '0' - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 256; i++) {\n\t\tc = i;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\ta = a << 7;\n\treturn a;\n}",
    "includes": [
      "#include <asm/types.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\nu32 yura_hash(const signed char *msg, int len)\n{\n\tint j, pow;\n\tu32 a, c;\n\tint i;\n\n\tfor (pow = 1, i = 1; i < len; i++)\n\t\tpow = pow * 10;\n\n\tif (len == 1)\n\t\ta = msg[0] - 48;\n\telse\n\t\ta = (msg[0] - 48) * pow;\n\n\tfor (i = 1; i < len; i++) {\n\t\tc = msg[i] - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 40; i++) {\n\t\tc = '0' - 48;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\tfor (; i < 256; i++) {\n\t\tc = i;\n\t\tfor (pow = 1, j = i; j < len - 1; j++)\n\t\t\tpow = pow * 10;\n\t\ta = a + c * pow;\n\t}\n\n\ta = a << 7;\n\treturn a;\n}"
  },
  {
    "function_name": "keyed_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/hashes.c",
    "lines": "44-122",
    "snippet": "u32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}",
    "includes": [
      "#include <asm/types.h>",
      "#include \"reiserfs.h\"",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PARTROUNDS 6\t\t/* 6 gets complete mixing */",
      "#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TEACORE",
          "args": [
            "FULLROUNDS"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TEACORE",
          "args": [
            "PARTROUNDS"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/types.h>\n#include \"reiserfs.h\"\n#include <linux/kernel.h>\n\n#define PARTROUNDS 6\t\t/* 6 gets complete mixing */\n#define FULLROUNDS 10\t\t/* 32 is overkill, 16 is strong crypto */\n\nu32 keyed_hash(const signed char *msg, int len)\n{\n\tu32 k[] = { 0x9464a485, 0x542e1a94, 0x3e846bff, 0xb75bcfc3 };\n\n\tu32 h0 = k[0], h1 = k[1];\n\tu32 a, b, c, d;\n\tu32 pad;\n\tint i;\n\n\t/*      assert(len >= 0 && len < 256); */\n\n\tpad = (u32) len | ((u32) len << 8);\n\tpad |= pad << 16;\n\n\twhile (len >= 16) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\t\td = (u32) msg[12] |\n\t\t    (u32) msg[13] << 8 |\n\t\t    (u32) msg[14] << 16 | (u32) msg[15] << 24;\n\n\t\tTEACORE(PARTROUNDS);\n\n\t\tlen -= 16;\n\t\tmsg += 16;\n\t}\n\n\tif (len >= 12) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\t\tc = (u32) msg[8] |\n\t\t    (u32) msg[9] << 8 |\n\t\t    (u32) msg[10] << 16 | (u32) msg[11] << 24;\n\n\t\td = pad;\n\t\tfor (i = 12; i < len; i++) {\n\t\t\td <<= 8;\n\t\t\td |= msg[i];\n\t\t}\n\t} else if (len >= 8) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\t\tb = (u32) msg[4] |\n\t\t    (u32) msg[5] << 8 | (u32) msg[6] << 16 | (u32) msg[7] << 24;\n\n\t\tc = d = pad;\n\t\tfor (i = 8; i < len; i++) {\n\t\t\tc <<= 8;\n\t\t\tc |= msg[i];\n\t\t}\n\t} else if (len >= 4) {\n\t\ta = (u32) msg[0] |\n\t\t    (u32) msg[1] << 8 | (u32) msg[2] << 16 | (u32) msg[3] << 24;\n\n\t\tb = c = d = pad;\n\t\tfor (i = 4; i < len; i++) {\n\t\t\tb <<= 8;\n\t\t\tb |= msg[i];\n\t\t}\n\t} else {\n\t\ta = b = c = d = pad;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\ta <<= 8;\n\t\t\ta |= msg[i];\n\t\t}\n\t}\n\n\tTEACORE(FULLROUNDS);\n\n/*\treturn 0;*/\n\treturn h0 ^ h1;\n}"
  }
]