[
  {
    "function_name": "ext4_trim_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "5161-5238",
    "snippet": "int ext4_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ext4_group_info *grp;\n\text4_group_t group, first_group, last_group;\n\text4_grpblk_t cnt = 0, first_cluster, last_cluster;\n\tuint64_t start, end, minlen, trimmed = 0;\n\text4_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n\text4_fsblk_t max_blks = ext4_blocks_count(EXT4_SB(sb)->s_es);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = EXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t      range->minlen >> sb->s_blocksize_bits);\n\n\tif (minlen > EXT4_CLUSTERS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\t/* Determine first and last group to examine based on start and end */\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) start,\n\t\t\t\t     &first_group, &first_cluster);\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) end,\n\t\t\t\t     &last_group, &last_cluster);\n\n\t/* end now represents the last cluster to discard in this group */\n\tend = EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* We only do this if the grp has never been initialized */\n\t\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t\tret = ext4_mb_init_group(sb, group);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For all the groups except the last one, last cluster will\n\t\t * always be EXT4_CLUSTERS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_cluster is\n\t\t * already computed earlier by ext4_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_cluster;\n\n\t\tif (grp->bb_free >= minlen) {\n\t\t\tcnt = ext4_trim_all_free(sb, group, first_cluster,\n\t\t\t\t\t\tend, minlen);\n\t\t\tif (cnt < 0) {\n\t\t\t\tret = cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrimmed += cnt;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first cluster to discard will be cluster #0.\n\t\t */\n\t\tfirst_cluster = 0;\n\t}\n\n\tif (!ret)\n\t\tatomic_set(&EXT4_SB(sb)->s_last_trim_minblks, minlen);\n\nout:\n\trange->len = EXT4_C2B(EXT4_SB(sb), trimmed) << sb->s_blocksize_bits;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "trimmed"
          ],
          "line": 5236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5236
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&EXT4_SB(sb)->s_last_trim_minblks",
            "minlen"
          ],
          "line": 5233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_trim_all_free",
          "args": [
            "sb",
            "group",
            "first_cluster",
            "end",
            "minlen"
          ],
          "line": 5216
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_trim_all_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "5075-5147",
          "snippet": "static ext4_grpblk_t\next4_trim_all_free(struct super_block *sb, ext4_group_t group,\n\t\t   ext4_grpblk_t start, ext4_grpblk_t max,\n\t\t   ext4_grpblk_t minblocks)\n{\n\tvoid *bitmap;\n\text4_grpblk_t next, count = 0, free_count = 0;\n\tstruct ext4_buddy e4b;\n\tint ret = 0;\n\n\ttrace_ext4_trim_all_free(sb, group, start, max);\n\n\tret = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (ret) {\n\t\text4_error(sb, \"Error in loading buddy \"\n\t\t\t\t\"information for %u\", group);\n\t\treturn ret;\n\t}\n\tbitmap = e4b.bd_bitmap;\n\n\text4_lock_group(sb, group);\n\tif (EXT4_MB_GRP_WAS_TRIMMED(e4b.bd_info) &&\n\t    minblocks >= atomic_read(&EXT4_SB(sb)->s_last_trim_minblks))\n\t\tgoto out;\n\n\tstart = (e4b.bd_info->bb_first_free > start) ?\n\t\te4b.bd_info->bb_first_free : start;\n\n\twhile (start <= max) {\n\t\tstart = mb_find_next_zero_bit(bitmap, max + 1, start);\n\t\tif (start > max)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap, max + 1, start);\n\n\t\tif ((next - start) >= minblocks) {\n\t\t\tret = ext4_trim_extent(sb, start,\n\t\t\t\t\t       next - start, group, &e4b);\n\t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tcount += next - start;\n\t\t}\n\t\tfree_count += next - start;\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (need_resched()) {\n\t\t\text4_unlock_group(sb, group);\n\t\t\tcond_resched();\n\t\t\text4_lock_group(sb, group);\n\t\t}\n\n\t\tif ((e4b.bd_info->bb_free - free_count) < minblocks)\n\t\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tret = count;\n\t\tEXT4_MB_GRP_SET_TRIMMED(e4b.bd_info);\n\t}\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\n\text4_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic ext4_grpblk_t\next4_trim_all_free(struct super_block *sb, ext4_group_t group,\n\t\t   ext4_grpblk_t start, ext4_grpblk_t max,\n\t\t   ext4_grpblk_t minblocks)\n{\n\tvoid *bitmap;\n\text4_grpblk_t next, count = 0, free_count = 0;\n\tstruct ext4_buddy e4b;\n\tint ret = 0;\n\n\ttrace_ext4_trim_all_free(sb, group, start, max);\n\n\tret = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (ret) {\n\t\text4_error(sb, \"Error in loading buddy \"\n\t\t\t\t\"information for %u\", group);\n\t\treturn ret;\n\t}\n\tbitmap = e4b.bd_bitmap;\n\n\text4_lock_group(sb, group);\n\tif (EXT4_MB_GRP_WAS_TRIMMED(e4b.bd_info) &&\n\t    minblocks >= atomic_read(&EXT4_SB(sb)->s_last_trim_minblks))\n\t\tgoto out;\n\n\tstart = (e4b.bd_info->bb_first_free > start) ?\n\t\te4b.bd_info->bb_first_free : start;\n\n\twhile (start <= max) {\n\t\tstart = mb_find_next_zero_bit(bitmap, max + 1, start);\n\t\tif (start > max)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap, max + 1, start);\n\n\t\tif ((next - start) >= minblocks) {\n\t\t\tret = ext4_trim_extent(sb, start,\n\t\t\t\t\t       next - start, group, &e4b);\n\t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tcount += next - start;\n\t\t}\n\t\tfree_count += next - start;\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (need_resched()) {\n\t\t\text4_unlock_group(sb, group);\n\t\t\tcond_resched();\n\t\t\text4_lock_group(sb, group);\n\t\t}\n\n\t\tif ((e4b.bd_info->bb_free - free_count) < minblocks)\n\t\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tret = count;\n\t\tEXT4_MB_GRP_SET_TRIMMED(e4b.bd_info);\n\t}\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\n\text4_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_init_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 5201
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_init_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1033-1093",
          "snippet": "static noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(1, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(1, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_MB_GRP_NEED_INIT(grp)"
          ],
          "line": 5200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_NEED_INIT",
          "args": [
            "grp"
          ],
          "line": 5200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 5198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "(ext4_fsblk_t) end",
            "&last_group",
            "&last_cluster"
          ],
          "line": 5191
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 5177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "EXT4_SB(sb)",
            "range->minlen >> sb->s_blocksize_bits"
          ],
          "line": 5174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "EXT4_SB(sb)->s_es"
          ],
          "line": 5169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT4_SB(sb)->s_es->s_first_data_block"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\tstruct ext4_group_info *grp;\n\text4_group_t group, first_group, last_group;\n\text4_grpblk_t cnt = 0, first_cluster, last_cluster;\n\tuint64_t start, end, minlen, trimmed = 0;\n\text4_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n\text4_fsblk_t max_blks = ext4_blocks_count(EXT4_SB(sb)->s_es);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = EXT4_NUM_B2C(EXT4_SB(sb),\n\t\t\t      range->minlen >> sb->s_blocksize_bits);\n\n\tif (minlen > EXT4_CLUSTERS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\t/* Determine first and last group to examine based on start and end */\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) start,\n\t\t\t\t     &first_group, &first_cluster);\n\text4_get_group_no_and_offset(sb, (ext4_fsblk_t) end,\n\t\t\t\t     &last_group, &last_cluster);\n\n\t/* end now represents the last cluster to discard in this group */\n\tend = EXT4_CLUSTERS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgrp = ext4_get_group_info(sb, group);\n\t\t/* We only do this if the grp has never been initialized */\n\t\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t\tret = ext4_mb_init_group(sb, group);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * For all the groups except the last one, last cluster will\n\t\t * always be EXT4_CLUSTERS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_cluster is\n\t\t * already computed earlier by ext4_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_cluster;\n\n\t\tif (grp->bb_free >= minlen) {\n\t\t\tcnt = ext4_trim_all_free(sb, group, first_cluster,\n\t\t\t\t\t\tend, minlen);\n\t\t\tif (cnt < 0) {\n\t\t\t\tret = cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttrimmed += cnt;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first cluster to discard will be cluster #0.\n\t\t */\n\t\tfirst_cluster = 0;\n\t}\n\n\tif (!ret)\n\t\tatomic_set(&EXT4_SB(sb)->s_last_trim_minblks, minlen);\n\nout:\n\trange->len = EXT4_C2B(EXT4_SB(sb), trimmed) << sb->s_blocksize_bits;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_trim_all_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "5075-5147",
    "snippet": "static ext4_grpblk_t\next4_trim_all_free(struct super_block *sb, ext4_group_t group,\n\t\t   ext4_grpblk_t start, ext4_grpblk_t max,\n\t\t   ext4_grpblk_t minblocks)\n{\n\tvoid *bitmap;\n\text4_grpblk_t next, count = 0, free_count = 0;\n\tstruct ext4_buddy e4b;\n\tint ret = 0;\n\n\ttrace_ext4_trim_all_free(sb, group, start, max);\n\n\tret = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (ret) {\n\t\text4_error(sb, \"Error in loading buddy \"\n\t\t\t\t\"information for %u\", group);\n\t\treturn ret;\n\t}\n\tbitmap = e4b.bd_bitmap;\n\n\text4_lock_group(sb, group);\n\tif (EXT4_MB_GRP_WAS_TRIMMED(e4b.bd_info) &&\n\t    minblocks >= atomic_read(&EXT4_SB(sb)->s_last_trim_minblks))\n\t\tgoto out;\n\n\tstart = (e4b.bd_info->bb_first_free > start) ?\n\t\te4b.bd_info->bb_first_free : start;\n\n\twhile (start <= max) {\n\t\tstart = mb_find_next_zero_bit(bitmap, max + 1, start);\n\t\tif (start > max)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap, max + 1, start);\n\n\t\tif ((next - start) >= minblocks) {\n\t\t\tret = ext4_trim_extent(sb, start,\n\t\t\t\t\t       next - start, group, &e4b);\n\t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tcount += next - start;\n\t\t}\n\t\tfree_count += next - start;\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (need_resched()) {\n\t\t\text4_unlock_group(sb, group);\n\t\t\tcond_resched();\n\t\t\text4_lock_group(sb, group);\n\t\t}\n\n\t\tif ((e4b.bd_info->bb_free - free_count) < minblocks)\n\t\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tret = count;\n\t\tEXT4_MB_GRP_SET_TRIMMED(e4b.bd_info);\n\t}\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\n\text4_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"trimmed %d blocks in the group %d\\n\"",
            "count",
            "group"
          ],
          "line": 5143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 5141
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 5140
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_SET_TRIMMED",
          "args": [
            "e4b.bd_info"
          ],
          "line": 5137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 5128
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 5127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 5125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 5120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_trim_extent",
          "args": [
            "sb",
            "start",
            "next - start",
            "group",
            "&e4b"
          ],
          "line": 5110
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_trim_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "5029-5055",
          "snippet": "static int ext4_trim_extent(struct super_block *sb, int start, int count,\n\t\t\t     ext4_group_t group, struct ext4_buddy *e4b)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct ext4_free_extent ex;\n\tint ret = 0;\n\n\ttrace_ext4_trim_extent(sb, group, start, count);\n\n\tassert_spin_locked(ext4_group_lock_ptr(sb, group));\n\n\tex.fe_start = start;\n\tex.fe_group = group;\n\tex.fe_len = count;\n\n\t/*\n\t * Mark blocks used, so no one can reuse them while\n\t * being trimmed.\n\t */\n\tmb_mark_used(e4b, &ex);\n\text4_unlock_group(sb, group);\n\tret = ext4_issue_discard(sb, group, start, count);\n\text4_lock_group(sb, group);\n\tmb_free_blocks(NULL, e4b, start, ex.fe_len);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_trim_extent(struct super_block *sb, int start, int count,\n\t\t\t     ext4_group_t group, struct ext4_buddy *e4b)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct ext4_free_extent ex;\n\tint ret = 0;\n\n\ttrace_ext4_trim_extent(sb, group, start, count);\n\n\tassert_spin_locked(ext4_group_lock_ptr(sb, group));\n\n\tex.fe_start = start;\n\tex.fe_group = group;\n\tex.fe_len = count;\n\n\t/*\n\t * Mark blocks used, so no one can reuse them while\n\t * being trimmed.\n\t */\n\tmb_mark_used(e4b, &ex);\n\text4_unlock_group(sb, group);\n\tret = ext4_issue_discard(sb, group, start, count);\n\text4_lock_group(sb, group);\n\tmb_free_blocks(NULL, e4b, start, ex.fe_len);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_next_bit",
          "args": [
            "bitmap",
            "max + 1",
            "start"
          ],
          "line": 5107
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_next_zero_bit",
          "args": [
            "bitmap",
            "max + 1",
            "start"
          ],
          "line": 5104
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "414-425",
          "snippet": "static inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&EXT4_SB(sb)->s_last_trim_minblks"
          ],
          "line": 5097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 5097
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_WAS_TRIMMED",
          "args": [
            "e4b.bd_info"
          ],
          "line": 5096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Error in loading buddy \"\n\t\t\t\t\"information for %u\"",
            "group"
          ],
          "line": 5089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "group",
            "&e4b"
          ],
          "line": 5087
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_trim_all_free",
          "args": [
            "sb",
            "group",
            "start",
            "max"
          ],
          "line": 5085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic ext4_grpblk_t\next4_trim_all_free(struct super_block *sb, ext4_group_t group,\n\t\t   ext4_grpblk_t start, ext4_grpblk_t max,\n\t\t   ext4_grpblk_t minblocks)\n{\n\tvoid *bitmap;\n\text4_grpblk_t next, count = 0, free_count = 0;\n\tstruct ext4_buddy e4b;\n\tint ret = 0;\n\n\ttrace_ext4_trim_all_free(sb, group, start, max);\n\n\tret = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (ret) {\n\t\text4_error(sb, \"Error in loading buddy \"\n\t\t\t\t\"information for %u\", group);\n\t\treturn ret;\n\t}\n\tbitmap = e4b.bd_bitmap;\n\n\text4_lock_group(sb, group);\n\tif (EXT4_MB_GRP_WAS_TRIMMED(e4b.bd_info) &&\n\t    minblocks >= atomic_read(&EXT4_SB(sb)->s_last_trim_minblks))\n\t\tgoto out;\n\n\tstart = (e4b.bd_info->bb_first_free > start) ?\n\t\te4b.bd_info->bb_first_free : start;\n\n\twhile (start <= max) {\n\t\tstart = mb_find_next_zero_bit(bitmap, max + 1, start);\n\t\tif (start > max)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap, max + 1, start);\n\n\t\tif ((next - start) >= minblocks) {\n\t\t\tret = ext4_trim_extent(sb, start,\n\t\t\t\t\t       next - start, group, &e4b);\n\t\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\t\tbreak;\n\t\t\tret = 0;\n\t\t\tcount += next - start;\n\t\t}\n\t\tfree_count += next - start;\n\t\tstart = next + 1;\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tcount = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (need_resched()) {\n\t\t\text4_unlock_group(sb, group);\n\t\t\tcond_resched();\n\t\t\text4_lock_group(sb, group);\n\t\t}\n\n\t\tif ((e4b.bd_info->bb_free - free_count) < minblocks)\n\t\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tret = count;\n\t\tEXT4_MB_GRP_SET_TRIMMED(e4b.bd_info);\n\t}\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\n\text4_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_trim_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "5029-5055",
    "snippet": "static int ext4_trim_extent(struct super_block *sb, int start, int count,\n\t\t\t     ext4_group_t group, struct ext4_buddy *e4b)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct ext4_free_extent ex;\n\tint ret = 0;\n\n\ttrace_ext4_trim_extent(sb, group, start, count);\n\n\tassert_spin_locked(ext4_group_lock_ptr(sb, group));\n\n\tex.fe_start = start;\n\tex.fe_group = group;\n\tex.fe_len = count;\n\n\t/*\n\t * Mark blocks used, so no one can reuse them while\n\t * being trimmed.\n\t */\n\tmb_mark_used(e4b, &ex);\n\text4_unlock_group(sb, group);\n\tret = ext4_issue_discard(sb, group, start, count);\n\text4_lock_group(sb, group);\n\tmb_free_blocks(NULL, e4b, start, ex.fe_len);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_free_blocks",
          "args": [
            "NULL",
            "e4b",
            "start",
            "ex.fe_len"
          ],
          "line": 5053
        },
        "resolved": true,
        "details": {
          "function_name": "mb_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1406-1488",
          "snippet": "static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 5052
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_issue_discard",
          "args": [
            "sb",
            "group",
            "start",
            "count"
          ],
          "line": 5051
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_issue_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2745-2756",
          "snippet": "static inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 5050
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_mark_used",
          "args": [
            "e4b",
            "&ex"
          ],
          "line": 5049
        },
        "resolved": true,
        "details": {
          "function_name": "mb_mark_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1543-1616",
          "snippet": "static int mb_mark_used(struct ext4_buddy *e4b, struct ext4_free_extent *ex)\n{\n\tint ord;\n\tint mlen = 0;\n\tint max = 0;\n\tint cur;\n\tint start = ex->fe_start;\n\tint len = ex->fe_len;\n\tunsigned ret = 0;\n\tint len0 = len;\n\tvoid *buddy;\n\n\tBUG_ON(start + len > (e4b->bd_sb->s_blocksize << 3));\n\tBUG_ON(e4b->bd_group != ex->fe_group);\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tmb_check_buddy(e4b);\n\tmb_mark_used_double(e4b, start, len);\n\n\te4b->bd_info->bb_free -= len;\n\tif (e4b->bd_info->bb_first_free == start)\n\t\te4b->bd_info->bb_first_free += len;\n\n\t/* let's maintain fragments counter */\n\tif (start != 0)\n\t\tmlen = !mb_test_bit(start - 1, e4b->bd_bitmap);\n\tif (start + len < EXT4_SB(e4b->bd_sb)->s_mb_maxs[0])\n\t\tmax = !mb_test_bit(start + len, e4b->bd_bitmap);\n\tif (mlen && max)\n\t\te4b->bd_info->bb_fragments++;\n\telse if (!mlen && !max)\n\t\te4b->bd_info->bb_fragments--;\n\n\t/* let's maintain buddy itself */\n\twhile (len) {\n\t\tord = mb_find_order_for_block(e4b, start);\n\n\t\tif (((start >> ord) << ord) == start && len >= (1 << ord)) {\n\t\t\t/* the whole chunk may be allocated at once! */\n\t\t\tmlen = 1 << ord;\n\t\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\t\tBUG_ON((start >> ord) >= max);\n\t\t\tmb_set_bit(start >> ord, buddy);\n\t\t\te4b->bd_info->bb_counters[ord]--;\n\t\t\tstart += mlen;\n\t\t\tlen -= mlen;\n\t\t\tBUG_ON(len < 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* store for history */\n\t\tif (ret == 0)\n\t\t\tret = len | (ord << 16);\n\n\t\t/* we have to split large buddy */\n\t\tBUG_ON(ord <= 0);\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_set_bit(start >> ord, buddy);\n\t\te4b->bd_info->bb_counters[ord]--;\n\n\t\tord--;\n\t\tcur = (start >> ord) & ~1U;\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_clear_bit(cur, buddy);\n\t\tmb_clear_bit(cur + 1, buddy);\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\te4b->bd_info->bb_counters[ord]++;\n\t}\n\tmb_set_largest_free_order(e4b->bd_sb, e4b->bd_info);\n\n\text4_set_bits(e4b->bd_bitmap, ex->fe_start, len0);\n\tmb_check_buddy(e4b);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_mark_used(struct ext4_buddy *e4b, struct ext4_free_extent *ex)\n{\n\tint ord;\n\tint mlen = 0;\n\tint max = 0;\n\tint cur;\n\tint start = ex->fe_start;\n\tint len = ex->fe_len;\n\tunsigned ret = 0;\n\tint len0 = len;\n\tvoid *buddy;\n\n\tBUG_ON(start + len > (e4b->bd_sb->s_blocksize << 3));\n\tBUG_ON(e4b->bd_group != ex->fe_group);\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tmb_check_buddy(e4b);\n\tmb_mark_used_double(e4b, start, len);\n\n\te4b->bd_info->bb_free -= len;\n\tif (e4b->bd_info->bb_first_free == start)\n\t\te4b->bd_info->bb_first_free += len;\n\n\t/* let's maintain fragments counter */\n\tif (start != 0)\n\t\tmlen = !mb_test_bit(start - 1, e4b->bd_bitmap);\n\tif (start + len < EXT4_SB(e4b->bd_sb)->s_mb_maxs[0])\n\t\tmax = !mb_test_bit(start + len, e4b->bd_bitmap);\n\tif (mlen && max)\n\t\te4b->bd_info->bb_fragments++;\n\telse if (!mlen && !max)\n\t\te4b->bd_info->bb_fragments--;\n\n\t/* let's maintain buddy itself */\n\twhile (len) {\n\t\tord = mb_find_order_for_block(e4b, start);\n\n\t\tif (((start >> ord) << ord) == start && len >= (1 << ord)) {\n\t\t\t/* the whole chunk may be allocated at once! */\n\t\t\tmlen = 1 << ord;\n\t\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\t\tBUG_ON((start >> ord) >= max);\n\t\t\tmb_set_bit(start >> ord, buddy);\n\t\t\te4b->bd_info->bb_counters[ord]--;\n\t\t\tstart += mlen;\n\t\t\tlen -= mlen;\n\t\t\tBUG_ON(len < 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* store for history */\n\t\tif (ret == 0)\n\t\t\tret = len | (ord << 16);\n\n\t\t/* we have to split large buddy */\n\t\tBUG_ON(ord <= 0);\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_set_bit(start >> ord, buddy);\n\t\te4b->bd_info->bb_counters[ord]--;\n\n\t\tord--;\n\t\tcur = (start >> ord) & ~1U;\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_clear_bit(cur, buddy);\n\t\tmb_clear_bit(cur + 1, buddy);\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\te4b->bd_info->bb_counters[ord]++;\n\t}\n\tmb_set_largest_free_order(e4b->bd_sb, e4b->bd_info);\n\n\text4_set_bits(e4b->bd_bitmap, ex->fe_start, len0);\n\tmb_check_buddy(e4b);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "ext4_group_lock_ptr(sb, group)"
          ],
          "line": 5039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_lock_ptr",
          "args": [
            "sb",
            "group"
          ],
          "line": 5039
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2211-2536",
          "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
            "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_trim_extent",
          "args": [
            "sb",
            "group",
            "start",
            "count"
          ],
          "line": 5037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "bitlock"
          ],
          "line": 5032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "bitlock"
          ],
          "line": 5031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_trim_extent(struct super_block *sb, int start, int count,\n\t\t\t     ext4_group_t group, struct ext4_buddy *e4b)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct ext4_free_extent ex;\n\tint ret = 0;\n\n\ttrace_ext4_trim_extent(sb, group, start, count);\n\n\tassert_spin_locked(ext4_group_lock_ptr(sb, group));\n\n\tex.fe_start = start;\n\tex.fe_group = group;\n\tex.fe_len = count;\n\n\t/*\n\t * Mark blocks used, so no one can reuse them while\n\t * being trimmed.\n\t */\n\tmb_mark_used(e4b, &ex);\n\text4_unlock_group(sb, group);\n\tret = ext4_issue_discard(sb, group, start, count);\n\text4_lock_group(sb, group);\n\tmb_free_blocks(NULL, e4b, start, ex.fe_len);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_group_add_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4892-5015",
    "snippet": "int ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t ext4_fsblk_t block, unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\text4_grpblk_t bit;\n\tunsigned int i;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_buddy e4b;\n\tint err = 0, ret, blk_free_count;\n\text4_grpblk_t blocks_freed;\n\n\text4_debug(\"Adding block(s) %llu-%llu\\n\", block, block + count - 1);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\text4_warning(sb, \"too much blocks added to group %u\\n\",\n\t\t\t     block_group);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tdesc = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!desc) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, desc), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, desc), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, desc), sbi->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, desc),\n\t\t     sbi->s_itb_per_group)) {\n\t\text4_error(sb, \"Adding blocks in system zones - \"\n\t\t\t   \"Block = %llu, count = %lu\",\n\t\t\t   block, count);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tfor (i = 0, blocks_freed = 0; i < count; i++) {\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!mb_test_bit(bit + i, bitmap_bh->b_data)) {\n\t\t\text4_error(sb, \"bit already cleared for block %llu\",\n\t\t\t\t   (ext4_fsblk_t)(block + i));\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tblocks_freed++;\n\t\t}\n\t}\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * need to update group_info->bb_free and bitmap\n\t * with group lock held. generate_buddy look at\n\t * them with group lock_held\n\t */\n\text4_lock_group(sb, block_group);\n\tmb_clear_bits(bitmap_bh->b_data, bit, count);\n\tmb_free_blocks(NULL, &e4b, bit, count);\n\tblk_free_count = blocks_freed + ext4_free_group_clusters(sb, desc);\n\text4_free_group_clusters_set(sb, desc, blk_free_count);\n\text4_block_bitmap_csum_set(sb, block_group, desc, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, desc);\n\text4_unlock_group(sb, block_group);\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, blocks_freed));\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, blocks_freed),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 5013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 5012
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "gd_bh"
          ],
          "line": 5007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gd_bh",
            "\"dirtied group descriptor block\""
          ],
          "line": 5006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bitmap_bh"
          ],
          "line": 5003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"dirtied bitmap block\""
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 4999
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "EXT4_NUM_B2C(sbi, blocks_freed)",
            "&sbi->s_flex_groups[flex_group].free_clusters"
          ],
          "line": 4995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "blocks_freed"
          ],
          "line": 4995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_group",
          "args": [
            "sbi",
            "block_group"
          ],
          "line": 4994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeclusters_counter",
            "EXT4_NUM_B2C(sbi, blocks_freed)"
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "blocks_freed"
          ],
          "line": 4991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 4989
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_set",
          "args": [
            "sb",
            "block_group",
            "desc"
          ],
          "line": 4988
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap_csum_set",
          "args": [
            "sb",
            "block_group",
            "desc",
            "bitmap_bh"
          ],
          "line": 4987
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "83-98",
          "snippet": "void ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nvoid ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters_set",
          "args": [
            "sb",
            "desc",
            "blk_free_count"
          ],
          "line": 4986
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "259-265",
          "snippet": "void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters",
          "args": [
            "sb",
            "desc"
          ],
          "line": 4985
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "203-209",
          "snippet": "__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_free_blocks",
          "args": [
            "NULL",
            "&e4b",
            "bit",
            "count"
          ],
          "line": 4984
        },
        "resolved": true,
        "details": {
          "function_name": "mb_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1406-1488",
          "snippet": "static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_clear_bits",
          "args": [
            "bitmap_bh->b_data",
            "bit",
            "count"
          ],
          "line": 4983
        },
        "resolved": true,
        "details": {
          "function_name": "mb_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1269-1285",
          "snippet": "static void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 4982
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "block_group",
            "&e4b"
          ],
          "line": 4973
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"bit already cleared\""
          ],
          "line": 4967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"bit already cleared for block %llu\"",
            "(ext4_fsblk_t)(block + i)"
          ],
          "line": 4965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "block + i"
          ],
          "line": 4966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "bit + i",
            "bitmap_bh->b_data"
          ],
          "line": 4964
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"clear bit\""
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "gd_bh"
          ],
          "line": 4958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gd_bh",
            "\"get_write_access\""
          ],
          "line": 4957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 4948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"getting write access\""
          ],
          "line": 4947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Adding blocks in system zones - \"\n\t\t\t   \"Block = %llu, count = %lu\"",
            "block",
            "count"
          ],
          "line": 4940
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "block + count - 1",
            "ext4_inode_table(sb, desc)",
            "sbi->s_itb_per_group"
          ],
          "line": 4938
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "desc"
          ],
          "line": 4938
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "desc"
          ],
          "line": 4936
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "desc"
          ],
          "line": 4935
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "&gd_bh"
          ],
          "line": 4929
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 4923
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "504-517",
          "snippet": "struct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_warning",
          "args": [
            "sb",
            "\"too much blocks added to group %u\\n\"",
            "block_group"
          ],
          "line": 4917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 4916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "block",
            "&block_group",
            "&bit"
          ],
          "line": 4911
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"Adding block(s) %llu-%llu\\n\"",
            "block",
            "block + count - 1"
          ],
          "line": 4906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4901
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_group_add_blocks(handle_t *handle, struct super_block *sb,\n\t\t\t ext4_fsblk_t block, unsigned long count)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\text4_grpblk_t bit;\n\tunsigned int i;\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_buddy e4b;\n\tint err = 0, ret, blk_free_count;\n\text4_grpblk_t blocks_freed;\n\n\text4_debug(\"Adding block(s) %llu-%llu\\n\", block, block + count - 1);\n\n\tif (count == 0)\n\t\treturn 0;\n\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\text4_warning(sb, \"too much blocks added to group %u\\n\",\n\t\t\t     block_group);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tdesc = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!desc) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, desc), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, desc), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, desc), sbi->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, desc),\n\t\t     sbi->s_itb_per_group)) {\n\t\text4_error(sb, \"Adding blocks in system zones - \"\n\t\t\t   \"Block = %llu, count = %lu\",\n\t\t\t   block, count);\n\t\terr = -EINVAL;\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tfor (i = 0, blocks_freed = 0; i < count; i++) {\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!mb_test_bit(bit + i, bitmap_bh->b_data)) {\n\t\t\text4_error(sb, \"bit already cleared for block %llu\",\n\t\t\t\t   (ext4_fsblk_t)(block + i));\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tblocks_freed++;\n\t\t}\n\t}\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * need to update group_info->bb_free and bitmap\n\t * with group lock held. generate_buddy look at\n\t * them with group lock_held\n\t */\n\text4_lock_group(sb, block_group);\n\tmb_clear_bits(bitmap_bh->b_data, bit, count);\n\tmb_free_blocks(NULL, &e4b, bit, count);\n\tblk_free_count = blocks_freed + ext4_free_group_clusters(sb, desc);\n\text4_free_group_clusters_set(sb, desc, blk_free_count);\n\text4_block_bitmap_csum_set(sb, block_group, desc, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, desc);\n\text4_unlock_group(sb, block_group);\n\tpercpu_counter_add(&sbi->s_freeclusters_counter,\n\t\t\t   EXT4_NUM_B2C(sbi, blocks_freed));\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(EXT4_NUM_B2C(sbi, blocks_freed),\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4633-4881",
    "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_free_data_cachep;",
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 4879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 4878
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bitmap_bh"
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "gd_bh"
          ],
          "line": 4867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gd_bh",
            "\"dirtied group descriptor block\""
          ],
          "line": 4866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bitmap_bh"
          ],
          "line": 4863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"dirtied bitmap block\""
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 4859
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeclusters_counter",
            "count_clusters"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "EXT4_C2B(sbi, count_clusters)"
          ],
          "line": 4856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "count_clusters"
          ],
          "line": 4856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_add",
          "args": [
            "count_clusters",
            "&sbi->s_flex_groups[flex_group].free_clusters"
          ],
          "line": 4851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_group",
          "args": [
            "sbi",
            "block_group"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 4847
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_set",
          "args": [
            "sb",
            "block_group",
            "gdp"
          ],
          "line": 4846
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap_csum_set",
          "args": [
            "sb",
            "block_group",
            "gdp",
            "bitmap_bh"
          ],
          "line": 4845
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "83-98",
          "snippet": "void ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nvoid ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters_set",
          "args": [
            "sb",
            "gdp",
            "ret"
          ],
          "line": 4844
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "259-265",
          "snippet": "void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 4843
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "203-209",
          "snippet": "__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_free_blocks",
          "args": [
            "inode",
            "&e4b",
            "bit",
            "count_clusters"
          ],
          "line": 4840
        },
        "resolved": true,
        "details": {
          "function_name": "mb_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1406-1488",
          "snippet": "static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_clear_bits",
          "args": [
            "bitmap_bh->b_data",
            "bit",
            "count_clusters"
          ],
          "line": 4839
        },
        "resolved": true,
        "details": {
          "function_name": "mb_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1269-1285",
          "snippet": "static void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 4838
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_CLEAR_TRIMMED",
          "args": [
            "e4b.bd_info"
          ],
          "line": 4836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\"",
            "block_group",
            "bit",
            "count",
            "err"
          ],
          "line": 4831
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_issue_discard",
          "args": [
            "sb",
            "block_group",
            "bit",
            "count"
          ],
          "line": 4829
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_issue_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2745-2756",
          "snippet": "static inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DISCARD"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_free_metadata",
          "args": [
            "handle",
            "&e4b",
            "new_entry"
          ],
          "line": 4822
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_free_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4548-4623",
          "snippet": "static noinline_for_stack int\next4_mb_free_metadata(handle_t *handle, struct ext4_buddy *e4b,\n\t\t      struct ext4_free_data *new_entry)\n{\n\text4_group_t group = e4b->bd_group;\n\text4_grpblk_t cluster;\n\tstruct ext4_free_data *entry;\n\tstruct ext4_group_info *db = e4b->bd_info;\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct rb_node **n = &db->bb_free_root.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\tnew_node = &new_entry->efd_node;\n\tcluster = new_entry->efd_start_cluster;\n\n\tif (!*n) {\n\t\t/* first free block exent. We need to\n\t\t   protect buddy cache from being freed,\n\t\t * otherwise we'll refresh it from\n\t\t * on-disk bitmap and lose not-yet-available\n\t\t * blocks */\n\t\tpage_cache_get(e4b->bd_buddy_page);\n\t\tpage_cache_get(e4b->bd_bitmap_page);\n\t}\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_free_data, efd_node);\n\t\tif (cluster < entry->efd_start_cluster)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (cluster >= (entry->efd_start_cluster + entry->efd_count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\text4_grp_locked_error(sb, group, 0,\n\t\t\t\text4_group_first_block_no(sb, group) +\n\t\t\t\tEXT4_C2B(sbi, cluster),\n\t\t\t\t\"Block already on to-be-freed list\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trb_link_node(new_node, parent, n);\n\trb_insert_color(new_node, &db->bb_free_root);\n\n\t/* Now try to see the extent can be merged to left and right */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\tif (can_merge(entry, new_entry) &&\n\t\t    ext4_journal_callback_try_del(handle, &entry->efd_jce)) {\n\t\t\tnew_entry->efd_start_cluster = entry->efd_start_cluster;\n\t\t\tnew_entry->efd_count += entry->efd_count;\n\t\t\trb_erase(node, &(db->bb_free_root));\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t\t}\n\t}\n\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\tif (can_merge(new_entry, entry) &&\n\t\t    ext4_journal_callback_try_del(handle, &entry->efd_jce)) {\n\t\t\tnew_entry->efd_count += entry->efd_count;\n\t\t\trb_erase(node, &(db->bb_free_root));\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t\t}\n\t}\n\t/* Add the extent to transaction's private list */\n\text4_journal_callback_add(handle, ext4_free_data_callback,\n\t\t\t\t  &new_entry->efd_jce);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_free_metadata(handle_t *handle, struct ext4_buddy *e4b,\n\t\t      struct ext4_free_data *new_entry)\n{\n\text4_group_t group = e4b->bd_group;\n\text4_grpblk_t cluster;\n\tstruct ext4_free_data *entry;\n\tstruct ext4_group_info *db = e4b->bd_info;\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct rb_node **n = &db->bb_free_root.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\tnew_node = &new_entry->efd_node;\n\tcluster = new_entry->efd_start_cluster;\n\n\tif (!*n) {\n\t\t/* first free block exent. We need to\n\t\t   protect buddy cache from being freed,\n\t\t * otherwise we'll refresh it from\n\t\t * on-disk bitmap and lose not-yet-available\n\t\t * blocks */\n\t\tpage_cache_get(e4b->bd_buddy_page);\n\t\tpage_cache_get(e4b->bd_bitmap_page);\n\t}\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_free_data, efd_node);\n\t\tif (cluster < entry->efd_start_cluster)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (cluster >= (entry->efd_start_cluster + entry->efd_count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\text4_grp_locked_error(sb, group, 0,\n\t\t\t\text4_group_first_block_no(sb, group) +\n\t\t\t\tEXT4_C2B(sbi, cluster),\n\t\t\t\t\"Block already on to-be-freed list\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trb_link_node(new_node, parent, n);\n\trb_insert_color(new_node, &db->bb_free_root);\n\n\t/* Now try to see the extent can be merged to left and right */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\tif (can_merge(entry, new_entry) &&\n\t\t    ext4_journal_callback_try_del(handle, &entry->efd_jce)) {\n\t\t\tnew_entry->efd_start_cluster = entry->efd_start_cluster;\n\t\t\tnew_entry->efd_count += entry->efd_count;\n\t\t\trb_erase(node, &(db->bb_free_root));\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t\t}\n\t}\n\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\tif (can_merge(new_entry, entry) &&\n\t\t    ext4_journal_callback_try_del(handle, &entry->efd_jce)) {\n\t\t\tnew_entry->efd_count += entry->efd_count;\n\t\t\trb_erase(node, &(db->bb_free_root));\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t\t}\n\t}\n\t/* Add the extent to transaction's private list */\n\text4_journal_callback_add(handle, ext4_free_data_callback,\n\t\t\t\t  &new_entry->efd_jce);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/50"
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ext4_free_data_cachep",
            "GFP_NOFS"
          ],
          "line": 4805
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 4798
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "block_group",
            "&e4b"
          ],
          "line": 4794
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_mballoc_free",
          "args": [
            "sb",
            "inode",
            "block_group",
            "bit",
            "count_clusters"
          ],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mb_test_bit(bit + i, bitmap_bh->b_data)"
          ],
          "line": 4789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "bit + i",
            "bitmap_bh->b_data"
          ],
          "line": 4789
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "gd_bh"
          ],
          "line": 4782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gd_bh",
            "\"get_write_access\""
          ],
          "line": 4781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"getting write access\""
          ],
          "line": 4771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\"",
            "block",
            "count"
          ],
          "line": 4765
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "block + count - 1",
            "ext4_inode_table(sb, gdp)",
            "EXT4_SB(sb)->s_itb_per_group"
          ],
          "line": 4762
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4763
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_table",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 4762
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "195-201",
          "snippet": "ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t      struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_table_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_table_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_inode_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 4759
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_inode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "187-193",
          "snippet": "ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_inode_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_inode_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 4758
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "179-185",
          "snippet": "ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\next4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le32_to_cpu(bg->bg_block_bitmap_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (ext4_fsblk_t)le32_to_cpu(bg->bg_block_bitmap_hi) << 32 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "&gd_bh"
          ],
          "line": 4752
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 4747
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "504-517",
          "snippet": "struct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "count"
          ],
          "line": 4746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "bit"
          ],
          "line": 4742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "bit"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "ext4_get_group_info(sb, block_group)"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "block",
            "&block_group",
            "&bit"
          ],
          "line": 4731
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_LBLK_COFF",
          "args": [
            "sbi",
            "count"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_PBLK_COFF",
          "args": [
            "sbi",
            "block"
          ],
          "line": 4704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_should_writeback_data",
          "args": [
            "inode"
          ],
          "line": 4694
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_writeback_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "423-426",
          "snippet": "static inline int ext4_should_writeback_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_WRITEBACK_DATA_MODE;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_INODE_WRITEBACK_DATA_MODE\t0x04 /* writeback data mode */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_INODE_WRITEBACK_DATA_MODE\t0x04 /* writeback data mode */\n\nstatic inline int ext4_should_writeback_data(struct inode *inode)\n{\n\treturn ext4_inode_journal_mode(inode) & EXT4_INODE_WRITEBACK_DATA_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_forget",
          "args": [
            "handle",
            "flags & EXT4_FREE_BLOCKS_METADATA",
            "inode",
            "tbh",
            "block + i"
          ],
          "line": 4682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_find_get_block",
          "args": [
            "inode->i_sb",
            "block + i"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bh && (count > 1)"
          ],
          "line": 4673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_free_blocks",
          "args": [
            "inode",
            "block",
            "count",
            "flags"
          ],
          "line": 4667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"freeing block %llu\\n\"",
            "block"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_data_block_valid",
          "args": [
            "sbi",
            "block",
            "count"
          ],
          "line": 4660
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_data_block_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "197-221",
          "snippet": "int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block != bh->b_blocknr"
          ],
          "line": 4653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 4650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
  },
  {
    "function_name": "ext4_mb_free_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4548-4623",
    "snippet": "static noinline_for_stack int\next4_mb_free_metadata(handle_t *handle, struct ext4_buddy *e4b,\n\t\t      struct ext4_free_data *new_entry)\n{\n\text4_group_t group = e4b->bd_group;\n\text4_grpblk_t cluster;\n\tstruct ext4_free_data *entry;\n\tstruct ext4_group_info *db = e4b->bd_info;\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct rb_node **n = &db->bb_free_root.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\tnew_node = &new_entry->efd_node;\n\tcluster = new_entry->efd_start_cluster;\n\n\tif (!*n) {\n\t\t/* first free block exent. We need to\n\t\t   protect buddy cache from being freed,\n\t\t * otherwise we'll refresh it from\n\t\t * on-disk bitmap and lose not-yet-available\n\t\t * blocks */\n\t\tpage_cache_get(e4b->bd_buddy_page);\n\t\tpage_cache_get(e4b->bd_bitmap_page);\n\t}\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_free_data, efd_node);\n\t\tif (cluster < entry->efd_start_cluster)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (cluster >= (entry->efd_start_cluster + entry->efd_count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\text4_grp_locked_error(sb, group, 0,\n\t\t\t\text4_group_first_block_no(sb, group) +\n\t\t\t\tEXT4_C2B(sbi, cluster),\n\t\t\t\t\"Block already on to-be-freed list\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trb_link_node(new_node, parent, n);\n\trb_insert_color(new_node, &db->bb_free_root);\n\n\t/* Now try to see the extent can be merged to left and right */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\tif (can_merge(entry, new_entry) &&\n\t\t    ext4_journal_callback_try_del(handle, &entry->efd_jce)) {\n\t\t\tnew_entry->efd_start_cluster = entry->efd_start_cluster;\n\t\t\tnew_entry->efd_count += entry->efd_count;\n\t\t\trb_erase(node, &(db->bb_free_root));\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t\t}\n\t}\n\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\tif (can_merge(new_entry, entry) &&\n\t\t    ext4_journal_callback_try_del(handle, &entry->efd_jce)) {\n\t\t\tnew_entry->efd_count += entry->efd_count;\n\t\t\trb_erase(node, &(db->bb_free_root));\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t\t}\n\t}\n\t/* Add the extent to transaction's private list */\n\text4_journal_callback_add(handle, ext4_free_data_callback,\n\t\t\t\t  &new_entry->efd_jce);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_free_data_cachep;",
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_journal_callback_add",
          "args": [
            "handle",
            "ext4_free_data_callback",
            "&new_entry->efd_jce"
          ],
          "line": 4620
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_callback_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "180-194",
          "snippet": "static inline void ext4_journal_callback_add(handle_t *handle,\n\t\t\tvoid (*func)(struct super_block *sb,\n\t\t\t\t     struct ext4_journal_cb_entry *jce,\n\t\t\t\t     int rc),\n\t\t\tstruct ext4_journal_cb_entry *jce)\n{\n\tstruct ext4_sb_info *sbi =\n\t\t\tEXT4_SB(handle->h_transaction->t_journal->j_private);\n\n\t/* Add the jce to transaction's private list */\n\tjce->jce_func = func;\n\tspin_lock(&sbi->s_md_lock);\n\tlist_add_tail(&jce->jce_list, &handle->h_transaction->t_private_list);\n\tspin_unlock(&sbi->s_md_lock);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_journal_callback_add(handle_t *handle,\n\t\t\tvoid (*func)(struct super_block *sb,\n\t\t\t\t     struct ext4_journal_cb_entry *jce,\n\t\t\t\t     int rc),\n\t\t\tstruct ext4_journal_cb_entry *jce)\n{\n\tstruct ext4_sb_info *sbi =\n\t\t\tEXT4_SB(handle->h_transaction->t_journal->j_private);\n\n\t/* Add the jce to transaction's private list */\n\tjce->jce_func = func;\n\tspin_lock(&sbi->s_md_lock);\n\tlist_add_tail(&jce->jce_list, &handle->h_transaction->t_private_list);\n\tspin_unlock(&sbi->s_md_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_free_data_cachep",
            "entry"
          ],
          "line": 4616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&(db->bb_free_root)"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_callback_try_del",
          "args": [
            "handle",
            "&entry->efd_jce"
          ],
          "line": 4613
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_journal_callback_try_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "202-214",
          "snippet": "static inline bool ext4_journal_callback_try_del(handle_t *handle,\n\t\t\t\t\t     struct ext4_journal_cb_entry *jce)\n{\n\tbool deleted;\n\tstruct ext4_sb_info *sbi =\n\t\t\tEXT4_SB(handle->h_transaction->t_journal->j_private);\n\n\tspin_lock(&sbi->s_md_lock);\n\tdeleted = !list_empty(&jce->jce_list);\n\tlist_del_init(&jce->jce_list);\n\tspin_unlock(&sbi->s_md_lock);\n\treturn deleted;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline bool ext4_journal_callback_try_del(handle_t *handle,\n\t\t\t\t\t     struct ext4_journal_cb_entry *jce)\n{\n\tbool deleted;\n\tstruct ext4_sb_info *sbi =\n\t\t\tEXT4_SB(handle->h_transaction->t_journal->j_private);\n\n\tspin_lock(&sbi->s_md_lock);\n\tdeleted = !list_empty(&jce->jce_list);\n\tlist_del_init(&jce->jce_list);\n\tspin_unlock(&sbi->s_md_lock);\n\treturn deleted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_merge",
          "args": [
            "new_entry",
            "entry"
          ],
          "line": 4612
        },
        "resolved": true,
        "details": {
          "function_name": "can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4538-4546",
          "snippet": "static int can_merge(struct ext4_free_data *entry1,\n\t\t\tstruct ext4_free_data *entry2)\n{\n\tif ((entry1->efd_tid == entry2->efd_tid) &&\n\t    (entry1->efd_group == entry2->efd_group) &&\n\t    ((entry1->efd_start_cluster + entry1->efd_count) == entry2->efd_start_cluster))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int can_merge(struct ext4_free_data *entry1,\n\t\t\tstruct ext4_free_data *entry2)\n{\n\tif ((entry1->efd_tid == entry2->efd_tid) &&\n\t    (entry1->efd_group == entry2->efd_group) &&\n\t    ((entry1->efd_start_cluster + entry1->efd_count) == entry2->efd_start_cluster))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structext4_free_data",
            "efd_node"
          ],
          "line": 4611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "new_node"
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_free_data_cachep",
            "entry"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&(db->bb_free_root)"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structext4_free_data",
            "efd_node"
          ],
          "line": 4599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "new_node"
          ],
          "line": 4597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "new_node",
            "&db->bb_free_root"
          ],
          "line": 4594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "new_node",
            "parent",
            "n"
          ],
          "line": 4593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_locked_error",
          "args": [
            "sb",
            "group",
            "0",
            "ext4_group_first_block_no(sb, group) +\n\t\t\t\tEXT4_C2B(sbi, cluster)",
            "\"Block already on to-be-freed list\""
          ],
          "line": 4585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "cluster"
          ],
          "line": 4587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 4586
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structext4_free_data",
            "efd_node"
          ],
          "line": 4579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "e4b->bd_bitmap_page"
          ],
          "line": 4575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "e4b->bd_buddy_page"
          ],
          "line": 4574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "e4b->bd_buddy_page == NULL"
          ],
          "line": 4563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "e4b->bd_bitmap_page == NULL"
          ],
          "line": 4562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ext4_handle_valid(handle)"
          ],
          "line": 4561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4557
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_free_metadata(handle_t *handle, struct ext4_buddy *e4b,\n\t\t      struct ext4_free_data *new_entry)\n{\n\text4_group_t group = e4b->bd_group;\n\text4_grpblk_t cluster;\n\tstruct ext4_free_data *entry;\n\tstruct ext4_group_info *db = e4b->bd_info;\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct rb_node **n = &db->bb_free_root.rb_node, *node;\n\tstruct rb_node *parent = NULL, *new_node;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\tnew_node = &new_entry->efd_node;\n\tcluster = new_entry->efd_start_cluster;\n\n\tif (!*n) {\n\t\t/* first free block exent. We need to\n\t\t   protect buddy cache from being freed,\n\t\t * otherwise we'll refresh it from\n\t\t * on-disk bitmap and lose not-yet-available\n\t\t * blocks */\n\t\tpage_cache_get(e4b->bd_buddy_page);\n\t\tpage_cache_get(e4b->bd_bitmap_page);\n\t}\n\twhile (*n) {\n\t\tparent = *n;\n\t\tentry = rb_entry(parent, struct ext4_free_data, efd_node);\n\t\tif (cluster < entry->efd_start_cluster)\n\t\t\tn = &(*n)->rb_left;\n\t\telse if (cluster >= (entry->efd_start_cluster + entry->efd_count))\n\t\t\tn = &(*n)->rb_right;\n\t\telse {\n\t\t\text4_grp_locked_error(sb, group, 0,\n\t\t\t\text4_group_first_block_no(sb, group) +\n\t\t\t\tEXT4_C2B(sbi, cluster),\n\t\t\t\t\"Block already on to-be-freed list\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trb_link_node(new_node, parent, n);\n\trb_insert_color(new_node, &db->bb_free_root);\n\n\t/* Now try to see the extent can be merged to left and right */\n\tnode = rb_prev(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\tif (can_merge(entry, new_entry) &&\n\t\t    ext4_journal_callback_try_del(handle, &entry->efd_jce)) {\n\t\t\tnew_entry->efd_start_cluster = entry->efd_start_cluster;\n\t\t\tnew_entry->efd_count += entry->efd_count;\n\t\t\trb_erase(node, &(db->bb_free_root));\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t\t}\n\t}\n\n\tnode = rb_next(new_node);\n\tif (node) {\n\t\tentry = rb_entry(node, struct ext4_free_data, efd_node);\n\t\tif (can_merge(new_entry, entry) &&\n\t\t    ext4_journal_callback_try_del(handle, &entry->efd_jce)) {\n\t\t\tnew_entry->efd_count += entry->efd_count;\n\t\t\trb_erase(node, &(db->bb_free_root));\n\t\t\tkmem_cache_free(ext4_free_data_cachep, entry);\n\t\t}\n\t}\n\t/* Add the extent to transaction's private list */\n\text4_journal_callback_add(handle, ext4_free_data_callback,\n\t\t\t\t  &new_entry->efd_jce);\n\treturn 0;\n}"
  },
  {
    "function_name": "can_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4538-4546",
    "snippet": "static int can_merge(struct ext4_free_data *entry1,\n\t\t\tstruct ext4_free_data *entry2)\n{\n\tif ((entry1->efd_tid == entry2->efd_tid) &&\n\t    (entry1->efd_group == entry2->efd_group) &&\n\t    ((entry1->efd_start_cluster + entry1->efd_count) == entry2->efd_start_cluster))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int can_merge(struct ext4_free_data *entry1,\n\t\t\tstruct ext4_free_data *entry2)\n{\n\tif ((entry1->efd_tid == entry2->efd_tid) &&\n\t    (entry1->efd_group == entry2->efd_group) &&\n\t    ((entry1->efd_start_cluster + entry1->efd_count) == entry2->efd_start_cluster))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_new_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4390-4531",
    "snippet": "ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tint freed;\n\tstruct ext4_allocation_context *ac = NULL;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block = 0;\n\tunsigned int inquota = 0;\n\tunsigned int reserv_clstrs = 0;\n\n\tmight_sleep();\n\tsb = ar->inode->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\ttrace_ext4_request_blocks(ar);\n\n\t/* Allow to use superuser reservation for quota file */\n\tif (IS_NOQUOTA(ar->inode))\n\t\tar->flags |= EXT4_MB_USE_ROOT_BLOCKS;\n\n\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {\n\t\t/* Without delayed allocation we need to verify\n\t\t * there is enough free blocks to do block allocation\n\t\t * and verify allocation doesn't exceed the quota limits.\n\t\t */\n\t\twhile (ar->len &&\n\t\t\text4_claim_free_clusters(sbi, ar->len, ar->flags)) {\n\n\t\t\t/* let others to free the space */\n\t\t\tcond_resched();\n\t\t\tar->len = ar->len >> 1;\n\t\t}\n\t\tif (!ar->len) {\n\t\t\t*errp = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\treserv_clstrs = ar->len;\n\t\tif (ar->flags & EXT4_MB_USE_ROOT_BLOCKS) {\n\t\t\tdquot_alloc_block_nofail(ar->inode,\n\t\t\t\t\t\t EXT4_C2B(sbi, ar->len));\n\t\t} else {\n\t\t\twhile (ar->len &&\n\t\t\t\tdquot_alloc_block(ar->inode,\n\t\t\t\t\t\t  EXT4_C2B(sbi, ar->len))) {\n\n\t\t\t\tar->flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\t\t\tar->len--;\n\t\t\t}\n\t\t}\n\t\tinquota = ar->len;\n\t\tif (ar->len == 0) {\n\t\t\t*errp = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);\n\tif (!ac) {\n\t\tar->len = 0;\n\t\t*errp = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*errp = ext4_mb_initialize_context(ac, ar);\n\tif (*errp) {\n\t\tar->len = 0;\n\t\tgoto out;\n\t}\n\n\tac->ac_op = EXT4_MB_HISTORY_PREALLOC;\n\tif (!ext4_mb_use_preallocated(ac)) {\n\t\tac->ac_op = EXT4_MB_HISTORY_ALLOC;\n\t\text4_mb_normalize_request(ac, ar);\nrepeat:\n\t\t/* allocate space in core */\n\t\t*errp = ext4_mb_regular_allocator(ac);\n\t\tif (*errp)\n\t\t\tgoto discard_and_exit;\n\n\t\t/* as we've just preallocated more space than\n\t\t * user requested originally, we store allocated\n\t\t * space in a special descriptor */\n\t\tif (ac->ac_status == AC_STATUS_FOUND &&\n\t\t    ac->ac_o_ex.fe_len < ac->ac_b_ex.fe_len)\n\t\t\t*errp = ext4_mb_new_preallocation(ac);\n\t\tif (*errp) {\n\t\tdiscard_and_exit:\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (likely(ac->ac_status == AC_STATUS_FOUND)) {\n\t\t*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);\n\t\tif (*errp == -EAGAIN) {\n\t\t\t/*\n\t\t\t * drop the reference that we took\n\t\t\t * in ext4_mb_use_best_found\n\t\t\t */\n\t\t\text4_mb_release_context(ac);\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tgoto repeat;\n\t\t} else if (*errp) {\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t} else {\n\t\t\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\t\t\tar->len = ac->ac_b_ex.fe_len;\n\t\t}\n\t} else {\n\t\tfreed  = ext4_mb_discard_preallocations(sb, ac->ac_o_ex.fe_len);\n\t\tif (freed)\n\t\t\tgoto repeat;\n\t\t*errp = -ENOSPC;\n\t}\n\nerrout:\n\tif (*errp) {\n\t\tac->ac_b_ex.fe_len = 0;\n\t\tar->len = 0;\n\t\text4_mb_show_ac(ac);\n\t}\n\text4_mb_release_context(ac);\nout:\n\tif (ac)\n\t\tkmem_cache_free(ext4_ac_cachep, ac);\n\tif (inquota && ar->len < inquota)\n\t\tdquot_free_block(ar->inode, EXT4_C2B(sbi, inquota - ar->len));\n\tif (!ar->len) {\n\t\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0)\n\t\t\t/* release all the reserved blocks if non delalloc */\n\t\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t\t\treserv_clstrs);\n\t}\n\n\ttrace_ext4_allocate_blocks(ar, (unsigned long long)block);\n\n\treturn block;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_ac_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_allocate_blocks",
          "args": [
            "ar",
            "(unsigned long long)block"
          ],
          "line": 4528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_dirtyclusters_counter",
            "reserv_clstrs"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "ar->inode",
            "EXT4_C2B(sbi, inquota - ar->len)"
          ],
          "line": 4520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "inquota - ar->len"
          ],
          "line": 4520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_ac_cachep",
            "ac"
          ],
          "line": 4518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_release_context",
          "args": [
            "ac"
          ],
          "line": 4515
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_release_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4329-4367",
          "snippet": "static int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t}\n\tif (pa) {\n\t\t/*\n\t\t * We want to add the pa to the right bucket.\n\t\t * Remove it from the list and while adding\n\t\t * make sure the list to which we are adding\n\t\t * doesn't grow big.\n\t\t */\n\t\tif ((pa->pa_type == MB_GROUP_PA) && likely(pa->pa_free)) {\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\text4_mb_add_n_trim(ac);\n\t\t}\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tpage_cache_release(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tpage_cache_release(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t}\n\tif (pa) {\n\t\t/*\n\t\t * We want to add the pa to the right bucket.\n\t\t * Remove it from the list and while adding\n\t\t * make sure the list to which we are adding\n\t\t * doesn't grow big.\n\t\t */\n\t\tif ((pa->pa_type == MB_GROUP_PA) && likely(pa->pa_free)) {\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\text4_mb_add_n_trim(ac);\n\t\t}\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tpage_cache_release(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tpage_cache_release(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_show_ac",
          "args": [
            "ac"
          ],
          "line": 4513
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_show_ac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4081-4084",
          "snippet": "static inline void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_discard_preallocations",
          "args": [
            "sb",
            "ac->ac_o_ex.fe_len"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_discard_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4369-4383",
          "snippet": "static int ext4_mb_discard_preallocations(struct super_block *sb, int needed)\n{\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\tint ret;\n\tint freed = 0;\n\n\ttrace_ext4_mb_discard_preallocations(sb, needed);\n\tfor (i = 0; i < ngroups && needed > 0; i++) {\n\t\tret = ext4_mb_discard_group_preallocations(sb, i, needed);\n\t\tfreed += ret;\n\t\tneeded -= ret;\n\t}\n\n\treturn freed;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_discard_preallocations(struct super_block *sb, int needed)\n{\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\tint ret;\n\tint freed = 0;\n\n\ttrace_ext4_mb_discard_preallocations(sb, needed);\n\tfor (i = 0; i < ngroups && needed > 0; i++) {\n\t\tret = ext4_mb_discard_group_preallocations(sb, i, needed);\n\t\tfreed += ret;\n\t\tneeded -= ret;\n\t}\n\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_grp_offs_to_block",
          "args": [
            "sb",
            "&ac->ac_b_ex"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_grp_offs_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.h",
          "lines": "209-214",
          "snippet": "static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_discard_allocated_blocks",
          "args": [
            "ac"
          ],
          "line": 4496
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_discard_allocated_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3217-3245",
          "snippet": "static void ext4_discard_allocated_blocks(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (pa == NULL) {\n\t\tif (ac->ac_f_ex.fe_len == 0)\n\t\t\treturn;\n\t\terr = ext4_mb_load_buddy(ac->ac_sb, ac->ac_f_ex.fe_group, &e4b);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * This should never happen since we pin the\n\t\t\t * pages in the ext4_allocation_context so\n\t\t\t * ext4_mb_load_buddy() should never fail.\n\t\t\t */\n\t\t\tWARN(1, \"mb_load_buddy failed (%d)\", err);\n\t\t\treturn;\n\t\t}\n\t\text4_lock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\tmb_free_blocks(ac->ac_inode, &e4b, ac->ac_f_ex.fe_start,\n\t\t\t       ac->ac_f_ex.fe_len);\n\t\text4_unlock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\text4_mb_unload_buddy(&e4b);\n\t\treturn;\n\t}\n\tif (pa->pa_type == MB_INODE_PA)\n\t\tpa->pa_free += ac->ac_b_ex.fe_len;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_discard_allocated_blocks(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (pa == NULL) {\n\t\tif (ac->ac_f_ex.fe_len == 0)\n\t\t\treturn;\n\t\terr = ext4_mb_load_buddy(ac->ac_sb, ac->ac_f_ex.fe_group, &e4b);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * This should never happen since we pin the\n\t\t\t * pages in the ext4_allocation_context so\n\t\t\t * ext4_mb_load_buddy() should never fail.\n\t\t\t */\n\t\t\tWARN(1, \"mb_load_buddy failed (%d)\", err);\n\t\t\treturn;\n\t\t}\n\t\text4_lock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\tmb_free_blocks(ac->ac_inode, &e4b, ac->ac_f_ex.fe_start,\n\t\t\t       ac->ac_f_ex.fe_len);\n\t\text4_unlock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\text4_mb_unload_buddy(&e4b);\n\t\treturn;\n\t}\n\tif (pa->pa_type == MB_INODE_PA)\n\t\tpa->pa_free += ac->ac_b_ex.fe_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_mark_diskspace_used",
          "args": [
            "ac",
            "handle",
            "reserv_clstrs"
          ],
          "line": 4483
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_mark_diskspace_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2865-2974",
          "snippet": "static noinline_for_stack int\next4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,\n\t\t\t\thandle_t *handle, unsigned int reserv_clstrs)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block;\n\tint err, len;\n\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(ac->ac_b_ex.fe_len <= 0);\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\n\terr = -EIO;\n\tbitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);\n\tif (!bitmap_bh)\n\t\tgoto out_err;\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tgdp = ext4_get_group_desc(sb, ac->ac_b_ex.fe_group, &gdp_bh);\n\tif (!gdp)\n\t\tgoto out_err;\n\n\text4_debug(\"using block group %u(%d)\\n\", ac->ac_b_ex.fe_group,\n\t\t\text4_free_group_clusters(sb, gdp));\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\n\tlen = EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\tif (!ext4_data_block_valid(sbi, block, len)) {\n\t\text4_error(sb, \"Allocating blocks %llu-%llu which overlap \"\n\t\t\t   \"fs metadata\", block, block+len);\n\t\t/* File system mounted not to panic on error\n\t\t * Fix the bitmap and repeat the block allocation\n\t\t * We leak some of the blocks here.\n\t\t */\n\t\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\t\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t\t      ac->ac_b_ex.fe_len);\n\t\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!err)\n\t\t\terr = -EAGAIN;\n\t\tgoto out_err;\n\t}\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < ac->ac_b_ex.fe_len; i++) {\n\t\t\tBUG_ON(mb_test_bit(ac->ac_b_ex.fe_start + i,\n\t\t\t\t\t\tbitmap_bh->b_data));\n\t\t}\n\t}\n#endif\n\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t      ac->ac_b_ex.fe_len);\n\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     ext4_free_clusters_after_init(sb,\n\t\t\t\t\t\tac->ac_b_ex.fe_group, gdp));\n\t}\n\tlen = ext4_free_group_clusters(sb, gdp) - ac->ac_b_ex.fe_len;\n\text4_free_group_clusters_set(sb, gdp, len);\n\text4_block_bitmap_csum_set(sb, ac->ac_b_ex.fe_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, ac->ac_b_ex.fe_group, gdp);\n\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\tpercpu_counter_sub(&sbi->s_freeclusters_counter, ac->ac_b_ex.fe_len);\n\t/*\n\t * Now reduce the dirty block count also. Should not go negative\n\t */\n\tif (!(ac->ac_flags & EXT4_MB_DELALLOC_RESERVED))\n\t\t/* release all the reserved blocks if non delalloc */\n\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t   reserv_clstrs);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi,\n\t\t\t\t\t\t\t  ac->ac_b_ex.fe_group);\n\t\tatomic64_sub(ac->ac_b_ex.fe_len,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);\n\nout_err:\n\tbrelse(bitmap_bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,\n\t\t\t\thandle_t *handle, unsigned int reserv_clstrs)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block;\n\tint err, len;\n\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(ac->ac_b_ex.fe_len <= 0);\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\n\terr = -EIO;\n\tbitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);\n\tif (!bitmap_bh)\n\t\tgoto out_err;\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tgdp = ext4_get_group_desc(sb, ac->ac_b_ex.fe_group, &gdp_bh);\n\tif (!gdp)\n\t\tgoto out_err;\n\n\text4_debug(\"using block group %u(%d)\\n\", ac->ac_b_ex.fe_group,\n\t\t\text4_free_group_clusters(sb, gdp));\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\n\tlen = EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\tif (!ext4_data_block_valid(sbi, block, len)) {\n\t\text4_error(sb, \"Allocating blocks %llu-%llu which overlap \"\n\t\t\t   \"fs metadata\", block, block+len);\n\t\t/* File system mounted not to panic on error\n\t\t * Fix the bitmap and repeat the block allocation\n\t\t * We leak some of the blocks here.\n\t\t */\n\t\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\t\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t\t      ac->ac_b_ex.fe_len);\n\t\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!err)\n\t\t\terr = -EAGAIN;\n\t\tgoto out_err;\n\t}\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < ac->ac_b_ex.fe_len; i++) {\n\t\t\tBUG_ON(mb_test_bit(ac->ac_b_ex.fe_start + i,\n\t\t\t\t\t\tbitmap_bh->b_data));\n\t\t}\n\t}\n#endif\n\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t      ac->ac_b_ex.fe_len);\n\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     ext4_free_clusters_after_init(sb,\n\t\t\t\t\t\tac->ac_b_ex.fe_group, gdp));\n\t}\n\tlen = ext4_free_group_clusters(sb, gdp) - ac->ac_b_ex.fe_len;\n\text4_free_group_clusters_set(sb, gdp, len);\n\text4_block_bitmap_csum_set(sb, ac->ac_b_ex.fe_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, ac->ac_b_ex.fe_group, gdp);\n\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\tpercpu_counter_sub(&sbi->s_freeclusters_counter, ac->ac_b_ex.fe_len);\n\t/*\n\t * Now reduce the dirty block count also. Should not go negative\n\t */\n\tif (!(ac->ac_flags & EXT4_MB_DELALLOC_RESERVED))\n\t\t/* release all the reserved blocks if non delalloc */\n\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t   reserv_clstrs);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi,\n\t\t\t\t\t\t\t  ac->ac_b_ex.fe_group);\n\t\tatomic64_sub(ac->ac_b_ex.fe_len,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);\n\nout_err:\n\tbrelse(bitmap_bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ac->ac_status == AC_STATUS_FOUND"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_new_preallocation",
          "args": [
            "ac"
          ],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_new_preallocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3709-3718",
          "snippet": "static int ext4_mb_new_preallocation(struct ext4_allocation_context *ac)\n{\n\tint err;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\terr = ext4_mb_new_group_pa(ac);\n\telse\n\t\terr = ext4_mb_new_inode_pa(ac);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_new_preallocation(struct ext4_allocation_context *ac)\n{\n\tint err;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\terr = ext4_mb_new_group_pa(ac);\n\telse\n\t\terr = ext4_mb_new_inode_pa(ac);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_regular_allocator",
          "args": [
            "ac"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_regular_allocator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2076-2220",
          "snippet": "static noinline_for_stack int\next4_mb_regular_allocator(struct ext4_allocation_context *ac)\n{\n\text4_group_t ngroups, group, i;\n\tint cr;\n\tint err = 0;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\tstruct ext4_buddy e4b;\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\tngroups = ext4_get_groups_count(sb);\n\t/* non-extent files are limited to low blocks/groups */\n\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)))\n\t\tngroups = sbi->s_blockfile_groups;\n\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\t/* first, try the goal */\n\terr = ext4_mb_find_by_goal(ac, &e4b);\n\tif (err || ac->ac_status == AC_STATUS_FOUND)\n\t\tgoto out;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\tgoto out;\n\n\t/*\n\t * ac->ac2_order is set only if the fe_len is a power of 2\n\t * if ac2_order is set we also set criteria to 0 so that we\n\t * try exact allocation using buddy.\n\t */\n\ti = fls(ac->ac_g_ex.fe_len);\n\tac->ac_2order = 0;\n\t/*\n\t * We search using buddy data only if the order of the request\n\t * is greater than equal to the sbi_s_mb_order2_reqs\n\t * You can tune it via /sys/fs/ext4/<partition>/mb_order2_req\n\t */\n\tif (i >= sbi->s_mb_order2_reqs) {\n\t\t/*\n\t\t * This should tell if fe_len is exactly power of 2\n\t\t */\n\t\tif ((ac->ac_g_ex.fe_len & (~(1 << (i - 1)))) == 0)\n\t\t\tac->ac_2order = i - 1;\n\t}\n\n\t/* if stream allocation is enabled, use global goal */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\t/* TBD: may be hot point */\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tac->ac_g_ex.fe_group = sbi->s_mb_last_group;\n\t\tac->ac_g_ex.fe_start = sbi->s_mb_last_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n\n\t/* Let's just scan groups to find more-less suitable blocks */\n\tcr = ac->ac_2order ? 0 : 1;\n\t/*\n\t * cr == 0 try to get exact allocation,\n\t * cr == 3  try to get anything\n\t */\nrepeat:\n\tfor (; cr < 4 && ac->ac_status == AC_STATUS_CONTINUE; cr++) {\n\t\tac->ac_criteria = cr;\n\t\t/*\n\t\t * searching for the right group start\n\t\t * from the goal value specified\n\t\t */\n\t\tgroup = ac->ac_g_ex.fe_group;\n\n\t\tfor (i = 0; i < ngroups; group++, i++) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Artificially restricted ngroups for non-extent\n\t\t\t * files makes group > ngroups possible on first loop.\n\t\t\t */\n\t\t\tif (group >= ngroups)\n\t\t\t\tgroup = 0;\n\n\t\t\t/* This now checks without needing the buddy page */\n\t\t\tif (!ext4_mb_good_group(ac, group, cr))\n\t\t\t\tcontinue;\n\n\t\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\text4_lock_group(sb, group);\n\n\t\t\t/*\n\t\t\t * We need to check again after locking the\n\t\t\t * block group\n\t\t\t */\n\t\t\tif (!ext4_mb_good_group(ac, group, cr)) {\n\t\t\t\text4_unlock_group(sb, group);\n\t\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tac->ac_groups_scanned++;\n\t\t\tif (cr == 0 && ac->ac_2order < sb->s_blocksize_bits+2)\n\t\t\t\text4_mb_simple_scan_group(ac, &e4b);\n\t\t\telse if (cr == 1 && sbi->s_stripe &&\n\t\t\t\t\t!(ac->ac_g_ex.fe_len % sbi->s_stripe))\n\t\t\t\text4_mb_scan_aligned(ac, &e4b);\n\t\t\telse\n\t\t\t\text4_mb_complex_scan_group(ac, &e4b);\n\n\t\t\text4_unlock_group(sb, group);\n\t\t\text4_mb_unload_buddy(&e4b);\n\n\t\t\tif (ac->ac_status != AC_STATUS_CONTINUE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ac->ac_b_ex.fe_len > 0 && ac->ac_status != AC_STATUS_FOUND &&\n\t    !(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t/*\n\t\t * We've been searching too long. Let's try to allocate\n\t\t * the best chunk we've found so far\n\t\t */\n\n\t\text4_mb_try_best_found(ac, &e4b);\n\t\tif (ac->ac_status != AC_STATUS_FOUND) {\n\t\t\t/*\n\t\t\t * Someone more lucky has already allocated it.\n\t\t\t * The only thing we can do is just take first\n\t\t\t * found block(s)\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: someone won our chunk\\n\");\n\t\t\t */\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tac->ac_flags |= EXT4_MB_HINT_FIRST;\n\t\t\tcr = 3;\n\t\t\tatomic_inc(&sbi->s_mb_lost_chunks);\n\t\t\tgoto repeat;\n\t\t}\n\t}\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_regular_allocator(struct ext4_allocation_context *ac)\n{\n\text4_group_t ngroups, group, i;\n\tint cr;\n\tint err = 0;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\tstruct ext4_buddy e4b;\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\tngroups = ext4_get_groups_count(sb);\n\t/* non-extent files are limited to low blocks/groups */\n\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)))\n\t\tngroups = sbi->s_blockfile_groups;\n\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\t/* first, try the goal */\n\terr = ext4_mb_find_by_goal(ac, &e4b);\n\tif (err || ac->ac_status == AC_STATUS_FOUND)\n\t\tgoto out;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\tgoto out;\n\n\t/*\n\t * ac->ac2_order is set only if the fe_len is a power of 2\n\t * if ac2_order is set we also set criteria to 0 so that we\n\t * try exact allocation using buddy.\n\t */\n\ti = fls(ac->ac_g_ex.fe_len);\n\tac->ac_2order = 0;\n\t/*\n\t * We search using buddy data only if the order of the request\n\t * is greater than equal to the sbi_s_mb_order2_reqs\n\t * You can tune it via /sys/fs/ext4/<partition>/mb_order2_req\n\t */\n\tif (i >= sbi->s_mb_order2_reqs) {\n\t\t/*\n\t\t * This should tell if fe_len is exactly power of 2\n\t\t */\n\t\tif ((ac->ac_g_ex.fe_len & (~(1 << (i - 1)))) == 0)\n\t\t\tac->ac_2order = i - 1;\n\t}\n\n\t/* if stream allocation is enabled, use global goal */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\t/* TBD: may be hot point */\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tac->ac_g_ex.fe_group = sbi->s_mb_last_group;\n\t\tac->ac_g_ex.fe_start = sbi->s_mb_last_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n\n\t/* Let's just scan groups to find more-less suitable blocks */\n\tcr = ac->ac_2order ? 0 : 1;\n\t/*\n\t * cr == 0 try to get exact allocation,\n\t * cr == 3  try to get anything\n\t */\nrepeat:\n\tfor (; cr < 4 && ac->ac_status == AC_STATUS_CONTINUE; cr++) {\n\t\tac->ac_criteria = cr;\n\t\t/*\n\t\t * searching for the right group start\n\t\t * from the goal value specified\n\t\t */\n\t\tgroup = ac->ac_g_ex.fe_group;\n\n\t\tfor (i = 0; i < ngroups; group++, i++) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Artificially restricted ngroups for non-extent\n\t\t\t * files makes group > ngroups possible on first loop.\n\t\t\t */\n\t\t\tif (group >= ngroups)\n\t\t\t\tgroup = 0;\n\n\t\t\t/* This now checks without needing the buddy page */\n\t\t\tif (!ext4_mb_good_group(ac, group, cr))\n\t\t\t\tcontinue;\n\n\t\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\text4_lock_group(sb, group);\n\n\t\t\t/*\n\t\t\t * We need to check again after locking the\n\t\t\t * block group\n\t\t\t */\n\t\t\tif (!ext4_mb_good_group(ac, group, cr)) {\n\t\t\t\text4_unlock_group(sb, group);\n\t\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tac->ac_groups_scanned++;\n\t\t\tif (cr == 0 && ac->ac_2order < sb->s_blocksize_bits+2)\n\t\t\t\text4_mb_simple_scan_group(ac, &e4b);\n\t\t\telse if (cr == 1 && sbi->s_stripe &&\n\t\t\t\t\t!(ac->ac_g_ex.fe_len % sbi->s_stripe))\n\t\t\t\text4_mb_scan_aligned(ac, &e4b);\n\t\t\telse\n\t\t\t\text4_mb_complex_scan_group(ac, &e4b);\n\n\t\t\text4_unlock_group(sb, group);\n\t\t\text4_mb_unload_buddy(&e4b);\n\n\t\t\tif (ac->ac_status != AC_STATUS_CONTINUE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ac->ac_b_ex.fe_len > 0 && ac->ac_status != AC_STATUS_FOUND &&\n\t    !(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t/*\n\t\t * We've been searching too long. Let's try to allocate\n\t\t * the best chunk we've found so far\n\t\t */\n\n\t\text4_mb_try_best_found(ac, &e4b);\n\t\tif (ac->ac_status != AC_STATUS_FOUND) {\n\t\t\t/*\n\t\t\t * Someone more lucky has already allocated it.\n\t\t\t * The only thing we can do is just take first\n\t\t\t * found block(s)\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: someone won our chunk\\n\");\n\t\t\t */\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tac->ac_flags |= EXT4_MB_HINT_FIRST;\n\t\t\tcr = 3;\n\t\t\tatomic_inc(&sbi->s_mb_lost_chunks);\n\t\t\tgoto repeat;\n\t\t}\n\t}\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_normalize_request",
          "args": [
            "ac",
            "ar"
          ],
          "line": 4463
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_normalize_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3000-3186",
          "snippet": "static noinline_for_stack void\next4_mb_normalize_request(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits, max;\n\text4_lblk_t end;\n\tloff_t size, start_off;\n\tloff_t orig_size __maybe_unused;\n\text4_lblk_t start;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_prealloc_space *pa;\n\n\t/* do normalize only data requests, metadata requests\n\t   do not need preallocation */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\t/* sometime caller may want exact blocks */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\t/* caller may indicate that preallocation isn't\n\t * required (it's a tail, for example) */\n\tif (ac->ac_flags & EXT4_MB_HINT_NOPREALLOC)\n\t\treturn;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC) {\n\t\text4_mb_normalize_group_request(ac);\n\t\treturn ;\n\t}\n\n\tbsbits = ac->ac_sb->s_blocksize_bits;\n\n\t/* first, let's learn actual file size\n\t * given current request is allocated */\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tsize = size << bsbits;\n\tif (size < i_size_read(ac->ac_inode))\n\t\tsize = i_size_read(ac->ac_inode);\n\torig_size = size;\n\n\t/* max size of free chunks */\n\tmax = 2 << bsbits;\n\n#define NRL_CHECK_SIZE(req, size, max, chunk_size)\t\\\n\t\t(req <= (size) || max <= (chunk_size))\n\n\t/* first, try to predict filesize */\n\t/* XXX: should this table be tunable? */\n\tstart_off = 0;\n\tif (size <= 16 * 1024) {\n\t\tsize = 16 * 1024;\n\t} else if (size <= 32 * 1024) {\n\t\tsize = 32 * 1024;\n\t} else if (size <= 64 * 1024) {\n\t\tsize = 64 * 1024;\n\t} else if (size <= 128 * 1024) {\n\t\tsize = 128 * 1024;\n\t} else if (size <= 256 * 1024) {\n\t\tsize = 256 * 1024;\n\t} else if (size <= 512 * 1024) {\n\t\tsize = 512 * 1024;\n\t} else if (size <= 1024 * 1024) {\n\t\tsize = 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 4 * 1024 * 1024, max, 2 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t(21 - bsbits)) << 21;\n\t\tsize = 2 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 8 * 1024 * 1024, max, 4 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(22 - bsbits)) << 22;\n\t\tsize = 4 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(ac->ac_o_ex.fe_len,\n\t\t\t\t\t(8<<20)>>bsbits, max, 8 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(23 - bsbits)) << 23;\n\t\tsize = 8 * 1024 * 1024;\n\t} else {\n\t\tstart_off = (loff_t) ac->ac_o_ex.fe_logical << bsbits;\n\t\tsize\t  = (loff_t) EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t      ac->ac_o_ex.fe_len) << bsbits;\n\t}\n\tsize = size >> bsbits;\n\tstart = start_off >> bsbits;\n\n\t/* don't cover already allocated blocks in selected range */\n\tif (ar->pleft && start <= ar->lleft) {\n\t\tsize -= ar->lleft + 1 - start;\n\t\tstart = ar->lleft + 1;\n\t}\n\tif (ar->pright && start + size - 1 >= ar->lright)\n\t\tsize -= start + size - ar->lright;\n\n\tend = start + size;\n\n\t/* check we don't cross already preallocated blocks */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tif (pa->pa_deleted)\n\t\t\tcontinue;\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t  pa->pa_len);\n\n\t\t/* PA must not overlap original request */\n\t\tBUG_ON(!(ac->ac_o_ex.fe_logical >= pa_end ||\n\t\t\tac->ac_o_ex.fe_logical < pa->pa_lstart));\n\n\t\t/* skip PAs this normalized request doesn't overlap with */\n\t\tif (pa->pa_lstart >= end || pa_end <= start) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tBUG_ON(pa->pa_lstart <= start && pa_end >= end);\n\n\t\t/* adjust start or end to be adjacent to this pa */\n\t\tif (pa_end <= ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa_end < start);\n\t\t\tstart = pa_end;\n\t\t} else if (pa->pa_lstart > ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa->pa_lstart > end);\n\t\t\tend = pa->pa_lstart;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\tsize = end - start;\n\n\t/* XXX: extra loop to check we really don't overlap preallocations */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t\t  pa->pa_len);\n\t\t\tBUG_ON(!(start >= pa_end || end <= pa->pa_lstart));\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\tif (start + size <= ac->ac_o_ex.fe_logical &&\n\t\t\tstart > ac->ac_o_ex.fe_logical) {\n\t\text4_msg(ac->ac_sb, KERN_ERR,\n\t\t\t \"start %lu, size %lu, fe_logical %lu\",\n\t\t\t (unsigned long) start, (unsigned long) size,\n\t\t\t (unsigned long) ac->ac_o_ex.fe_logical);\n\t\tBUG();\n\t}\n\tBUG_ON(size <= 0 || size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb));\n\n\t/* now prepare goal request */\n\n\t/* XXX: is it better to align blocks WRT to logical\n\t * placement or satisfy big request as is */\n\tac->ac_g_ex.fe_logical = start;\n\tac->ac_g_ex.fe_len = EXT4_NUM_B2C(sbi, size);\n\n\t/* define goal start in order to merge */\n\tif (ar->pright && (ar->lright == (start + size))) {\n\t\t/* merge to the right */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pright - size,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\tif (ar->pleft && (ar->lleft + 1 == start)) {\n\t\t/* merge to the left */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pleft + 1,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\n\tmb_debug(1, \"goal: %u(was %u) blocks at %u\\n\", (unsigned) size,\n\t\t(unsigned) orig_size, (unsigned) start);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic noinline_for_stack void\next4_mb_normalize_request(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits, max;\n\text4_lblk_t end;\n\tloff_t size, start_off;\n\tloff_t orig_size __maybe_unused;\n\text4_lblk_t start;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_prealloc_space *pa;\n\n\t/* do normalize only data requests, metadata requests\n\t   do not need preallocation */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\t/* sometime caller may want exact blocks */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\t/* caller may indicate that preallocation isn't\n\t * required (it's a tail, for example) */\n\tif (ac->ac_flags & EXT4_MB_HINT_NOPREALLOC)\n\t\treturn;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC) {\n\t\text4_mb_normalize_group_request(ac);\n\t\treturn ;\n\t}\n\n\tbsbits = ac->ac_sb->s_blocksize_bits;\n\n\t/* first, let's learn actual file size\n\t * given current request is allocated */\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tsize = size << bsbits;\n\tif (size < i_size_read(ac->ac_inode))\n\t\tsize = i_size_read(ac->ac_inode);\n\torig_size = size;\n\n\t/* max size of free chunks */\n\tmax = 2 << bsbits;\n\n#define NRL_CHECK_SIZE(req, size, max, chunk_size)\t\\\n\t\t(req <= (size) || max <= (chunk_size))\n\n\t/* first, try to predict filesize */\n\t/* XXX: should this table be tunable? */\n\tstart_off = 0;\n\tif (size <= 16 * 1024) {\n\t\tsize = 16 * 1024;\n\t} else if (size <= 32 * 1024) {\n\t\tsize = 32 * 1024;\n\t} else if (size <= 64 * 1024) {\n\t\tsize = 64 * 1024;\n\t} else if (size <= 128 * 1024) {\n\t\tsize = 128 * 1024;\n\t} else if (size <= 256 * 1024) {\n\t\tsize = 256 * 1024;\n\t} else if (size <= 512 * 1024) {\n\t\tsize = 512 * 1024;\n\t} else if (size <= 1024 * 1024) {\n\t\tsize = 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 4 * 1024 * 1024, max, 2 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t(21 - bsbits)) << 21;\n\t\tsize = 2 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 8 * 1024 * 1024, max, 4 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(22 - bsbits)) << 22;\n\t\tsize = 4 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(ac->ac_o_ex.fe_len,\n\t\t\t\t\t(8<<20)>>bsbits, max, 8 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(23 - bsbits)) << 23;\n\t\tsize = 8 * 1024 * 1024;\n\t} else {\n\t\tstart_off = (loff_t) ac->ac_o_ex.fe_logical << bsbits;\n\t\tsize\t  = (loff_t) EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t      ac->ac_o_ex.fe_len) << bsbits;\n\t}\n\tsize = size >> bsbits;\n\tstart = start_off >> bsbits;\n\n\t/* don't cover already allocated blocks in selected range */\n\tif (ar->pleft && start <= ar->lleft) {\n\t\tsize -= ar->lleft + 1 - start;\n\t\tstart = ar->lleft + 1;\n\t}\n\tif (ar->pright && start + size - 1 >= ar->lright)\n\t\tsize -= start + size - ar->lright;\n\n\tend = start + size;\n\n\t/* check we don't cross already preallocated blocks */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tif (pa->pa_deleted)\n\t\t\tcontinue;\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t  pa->pa_len);\n\n\t\t/* PA must not overlap original request */\n\t\tBUG_ON(!(ac->ac_o_ex.fe_logical >= pa_end ||\n\t\t\tac->ac_o_ex.fe_logical < pa->pa_lstart));\n\n\t\t/* skip PAs this normalized request doesn't overlap with */\n\t\tif (pa->pa_lstart >= end || pa_end <= start) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tBUG_ON(pa->pa_lstart <= start && pa_end >= end);\n\n\t\t/* adjust start or end to be adjacent to this pa */\n\t\tif (pa_end <= ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa_end < start);\n\t\t\tstart = pa_end;\n\t\t} else if (pa->pa_lstart > ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa->pa_lstart > end);\n\t\t\tend = pa->pa_lstart;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\tsize = end - start;\n\n\t/* XXX: extra loop to check we really don't overlap preallocations */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t\t  pa->pa_len);\n\t\t\tBUG_ON(!(start >= pa_end || end <= pa->pa_lstart));\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\tif (start + size <= ac->ac_o_ex.fe_logical &&\n\t\t\tstart > ac->ac_o_ex.fe_logical) {\n\t\text4_msg(ac->ac_sb, KERN_ERR,\n\t\t\t \"start %lu, size %lu, fe_logical %lu\",\n\t\t\t (unsigned long) start, (unsigned long) size,\n\t\t\t (unsigned long) ac->ac_o_ex.fe_logical);\n\t\tBUG();\n\t}\n\tBUG_ON(size <= 0 || size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb));\n\n\t/* now prepare goal request */\n\n\t/* XXX: is it better to align blocks WRT to logical\n\t * placement or satisfy big request as is */\n\tac->ac_g_ex.fe_logical = start;\n\tac->ac_g_ex.fe_len = EXT4_NUM_B2C(sbi, size);\n\n\t/* define goal start in order to merge */\n\tif (ar->pright && (ar->lright == (start + size))) {\n\t\t/* merge to the right */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pright - size,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\tif (ar->pleft && (ar->lleft + 1 == start)) {\n\t\t/* merge to the left */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pleft + 1,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\n\tmb_debug(1, \"goal: %u(was %u) blocks at %u\\n\", (unsigned) size,\n\t\t(unsigned) orig_size, (unsigned) start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_use_preallocated",
          "args": [
            "ac"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_preallocated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3333-3417",
          "snippet": "static noinline_for_stack int\next4_mb_use_preallocated(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint order, i;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa, *cpa = NULL;\n\text4_fsblk_t goal_block;\n\n\t/* only data can be preallocated */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn 0;\n\n\t/* first, try per-file preallocation */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\n\t\t/* all fields in this condition don't change,\n\t\t * so we can skip locking for them */\n\t\tif (ac->ac_o_ex.fe_logical < pa->pa_lstart ||\n\t\t    ac->ac_o_ex.fe_logical >= (pa->pa_lstart +\n\t\t\t\t\t       EXT4_C2B(sbi, pa->pa_len)))\n\t\t\tcontinue;\n\n\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)) &&\n\t\t    (pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len) >\n\t\t     EXT4_MAX_BLOCK_FILE_PHYS))\n\t\t\tcontinue;\n\n\t\t/* found preallocated blocks, use them */\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0 && pa->pa_free) {\n\t\t\tatomic_inc(&pa->pa_count);\n\t\t\text4_mb_use_inode_pa(ac, pa);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tac->ac_criteria = 10;\n\t\t\trcu_read_unlock();\n\t\t\treturn 1;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\t/* can we use group allocation? */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC))\n\t\treturn 0;\n\n\t/* inode may have no locality group for some reason */\n\tlg = ac->ac_lg;\n\tif (lg == NULL)\n\t\treturn 0;\n\torder  = fls(ac->ac_o_ex.fe_len) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\n\tgoal_block = ext4_grp_offs_to_block(ac->ac_sb, &ac->ac_g_ex);\n\t/*\n\t * search for the prealloc space that is having\n\t * minimal distance from the goal block.\n\t */\n\tfor (i = order; i < PREALLOC_TB_SIZE; i++) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[i],\n\t\t\t\t\tpa_inode_list) {\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tif (pa->pa_deleted == 0 &&\n\t\t\t\t\tpa->pa_free >= ac->ac_o_ex.fe_len) {\n\n\t\t\t\tcpa = ext4_mb_check_group_pa(goal_block,\n\t\t\t\t\t\t\t\tpa, cpa);\n\t\t\t}\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (cpa) {\n\t\text4_mb_use_group_pa(ac, cpa);\n\t\tac->ac_criteria = 20;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_use_preallocated(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint order, i;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa, *cpa = NULL;\n\text4_fsblk_t goal_block;\n\n\t/* only data can be preallocated */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn 0;\n\n\t/* first, try per-file preallocation */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\n\t\t/* all fields in this condition don't change,\n\t\t * so we can skip locking for them */\n\t\tif (ac->ac_o_ex.fe_logical < pa->pa_lstart ||\n\t\t    ac->ac_o_ex.fe_logical >= (pa->pa_lstart +\n\t\t\t\t\t       EXT4_C2B(sbi, pa->pa_len)))\n\t\t\tcontinue;\n\n\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)) &&\n\t\t    (pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len) >\n\t\t     EXT4_MAX_BLOCK_FILE_PHYS))\n\t\t\tcontinue;\n\n\t\t/* found preallocated blocks, use them */\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0 && pa->pa_free) {\n\t\t\tatomic_inc(&pa->pa_count);\n\t\t\text4_mb_use_inode_pa(ac, pa);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tac->ac_criteria = 10;\n\t\t\trcu_read_unlock();\n\t\t\treturn 1;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\t/* can we use group allocation? */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC))\n\t\treturn 0;\n\n\t/* inode may have no locality group for some reason */\n\tlg = ac->ac_lg;\n\tif (lg == NULL)\n\t\treturn 0;\n\torder  = fls(ac->ac_o_ex.fe_len) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\n\tgoal_block = ext4_grp_offs_to_block(ac->ac_sb, &ac->ac_g_ex);\n\t/*\n\t * search for the prealloc space that is having\n\t * minimal distance from the goal block.\n\t */\n\tfor (i = order; i < PREALLOC_TB_SIZE; i++) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[i],\n\t\t\t\t\tpa_inode_list) {\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tif (pa->pa_deleted == 0 &&\n\t\t\t\t\tpa->pa_free >= ac->ac_o_ex.fe_len) {\n\n\t\t\t\tcpa = ext4_mb_check_group_pa(goal_block,\n\t\t\t\t\t\t\t\tpa, cpa);\n\t\t\t}\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (cpa) {\n\t\text4_mb_use_group_pa(ac, cpa);\n\t\tac->ac_criteria = 20;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_initialize_context",
          "args": [
            "ac",
            "ar"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_initialize_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4144-4195",
          "snippet": "static noinline_for_stack int\next4_mb_initialize_context(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct super_block *sb = ar->inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t group;\n\tunsigned int len;\n\text4_fsblk_t goal;\n\text4_grpblk_t block;\n\n\t/* we can't allocate > group size */\n\tlen = ar->len;\n\n\t/* just a dirty hack to filter too big requests  */\n\tif (len >= EXT4_CLUSTERS_PER_GROUP(sb))\n\t\tlen = EXT4_CLUSTERS_PER_GROUP(sb);\n\n\t/* start searching from the goal */\n\tgoal = ar->goal;\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t\t\tgoal >= ext4_blocks_count(es))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\text4_get_group_no_and_offset(sb, goal, &group, &block);\n\n\t/* set up allocation goals */\n\tac->ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar->logical);\n\tac->ac_status = AC_STATUS_CONTINUE;\n\tac->ac_sb = sb;\n\tac->ac_inode = ar->inode;\n\tac->ac_o_ex.fe_logical = ac->ac_b_ex.fe_logical;\n\tac->ac_o_ex.fe_group = group;\n\tac->ac_o_ex.fe_start = block;\n\tac->ac_o_ex.fe_len = len;\n\tac->ac_g_ex = ac->ac_o_ex;\n\tac->ac_flags = ar->flags;\n\n\t/* we have to define context: we'll we work with a file or\n\t * locality group. this is a policy, actually */\n\text4_mb_group_or_file(ac);\n\n\tmb_debug(1, \"init ac: %u blocks @ %u, goal %u, flags %x, 2^%d, \"\n\t\t\t\"left: %u/%u, right %u/%u to %swritable\\n\",\n\t\t\t(unsigned) ar->len, (unsigned) ar->logical,\n\t\t\t(unsigned) ar->goal, ac->ac_flags, ac->ac_2order,\n\t\t\t(unsigned) ar->lleft, (unsigned) ar->pleft,\n\t\t\t(unsigned) ar->lright, (unsigned) ar->pright,\n\t\t\tatomic_read(&ar->inode->i_writecount) ? \"\" : \"non-\");\n\treturn 0;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_initialize_context(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct super_block *sb = ar->inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t group;\n\tunsigned int len;\n\text4_fsblk_t goal;\n\text4_grpblk_t block;\n\n\t/* we can't allocate > group size */\n\tlen = ar->len;\n\n\t/* just a dirty hack to filter too big requests  */\n\tif (len >= EXT4_CLUSTERS_PER_GROUP(sb))\n\t\tlen = EXT4_CLUSTERS_PER_GROUP(sb);\n\n\t/* start searching from the goal */\n\tgoal = ar->goal;\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t\t\tgoal >= ext4_blocks_count(es))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\text4_get_group_no_and_offset(sb, goal, &group, &block);\n\n\t/* set up allocation goals */\n\tac->ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar->logical);\n\tac->ac_status = AC_STATUS_CONTINUE;\n\tac->ac_sb = sb;\n\tac->ac_inode = ar->inode;\n\tac->ac_o_ex.fe_logical = ac->ac_b_ex.fe_logical;\n\tac->ac_o_ex.fe_group = group;\n\tac->ac_o_ex.fe_start = block;\n\tac->ac_o_ex.fe_len = len;\n\tac->ac_g_ex = ac->ac_o_ex;\n\tac->ac_flags = ar->flags;\n\n\t/* we have to define context: we'll we work with a file or\n\t * locality group. this is a policy, actually */\n\text4_mb_group_or_file(ac);\n\n\tmb_debug(1, \"init ac: %u blocks @ %u, goal %u, flags %x, 2^%d, \"\n\t\t\t\"left: %u/%u, right %u/%u to %swritable\\n\",\n\t\t\t(unsigned) ar->len, (unsigned) ar->logical,\n\t\t\t(unsigned) ar->goal, ac->ac_flags, ac->ac_2order,\n\t\t\t(unsigned) ar->lleft, (unsigned) ar->pleft,\n\t\t\t(unsigned) ar->lright, (unsigned) ar->pright,\n\t\t\tatomic_read(&ar->inode->i_writecount) ? \"\" : \"non-\");\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ext4_ac_cachep",
            "GFP_NOFS"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "ar->inode",
            "EXT4_C2B(sbi, ar->len)"
          ],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ar->len"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block_nofail",
          "args": [
            "ar->inode",
            "EXT4_C2B(sbi, ar->len)"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ar->len"
          ],
          "line": 4430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_claim_free_clusters",
          "args": [
            "sbi",
            "ar->len",
            "ar->flags"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_claim_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "576-584",
          "snippet": "int ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t     s64 nclusters, unsigned int flags)\n{\n\tif (ext4_has_free_clusters(sbi, nclusters, flags)) {\n\t\tpercpu_counter_add(&sbi->s_dirtyclusters_counter, nclusters);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOSPC;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_claim_free_clusters(struct ext4_sb_info *sbi,\n\t\t\t     s64 nclusters, unsigned int flags)\n{\n\tif (ext4_has_free_clusters(sbi, nclusters, flags)) {\n\t\tpercpu_counter_add(&sbi->s_dirtyclusters_counter, nclusters);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NOQUOTA",
          "args": [
            "ar->inode"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_request_blocks",
          "args": [
            "ar"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4403
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_ac_cachep;\n\next4_fsblk_t ext4_mb_new_blocks(handle_t *handle,\n\t\t\t\tstruct ext4_allocation_request *ar, int *errp)\n{\n\tint freed;\n\tstruct ext4_allocation_context *ac = NULL;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block = 0;\n\tunsigned int inquota = 0;\n\tunsigned int reserv_clstrs = 0;\n\n\tmight_sleep();\n\tsb = ar->inode->i_sb;\n\tsbi = EXT4_SB(sb);\n\n\ttrace_ext4_request_blocks(ar);\n\n\t/* Allow to use superuser reservation for quota file */\n\tif (IS_NOQUOTA(ar->inode))\n\t\tar->flags |= EXT4_MB_USE_ROOT_BLOCKS;\n\n\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0) {\n\t\t/* Without delayed allocation we need to verify\n\t\t * there is enough free blocks to do block allocation\n\t\t * and verify allocation doesn't exceed the quota limits.\n\t\t */\n\t\twhile (ar->len &&\n\t\t\text4_claim_free_clusters(sbi, ar->len, ar->flags)) {\n\n\t\t\t/* let others to free the space */\n\t\t\tcond_resched();\n\t\t\tar->len = ar->len >> 1;\n\t\t}\n\t\tif (!ar->len) {\n\t\t\t*errp = -ENOSPC;\n\t\t\treturn 0;\n\t\t}\n\t\treserv_clstrs = ar->len;\n\t\tif (ar->flags & EXT4_MB_USE_ROOT_BLOCKS) {\n\t\t\tdquot_alloc_block_nofail(ar->inode,\n\t\t\t\t\t\t EXT4_C2B(sbi, ar->len));\n\t\t} else {\n\t\t\twhile (ar->len &&\n\t\t\t\tdquot_alloc_block(ar->inode,\n\t\t\t\t\t\t  EXT4_C2B(sbi, ar->len))) {\n\n\t\t\t\tar->flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\t\t\tar->len--;\n\t\t\t}\n\t\t}\n\t\tinquota = ar->len;\n\t\tif (ar->len == 0) {\n\t\t\t*errp = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tac = kmem_cache_zalloc(ext4_ac_cachep, GFP_NOFS);\n\tif (!ac) {\n\t\tar->len = 0;\n\t\t*errp = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t*errp = ext4_mb_initialize_context(ac, ar);\n\tif (*errp) {\n\t\tar->len = 0;\n\t\tgoto out;\n\t}\n\n\tac->ac_op = EXT4_MB_HISTORY_PREALLOC;\n\tif (!ext4_mb_use_preallocated(ac)) {\n\t\tac->ac_op = EXT4_MB_HISTORY_ALLOC;\n\t\text4_mb_normalize_request(ac, ar);\nrepeat:\n\t\t/* allocate space in core */\n\t\t*errp = ext4_mb_regular_allocator(ac);\n\t\tif (*errp)\n\t\t\tgoto discard_and_exit;\n\n\t\t/* as we've just preallocated more space than\n\t\t * user requested originally, we store allocated\n\t\t * space in a special descriptor */\n\t\tif (ac->ac_status == AC_STATUS_FOUND &&\n\t\t    ac->ac_o_ex.fe_len < ac->ac_b_ex.fe_len)\n\t\t\t*errp = ext4_mb_new_preallocation(ac);\n\t\tif (*errp) {\n\t\tdiscard_and_exit:\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (likely(ac->ac_status == AC_STATUS_FOUND)) {\n\t\t*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);\n\t\tif (*errp == -EAGAIN) {\n\t\t\t/*\n\t\t\t * drop the reference that we took\n\t\t\t * in ext4_mb_use_best_found\n\t\t\t */\n\t\t\text4_mb_release_context(ac);\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tgoto repeat;\n\t\t} else if (*errp) {\n\t\t\text4_discard_allocated_blocks(ac);\n\t\t\tgoto errout;\n\t\t} else {\n\t\t\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\t\t\tar->len = ac->ac_b_ex.fe_len;\n\t\t}\n\t} else {\n\t\tfreed  = ext4_mb_discard_preallocations(sb, ac->ac_o_ex.fe_len);\n\t\tif (freed)\n\t\t\tgoto repeat;\n\t\t*errp = -ENOSPC;\n\t}\n\nerrout:\n\tif (*errp) {\n\t\tac->ac_b_ex.fe_len = 0;\n\t\tar->len = 0;\n\t\text4_mb_show_ac(ac);\n\t}\n\text4_mb_release_context(ac);\nout:\n\tif (ac)\n\t\tkmem_cache_free(ext4_ac_cachep, ac);\n\tif (inquota && ar->len < inquota)\n\t\tdquot_free_block(ar->inode, EXT4_C2B(sbi, inquota - ar->len));\n\tif (!ar->len) {\n\t\tif ((ar->flags & EXT4_MB_DELALLOC_RESERVED) == 0)\n\t\t\t/* release all the reserved blocks if non delalloc */\n\t\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t\t\treserv_clstrs);\n\t}\n\n\ttrace_ext4_allocate_blocks(ar, (unsigned long long)block);\n\n\treturn block;\n}"
  },
  {
    "function_name": "ext4_mb_discard_preallocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4369-4383",
    "snippet": "static int ext4_mb_discard_preallocations(struct super_block *sb, int needed)\n{\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\tint ret;\n\tint freed = 0;\n\n\ttrace_ext4_mb_discard_preallocations(sb, needed);\n\tfor (i = 0; i < ngroups && needed > 0; i++) {\n\t\tret = ext4_mb_discard_group_preallocations(sb, i, needed);\n\t\tfreed += ret;\n\t\tneeded -= ret;\n\t}\n\n\treturn freed;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_discard_group_preallocations",
          "args": [
            "sb",
            "i",
            "needed"
          ],
          "line": 4377
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_discard_group_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3811-3909",
          "snippet": "static noinline_for_stack int\next4_mb_discard_group_preallocations(struct super_block *sb,\n\t\t\t\t\text4_group_t group, int needed)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\tint busy = 0;\n\tint free = 0;\n\n\tmb_debug(1, \"discard preallocation for group %u\\n\", group);\n\n\tif (list_empty(&grp->bb_prealloc_list))\n\t\treturn 0;\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (bitmap_bh == NULL) {\n\t\text4_error(sb, \"Error reading block bitmap for %u\", group);\n\t\treturn 0;\n\t}\n\n\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (err) {\n\t\text4_error(sb, \"Error loading buddy information for %u\", group);\n\t\tput_bh(bitmap_bh);\n\t\treturn 0;\n\t}\n\n\tif (needed == 0)\n\t\tneeded = EXT4_CLUSTERS_PER_GROUP(sb) + 1;\n\n\tINIT_LIST_HEAD(&list);\nrepeat:\n\text4_lock_group(sb, group);\n\tlist_for_each_entry_safe(pa, tmp,\n\t\t\t\t&grp->bb_prealloc_list, pa_group_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* seems this one can be freed ... */\n\t\tpa->pa_deleted = 1;\n\n\t\t/* we can trust pa_free ... */\n\t\tfree += pa->pa_free;\n\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del(&pa->pa_group_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t}\n\n\t/* if we still need more blocks and some PAs were used, try again */\n\tif (free < needed && busy) {\n\t\tbusy = 0;\n\t\text4_unlock_group(sb, group);\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\n\t/* found anything to free? */\n\tif (list_empty(&list)) {\n\t\tBUG_ON(free != 0);\n\t\tgoto out;\n\t}\n\n\t/* now free all selected PAs */\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\n\t\t/* remove from object (inode or locality group) */\n\t\tspin_lock(pa->pa_obj_lock);\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tspin_unlock(pa->pa_obj_lock);\n\n\t\tif (pa->pa_type == MB_GROUP_PA)\n\t\t\text4_mb_release_group_pa(&e4b, pa);\n\t\telse\n\t\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\tput_bh(bitmap_bh);\n\treturn free;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_discard_group_preallocations(struct super_block *sb,\n\t\t\t\t\text4_group_t group, int needed)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\tint busy = 0;\n\tint free = 0;\n\n\tmb_debug(1, \"discard preallocation for group %u\\n\", group);\n\n\tif (list_empty(&grp->bb_prealloc_list))\n\t\treturn 0;\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (bitmap_bh == NULL) {\n\t\text4_error(sb, \"Error reading block bitmap for %u\", group);\n\t\treturn 0;\n\t}\n\n\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (err) {\n\t\text4_error(sb, \"Error loading buddy information for %u\", group);\n\t\tput_bh(bitmap_bh);\n\t\treturn 0;\n\t}\n\n\tif (needed == 0)\n\t\tneeded = EXT4_CLUSTERS_PER_GROUP(sb) + 1;\n\n\tINIT_LIST_HEAD(&list);\nrepeat:\n\text4_lock_group(sb, group);\n\tlist_for_each_entry_safe(pa, tmp,\n\t\t\t\t&grp->bb_prealloc_list, pa_group_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* seems this one can be freed ... */\n\t\tpa->pa_deleted = 1;\n\n\t\t/* we can trust pa_free ... */\n\t\tfree += pa->pa_free;\n\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del(&pa->pa_group_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t}\n\n\t/* if we still need more blocks and some PAs were used, try again */\n\tif (free < needed && busy) {\n\t\tbusy = 0;\n\t\text4_unlock_group(sb, group);\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\n\t/* found anything to free? */\n\tif (list_empty(&list)) {\n\t\tBUG_ON(free != 0);\n\t\tgoto out;\n\t}\n\n\t/* now free all selected PAs */\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\n\t\t/* remove from object (inode or locality group) */\n\t\tspin_lock(pa->pa_obj_lock);\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tspin_unlock(pa->pa_obj_lock);\n\n\t\tif (pa->pa_type == MB_GROUP_PA)\n\t\t\text4_mb_release_group_pa(&e4b, pa);\n\t\telse\n\t\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\tput_bh(bitmap_bh);\n\treturn free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_mb_discard_preallocations",
          "args": [
            "sb",
            "needed"
          ],
          "line": 4375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_discard_preallocations(struct super_block *sb, int needed)\n{\n\text4_group_t i, ngroups = ext4_get_groups_count(sb);\n\tint ret;\n\tint freed = 0;\n\n\ttrace_ext4_mb_discard_preallocations(sb, needed);\n\tfor (i = 0; i < ngroups && needed > 0; i++) {\n\t\tret = ext4_mb_discard_group_preallocations(sb, i, needed);\n\t\tfreed += ret;\n\t\tneeded -= ret;\n\t}\n\n\treturn freed;\n}"
  },
  {
    "function_name": "ext4_mb_release_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4329-4367",
    "snippet": "static int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t}\n\tif (pa) {\n\t\t/*\n\t\t * We want to add the pa to the right bucket.\n\t\t * Remove it from the list and while adding\n\t\t * make sure the list to which we are adding\n\t\t * doesn't grow big.\n\t\t */\n\t\tif ((pa->pa_type == MB_GROUP_PA) && likely(pa->pa_free)) {\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\text4_mb_add_n_trim(ac);\n\t\t}\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tpage_cache_release(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tpage_cache_release(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_collect_stats",
          "args": [
            "ac"
          ],
          "line": 4365
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_collect_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3188-3209",
          "snippet": "static void ext4_mb_collect_stats(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\n\tif (sbi->s_mb_stats && ac->ac_g_ex.fe_len > 1) {\n\t\tatomic_inc(&sbi->s_bal_reqs);\n\t\tatomic_add(ac->ac_b_ex.fe_len, &sbi->s_bal_allocated);\n\t\tif (ac->ac_b_ex.fe_len >= ac->ac_o_ex.fe_len)\n\t\t\tatomic_inc(&sbi->s_bal_success);\n\t\tatomic_add(ac->ac_found, &sbi->s_bal_ex_scanned);\n\t\tif (ac->ac_g_ex.fe_start == ac->ac_b_ex.fe_start &&\n\t\t\t\tac->ac_g_ex.fe_group == ac->ac_b_ex.fe_group)\n\t\t\tatomic_inc(&sbi->s_bal_goals);\n\t\tif (ac->ac_found > sbi->s_mb_max_to_scan)\n\t\t\tatomic_inc(&sbi->s_bal_breaks);\n\t}\n\n\tif (ac->ac_op == EXT4_MB_HISTORY_ALLOC)\n\t\ttrace_ext4_mballoc_alloc(ac);\n\telse\n\t\ttrace_ext4_mballoc_prealloc(ac);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_collect_stats(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\n\tif (sbi->s_mb_stats && ac->ac_g_ex.fe_len > 1) {\n\t\tatomic_inc(&sbi->s_bal_reqs);\n\t\tatomic_add(ac->ac_b_ex.fe_len, &sbi->s_bal_allocated);\n\t\tif (ac->ac_b_ex.fe_len >= ac->ac_o_ex.fe_len)\n\t\t\tatomic_inc(&sbi->s_bal_success);\n\t\tatomic_add(ac->ac_found, &sbi->s_bal_ex_scanned);\n\t\tif (ac->ac_g_ex.fe_start == ac->ac_b_ex.fe_start &&\n\t\t\t\tac->ac_g_ex.fe_group == ac->ac_b_ex.fe_group)\n\t\t\tatomic_inc(&sbi->s_bal_goals);\n\t\tif (ac->ac_found > sbi->s_mb_max_to_scan)\n\t\t\tatomic_inc(&sbi->s_bal_breaks);\n\t}\n\n\tif (ac->ac_op == EXT4_MB_HISTORY_ALLOC)\n\t\ttrace_ext4_mballoc_alloc(ac);\n\telse\n\t\ttrace_ext4_mballoc_prealloc(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ac->ac_lg->lg_mutex"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "ac->ac_buddy_page"
          ],
          "line": 4362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "ac->ac_bitmap_page"
          ],
          "line": 4360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_put_pa",
          "args": [
            "ac",
            "ac->ac_sb",
            "pa"
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_put_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3498-3552",
          "snippet": "static void ext4_mb_put_pa(struct ext4_allocation_context *ac,\n\t\t\tstruct super_block *sb, struct ext4_prealloc_space *pa)\n{\n\text4_group_t grp;\n\text4_fsblk_t grp_blk;\n\n\t/* in this short window concurrent discard can set pa_deleted */\n\tspin_lock(&pa->pa_lock);\n\tif (!atomic_dec_and_test(&pa->pa_count) || pa->pa_free != 0) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tif (pa->pa_deleted == 1) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tpa->pa_deleted = 1;\n\tspin_unlock(&pa->pa_lock);\n\n\tgrp_blk = pa->pa_pstart;\n\t/*\n\t * If doing group-based preallocation, pa_pstart may be in the\n\t * next group when pa is used up\n\t */\n\tif (pa->pa_type == MB_GROUP_PA)\n\t\tgrp_blk--;\n\n\tgrp = ext4_get_group_number(sb, grp_blk);\n\n\t/*\n\t * possible race:\n\t *\n\t *  P1 (buddy init)\t\t\tP2 (regular allocation)\n\t *\t\t\t\t\tfind block B in PA\n\t *  copy on-disk bitmap to buddy\n\t *  \t\t\t\t\tmark B in on-disk bitmap\n\t *\t\t\t\t\tdrop PA from group\n\t *  mark all PAs in buddy\n\t *\n\t * thus, P1 initializes buddy with B available. to prevent this\n\t * we make \"copy\" and \"mark all PAs\" atomic and serialize \"drop PA\"\n\t * against that pair\n\t */\n\text4_lock_group(sb, grp);\n\tlist_del(&pa->pa_group_list);\n\text4_unlock_group(sb, grp);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_del_rcu(&pa->pa_inode_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_put_pa(struct ext4_allocation_context *ac,\n\t\t\tstruct super_block *sb, struct ext4_prealloc_space *pa)\n{\n\text4_group_t grp;\n\text4_fsblk_t grp_blk;\n\n\t/* in this short window concurrent discard can set pa_deleted */\n\tspin_lock(&pa->pa_lock);\n\tif (!atomic_dec_and_test(&pa->pa_count) || pa->pa_free != 0) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tif (pa->pa_deleted == 1) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tpa->pa_deleted = 1;\n\tspin_unlock(&pa->pa_lock);\n\n\tgrp_blk = pa->pa_pstart;\n\t/*\n\t * If doing group-based preallocation, pa_pstart may be in the\n\t * next group when pa is used up\n\t */\n\tif (pa->pa_type == MB_GROUP_PA)\n\t\tgrp_blk--;\n\n\tgrp = ext4_get_group_number(sb, grp_blk);\n\n\t/*\n\t * possible race:\n\t *\n\t *  P1 (buddy init)\t\t\tP2 (regular allocation)\n\t *\t\t\t\t\tfind block B in PA\n\t *  copy on-disk bitmap to buddy\n\t *  \t\t\t\t\tmark B in on-disk bitmap\n\t *\t\t\t\t\tdrop PA from group\n\t *  mark all PAs in buddy\n\t *\n\t * thus, P1 initializes buddy with B available. to prevent this\n\t * we make \"copy\" and \"mark all PAs\" atomic and serialize \"drop PA\"\n\t * against that pair\n\t */\n\text4_lock_group(sb, grp);\n\tlist_del(&pa->pa_group_list);\n\text4_unlock_group(sb, grp);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_del_rcu(&pa->pa_inode_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_add_n_trim",
          "args": [
            "ac"
          ],
          "line": 4355
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_add_n_trim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4279-4324",
          "snippet": "static void ext4_mb_add_n_trim(struct ext4_allocation_context *ac)\n{\n\tint order, added = 0, lg_prealloc_count = 1;\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\tstruct ext4_prealloc_space *tmp_pa, *pa = ac->ac_pa;\n\n\torder = fls(pa->pa_free) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\t/* Add the prealloc space to lg */\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(tmp_pa, &lg->lg_prealloc_list[order],\n\t\t\t\t\t\tpa_inode_list) {\n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted) {\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!added && pa->pa_free < tmp_pa->pa_free) {\n\t\t\t/* Add to the tail of the previous entry */\n\t\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t\t&tmp_pa->pa_inode_list);\n\t\t\tadded = 1;\n\t\t\t/*\n\t\t\t * we want to count the total\n\t\t\t * number of entries in the list\n\t\t\t */\n\t\t}\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tlg_prealloc_count++;\n\t}\n\tif (!added)\n\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t&lg->lg_prealloc_list[order]);\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\t/* Now trim the list to be not more than 8 elements */\n\tif (lg_prealloc_count > 8) {\n\t\text4_mb_discard_lg_preallocations(sb, lg,\n\t\t\t\t\t\t  order, lg_prealloc_count);\n\t\treturn;\n\t}\n\treturn ;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_add_n_trim(struct ext4_allocation_context *ac)\n{\n\tint order, added = 0, lg_prealloc_count = 1;\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\tstruct ext4_prealloc_space *tmp_pa, *pa = ac->ac_pa;\n\n\torder = fls(pa->pa_free) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\t/* Add the prealloc space to lg */\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(tmp_pa, &lg->lg_prealloc_list[order],\n\t\t\t\t\t\tpa_inode_list) {\n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted) {\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!added && pa->pa_free < tmp_pa->pa_free) {\n\t\t\t/* Add to the tail of the previous entry */\n\t\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t\t&tmp_pa->pa_inode_list);\n\t\t\tadded = 1;\n\t\t\t/*\n\t\t\t * we want to count the total\n\t\t\t * number of entries in the list\n\t\t\t */\n\t\t}\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tlg_prealloc_count++;\n\t}\n\tif (!added)\n\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t&lg->lg_prealloc_list[order]);\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\t/* Now trim the list to be not more than 8 elements */\n\tif (lg_prealloc_count > 8) {\n\t\text4_mb_discard_lg_preallocations(sb, lg,\n\t\t\t\t\t\t  order, lg_prealloc_count);\n\t\treturn;\n\t}\n\treturn ;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pa->pa_obj_lock"
          ],
          "line": 4354
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&pa->pa_inode_list"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pa->pa_obj_lock"
          ],
          "line": 4352
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "pa->pa_free"
          ],
          "line": 4351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ac->ac_b_ex.fe_len"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ac->ac_b_ex.fe_len"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 4331
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_release_context(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tif (pa) {\n\t\tif (pa->pa_type == MB_GROUP_PA) {\n\t\t\t/* see comment in ext4_mb_use_group_pa() */\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tpa->pa_pstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_lstart += EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\t\tpa->pa_free -= ac->ac_b_ex.fe_len;\n\t\t\tpa->pa_len -= ac->ac_b_ex.fe_len;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t}\n\tif (pa) {\n\t\t/*\n\t\t * We want to add the pa to the right bucket.\n\t\t * Remove it from the list and while adding\n\t\t * make sure the list to which we are adding\n\t\t * doesn't grow big.\n\t\t */\n\t\tif ((pa->pa_type == MB_GROUP_PA) && likely(pa->pa_free)) {\n\t\t\tspin_lock(pa->pa_obj_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tspin_unlock(pa->pa_obj_lock);\n\t\t\text4_mb_add_n_trim(ac);\n\t\t}\n\t\text4_mb_put_pa(ac, ac->ac_sb, pa);\n\t}\n\tif (ac->ac_bitmap_page)\n\t\tpage_cache_release(ac->ac_bitmap_page);\n\tif (ac->ac_buddy_page)\n\t\tpage_cache_release(ac->ac_buddy_page);\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\tmutex_unlock(&ac->ac_lg->lg_mutex);\n\text4_mb_collect_stats(ac);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_add_n_trim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4279-4324",
    "snippet": "static void ext4_mb_add_n_trim(struct ext4_allocation_context *ac)\n{\n\tint order, added = 0, lg_prealloc_count = 1;\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\tstruct ext4_prealloc_space *tmp_pa, *pa = ac->ac_pa;\n\n\torder = fls(pa->pa_free) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\t/* Add the prealloc space to lg */\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(tmp_pa, &lg->lg_prealloc_list[order],\n\t\t\t\t\t\tpa_inode_list) {\n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted) {\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!added && pa->pa_free < tmp_pa->pa_free) {\n\t\t\t/* Add to the tail of the previous entry */\n\t\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t\t&tmp_pa->pa_inode_list);\n\t\t\tadded = 1;\n\t\t\t/*\n\t\t\t * we want to count the total\n\t\t\t * number of entries in the list\n\t\t\t */\n\t\t}\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tlg_prealloc_count++;\n\t}\n\tif (!added)\n\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t&lg->lg_prealloc_list[order]);\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\t/* Now trim the list to be not more than 8 elements */\n\tif (lg_prealloc_count > 8) {\n\t\text4_mb_discard_lg_preallocations(sb, lg,\n\t\t\t\t\t\t  order, lg_prealloc_count);\n\t\treturn;\n\t}\n\treturn ;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_discard_lg_preallocations",
          "args": [
            "sb",
            "lg",
            "order",
            "lg_prealloc_count"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_discard_lg_preallocations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4197-4268",
          "snippet": "static noinline_for_stack void\next4_mb_discard_lg_preallocations(struct super_block *sb,\n\t\t\t\t\tstruct ext4_locality_group *lg,\n\t\t\t\t\tint order, int total_entries)\n{\n\text4_group_t group = 0;\n\tstruct ext4_buddy e4b;\n\tstruct list_head discard_list;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\n\tmb_debug(1, \"discard locality group preallocation\\n\");\n\n\tINIT_LIST_HEAD(&discard_list);\n\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[order],\n\t\t\t\t\t\tpa_inode_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/*\n\t\t\t * This is the pa that we just used\n\t\t\t * for block allocation. So don't\n\t\t\t * free that\n\t\t\t */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* only lg prealloc space */\n\t\tBUG_ON(pa->pa_type != MB_GROUP_PA);\n\n\t\t/* seems this one can be freed ... */\n\t\tpa->pa_deleted = 1;\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &discard_list);\n\n\t\ttotal_entries--;\n\t\tif (total_entries <= 5) {\n\t\t\t/*\n\t\t\t * we want to keep only 5 entries\n\t\t\t * allowing it to grow to 8. This\n\t\t\t * mak sure we don't call discard\n\t\t\t * soon for this list.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &discard_list, u.pa_tmp_list) {\n\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\t\tif (ext4_mb_load_buddy(sb, group, &e4b)) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_group_pa(&e4b, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack void\next4_mb_discard_lg_preallocations(struct super_block *sb,\n\t\t\t\t\tstruct ext4_locality_group *lg,\n\t\t\t\t\tint order, int total_entries)\n{\n\text4_group_t group = 0;\n\tstruct ext4_buddy e4b;\n\tstruct list_head discard_list;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\n\tmb_debug(1, \"discard locality group preallocation\\n\");\n\n\tINIT_LIST_HEAD(&discard_list);\n\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[order],\n\t\t\t\t\t\tpa_inode_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/*\n\t\t\t * This is the pa that we just used\n\t\t\t * for block allocation. So don't\n\t\t\t * free that\n\t\t\t */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* only lg prealloc space */\n\t\tBUG_ON(pa->pa_type != MB_GROUP_PA);\n\n\t\t/* seems this one can be freed ... */\n\t\tpa->pa_deleted = 1;\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &discard_list);\n\n\t\ttotal_entries--;\n\t\tif (total_entries <= 5) {\n\t\t\t/*\n\t\t\t * we want to keep only 5 entries\n\t\t\t * allowing it to grow to 8. This\n\t\t\t * mak sure we don't call discard\n\t\t\t * soon for this list.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &discard_list, u.pa_tmp_list) {\n\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\t\tif (ext4_mb_load_buddy(sb, group, &e4b)) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_group_pa(&e4b, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lg->lg_prealloc_lock"
          ],
          "line": 4315
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&pa->pa_inode_list",
            "&lg->lg_prealloc_list[order]"
          ],
          "line": 4313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&pa->pa_inode_list",
            "&tmp_pa->pa_inode_list"
          ],
          "line": 4301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tmp_pa->pa_lock"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "tmp_pa",
            "&lg->lg_prealloc_list[order]",
            "pa_inode_list"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "pa->pa_free"
          ],
          "line": 4286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_add_n_trim(struct ext4_allocation_context *ac)\n{\n\tint order, added = 0, lg_prealloc_count = 1;\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\tstruct ext4_prealloc_space *tmp_pa, *pa = ac->ac_pa;\n\n\torder = fls(pa->pa_free) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\t/* Add the prealloc space to lg */\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(tmp_pa, &lg->lg_prealloc_list[order],\n\t\t\t\t\t\tpa_inode_list) {\n\t\tspin_lock(&tmp_pa->pa_lock);\n\t\tif (tmp_pa->pa_deleted) {\n\t\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!added && pa->pa_free < tmp_pa->pa_free) {\n\t\t\t/* Add to the tail of the previous entry */\n\t\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t\t&tmp_pa->pa_inode_list);\n\t\t\tadded = 1;\n\t\t\t/*\n\t\t\t * we want to count the total\n\t\t\t * number of entries in the list\n\t\t\t */\n\t\t}\n\t\tspin_unlock(&tmp_pa->pa_lock);\n\t\tlg_prealloc_count++;\n\t}\n\tif (!added)\n\t\tlist_add_tail_rcu(&pa->pa_inode_list,\n\t\t\t\t\t&lg->lg_prealloc_list[order]);\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\t/* Now trim the list to be not more than 8 elements */\n\tif (lg_prealloc_count > 8) {\n\t\text4_mb_discard_lg_preallocations(sb, lg,\n\t\t\t\t\t\t  order, lg_prealloc_count);\n\t\treturn;\n\t}\n\treturn ;\n}"
  },
  {
    "function_name": "ext4_mb_discard_lg_preallocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4197-4268",
    "snippet": "static noinline_for_stack void\next4_mb_discard_lg_preallocations(struct super_block *sb,\n\t\t\t\t\tstruct ext4_locality_group *lg,\n\t\t\t\t\tint order, int total_entries)\n{\n\text4_group_t group = 0;\n\tstruct ext4_buddy e4b;\n\tstruct list_head discard_list;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\n\tmb_debug(1, \"discard locality group preallocation\\n\");\n\n\tINIT_LIST_HEAD(&discard_list);\n\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[order],\n\t\t\t\t\t\tpa_inode_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/*\n\t\t\t * This is the pa that we just used\n\t\t\t * for block allocation. So don't\n\t\t\t * free that\n\t\t\t */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* only lg prealloc space */\n\t\tBUG_ON(pa->pa_type != MB_GROUP_PA);\n\n\t\t/* seems this one can be freed ... */\n\t\tpa->pa_deleted = 1;\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &discard_list);\n\n\t\ttotal_entries--;\n\t\tif (total_entries <= 5) {\n\t\t\t/*\n\t\t\t * we want to keep only 5 entries\n\t\t\t * allowing it to grow to 8. This\n\t\t\t * mak sure we don't call discard\n\t\t\t * soon for this list.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &discard_list, u.pa_tmp_list) {\n\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\t\tif (ext4_mb_load_buddy(sb, group, &e4b)) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_group_pa(&e4b, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&(pa)->u.pa_rcu",
            "ext4_mb_pa_callback"
          ],
          "line": 4266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pa->u.pa_tmp_list"
          ],
          "line": 4265
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "316-328",
          "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 4262
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_release_group_pa",
          "args": [
            "&e4b",
            "pa"
          ],
          "line": 4261
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_release_group_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3783-3800",
          "snippet": "static noinline_for_stack int\next4_mb_release_group_pa(struct ext4_buddy *e4b,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\n\ttrace_ext4_mb_release_group_pa(sb, pa);\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tmb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);\n\tatomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);\n\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, pa->pa_len);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_release_group_pa(struct ext4_buddy *e4b,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\n\ttrace_ext4_mb_release_group_pa(sb, pa);\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tmb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);\n\tatomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);\n\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, pa->pa_len);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 4259
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Error loading buddy information for %u\"",
            "group"
          ],
          "line": 4255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "group",
            "&e4b"
          ],
          "line": 4254
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_number",
          "args": [
            "sb",
            "pa->pa_pstart"
          ],
          "line": 4253
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "35-47",
          "snippet": "ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pa",
            "tmp",
            "&discard_list",
            "u.pa_tmp_list"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lg->lg_prealloc_lock"
          ],
          "line": 4249
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pa->u.pa_tmp_list",
            "&discard_list"
          ],
          "line": 4236
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&pa->pa_inode_list"
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_type != MB_GROUP_PA"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pa->pa_count"
          ],
          "line": 4215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 4214
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "pa",
            "&lg->lg_prealloc_list[order]",
            "pa_inode_list"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&discard_list"
          ],
          "line": 4209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"discard locality group preallocation\\n\""
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack void\next4_mb_discard_lg_preallocations(struct super_block *sb,\n\t\t\t\t\tstruct ext4_locality_group *lg,\n\t\t\t\t\tint order, int total_entries)\n{\n\text4_group_t group = 0;\n\tstruct ext4_buddy e4b;\n\tstruct list_head discard_list;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\n\tmb_debug(1, \"discard locality group preallocation\\n\");\n\n\tINIT_LIST_HEAD(&discard_list);\n\n\tspin_lock(&lg->lg_prealloc_lock);\n\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[order],\n\t\t\t\t\t\tpa_inode_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/*\n\t\t\t * This is the pa that we just used\n\t\t\t * for block allocation. So don't\n\t\t\t * free that\n\t\t\t */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t/* only lg prealloc space */\n\t\tBUG_ON(pa->pa_type != MB_GROUP_PA);\n\n\t\t/* seems this one can be freed ... */\n\t\tpa->pa_deleted = 1;\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &discard_list);\n\n\t\ttotal_entries--;\n\t\tif (total_entries <= 5) {\n\t\t\t/*\n\t\t\t * we want to keep only 5 entries\n\t\t\t * allowing it to grow to 8. This\n\t\t\t * mak sure we don't call discard\n\t\t\t * soon for this list.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&lg->lg_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &discard_list, u.pa_tmp_list) {\n\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\t\tif (ext4_mb_load_buddy(sb, group, &e4b)) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_group_pa(&e4b, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
  },
  {
    "function_name": "ext4_mb_initialize_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4144-4195",
    "snippet": "static noinline_for_stack int\next4_mb_initialize_context(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct super_block *sb = ar->inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t group;\n\tunsigned int len;\n\text4_fsblk_t goal;\n\text4_grpblk_t block;\n\n\t/* we can't allocate > group size */\n\tlen = ar->len;\n\n\t/* just a dirty hack to filter too big requests  */\n\tif (len >= EXT4_CLUSTERS_PER_GROUP(sb))\n\t\tlen = EXT4_CLUSTERS_PER_GROUP(sb);\n\n\t/* start searching from the goal */\n\tgoal = ar->goal;\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t\t\tgoal >= ext4_blocks_count(es))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\text4_get_group_no_and_offset(sb, goal, &group, &block);\n\n\t/* set up allocation goals */\n\tac->ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar->logical);\n\tac->ac_status = AC_STATUS_CONTINUE;\n\tac->ac_sb = sb;\n\tac->ac_inode = ar->inode;\n\tac->ac_o_ex.fe_logical = ac->ac_b_ex.fe_logical;\n\tac->ac_o_ex.fe_group = group;\n\tac->ac_o_ex.fe_start = block;\n\tac->ac_o_ex.fe_len = len;\n\tac->ac_g_ex = ac->ac_o_ex;\n\tac->ac_flags = ar->flags;\n\n\t/* we have to define context: we'll we work with a file or\n\t * locality group. this is a policy, actually */\n\text4_mb_group_or_file(ac);\n\n\tmb_debug(1, \"init ac: %u blocks @ %u, goal %u, flags %x, 2^%d, \"\n\t\t\t\"left: %u/%u, right %u/%u to %swritable\\n\",\n\t\t\t(unsigned) ar->len, (unsigned) ar->logical,\n\t\t\t(unsigned) ar->goal, ac->ac_flags, ac->ac_2order,\n\t\t\t(unsigned) ar->lleft, (unsigned) ar->pleft,\n\t\t\t(unsigned) ar->lright, (unsigned) ar->pright,\n\t\t\tatomic_read(&ar->inode->i_writecount) ? \"\" : \"non-\");\n\treturn 0;\n\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"init ac: %u blocks @ %u, goal %u, flags %x, 2^%d, \"\n\t\t\t\"left: %u/%u, right %u/%u to %swritable\\n\"",
            "(unsigned) ar->len",
            "(unsigned) ar->logical",
            "(unsigned) ar->goal",
            "ac->ac_flags",
            "ac->ac_2order",
            "(unsigned) ar->lleft",
            "(unsigned) ar->pleft",
            "(unsigned) ar->lright",
            "(unsigned) ar->pright",
            "atomic_read(&ar->inode->i_writecount) ? \"\" : \"non-\""
          ],
          "line": 4186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ar->inode->i_writecount"
          ],
          "line": 4192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_group_or_file",
          "args": [
            "ac"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_group_or_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4094-4142",
          "snippet": "static void ext4_mb_group_or_file(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits = ac->ac_sb->s_blocksize_bits;\n\tloff_t size, isize;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tisize = (i_size_read(ac->ac_inode) + ac->ac_sb->s_blocksize - 1)\n\t\t>> bsbits;\n\n\tif ((size == isize) &&\n\t    !ext4_fs_is_busy(sbi) &&\n\t    (atomic_read(&ac->ac_inode->i_writecount) == 0)) {\n\t\tac->ac_flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\treturn;\n\t}\n\n\tif (sbi->s_mb_group_prealloc <= 0) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\t/* don't use group allocation for large files */\n\tsize = max(size, isize);\n\tif (size > sbi->s_mb_stream_request) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\tBUG_ON(ac->ac_lg != NULL);\n\t/*\n\t * locality group prealloc space are per cpu. The reason for having\n\t * per cpu locality group is to reduce the contention between block\n\t * request from multiple CPUs.\n\t */\n\tac->ac_lg = raw_cpu_ptr(sbi->s_locality_groups);\n\n\t/* we're going to use group allocation */\n\tac->ac_flags |= EXT4_MB_HINT_GROUP_ALLOC;\n\n\t/* serialize all allocations in the group */\n\tmutex_lock(&ac->ac_lg->lg_mutex);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_group_or_file(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits = ac->ac_sb->s_blocksize_bits;\n\tloff_t size, isize;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tisize = (i_size_read(ac->ac_inode) + ac->ac_sb->s_blocksize - 1)\n\t\t>> bsbits;\n\n\tif ((size == isize) &&\n\t    !ext4_fs_is_busy(sbi) &&\n\t    (atomic_read(&ac->ac_inode->i_writecount) == 0)) {\n\t\tac->ac_flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\treturn;\n\t}\n\n\tif (sbi->s_mb_group_prealloc <= 0) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\t/* don't use group allocation for large files */\n\tsize = max(size, isize);\n\tif (size > sbi->s_mb_stream_request) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\tBUG_ON(ac->ac_lg != NULL);\n\t/*\n\t * locality group prealloc space are per cpu. The reason for having\n\t * per cpu locality group is to reduce the contention between block\n\t * request from multiple CPUs.\n\t */\n\tac->ac_lg = raw_cpu_ptr(sbi->s_locality_groups);\n\n\t/* we're going to use group allocation */\n\tac->ac_flags |= EXT4_MB_HINT_GROUP_ALLOC;\n\n\t/* serialize all allocations in the group */\n\tmutex_lock(&ac->ac_lg->lg_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_LBLK_CMASK",
          "args": [
            "sbi",
            "ar->logical"
          ],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "goal",
            "&group",
            "&block"
          ],
          "line": 4168
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_first_data_block"
          ],
          "line": 4167
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_blocks_count",
          "args": [
            "es"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 4161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4149
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_initialize_context(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct super_block *sb = ar->inode->i_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\text4_group_t group;\n\tunsigned int len;\n\text4_fsblk_t goal;\n\text4_grpblk_t block;\n\n\t/* we can't allocate > group size */\n\tlen = ar->len;\n\n\t/* just a dirty hack to filter too big requests  */\n\tif (len >= EXT4_CLUSTERS_PER_GROUP(sb))\n\t\tlen = EXT4_CLUSTERS_PER_GROUP(sb);\n\n\t/* start searching from the goal */\n\tgoal = ar->goal;\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t\t\tgoal >= ext4_blocks_count(es))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\text4_get_group_no_and_offset(sb, goal, &group, &block);\n\n\t/* set up allocation goals */\n\tac->ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar->logical);\n\tac->ac_status = AC_STATUS_CONTINUE;\n\tac->ac_sb = sb;\n\tac->ac_inode = ar->inode;\n\tac->ac_o_ex.fe_logical = ac->ac_b_ex.fe_logical;\n\tac->ac_o_ex.fe_group = group;\n\tac->ac_o_ex.fe_start = block;\n\tac->ac_o_ex.fe_len = len;\n\tac->ac_g_ex = ac->ac_o_ex;\n\tac->ac_flags = ar->flags;\n\n\t/* we have to define context: we'll we work with a file or\n\t * locality group. this is a policy, actually */\n\text4_mb_group_or_file(ac);\n\n\tmb_debug(1, \"init ac: %u blocks @ %u, goal %u, flags %x, 2^%d, \"\n\t\t\t\"left: %u/%u, right %u/%u to %swritable\\n\",\n\t\t\t(unsigned) ar->len, (unsigned) ar->logical,\n\t\t\t(unsigned) ar->goal, ac->ac_flags, ac->ac_2order,\n\t\t\t(unsigned) ar->lleft, (unsigned) ar->pleft,\n\t\t\t(unsigned) ar->lright, (unsigned) ar->pright,\n\t\t\tatomic_read(&ar->inode->i_writecount) ? \"\" : \"non-\");\n\treturn 0;\n\n}"
  },
  {
    "function_name": "ext4_mb_group_or_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4094-4142",
    "snippet": "static void ext4_mb_group_or_file(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits = ac->ac_sb->s_blocksize_bits;\n\tloff_t size, isize;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tisize = (i_size_read(ac->ac_inode) + ac->ac_sb->s_blocksize - 1)\n\t\t>> bsbits;\n\n\tif ((size == isize) &&\n\t    !ext4_fs_is_busy(sbi) &&\n\t    (atomic_read(&ac->ac_inode->i_writecount) == 0)) {\n\t\tac->ac_flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\treturn;\n\t}\n\n\tif (sbi->s_mb_group_prealloc <= 0) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\t/* don't use group allocation for large files */\n\tsize = max(size, isize);\n\tif (size > sbi->s_mb_stream_request) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\tBUG_ON(ac->ac_lg != NULL);\n\t/*\n\t * locality group prealloc space are per cpu. The reason for having\n\t * per cpu locality group is to reduce the contention between block\n\t * request from multiple CPUs.\n\t */\n\tac->ac_lg = raw_cpu_ptr(sbi->s_locality_groups);\n\n\t/* we're going to use group allocation */\n\tac->ac_flags |= EXT4_MB_HINT_GROUP_ALLOC;\n\n\t/* serialize all allocations in the group */\n\tmutex_lock(&ac->ac_lg->lg_mutex);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ac->ac_lg->lg_mutex"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "sbi->s_locality_groups"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_lg != NULL"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "size",
            "isize"
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_max_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "353-371",
          "snippet": "static int\next4_ext_max_entries(struct inode *inode, int depth)\n{\n\tint max;\n\n\tif (depth == ext_depth(inode)) {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_root(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_root_idx(inode, 1);\n\t} else {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_block(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_block_idx(inode, 1);\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int\next4_ext_max_entries(struct inode *inode, int depth)\n{\n\tint max;\n\n\tif (depth == ext_depth(inode)) {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_root(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_root_idx(inode, 1);\n\t} else {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_block(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_block_idx(inode, 1);\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ac->ac_inode->i_writecount"
          ],
          "line": 4112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_fs_is_busy",
          "args": [
            "sbi"
          ],
          "line": 4111
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_fs_is_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2542-2545",
          "snippet": "static inline int ext4_fs_is_busy(struct ext4_sb_info *sbi)\n{\n\treturn (atomic_read(&sbi->s_lock_busy) > EXT4_CONTENTION_THRESHOLD);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_fs_is_busy(struct ext4_sb_info *sbi)\n{\n\treturn (atomic_read(&sbi->s_lock_busy) > EXT4_CONTENTION_THRESHOLD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ac->ac_inode"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ac->ac_o_ex.fe_len"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_group_or_file(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits = ac->ac_sb->s_blocksize_bits;\n\tloff_t size, isize;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tisize = (i_size_read(ac->ac_inode) + ac->ac_sb->s_blocksize - 1)\n\t\t>> bsbits;\n\n\tif ((size == isize) &&\n\t    !ext4_fs_is_busy(sbi) &&\n\t    (atomic_read(&ac->ac_inode->i_writecount) == 0)) {\n\t\tac->ac_flags |= EXT4_MB_HINT_NOPREALLOC;\n\t\treturn;\n\t}\n\n\tif (sbi->s_mb_group_prealloc <= 0) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\t/* don't use group allocation for large files */\n\tsize = max(size, isize);\n\tif (size > sbi->s_mb_stream_request) {\n\t\tac->ac_flags |= EXT4_MB_STREAM_ALLOC;\n\t\treturn;\n\t}\n\n\tBUG_ON(ac->ac_lg != NULL);\n\t/*\n\t * locality group prealloc space are per cpu. The reason for having\n\t * per cpu locality group is to reduce the contention between block\n\t * request from multiple CPUs.\n\t */\n\tac->ac_lg = raw_cpu_ptr(sbi->s_locality_groups);\n\n\t/* we're going to use group allocation */\n\tac->ac_flags |= EXT4_MB_HINT_GROUP_ALLOC;\n\n\t/* serialize all allocations in the group */\n\tmutex_lock(&ac->ac_lg->lg_mutex);\n}"
  },
  {
    "function_name": "ext4_mb_show_ac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4081-4084",
    "snippet": "static inline void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\treturn;\n}"
  },
  {
    "function_name": "ext4_mb_show_ac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "4023-4079",
    "snippet": "static void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\text4_group_t ngroups, i;\n\n\tif (!ext4_mballoc_debug ||\n\t    (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED))\n\t\treturn;\n\n\text4_msg(ac->ac_sb, KERN_ERR, \"Can't allocate:\"\n\t\t\t\" Allocation context details:\");\n\text4_msg(ac->ac_sb, KERN_ERR, \"status %d flags %d\",\n\t\t\tac->ac_status, ac->ac_flags);\n\text4_msg(ac->ac_sb, KERN_ERR, \"orig %lu/%lu/%lu@%lu, \"\n\t\t \t\"goal %lu/%lu/%lu@%lu, \"\n\t\t\t\"best %lu/%lu/%lu@%lu cr %d\",\n\t\t\t(unsigned long)ac->ac_o_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_logical,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_logical,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_logical,\n\t\t\t(int)ac->ac_criteria);\n\text4_msg(ac->ac_sb, KERN_ERR, \"%d found\", ac->ac_found);\n\text4_msg(ac->ac_sb, KERN_ERR, \"groups: \");\n\tngroups = ext4_get_groups_count(sb);\n\tfor (i = 0; i < ngroups; i++) {\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, i);\n\t\tstruct ext4_prealloc_space *pa;\n\t\text4_grpblk_t start;\n\t\tstruct list_head *cur;\n\t\text4_lock_group(sb, i);\n\t\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\t\tpa = list_entry(cur, struct ext4_prealloc_space,\n\t\t\t\t\tpa_group_list);\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t\t     NULL, &start);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tprintk(KERN_ERR \"PA:%u:%d:%u \\n\", i,\n\t\t\t       start, pa->pa_len);\n\t\t}\n\t\text4_unlock_group(sb, i);\n\n\t\tif (grp->bb_free == 0)\n\t\t\tcontinue;\n\t\tprintk(KERN_ERR \"%u: %d/%d \\n\",\n\t\t       i, grp->bb_free, grp->bb_fragments);\n\t}\n\tprintk(KERN_ERR \"\\n\");\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"\\n\""
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "i"
          ],
          "line": 4071
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 4067
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "pa->pa_pstart",
            "NULL",
            "&start"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 4064
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur",
            "structext4_prealloc_space",
            "pa_group_list"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "cur",
            "&grp->bb_prealloc_list"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "i"
          ],
          "line": 4060
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "i"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "ac->ac_sb",
            "KERN_ERR",
            "\"groups: \""
          ],
          "line": 4053
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_show_ac(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\text4_group_t ngroups, i;\n\n\tif (!ext4_mballoc_debug ||\n\t    (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED))\n\t\treturn;\n\n\text4_msg(ac->ac_sb, KERN_ERR, \"Can't allocate:\"\n\t\t\t\" Allocation context details:\");\n\text4_msg(ac->ac_sb, KERN_ERR, \"status %d flags %d\",\n\t\t\tac->ac_status, ac->ac_flags);\n\text4_msg(ac->ac_sb, KERN_ERR, \"orig %lu/%lu/%lu@%lu, \"\n\t\t \t\"goal %lu/%lu/%lu@%lu, \"\n\t\t\t\"best %lu/%lu/%lu@%lu cr %d\",\n\t\t\t(unsigned long)ac->ac_o_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_o_ex.fe_logical,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_g_ex.fe_logical,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_group,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_start,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_len,\n\t\t\t(unsigned long)ac->ac_b_ex.fe_logical,\n\t\t\t(int)ac->ac_criteria);\n\text4_msg(ac->ac_sb, KERN_ERR, \"%d found\", ac->ac_found);\n\text4_msg(ac->ac_sb, KERN_ERR, \"groups: \");\n\tngroups = ext4_get_groups_count(sb);\n\tfor (i = 0; i < ngroups; i++) {\n\t\tstruct ext4_group_info *grp = ext4_get_group_info(sb, i);\n\t\tstruct ext4_prealloc_space *pa;\n\t\text4_grpblk_t start;\n\t\tstruct list_head *cur;\n\t\text4_lock_group(sb, i);\n\t\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\t\tpa = list_entry(cur, struct ext4_prealloc_space,\n\t\t\t\t\tpa_group_list);\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t\t     NULL, &start);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tprintk(KERN_ERR \"PA:%u:%d:%u \\n\", i,\n\t\t\t       start, pa->pa_len);\n\t\t}\n\t\text4_unlock_group(sb, i);\n\n\t\tif (grp->bb_free == 0)\n\t\t\tcontinue;\n\t\tprintk(KERN_ERR \"%u: %d/%d \\n\",\n\t\t       i, grp->bb_free, grp->bb_fragments);\n\t}\n\tprintk(KERN_ERR \"\\n\");\n}"
  },
  {
    "function_name": "ext4_discard_preallocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3920-4020",
    "snippet": "void ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&(pa)->u.pa_rcu",
            "ext4_mb_pa_callback"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pa->u.pa_tmp_list"
          ],
          "line": 4017
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "316-328",
          "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bitmap_bh"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_release_inode_pa",
          "args": [
            "&e4b",
            "bitmap_bh",
            "pa"
          ],
          "line": 4011
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_release_inode_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3728-3781",
          "snippet": "static noinline_for_stack int\next4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,\n\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int end;\n\tunsigned int next;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\tunsigned long long grp_blk_start;\n\tint err = 0;\n\tint free = 0;\n\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tgrp_blk_start = pa->pa_pstart - EXT4_C2B(sbi, bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tend = bit + pa->pa_len;\n\n\twhile (bit < end) {\n\t\tbit = mb_find_next_zero_bit(bitmap_bh->b_data, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap_bh->b_data, end, bit);\n\t\tmb_debug(1, \"    free preallocated %u/%u in group %u\\n\",\n\t\t\t (unsigned) ext4_group_first_block_no(sb, group) + bit,\n\t\t\t (unsigned) next - bit, (unsigned) group);\n\t\tfree += next - bit;\n\n\t\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, next - bit);\n\t\ttrace_ext4_mb_release_inode_pa(pa, (grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit)),\n\t\t\t\t\t       next - bit);\n\t\tmb_free_blocks(pa->pa_inode, e4b, bit, next - bit);\n\t\tbit = next + 1;\n\t}\n\tif (free != pa->pa_free) {\n\t\text4_msg(e4b->bd_sb, KERN_CRIT,\n\t\t\t \"pa %p: logic %lu, phys. %lu, len %lu\",\n\t\t\t pa, (unsigned long) pa->pa_lstart,\n\t\t\t (unsigned long) pa->pa_pstart,\n\t\t\t (unsigned long) pa->pa_len);\n\t\text4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",\n\t\t\t\t\tfree, pa->pa_free);\n\t\t/*\n\t\t * pa is already deleted so we use the value obtained\n\t\t * from the bitmap and continue.\n\t\t */\n\t}\n\tatomic_add(free, &sbi->s_mb_discarded);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,\n\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int end;\n\tunsigned int next;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\tunsigned long long grp_blk_start;\n\tint err = 0;\n\tint free = 0;\n\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tgrp_blk_start = pa->pa_pstart - EXT4_C2B(sbi, bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tend = bit + pa->pa_len;\n\n\twhile (bit < end) {\n\t\tbit = mb_find_next_zero_bit(bitmap_bh->b_data, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap_bh->b_data, end, bit);\n\t\tmb_debug(1, \"    free preallocated %u/%u in group %u\\n\",\n\t\t\t (unsigned) ext4_group_first_block_no(sb, group) + bit,\n\t\t\t (unsigned) next - bit, (unsigned) group);\n\t\tfree += next - bit;\n\n\t\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, next - bit);\n\t\ttrace_ext4_mb_release_inode_pa(pa, (grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit)),\n\t\t\t\t\t       next - bit);\n\t\tmb_free_blocks(pa->pa_inode, e4b, bit, next - bit);\n\t\tbit = next + 1;\n\t}\n\tif (free != pa->pa_free) {\n\t\text4_msg(e4b->bd_sb, KERN_CRIT,\n\t\t\t \"pa %p: logic %lu, phys. %lu, len %lu\",\n\t\t\t pa, (unsigned long) pa->pa_lstart,\n\t\t\t (unsigned long) pa->pa_pstart,\n\t\t\t (unsigned long) pa->pa_len);\n\t\text4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",\n\t\t\t\t\tfree, pa->pa_free);\n\t\t/*\n\t\t * pa is already deleted so we use the value obtained\n\t\t * from the bitmap and continue.\n\t\t */\n\t}\n\tatomic_add(free, &sbi->s_mb_discarded);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 4009
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Error reading block bitmap for %u\"",
            "group"
          ],
          "line": 4003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap",
          "args": [
            "sb",
            "group"
          ],
          "line": 4001
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "504-517",
          "snippet": "struct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Error loading buddy information for %u\"",
            "group"
          ],
          "line": 3996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "group",
            "&e4b"
          ],
          "line": 3994
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_number",
          "args": [
            "sb",
            "pa->pa_pstart"
          ],
          "line": 3992
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "35-47",
          "snippet": "ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_type != MB_INODE_PA"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pa",
            "tmp",
            "&list",
            "u.pa_tmp_list"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ei->i_prealloc_lock"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "HZ"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pa->u.pa_tmp_list",
            "&list"
          ],
          "line": 3965
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&pa->pa_inode_list"
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "HZ"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 3956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"uh-oh! used pa while discarding\""
          ],
          "line": 3954
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pa->pa_count"
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_obj_lock != &ei->i_prealloc_lock"
          ],
          "line": 3947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ei->i_prealloc_list.next",
            "structext4_prealloc_space",
            "pa_inode_list"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ei->i_prealloc_list"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&list"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_discard_preallocations",
          "args": [
            "inode"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"discard preallocation for inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 3922
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_discard_preallocations(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\text4_group_t group = 0;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (!S_ISREG(inode->i_mode)) {\n\t\t/*BUG_ON(!list_empty(&ei->i_prealloc_list));*/\n\t\treturn;\n\t}\n\n\tmb_debug(1, \"discard preallocation for inode %lu\\n\", inode->i_ino);\n\ttrace_ext4_discard_preallocations(inode);\n\n\tINIT_LIST_HEAD(&list);\n\nrepeat:\n\t/* first, collect all pa's in the inode */\n\tspin_lock(&ei->i_prealloc_lock);\n\twhile (!list_empty(&ei->i_prealloc_list)) {\n\t\tpa = list_entry(ei->i_prealloc_list.next,\n\t\t\t\tstruct ext4_prealloc_space, pa_inode_list);\n\t\tBUG_ON(pa->pa_obj_lock != &ei->i_prealloc_lock);\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\t/* this shouldn't happen often - nobody should\n\t\t\t * use preallocation while we're discarding it */\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tspin_unlock(&ei->i_prealloc_lock);\n\t\t\text4_msg(sb, KERN_ERR,\n\t\t\t\t \"uh-oh! used pa while discarding\");\n\t\t\tWARN_ON(1);\n\t\t\tschedule_timeout_uninterruptible(HZ);\n\t\t\tgoto repeat;\n\n\t\t}\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa->pa_deleted = 1;\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* someone is deleting pa right now */\n\t\tspin_unlock(&pa->pa_lock);\n\t\tspin_unlock(&ei->i_prealloc_lock);\n\n\t\t/* we have to wait here because pa_deleted\n\t\t * doesn't mean pa is already unlinked from\n\t\t * the list. as we might be called from\n\t\t * ->clear_inode() the inode will get freed\n\t\t * and concurrent thread which is unlinking\n\t\t * pa from inode's list may access already\n\t\t * freed memory, bad-bad-bad */\n\n\t\t/* XXX: if this happens too often, we can\n\t\t * add a flag to force wait only in case\n\t\t * of ->clear_inode(), but not in case of\n\t\t * regular truncate */\n\t\tschedule_timeout_uninterruptible(HZ);\n\t\tgoto repeat;\n\t}\n\tspin_unlock(&ei->i_prealloc_lock);\n\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\t\tBUG_ON(pa->pa_type != MB_INODE_PA);\n\t\tgroup = ext4_get_group_number(sb, pa->pa_pstart);\n\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\text4_error(sb, \"Error loading buddy information for %u\",\n\t\t\t\t\tgroup);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\t\tif (bitmap_bh == NULL) {\n\t\t\text4_error(sb, \"Error reading block bitmap for %u\",\n\t\t\t\t\tgroup);\n\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\tcontinue;\n\t\t}\n\n\t\text4_lock_group(sb, group);\n\t\tlist_del(&pa->pa_group_list);\n\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\t\text4_unlock_group(sb, group);\n\n\t\text4_mb_unload_buddy(&e4b);\n\t\tput_bh(bitmap_bh);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n}"
  },
  {
    "function_name": "ext4_mb_discard_group_preallocations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3811-3909",
    "snippet": "static noinline_for_stack int\next4_mb_discard_group_preallocations(struct super_block *sb,\n\t\t\t\t\text4_group_t group, int needed)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\tint busy = 0;\n\tint free = 0;\n\n\tmb_debug(1, \"discard preallocation for group %u\\n\", group);\n\n\tif (list_empty(&grp->bb_prealloc_list))\n\t\treturn 0;\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (bitmap_bh == NULL) {\n\t\text4_error(sb, \"Error reading block bitmap for %u\", group);\n\t\treturn 0;\n\t}\n\n\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (err) {\n\t\text4_error(sb, \"Error loading buddy information for %u\", group);\n\t\tput_bh(bitmap_bh);\n\t\treturn 0;\n\t}\n\n\tif (needed == 0)\n\t\tneeded = EXT4_CLUSTERS_PER_GROUP(sb) + 1;\n\n\tINIT_LIST_HEAD(&list);\nrepeat:\n\text4_lock_group(sb, group);\n\tlist_for_each_entry_safe(pa, tmp,\n\t\t\t\t&grp->bb_prealloc_list, pa_group_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* seems this one can be freed ... */\n\t\tpa->pa_deleted = 1;\n\n\t\t/* we can trust pa_free ... */\n\t\tfree += pa->pa_free;\n\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del(&pa->pa_group_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t}\n\n\t/* if we still need more blocks and some PAs were used, try again */\n\tif (free < needed && busy) {\n\t\tbusy = 0;\n\t\text4_unlock_group(sb, group);\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\n\t/* found anything to free? */\n\tif (list_empty(&list)) {\n\t\tBUG_ON(free != 0);\n\t\tgoto out;\n\t}\n\n\t/* now free all selected PAs */\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\n\t\t/* remove from object (inode or locality group) */\n\t\tspin_lock(pa->pa_obj_lock);\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tspin_unlock(pa->pa_obj_lock);\n\n\t\tif (pa->pa_type == MB_GROUP_PA)\n\t\t\text4_mb_release_group_pa(&e4b, pa);\n\t\telse\n\t\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\tput_bh(bitmap_bh);\n\treturn free;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bitmap_bh"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 3906
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 3905
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&(pa)->u.pa_rcu",
            "ext4_mb_pa_callback"
          ],
          "line": 3901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pa->u.pa_tmp_list"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "316-328",
          "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_release_inode_pa",
          "args": [
            "&e4b",
            "bitmap_bh",
            "pa"
          ],
          "line": 3898
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_release_inode_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3728-3781",
          "snippet": "static noinline_for_stack int\next4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,\n\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int end;\n\tunsigned int next;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\tunsigned long long grp_blk_start;\n\tint err = 0;\n\tint free = 0;\n\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tgrp_blk_start = pa->pa_pstart - EXT4_C2B(sbi, bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tend = bit + pa->pa_len;\n\n\twhile (bit < end) {\n\t\tbit = mb_find_next_zero_bit(bitmap_bh->b_data, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap_bh->b_data, end, bit);\n\t\tmb_debug(1, \"    free preallocated %u/%u in group %u\\n\",\n\t\t\t (unsigned) ext4_group_first_block_no(sb, group) + bit,\n\t\t\t (unsigned) next - bit, (unsigned) group);\n\t\tfree += next - bit;\n\n\t\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, next - bit);\n\t\ttrace_ext4_mb_release_inode_pa(pa, (grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit)),\n\t\t\t\t\t       next - bit);\n\t\tmb_free_blocks(pa->pa_inode, e4b, bit, next - bit);\n\t\tbit = next + 1;\n\t}\n\tif (free != pa->pa_free) {\n\t\text4_msg(e4b->bd_sb, KERN_CRIT,\n\t\t\t \"pa %p: logic %lu, phys. %lu, len %lu\",\n\t\t\t pa, (unsigned long) pa->pa_lstart,\n\t\t\t (unsigned long) pa->pa_pstart,\n\t\t\t (unsigned long) pa->pa_len);\n\t\text4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",\n\t\t\t\t\tfree, pa->pa_free);\n\t\t/*\n\t\t * pa is already deleted so we use the value obtained\n\t\t * from the bitmap and continue.\n\t\t */\n\t}\n\tatomic_add(free, &sbi->s_mb_discarded);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,\n\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int end;\n\tunsigned int next;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\tunsigned long long grp_blk_start;\n\tint err = 0;\n\tint free = 0;\n\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tgrp_blk_start = pa->pa_pstart - EXT4_C2B(sbi, bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tend = bit + pa->pa_len;\n\n\twhile (bit < end) {\n\t\tbit = mb_find_next_zero_bit(bitmap_bh->b_data, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap_bh->b_data, end, bit);\n\t\tmb_debug(1, \"    free preallocated %u/%u in group %u\\n\",\n\t\t\t (unsigned) ext4_group_first_block_no(sb, group) + bit,\n\t\t\t (unsigned) next - bit, (unsigned) group);\n\t\tfree += next - bit;\n\n\t\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, next - bit);\n\t\ttrace_ext4_mb_release_inode_pa(pa, (grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit)),\n\t\t\t\t\t       next - bit);\n\t\tmb_free_blocks(pa->pa_inode, e4b, bit, next - bit);\n\t\tbit = next + 1;\n\t}\n\tif (free != pa->pa_free) {\n\t\text4_msg(e4b->bd_sb, KERN_CRIT,\n\t\t\t \"pa %p: logic %lu, phys. %lu, len %lu\",\n\t\t\t pa, (unsigned long) pa->pa_lstart,\n\t\t\t (unsigned long) pa->pa_pstart,\n\t\t\t (unsigned long) pa->pa_len);\n\t\text4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",\n\t\t\t\t\tfree, pa->pa_free);\n\t\t/*\n\t\t * pa is already deleted so we use the value obtained\n\t\t * from the bitmap and continue.\n\t\t */\n\t}\n\tatomic_add(free, &sbi->s_mb_discarded);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_release_group_pa",
          "args": [
            "&e4b",
            "pa"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_release_group_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3783-3800",
          "snippet": "static noinline_for_stack int\next4_mb_release_group_pa(struct ext4_buddy *e4b,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\n\ttrace_ext4_mb_release_group_pa(sb, pa);\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tmb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);\n\tatomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);\n\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, pa->pa_len);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_release_group_pa(struct ext4_buddy *e4b,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\n\ttrace_ext4_mb_release_group_pa(sb, pa);\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tmb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);\n\tatomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);\n\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, pa->pa_len);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pa->pa_obj_lock"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&pa->pa_inode_list"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pa->pa_obj_lock"
          ],
          "line": 3891
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pa",
            "tmp",
            "&list",
            "u.pa_tmp_list"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "free != 0"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&list"
          ],
          "line": 3882
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pa->u.pa_tmp_list",
            "&list"
          ],
          "line": 3870
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pa->pa_count"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "pa",
            "tmp",
            "&grp->bb_prealloc_list",
            "pa_group_list"
          ],
          "line": 3848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 3847
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&list"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bitmap_bh"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Error loading buddy information for %u\"",
            "group"
          ],
          "line": 3837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "group",
            "&e4b"
          ],
          "line": 3835
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Error reading block bitmap for %u\"",
            "group"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap",
          "args": [
            "sb",
            "group"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "504-517",
          "snippet": "struct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"discard preallocation for group %u\\n\"",
            "group"
          ],
          "line": 3824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_discard_group_preallocations(struct super_block *sb,\n\t\t\t\t\text4_group_t group, int needed)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_prealloc_space *pa, *tmp;\n\tstruct list_head list;\n\tstruct ext4_buddy e4b;\n\tint err;\n\tint busy = 0;\n\tint free = 0;\n\n\tmb_debug(1, \"discard preallocation for group %u\\n\", group);\n\n\tif (list_empty(&grp->bb_prealloc_list))\n\t\treturn 0;\n\n\tbitmap_bh = ext4_read_block_bitmap(sb, group);\n\tif (bitmap_bh == NULL) {\n\t\text4_error(sb, \"Error reading block bitmap for %u\", group);\n\t\treturn 0;\n\t}\n\n\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\tif (err) {\n\t\text4_error(sb, \"Error loading buddy information for %u\", group);\n\t\tput_bh(bitmap_bh);\n\t\treturn 0;\n\t}\n\n\tif (needed == 0)\n\t\tneeded = EXT4_CLUSTERS_PER_GROUP(sb) + 1;\n\n\tINIT_LIST_HEAD(&list);\nrepeat:\n\text4_lock_group(sb, group);\n\tlist_for_each_entry_safe(pa, tmp,\n\t\t\t\t&grp->bb_prealloc_list, pa_group_list) {\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (atomic_read(&pa->pa_count)) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* seems this one can be freed ... */\n\t\tpa->pa_deleted = 1;\n\n\t\t/* we can trust pa_free ... */\n\t\tfree += pa->pa_free;\n\n\t\tspin_unlock(&pa->pa_lock);\n\n\t\tlist_del(&pa->pa_group_list);\n\t\tlist_add(&pa->u.pa_tmp_list, &list);\n\t}\n\n\t/* if we still need more blocks and some PAs were used, try again */\n\tif (free < needed && busy) {\n\t\tbusy = 0;\n\t\text4_unlock_group(sb, group);\n\t\tcond_resched();\n\t\tgoto repeat;\n\t}\n\n\t/* found anything to free? */\n\tif (list_empty(&list)) {\n\t\tBUG_ON(free != 0);\n\t\tgoto out;\n\t}\n\n\t/* now free all selected PAs */\n\tlist_for_each_entry_safe(pa, tmp, &list, u.pa_tmp_list) {\n\n\t\t/* remove from object (inode or locality group) */\n\t\tspin_lock(pa->pa_obj_lock);\n\t\tlist_del_rcu(&pa->pa_inode_list);\n\t\tspin_unlock(pa->pa_obj_lock);\n\n\t\tif (pa->pa_type == MB_GROUP_PA)\n\t\t\text4_mb_release_group_pa(&e4b, pa);\n\t\telse\n\t\t\text4_mb_release_inode_pa(&e4b, bitmap_bh, pa);\n\n\t\tlist_del(&pa->u.pa_tmp_list);\n\t\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n\t}\n\nout:\n\text4_unlock_group(sb, group);\n\text4_mb_unload_buddy(&e4b);\n\tput_bh(bitmap_bh);\n\treturn free;\n}"
  },
  {
    "function_name": "ext4_mb_release_group_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3783-3800",
    "snippet": "static noinline_for_stack int\next4_mb_release_group_pa(struct ext4_buddy *e4b,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\n\ttrace_ext4_mb_release_group_pa(sb, pa);\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tmb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);\n\tatomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);\n\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, pa->pa_len);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_mballoc_discard",
          "args": [
            "sb",
            "NULL",
            "group",
            "bit",
            "pa->pa_len"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "pa->pa_len",
            "&EXT4_SB(sb)->s_mb_discarded"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3796
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_free_blocks",
          "args": [
            "pa->pa_inode",
            "e4b",
            "bit",
            "pa->pa_len"
          ],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "mb_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1406-1488",
          "snippet": "static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "group != e4b->bd_group && pa->pa_len != 0"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "pa->pa_pstart",
            "&group",
            "&bit"
          ],
          "line": 3793
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_deleted == 0"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_mb_release_group_pa",
          "args": [
            "sb",
            "pa"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_release_group_pa(struct ext4_buddy *e4b,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\n\ttrace_ext4_mb_release_group_pa(sb, pa);\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tmb_free_blocks(pa->pa_inode, e4b, bit, pa->pa_len);\n\tatomic_add(pa->pa_len, &EXT4_SB(sb)->s_mb_discarded);\n\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, pa->pa_len);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_release_inode_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3728-3781",
    "snippet": "static noinline_for_stack int\next4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,\n\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int end;\n\tunsigned int next;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\tunsigned long long grp_blk_start;\n\tint err = 0;\n\tint free = 0;\n\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tgrp_blk_start = pa->pa_pstart - EXT4_C2B(sbi, bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tend = bit + pa->pa_len;\n\n\twhile (bit < end) {\n\t\tbit = mb_find_next_zero_bit(bitmap_bh->b_data, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap_bh->b_data, end, bit);\n\t\tmb_debug(1, \"    free preallocated %u/%u in group %u\\n\",\n\t\t\t (unsigned) ext4_group_first_block_no(sb, group) + bit,\n\t\t\t (unsigned) next - bit, (unsigned) group);\n\t\tfree += next - bit;\n\n\t\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, next - bit);\n\t\ttrace_ext4_mb_release_inode_pa(pa, (grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit)),\n\t\t\t\t\t       next - bit);\n\t\tmb_free_blocks(pa->pa_inode, e4b, bit, next - bit);\n\t\tbit = next + 1;\n\t}\n\tif (free != pa->pa_free) {\n\t\text4_msg(e4b->bd_sb, KERN_CRIT,\n\t\t\t \"pa %p: logic %lu, phys. %lu, len %lu\",\n\t\t\t pa, (unsigned long) pa->pa_lstart,\n\t\t\t (unsigned long) pa->pa_pstart,\n\t\t\t (unsigned long) pa->pa_len);\n\t\text4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",\n\t\t\t\t\tfree, pa->pa_free);\n\t\t/*\n\t\t * pa is already deleted so we use the value obtained\n\t\t * from the bitmap and continue.\n\t\t */\n\t}\n\tatomic_add(free, &sbi->s_mb_discarded);\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "free",
            "&sbi->s_mb_discarded"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_locked_error",
          "args": [
            "sb",
            "group",
            "0",
            "0",
            "\"free %u, pa_free %u\"",
            "free",
            "pa->pa_free"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_grp_locked_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "627-677",
          "snippet": "void __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "e4b->bd_sb",
            "KERN_CRIT",
            "\"pa %p: logic %lu, phys. %lu, len %lu\"",
            "pa",
            "(unsigned long) pa->pa_lstart",
            "(unsigned long) pa->pa_pstart",
            "(unsigned long) pa->pa_len"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_free_blocks",
          "args": [
            "pa->pa_inode",
            "e4b",
            "bit",
            "next - bit"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "mb_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1406-1488",
          "snippet": "static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_mb_release_inode_pa",
          "args": [
            "pa",
            "(grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit))",
            "next - bit"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "bit"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_mballoc_discard",
          "args": [
            "sb",
            "NULL",
            "group",
            "bit",
            "next - bit"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"    free preallocated %u/%u in group %u\\n\"",
            "(unsigned) ext4_group_first_block_no(sb, group) + bit",
            "(unsigned) next - bit",
            "(unsigned) group"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 3754
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_next_bit",
          "args": [
            "bitmap_bh->b_data",
            "end",
            "bit"
          ],
          "line": 3752
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_next_zero_bit",
          "args": [
            "bitmap_bh->b_data",
            "end",
            "bit"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "414-425",
          "snippet": "static inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "group != e4b->bd_group && pa->pa_len != 0"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "bit"
          ],
          "line": 3744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "pa->pa_pstart",
            "&group",
            "&bit"
          ],
          "line": 3743
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_deleted == 0"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3733
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,\n\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned int end;\n\tunsigned int next;\n\text4_group_t group;\n\text4_grpblk_t bit;\n\tunsigned long long grp_blk_start;\n\tint err = 0;\n\tint free = 0;\n\n\tBUG_ON(pa->pa_deleted == 0);\n\text4_get_group_no_and_offset(sb, pa->pa_pstart, &group, &bit);\n\tgrp_blk_start = pa->pa_pstart - EXT4_C2B(sbi, bit);\n\tBUG_ON(group != e4b->bd_group && pa->pa_len != 0);\n\tend = bit + pa->pa_len;\n\n\twhile (bit < end) {\n\t\tbit = mb_find_next_zero_bit(bitmap_bh->b_data, end, bit);\n\t\tif (bit >= end)\n\t\t\tbreak;\n\t\tnext = mb_find_next_bit(bitmap_bh->b_data, end, bit);\n\t\tmb_debug(1, \"    free preallocated %u/%u in group %u\\n\",\n\t\t\t (unsigned) ext4_group_first_block_no(sb, group) + bit,\n\t\t\t (unsigned) next - bit, (unsigned) group);\n\t\tfree += next - bit;\n\n\t\ttrace_ext4_mballoc_discard(sb, NULL, group, bit, next - bit);\n\t\ttrace_ext4_mb_release_inode_pa(pa, (grp_blk_start +\n\t\t\t\t\t\t    EXT4_C2B(sbi, bit)),\n\t\t\t\t\t       next - bit);\n\t\tmb_free_blocks(pa->pa_inode, e4b, bit, next - bit);\n\t\tbit = next + 1;\n\t}\n\tif (free != pa->pa_free) {\n\t\text4_msg(e4b->bd_sb, KERN_CRIT,\n\t\t\t \"pa %p: logic %lu, phys. %lu, len %lu\",\n\t\t\t pa, (unsigned long) pa->pa_lstart,\n\t\t\t (unsigned long) pa->pa_pstart,\n\t\t\t (unsigned long) pa->pa_len);\n\t\text4_grp_locked_error(sb, group, 0, 0, \"free %u, pa_free %u\",\n\t\t\t\t\tfree, pa->pa_free);\n\t\t/*\n\t\t * pa is already deleted so we use the value obtained\n\t\t * from the bitmap and continue.\n\t\t */\n\t}\n\tatomic_add(free, &sbi->s_mb_discarded);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_mb_new_preallocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3709-3718",
    "snippet": "static int ext4_mb_new_preallocation(struct ext4_allocation_context *ac)\n{\n\tint err;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\terr = ext4_mb_new_group_pa(ac);\n\telse\n\t\terr = ext4_mb_new_inode_pa(ac);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_new_inode_pa",
          "args": [
            "ac"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_new_inode_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3557-3646",
          "snippet": "static noinline_for_stack int\next4_mb_new_inode_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_inode_info *ei;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ac->ac_b_ex.fe_len < ac->ac_g_ex.fe_len) {\n\t\tint winl;\n\t\tint wins;\n\t\tint win;\n\t\tint offs;\n\n\t\t/* we can't allocate as much as normalizer wants.\n\t\t * so, found space must get proper lstart\n\t\t * to cover original request */\n\t\tBUG_ON(ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical);\n\t\tBUG_ON(ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len);\n\n\t\t/* we're limited by original request in that\n\t\t * logical block must be covered any way\n\t\t * winl is window we can move our chunk within */\n\t\twinl = ac->ac_o_ex.fe_logical - ac->ac_g_ex.fe_logical;\n\n\t\t/* also, we should cover whole original request */\n\t\twins = EXT4_C2B(sbi, ac->ac_b_ex.fe_len - ac->ac_o_ex.fe_len);\n\n\t\t/* the smallest one defines real window */\n\t\twin = min(winl, wins);\n\n\t\toffs = ac->ac_o_ex.fe_logical %\n\t\t\tEXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\tif (offs && offs < win)\n\t\t\twin = offs;\n\n\t\tac->ac_b_ex.fe_logical = ac->ac_o_ex.fe_logical -\n\t\t\tEXT4_NUM_B2C(sbi, win);\n\t\tBUG_ON(ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical);\n\t\tBUG_ON(ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len);\n\t}\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_lstart = ac->ac_b_ex.fe_logical;\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_INODE_PA;\n\n\tmb_debug(1, \"new inode pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_inode_pa(ac, pa);\n\n\text4_mb_use_inode_pa(ac, pa);\n\tatomic_add(pa->pa_free, &sbi->s_mb_preallocated);\n\n\tei = EXT4_I(ac->ac_inode);\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\n\tpa->pa_obj_lock = &ei->i_prealloc_lock;\n\tpa->pa_inode = ac->ac_inode;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_add_rcu(&pa->pa_inode_list, &ei->i_prealloc_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_pspace_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\n\nstatic noinline_for_stack int\next4_mb_new_inode_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_inode_info *ei;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ac->ac_b_ex.fe_len < ac->ac_g_ex.fe_len) {\n\t\tint winl;\n\t\tint wins;\n\t\tint win;\n\t\tint offs;\n\n\t\t/* we can't allocate as much as normalizer wants.\n\t\t * so, found space must get proper lstart\n\t\t * to cover original request */\n\t\tBUG_ON(ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical);\n\t\tBUG_ON(ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len);\n\n\t\t/* we're limited by original request in that\n\t\t * logical block must be covered any way\n\t\t * winl is window we can move our chunk within */\n\t\twinl = ac->ac_o_ex.fe_logical - ac->ac_g_ex.fe_logical;\n\n\t\t/* also, we should cover whole original request */\n\t\twins = EXT4_C2B(sbi, ac->ac_b_ex.fe_len - ac->ac_o_ex.fe_len);\n\n\t\t/* the smallest one defines real window */\n\t\twin = min(winl, wins);\n\n\t\toffs = ac->ac_o_ex.fe_logical %\n\t\t\tEXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\tif (offs && offs < win)\n\t\t\twin = offs;\n\n\t\tac->ac_b_ex.fe_logical = ac->ac_o_ex.fe_logical -\n\t\t\tEXT4_NUM_B2C(sbi, win);\n\t\tBUG_ON(ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical);\n\t\tBUG_ON(ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len);\n\t}\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_lstart = ac->ac_b_ex.fe_logical;\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_INODE_PA;\n\n\tmb_debug(1, \"new inode pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_inode_pa(ac, pa);\n\n\text4_mb_use_inode_pa(ac, pa);\n\tatomic_add(pa->pa_free, &sbi->s_mb_preallocated);\n\n\tei = EXT4_I(ac->ac_inode);\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\n\tpa->pa_obj_lock = &ei->i_prealloc_lock;\n\tpa->pa_inode = ac->ac_inode;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_add_rcu(&pa->pa_inode_list, &ei->i_prealloc_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_new_group_pa",
          "args": [
            "ac"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_new_group_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3651-3707",
          "snippet": "static noinline_for_stack int\next4_mb_new_group_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tBUG_ON(ext4_pspace_cachep == NULL);\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_lstart = pa->pa_pstart;\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_GROUP_PA;\n\n\tmb_debug(1, \"new group pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_group_pa(ac, pa);\n\n\text4_mb_use_group_pa(ac, pa);\n\tatomic_add(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);\n\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\tlg = ac->ac_lg;\n\tBUG_ON(lg == NULL);\n\n\tpa->pa_obj_lock = &lg->lg_prealloc_lock;\n\tpa->pa_inode = NULL;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\t/*\n\t * We will later add the new pa to the right bucket\n\t * after updating the pa_free in ext4_mb_release_context\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_pspace_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_new_group_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tBUG_ON(ext4_pspace_cachep == NULL);\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_lstart = pa->pa_pstart;\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_GROUP_PA;\n\n\tmb_debug(1, \"new group pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_group_pa(ac, pa);\n\n\text4_mb_use_group_pa(ac, pa);\n\tatomic_add(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);\n\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\tlg = ac->ac_lg;\n\tBUG_ON(lg == NULL);\n\n\tpa->pa_obj_lock = &lg->lg_prealloc_lock;\n\tpa->pa_inode = NULL;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\t/*\n\t * We will later add the new pa to the right bucket\n\t * after updating the pa_free in ext4_mb_release_context\n\t */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_new_preallocation(struct ext4_allocation_context *ac)\n{\n\tint err;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC)\n\t\terr = ext4_mb_new_group_pa(ac);\n\telse\n\t\terr = ext4_mb_new_inode_pa(ac);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_mb_new_group_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3651-3707",
    "snippet": "static noinline_for_stack int\next4_mb_new_group_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tBUG_ON(ext4_pspace_cachep == NULL);\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_lstart = pa->pa_pstart;\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_GROUP_PA;\n\n\tmb_debug(1, \"new group pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_group_pa(ac, pa);\n\n\text4_mb_use_group_pa(ac, pa);\n\tatomic_add(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);\n\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\tlg = ac->ac_lg;\n\tBUG_ON(lg == NULL);\n\n\tpa->pa_obj_lock = &lg->lg_prealloc_lock;\n\tpa->pa_inode = NULL;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\t/*\n\t * We will later add the new pa to the right bucket\n\t * after updating the pa_free in ext4_mb_release_context\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_pspace_cachep;",
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pa->pa_group_list",
            "&grp->bb_prealloc_list"
          ],
          "line": 3699
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lg == NULL"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "pa->pa_free",
            "&EXT4_SB(sb)->s_mb_preallocated"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_use_group_pa",
          "args": [
            "ac",
            "pa"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_group_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3280-3299",
          "snippet": "static void ext4_mb_use_group_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tunsigned int len = ac->ac_o_ex.fe_len;\n\n\text4_get_group_no_and_offset(ac->ac_sb, pa->pa_pstart,\n\t\t\t\t\t&ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\t/* we don't correct pa_pstart or pa_plen here to avoid\n\t * possible race when the group is being loaded concurrently\n\t * instead we correct pa later, after blocks are marked\n\t * in on-disk bitmap -- see ext4_mb_release_context()\n\t * Other CPUs are prevented from allocating from this pa by lg_mutex\n\t */\n\tmb_debug(1, \"use %u/%u from group pa %p\\n\", pa->pa_lstart-len, len, pa);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_group_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tunsigned int len = ac->ac_o_ex.fe_len;\n\n\text4_get_group_no_and_offset(ac->ac_sb, pa->pa_pstart,\n\t\t\t\t\t&ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\t/* we don't correct pa_pstart or pa_plen here to avoid\n\t * possible race when the group is being loaded concurrently\n\t * instead we correct pa later, after blocks are marked\n\t * in on-disk bitmap -- see ext4_mb_release_context()\n\t * Other CPUs are prevented from allocating from this pa by lg_mutex\n\t */\n\tmb_debug(1, \"use %u/%u from group pa %p\\n\", pa->pa_lstart-len, len, pa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_mb_new_group_pa",
          "args": [
            "ac",
            "pa"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"new group pa %p: %llu/%u for %u\\n\"",
            "pa",
            "pa->pa_pstart",
            "pa->pa_len",
            "pa->pa_lstart"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pa->pa_group_list"
          ],
          "line": 3680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pa->pa_inode_list"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pa->pa_count",
            "1"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_offs_to_block",
          "args": [
            "sb",
            "&ac->ac_b_ex"
          ],
          "line": 3673
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_grp_offs_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.h",
          "lines": "209-214",
          "snippet": "static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ext4_pspace_cachep",
            "GFP_NOFS"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ext4_pspace_cachep == NULL"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!S_ISREG(ac->ac_inode->i_mode)"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ac->ac_inode->i_mode"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_status != AC_STATUS_FOUND"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_new_group_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tBUG_ON(ext4_pspace_cachep == NULL);\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_lstart = pa->pa_pstart;\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_GROUP_PA;\n\n\tmb_debug(1, \"new group pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_group_pa(ac, pa);\n\n\text4_mb_use_group_pa(ac, pa);\n\tatomic_add(pa->pa_free, &EXT4_SB(sb)->s_mb_preallocated);\n\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\tlg = ac->ac_lg;\n\tBUG_ON(lg == NULL);\n\n\tpa->pa_obj_lock = &lg->lg_prealloc_lock;\n\tpa->pa_inode = NULL;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\t/*\n\t * We will later add the new pa to the right bucket\n\t * after updating the pa_free in ext4_mb_release_context\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_new_inode_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3557-3646",
    "snippet": "static noinline_for_stack int\next4_mb_new_inode_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_inode_info *ei;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ac->ac_b_ex.fe_len < ac->ac_g_ex.fe_len) {\n\t\tint winl;\n\t\tint wins;\n\t\tint win;\n\t\tint offs;\n\n\t\t/* we can't allocate as much as normalizer wants.\n\t\t * so, found space must get proper lstart\n\t\t * to cover original request */\n\t\tBUG_ON(ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical);\n\t\tBUG_ON(ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len);\n\n\t\t/* we're limited by original request in that\n\t\t * logical block must be covered any way\n\t\t * winl is window we can move our chunk within */\n\t\twinl = ac->ac_o_ex.fe_logical - ac->ac_g_ex.fe_logical;\n\n\t\t/* also, we should cover whole original request */\n\t\twins = EXT4_C2B(sbi, ac->ac_b_ex.fe_len - ac->ac_o_ex.fe_len);\n\n\t\t/* the smallest one defines real window */\n\t\twin = min(winl, wins);\n\n\t\toffs = ac->ac_o_ex.fe_logical %\n\t\t\tEXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\tif (offs && offs < win)\n\t\t\twin = offs;\n\n\t\tac->ac_b_ex.fe_logical = ac->ac_o_ex.fe_logical -\n\t\t\tEXT4_NUM_B2C(sbi, win);\n\t\tBUG_ON(ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical);\n\t\tBUG_ON(ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len);\n\t}\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_lstart = ac->ac_b_ex.fe_logical;\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_INODE_PA;\n\n\tmb_debug(1, \"new inode pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_inode_pa(ac, pa);\n\n\text4_mb_use_inode_pa(ac, pa);\n\tatomic_add(pa->pa_free, &sbi->s_mb_preallocated);\n\n\tei = EXT4_I(ac->ac_inode);\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\n\tpa->pa_obj_lock = &ei->i_prealloc_lock;\n\tpa->pa_inode = ac->ac_inode;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_add_rcu(&pa->pa_inode_list, &ei->i_prealloc_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_pspace_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pa->pa_obj_lock"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&pa->pa_inode_list",
            "&ei->i_prealloc_list"
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pa->pa_obj_lock"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&pa->pa_group_list",
            "&grp->bb_prealloc_list"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "ac->ac_inode"
          ],
          "line": 3631
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "pa->pa_free",
            "&sbi->s_mb_preallocated"
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_use_inode_pa",
          "args": [
            "ac",
            "pa"
          ],
          "line": 3628
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_inode_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3250-3275",
          "snippet": "static void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\text4_fsblk_t end;\n\tint len;\n\n\t/* found preallocated blocks, use them */\n\tstart = pa->pa_pstart + (ac->ac_o_ex.fe_logical - pa->pa_lstart);\n\tend = min(pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len),\n\t\t  start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len));\n\tlen = EXT4_NUM_B2C(sbi, end - start);\n\text4_get_group_no_and_offset(ac->ac_sb, start, &ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\tBUG_ON(start < pa->pa_pstart);\n\tBUG_ON(end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len));\n\tBUG_ON(pa->pa_free < len);\n\tpa->pa_free -= len;\n\n\tmb_debug(1, \"use %llu/%u from inode pa %p\\n\", start, len, pa);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\text4_fsblk_t end;\n\tint len;\n\n\t/* found preallocated blocks, use them */\n\tstart = pa->pa_pstart + (ac->ac_o_ex.fe_logical - pa->pa_lstart);\n\tend = min(pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len),\n\t\t  start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len));\n\tlen = EXT4_NUM_B2C(sbi, end - start);\n\text4_get_group_no_and_offset(ac->ac_sb, start, &ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\tBUG_ON(start < pa->pa_pstart);\n\tBUG_ON(end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len));\n\tBUG_ON(pa->pa_free < len);\n\tpa->pa_free -= len;\n\n\tmb_debug(1, \"use %llu/%u from inode pa %p\\n\", start, len, pa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_mb_new_inode_pa",
          "args": [
            "ac",
            "pa"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"new inode pa %p: %llu/%u for %u\\n\"",
            "pa",
            "pa->pa_pstart",
            "pa->pa_len",
            "pa->pa_lstart"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pa->pa_group_list"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pa->pa_inode_list"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pa->pa_count",
            "1"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_offs_to_block",
          "args": [
            "sb",
            "&ac->ac_b_ex"
          ],
          "line": 3614
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_grp_offs_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.h",
          "lines": "209-214",
          "snippet": "static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len"
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "win"
          ],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ac->ac_b_ex.fe_len"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "winl",
            "wins"
          ],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "286-293",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ac->ac_b_ex.fe_len - ac->ac_o_ex.fe_len"
          ],
          "line": 3593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len"
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ext4_pspace_cachep",
            "GFP_NOFS"
          ],
          "line": 3571
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!S_ISREG(ac->ac_inode->i_mode)"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ac->ac_inode->i_mode"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_status != AC_STATUS_FOUND"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\n\nstatic noinline_for_stack int\next4_mb_new_inode_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_inode_info *ei;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ac->ac_b_ex.fe_len < ac->ac_g_ex.fe_len) {\n\t\tint winl;\n\t\tint wins;\n\t\tint win;\n\t\tint offs;\n\n\t\t/* we can't allocate as much as normalizer wants.\n\t\t * so, found space must get proper lstart\n\t\t * to cover original request */\n\t\tBUG_ON(ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical);\n\t\tBUG_ON(ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len);\n\n\t\t/* we're limited by original request in that\n\t\t * logical block must be covered any way\n\t\t * winl is window we can move our chunk within */\n\t\twinl = ac->ac_o_ex.fe_logical - ac->ac_g_ex.fe_logical;\n\n\t\t/* also, we should cover whole original request */\n\t\twins = EXT4_C2B(sbi, ac->ac_b_ex.fe_len - ac->ac_o_ex.fe_len);\n\n\t\t/* the smallest one defines real window */\n\t\twin = min(winl, wins);\n\n\t\toffs = ac->ac_o_ex.fe_logical %\n\t\t\tEXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\tif (offs && offs < win)\n\t\t\twin = offs;\n\n\t\tac->ac_b_ex.fe_logical = ac->ac_o_ex.fe_logical -\n\t\t\tEXT4_NUM_B2C(sbi, win);\n\t\tBUG_ON(ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical);\n\t\tBUG_ON(ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len);\n\t}\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_lstart = ac->ac_b_ex.fe_logical;\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_INODE_PA;\n\n\tmb_debug(1, \"new inode pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_inode_pa(ac, pa);\n\n\text4_mb_use_inode_pa(ac, pa);\n\tatomic_add(pa->pa_free, &sbi->s_mb_preallocated);\n\n\tei = EXT4_I(ac->ac_inode);\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\n\tpa->pa_obj_lock = &ei->i_prealloc_lock;\n\tpa->pa_inode = ac->ac_inode;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_add_rcu(&pa->pa_inode_list, &ei->i_prealloc_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_put_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3498-3552",
    "snippet": "static void ext4_mb_put_pa(struct ext4_allocation_context *ac,\n\t\t\tstruct super_block *sb, struct ext4_prealloc_space *pa)\n{\n\text4_group_t grp;\n\text4_fsblk_t grp_blk;\n\n\t/* in this short window concurrent discard can set pa_deleted */\n\tspin_lock(&pa->pa_lock);\n\tif (!atomic_dec_and_test(&pa->pa_count) || pa->pa_free != 0) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tif (pa->pa_deleted == 1) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tpa->pa_deleted = 1;\n\tspin_unlock(&pa->pa_lock);\n\n\tgrp_blk = pa->pa_pstart;\n\t/*\n\t * If doing group-based preallocation, pa_pstart may be in the\n\t * next group when pa is used up\n\t */\n\tif (pa->pa_type == MB_GROUP_PA)\n\t\tgrp_blk--;\n\n\tgrp = ext4_get_group_number(sb, grp_blk);\n\n\t/*\n\t * possible race:\n\t *\n\t *  P1 (buddy init)\t\t\tP2 (regular allocation)\n\t *\t\t\t\t\tfind block B in PA\n\t *  copy on-disk bitmap to buddy\n\t *  \t\t\t\t\tmark B in on-disk bitmap\n\t *\t\t\t\t\tdrop PA from group\n\t *  mark all PAs in buddy\n\t *\n\t * thus, P1 initializes buddy with B available. to prevent this\n\t * we make \"copy\" and \"mark all PAs\" atomic and serialize \"drop PA\"\n\t * against that pair\n\t */\n\text4_lock_group(sb, grp);\n\tlist_del(&pa->pa_group_list);\n\text4_unlock_group(sb, grp);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_del_rcu(&pa->pa_inode_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&(pa)->u.pa_rcu",
            "ext4_mb_pa_callback"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "pa->pa_obj_lock"
          ],
          "line": 3549
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&pa->pa_inode_list"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "pa->pa_obj_lock"
          ],
          "line": 3547
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "grp"
          ],
          "line": 3545
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pa->pa_group_list"
          ],
          "line": 3544
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "316-328",
          "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "grp"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_number",
          "args": [
            "sb",
            "grp_blk"
          ],
          "line": 3527
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "35-47",
          "snippet": "ext4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_group_t ext4_get_group_number(struct super_block *sb,\n\t\t\t\t   ext4_fsblk_t block)\n{\n\text4_group_t group;\n\n\tif (test_opt2(sb, STD_GROUP_SIZE))\n\t\tgroup = (block -\n\t\t\t le32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block)) >>\n\t\t\t(EXT4_BLOCK_SIZE_BITS(sb) + EXT4_CLUSTER_BITS(sb) + 3);\n\telse\n\t\text4_get_group_no_and_offset(sb, block, &group, NULL);\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&pa->pa_count"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_put_pa(struct ext4_allocation_context *ac,\n\t\t\tstruct super_block *sb, struct ext4_prealloc_space *pa)\n{\n\text4_group_t grp;\n\text4_fsblk_t grp_blk;\n\n\t/* in this short window concurrent discard can set pa_deleted */\n\tspin_lock(&pa->pa_lock);\n\tif (!atomic_dec_and_test(&pa->pa_count) || pa->pa_free != 0) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tif (pa->pa_deleted == 1) {\n\t\tspin_unlock(&pa->pa_lock);\n\t\treturn;\n\t}\n\n\tpa->pa_deleted = 1;\n\tspin_unlock(&pa->pa_lock);\n\n\tgrp_blk = pa->pa_pstart;\n\t/*\n\t * If doing group-based preallocation, pa_pstart may be in the\n\t * next group when pa is used up\n\t */\n\tif (pa->pa_type == MB_GROUP_PA)\n\t\tgrp_blk--;\n\n\tgrp = ext4_get_group_number(sb, grp_blk);\n\n\t/*\n\t * possible race:\n\t *\n\t *  P1 (buddy init)\t\t\tP2 (regular allocation)\n\t *\t\t\t\t\tfind block B in PA\n\t *  copy on-disk bitmap to buddy\n\t *  \t\t\t\t\tmark B in on-disk bitmap\n\t *\t\t\t\t\tdrop PA from group\n\t *  mark all PAs in buddy\n\t *\n\t * thus, P1 initializes buddy with B available. to prevent this\n\t * we make \"copy\" and \"mark all PAs\" atomic and serialize \"drop PA\"\n\t * against that pair\n\t */\n\text4_lock_group(sb, grp);\n\tlist_del(&pa->pa_group_list);\n\text4_unlock_group(sb, grp);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_del_rcu(&pa->pa_inode_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\tcall_rcu(&(pa)->u.pa_rcu, ext4_mb_pa_callback);\n}"
  },
  {
    "function_name": "ext4_mb_pa_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3484-3492",
    "snippet": "static void ext4_mb_pa_callback(struct rcu_head *head)\n{\n\tstruct ext4_prealloc_space *pa;\n\tpa = container_of(head, struct ext4_prealloc_space, u.pa_rcu);\n\n\tBUG_ON(atomic_read(&pa->pa_count));\n\tBUG_ON(pa->pa_deleted == 0);\n\tkmem_cache_free(ext4_pspace_cachep, pa);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_pspace_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_pspace_cachep",
            "pa"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_deleted == 0"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&pa->pa_count)"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pa->pa_count"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structext4_prealloc_space",
            "u.pa_rcu"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\n\nstatic void ext4_mb_pa_callback(struct rcu_head *head)\n{\n\tstruct ext4_prealloc_space *pa;\n\tpa = container_of(head, struct ext4_prealloc_space, u.pa_rcu);\n\n\tBUG_ON(atomic_read(&pa->pa_count));\n\tBUG_ON(pa->pa_deleted == 0);\n\tkmem_cache_free(ext4_pspace_cachep, pa);\n}"
  },
  {
    "function_name": "ext4_mb_generate_from_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3448-3482",
    "snippet": "static noinline_for_stack\nvoid ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur;\n\text4_group_t groupnr;\n\text4_grpblk_t start;\n\tint preallocated = 0;\n\tint len;\n\n\t/* all form of preallocation discards first load group,\n\t * so the only competing code is preallocation use.\n\t * we don't need any locking here\n\t * notice we do NOT ignore preallocations with pa_deleted\n\t * otherwise we could leave used blocks available for\n\t * allocation in buddy when concurrent ext4_mb_put_pa()\n\t * is dropping preallocation\n\t */\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tspin_lock(&pa->pa_lock);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t     &groupnr, &start);\n\t\tlen = pa->pa_len;\n\t\tspin_unlock(&pa->pa_lock);\n\t\tif (unlikely(len == 0))\n\t\t\tcontinue;\n\t\tBUG_ON(groupnr != group);\n\t\text4_set_bits(bitmap, start, len);\n\t\tpreallocated += len;\n\t}\n\tmb_debug(1, \"prellocated %u for group %u\\n\", preallocated, group);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"prellocated %u for group %u\\n\"",
            "preallocated",
            "group"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bits",
          "args": [
            "bitmap",
            "start",
            "len"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1314-1330",
          "snippet": "void ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "groupnr != group"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "len == 0"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3474
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "pa->pa_pstart",
            "&groupnr",
            "&start"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3470
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur",
            "structext4_prealloc_space",
            "pa_group_list"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "cur",
            "&grp->bb_prealloc_list"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur;\n\text4_group_t groupnr;\n\text4_grpblk_t start;\n\tint preallocated = 0;\n\tint len;\n\n\t/* all form of preallocation discards first load group,\n\t * so the only competing code is preallocation use.\n\t * we don't need any locking here\n\t * notice we do NOT ignore preallocations with pa_deleted\n\t * otherwise we could leave used blocks available for\n\t * allocation in buddy when concurrent ext4_mb_put_pa()\n\t * is dropping preallocation\n\t */\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tspin_lock(&pa->pa_lock);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t     &groupnr, &start);\n\t\tlen = pa->pa_len;\n\t\tspin_unlock(&pa->pa_lock);\n\t\tif (unlikely(len == 0))\n\t\t\tcontinue;\n\t\tBUG_ON(groupnr != group);\n\t\text4_set_bits(bitmap, start, len);\n\t\tpreallocated += len;\n\t}\n\tmb_debug(1, \"prellocated %u for group %u\\n\", preallocated, group);\n}"
  },
  {
    "function_name": "ext4_mb_generate_from_freelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3425-3441",
    "snippet": "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group)\n{\n\tstruct rb_node *n;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_free_data *entry;\n\n\tgrp = ext4_get_group_info(sb, group);\n\tn = rb_first(&(grp->bb_free_root));\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_free_data, efd_node);\n\t\text4_set_bits(bitmap, entry->efd_start_cluster, entry->efd_count);\n\t\tn = rb_next(n);\n\t}\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bits",
          "args": [
            "bitmap",
            "entry->efd_start_cluster",
            "entry->efd_count"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1314-1330",
          "snippet": "void ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structext4_free_data",
            "efd_node"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&(grp->bb_free_root)"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group)\n{\n\tstruct rb_node *n;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_free_data *entry;\n\n\tgrp = ext4_get_group_info(sb, group);\n\tn = rb_first(&(grp->bb_free_root));\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_free_data, efd_node);\n\t\text4_set_bits(bitmap, entry->efd_start_cluster, entry->efd_count);\n\t\tn = rb_next(n);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "ext4_mb_use_preallocated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3333-3417",
    "snippet": "static noinline_for_stack int\next4_mb_use_preallocated(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint order, i;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa, *cpa = NULL;\n\text4_fsblk_t goal_block;\n\n\t/* only data can be preallocated */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn 0;\n\n\t/* first, try per-file preallocation */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\n\t\t/* all fields in this condition don't change,\n\t\t * so we can skip locking for them */\n\t\tif (ac->ac_o_ex.fe_logical < pa->pa_lstart ||\n\t\t    ac->ac_o_ex.fe_logical >= (pa->pa_lstart +\n\t\t\t\t\t       EXT4_C2B(sbi, pa->pa_len)))\n\t\t\tcontinue;\n\n\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)) &&\n\t\t    (pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len) >\n\t\t     EXT4_MAX_BLOCK_FILE_PHYS))\n\t\t\tcontinue;\n\n\t\t/* found preallocated blocks, use them */\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0 && pa->pa_free) {\n\t\t\tatomic_inc(&pa->pa_count);\n\t\t\text4_mb_use_inode_pa(ac, pa);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tac->ac_criteria = 10;\n\t\t\trcu_read_unlock();\n\t\t\treturn 1;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\t/* can we use group allocation? */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC))\n\t\treturn 0;\n\n\t/* inode may have no locality group for some reason */\n\tlg = ac->ac_lg;\n\tif (lg == NULL)\n\t\treturn 0;\n\torder  = fls(ac->ac_o_ex.fe_len) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\n\tgoal_block = ext4_grp_offs_to_block(ac->ac_sb, &ac->ac_g_ex);\n\t/*\n\t * search for the prealloc space that is having\n\t * minimal distance from the goal block.\n\t */\n\tfor (i = order; i < PREALLOC_TB_SIZE; i++) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[i],\n\t\t\t\t\tpa_inode_list) {\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tif (pa->pa_deleted == 0 &&\n\t\t\t\t\tpa->pa_free >= ac->ac_o_ex.fe_len) {\n\n\t\t\t\tcpa = ext4_mb_check_group_pa(goal_block,\n\t\t\t\t\t\t\t\tpa, cpa);\n\t\t\t}\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (cpa) {\n\t\text4_mb_use_group_pa(ac, cpa);\n\t\tac->ac_criteria = 20;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_use_group_pa",
          "args": [
            "ac",
            "cpa"
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_group_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3280-3299",
          "snippet": "static void ext4_mb_use_group_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tunsigned int len = ac->ac_o_ex.fe_len;\n\n\text4_get_group_no_and_offset(ac->ac_sb, pa->pa_pstart,\n\t\t\t\t\t&ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\t/* we don't correct pa_pstart or pa_plen here to avoid\n\t * possible race when the group is being loaded concurrently\n\t * instead we correct pa later, after blocks are marked\n\t * in on-disk bitmap -- see ext4_mb_release_context()\n\t * Other CPUs are prevented from allocating from this pa by lg_mutex\n\t */\n\tmb_debug(1, \"use %u/%u from group pa %p\\n\", pa->pa_lstart-len, len, pa);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_group_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tunsigned int len = ac->ac_o_ex.fe_len;\n\n\text4_get_group_no_and_offset(ac->ac_sb, pa->pa_pstart,\n\t\t\t\t\t&ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\t/* we don't correct pa_pstart or pa_plen here to avoid\n\t * possible race when the group is being loaded concurrently\n\t * instead we correct pa later, after blocks are marked\n\t * in on-disk bitmap -- see ext4_mb_release_context()\n\t * Other CPUs are prevented from allocating from this pa by lg_mutex\n\t */\n\tmb_debug(1, \"use %u/%u from group pa %p\\n\", pa->pa_lstart-len, len, pa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_check_group_pa",
          "args": [
            "goal_block",
            "pa",
            "cpa"
          ],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_check_group_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3307-3328",
          "snippet": "static struct ext4_prealloc_space *\next4_mb_check_group_pa(ext4_fsblk_t goal_block,\n\t\t\tstruct ext4_prealloc_space *pa,\n\t\t\tstruct ext4_prealloc_space *cpa)\n{\n\text4_fsblk_t cur_distance, new_distance;\n\n\tif (cpa == NULL) {\n\t\tatomic_inc(&pa->pa_count);\n\t\treturn pa;\n\t}\n\tcur_distance = abs(goal_block - cpa->pa_pstart);\n\tnew_distance = abs(goal_block - pa->pa_pstart);\n\n\tif (cur_distance <= new_distance)\n\t\treturn cpa;\n\n\t/* drop the previous reference */\n\tatomic_dec(&cpa->pa_count);\n\tatomic_inc(&pa->pa_count);\n\treturn pa;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct ext4_prealloc_space *\next4_mb_check_group_pa(ext4_fsblk_t goal_block,\n\t\t\tstruct ext4_prealloc_space *pa,\n\t\t\tstruct ext4_prealloc_space *cpa)\n{\n\text4_fsblk_t cur_distance, new_distance;\n\n\tif (cpa == NULL) {\n\t\tatomic_inc(&pa->pa_count);\n\t\treturn pa;\n\t}\n\tcur_distance = abs(goal_block - cpa->pa_pstart);\n\tnew_distance = abs(goal_block - pa->pa_pstart);\n\n\tif (cur_distance <= new_distance)\n\t\treturn cpa;\n\n\t/* drop the previous reference */\n\tatomic_dec(&cpa->pa_count);\n\tatomic_inc(&pa->pa_count);\n\treturn pa;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "pa",
            "&lg->lg_prealloc_list[i]",
            "pa_inode_list"
          ],
          "line": 3398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_offs_to_block",
          "args": [
            "ac->ac_sb",
            "&ac->ac_g_ex"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_grp_offs_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.h",
          "lines": "209-214",
          "snippet": "static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "ac->ac_o_ex.fe_len"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_use_inode_pa",
          "args": [
            "ac",
            "pa"
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_inode_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3250-3275",
          "snippet": "static void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\text4_fsblk_t end;\n\tint len;\n\n\t/* found preallocated blocks, use them */\n\tstart = pa->pa_pstart + (ac->ac_o_ex.fe_logical - pa->pa_lstart);\n\tend = min(pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len),\n\t\t  start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len));\n\tlen = EXT4_NUM_B2C(sbi, end - start);\n\text4_get_group_no_and_offset(ac->ac_sb, start, &ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\tBUG_ON(start < pa->pa_pstart);\n\tBUG_ON(end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len));\n\tBUG_ON(pa->pa_free < len);\n\tpa->pa_free -= len;\n\n\tmb_debug(1, \"use %llu/%u from inode pa %p\\n\", start, len, pa);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\text4_fsblk_t end;\n\tint len;\n\n\t/* found preallocated blocks, use them */\n\tstart = pa->pa_pstart + (ac->ac_o_ex.fe_logical - pa->pa_lstart);\n\tend = min(pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len),\n\t\t  start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len));\n\tlen = EXT4_NUM_B2C(sbi, end - start);\n\text4_get_group_no_and_offset(ac->ac_sb, start, &ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\tBUG_ON(start < pa->pa_pstart);\n\tBUG_ON(end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len));\n\tBUG_ON(pa->pa_free < len);\n\tpa->pa_free -= len;\n\n\tmb_debug(1, \"use %llu/%u from inode pa %p\\n\", start, len, pa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pa->pa_count"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "pa->pa_len"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "ac->ac_inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "pa->pa_len"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "pa",
            "&ei->i_prealloc_list",
            "pa_inode_list"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "ac->ac_inode"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_use_preallocated(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint order, i;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_locality_group *lg;\n\tstruct ext4_prealloc_space *pa, *cpa = NULL;\n\text4_fsblk_t goal_block;\n\n\t/* only data can be preallocated */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn 0;\n\n\t/* first, try per-file preallocation */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\n\t\t/* all fields in this condition don't change,\n\t\t * so we can skip locking for them */\n\t\tif (ac->ac_o_ex.fe_logical < pa->pa_lstart ||\n\t\t    ac->ac_o_ex.fe_logical >= (pa->pa_lstart +\n\t\t\t\t\t       EXT4_C2B(sbi, pa->pa_len)))\n\t\t\tcontinue;\n\n\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)) &&\n\t\t    (pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len) >\n\t\t     EXT4_MAX_BLOCK_FILE_PHYS))\n\t\t\tcontinue;\n\n\t\t/* found preallocated blocks, use them */\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0 && pa->pa_free) {\n\t\t\tatomic_inc(&pa->pa_count);\n\t\t\text4_mb_use_inode_pa(ac, pa);\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tac->ac_criteria = 10;\n\t\t\trcu_read_unlock();\n\t\t\treturn 1;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\t/* can we use group allocation? */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC))\n\t\treturn 0;\n\n\t/* inode may have no locality group for some reason */\n\tlg = ac->ac_lg;\n\tif (lg == NULL)\n\t\treturn 0;\n\torder  = fls(ac->ac_o_ex.fe_len) - 1;\n\tif (order > PREALLOC_TB_SIZE - 1)\n\t\t/* The max size of hash table is PREALLOC_TB_SIZE */\n\t\torder = PREALLOC_TB_SIZE - 1;\n\n\tgoal_block = ext4_grp_offs_to_block(ac->ac_sb, &ac->ac_g_ex);\n\t/*\n\t * search for the prealloc space that is having\n\t * minimal distance from the goal block.\n\t */\n\tfor (i = order; i < PREALLOC_TB_SIZE; i++) {\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(pa, &lg->lg_prealloc_list[i],\n\t\t\t\t\tpa_inode_list) {\n\t\t\tspin_lock(&pa->pa_lock);\n\t\t\tif (pa->pa_deleted == 0 &&\n\t\t\t\t\tpa->pa_free >= ac->ac_o_ex.fe_len) {\n\n\t\t\t\tcpa = ext4_mb_check_group_pa(goal_block,\n\t\t\t\t\t\t\t\tpa, cpa);\n\t\t\t}\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tif (cpa) {\n\t\text4_mb_use_group_pa(ac, cpa);\n\t\tac->ac_criteria = 20;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_check_group_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3307-3328",
    "snippet": "static struct ext4_prealloc_space *\next4_mb_check_group_pa(ext4_fsblk_t goal_block,\n\t\t\tstruct ext4_prealloc_space *pa,\n\t\t\tstruct ext4_prealloc_space *cpa)\n{\n\text4_fsblk_t cur_distance, new_distance;\n\n\tif (cpa == NULL) {\n\t\tatomic_inc(&pa->pa_count);\n\t\treturn pa;\n\t}\n\tcur_distance = abs(goal_block - cpa->pa_pstart);\n\tnew_distance = abs(goal_block - pa->pa_pstart);\n\n\tif (cur_distance <= new_distance)\n\t\treturn cpa;\n\n\t/* drop the previous reference */\n\tatomic_dec(&cpa->pa_count);\n\tatomic_inc(&pa->pa_count);\n\treturn pa;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pa->pa_count"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&cpa->pa_count"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "goal_block - pa->pa_pstart"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "goal_block - cpa->pa_pstart"
          ],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&pa->pa_count"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct ext4_prealloc_space *\next4_mb_check_group_pa(ext4_fsblk_t goal_block,\n\t\t\tstruct ext4_prealloc_space *pa,\n\t\t\tstruct ext4_prealloc_space *cpa)\n{\n\text4_fsblk_t cur_distance, new_distance;\n\n\tif (cpa == NULL) {\n\t\tatomic_inc(&pa->pa_count);\n\t\treturn pa;\n\t}\n\tcur_distance = abs(goal_block - cpa->pa_pstart);\n\tnew_distance = abs(goal_block - pa->pa_pstart);\n\n\tif (cur_distance <= new_distance)\n\t\treturn cpa;\n\n\t/* drop the previous reference */\n\tatomic_dec(&cpa->pa_count);\n\tatomic_inc(&pa->pa_count);\n\treturn pa;\n}"
  },
  {
    "function_name": "ext4_mb_use_group_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3280-3299",
    "snippet": "static void ext4_mb_use_group_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tunsigned int len = ac->ac_o_ex.fe_len;\n\n\text4_get_group_no_and_offset(ac->ac_sb, pa->pa_pstart,\n\t\t\t\t\t&ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\t/* we don't correct pa_pstart or pa_plen here to avoid\n\t * possible race when the group is being loaded concurrently\n\t * instead we correct pa later, after blocks are marked\n\t * in on-disk bitmap -- see ext4_mb_release_context()\n\t * Other CPUs are prevented from allocating from this pa by lg_mutex\n\t */\n\tmb_debug(1, \"use %u/%u from group pa %p\\n\", pa->pa_lstart-len, len, pa);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"use %u/%u from group pa %p\\n\"",
            "pa->pa_lstart-len",
            "len",
            "pa"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "ac->ac_sb",
            "pa->pa_pstart",
            "&ac->ac_b_ex.fe_group",
            "&ac->ac_b_ex.fe_start"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_group_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tunsigned int len = ac->ac_o_ex.fe_len;\n\n\text4_get_group_no_and_offset(ac->ac_sb, pa->pa_pstart,\n\t\t\t\t\t&ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\t/* we don't correct pa_pstart or pa_plen here to avoid\n\t * possible race when the group is being loaded concurrently\n\t * instead we correct pa later, after blocks are marked\n\t * in on-disk bitmap -- see ext4_mb_release_context()\n\t * Other CPUs are prevented from allocating from this pa by lg_mutex\n\t */\n\tmb_debug(1, \"use %u/%u from group pa %p\\n\", pa->pa_lstart-len, len, pa);\n}"
  },
  {
    "function_name": "ext4_mb_use_inode_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3250-3275",
    "snippet": "static void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\text4_fsblk_t end;\n\tint len;\n\n\t/* found preallocated blocks, use them */\n\tstart = pa->pa_pstart + (ac->ac_o_ex.fe_logical - pa->pa_lstart);\n\tend = min(pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len),\n\t\t  start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len));\n\tlen = EXT4_NUM_B2C(sbi, end - start);\n\text4_get_group_no_and_offset(ac->ac_sb, start, &ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\tBUG_ON(start < pa->pa_pstart);\n\tBUG_ON(end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len));\n\tBUG_ON(pa->pa_free < len);\n\tpa->pa_free -= len;\n\n\tmb_debug(1, \"use %llu/%u from inode pa %p\\n\", start, len, pa);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"use %llu/%u from inode pa %p\\n\"",
            "start",
            "len",
            "pa"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_free < len"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len)"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "pa->pa_len"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start < pa->pa_pstart"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "ac->ac_sb",
            "start",
            "&ac->ac_b_ex.fe_group",
            "&ac->ac_b_ex.fe_start"
          ],
          "line": 3263
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "end - start"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len)",
            "start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len)"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "286-293",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ac->ac_o_ex.fe_len"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "pa->pa_len"
          ],
          "line": 3260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_use_inode_pa(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_prealloc_space *pa)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\text4_fsblk_t start;\n\text4_fsblk_t end;\n\tint len;\n\n\t/* found preallocated blocks, use them */\n\tstart = pa->pa_pstart + (ac->ac_o_ex.fe_logical - pa->pa_lstart);\n\tend = min(pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len),\n\t\t  start + EXT4_C2B(sbi, ac->ac_o_ex.fe_len));\n\tlen = EXT4_NUM_B2C(sbi, end - start);\n\text4_get_group_no_and_offset(ac->ac_sb, start, &ac->ac_b_ex.fe_group,\n\t\t\t\t\t&ac->ac_b_ex.fe_start);\n\tac->ac_b_ex.fe_len = len;\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_pa = pa;\n\n\tBUG_ON(start < pa->pa_pstart);\n\tBUG_ON(end > pa->pa_pstart + EXT4_C2B(sbi, pa->pa_len));\n\tBUG_ON(pa->pa_free < len);\n\tpa->pa_free -= len;\n\n\tmb_debug(1, \"use %llu/%u from inode pa %p\\n\", start, len, pa);\n}"
  },
  {
    "function_name": "ext4_discard_allocated_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3217-3245",
    "snippet": "static void ext4_discard_allocated_blocks(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (pa == NULL) {\n\t\tif (ac->ac_f_ex.fe_len == 0)\n\t\t\treturn;\n\t\terr = ext4_mb_load_buddy(ac->ac_sb, ac->ac_f_ex.fe_group, &e4b);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * This should never happen since we pin the\n\t\t\t * pages in the ext4_allocation_context so\n\t\t\t * ext4_mb_load_buddy() should never fail.\n\t\t\t */\n\t\t\tWARN(1, \"mb_load_buddy failed (%d)\", err);\n\t\t\treturn;\n\t\t}\n\t\text4_lock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\tmb_free_blocks(ac->ac_inode, &e4b, ac->ac_f_ex.fe_start,\n\t\t\t       ac->ac_f_ex.fe_len);\n\t\text4_unlock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\text4_mb_unload_buddy(&e4b);\n\t\treturn;\n\t}\n\tif (pa->pa_type == MB_INODE_PA)\n\t\tpa->pa_free += ac->ac_b_ex.fe_len;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "ac->ac_sb",
            "ac->ac_f_ex.fe_group"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_free_blocks",
          "args": [
            "ac->ac_inode",
            "&e4b",
            "ac->ac_f_ex.fe_start",
            "ac->ac_f_ex.fe_len"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "mb_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1406-1488",
          "snippet": "static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "ac->ac_sb",
            "ac->ac_f_ex.fe_group"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"mb_load_buddy failed (%d)\"",
            "err"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "ac->ac_sb",
            "ac->ac_f_ex.fe_group",
            "&e4b"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_discard_allocated_blocks(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_prealloc_space *pa = ac->ac_pa;\n\tstruct ext4_buddy e4b;\n\tint err;\n\n\tif (pa == NULL) {\n\t\tif (ac->ac_f_ex.fe_len == 0)\n\t\t\treturn;\n\t\terr = ext4_mb_load_buddy(ac->ac_sb, ac->ac_f_ex.fe_group, &e4b);\n\t\tif (err) {\n\t\t\t/*\n\t\t\t * This should never happen since we pin the\n\t\t\t * pages in the ext4_allocation_context so\n\t\t\t * ext4_mb_load_buddy() should never fail.\n\t\t\t */\n\t\t\tWARN(1, \"mb_load_buddy failed (%d)\", err);\n\t\t\treturn;\n\t\t}\n\t\text4_lock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\tmb_free_blocks(ac->ac_inode, &e4b, ac->ac_f_ex.fe_start,\n\t\t\t       ac->ac_f_ex.fe_len);\n\t\text4_unlock_group(ac->ac_sb, ac->ac_f_ex.fe_group);\n\t\text4_mb_unload_buddy(&e4b);\n\t\treturn;\n\t}\n\tif (pa->pa_type == MB_INODE_PA)\n\t\tpa->pa_free += ac->ac_b_ex.fe_len;\n}"
  },
  {
    "function_name": "ext4_mb_collect_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3188-3209",
    "snippet": "static void ext4_mb_collect_stats(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\n\tif (sbi->s_mb_stats && ac->ac_g_ex.fe_len > 1) {\n\t\tatomic_inc(&sbi->s_bal_reqs);\n\t\tatomic_add(ac->ac_b_ex.fe_len, &sbi->s_bal_allocated);\n\t\tif (ac->ac_b_ex.fe_len >= ac->ac_o_ex.fe_len)\n\t\t\tatomic_inc(&sbi->s_bal_success);\n\t\tatomic_add(ac->ac_found, &sbi->s_bal_ex_scanned);\n\t\tif (ac->ac_g_ex.fe_start == ac->ac_b_ex.fe_start &&\n\t\t\t\tac->ac_g_ex.fe_group == ac->ac_b_ex.fe_group)\n\t\t\tatomic_inc(&sbi->s_bal_goals);\n\t\tif (ac->ac_found > sbi->s_mb_max_to_scan)\n\t\t\tatomic_inc(&sbi->s_bal_breaks);\n\t}\n\n\tif (ac->ac_op == EXT4_MB_HISTORY_ALLOC)\n\t\ttrace_ext4_mballoc_alloc(ac);\n\telse\n\t\ttrace_ext4_mballoc_prealloc(ac);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ext4_mballoc_prealloc",
          "args": [
            "ac"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_mballoc_alloc",
          "args": [
            "ac"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sbi->s_bal_breaks"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sbi->s_bal_goals"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "ac->ac_found",
            "&sbi->s_bal_ex_scanned"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sbi->s_bal_success"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "ac->ac_b_ex.fe_len",
            "&sbi->s_bal_allocated"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sbi->s_bal_reqs"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_collect_stats(struct ext4_allocation_context *ac)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\n\tif (sbi->s_mb_stats && ac->ac_g_ex.fe_len > 1) {\n\t\tatomic_inc(&sbi->s_bal_reqs);\n\t\tatomic_add(ac->ac_b_ex.fe_len, &sbi->s_bal_allocated);\n\t\tif (ac->ac_b_ex.fe_len >= ac->ac_o_ex.fe_len)\n\t\t\tatomic_inc(&sbi->s_bal_success);\n\t\tatomic_add(ac->ac_found, &sbi->s_bal_ex_scanned);\n\t\tif (ac->ac_g_ex.fe_start == ac->ac_b_ex.fe_start &&\n\t\t\t\tac->ac_g_ex.fe_group == ac->ac_b_ex.fe_group)\n\t\t\tatomic_inc(&sbi->s_bal_goals);\n\t\tif (ac->ac_found > sbi->s_mb_max_to_scan)\n\t\t\tatomic_inc(&sbi->s_bal_breaks);\n\t}\n\n\tif (ac->ac_op == EXT4_MB_HISTORY_ALLOC)\n\t\ttrace_ext4_mballoc_alloc(ac);\n\telse\n\t\ttrace_ext4_mballoc_prealloc(ac);\n}"
  },
  {
    "function_name": "ext4_mb_normalize_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "3000-3186",
    "snippet": "static noinline_for_stack void\next4_mb_normalize_request(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits, max;\n\text4_lblk_t end;\n\tloff_t size, start_off;\n\tloff_t orig_size __maybe_unused;\n\text4_lblk_t start;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_prealloc_space *pa;\n\n\t/* do normalize only data requests, metadata requests\n\t   do not need preallocation */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\t/* sometime caller may want exact blocks */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\t/* caller may indicate that preallocation isn't\n\t * required (it's a tail, for example) */\n\tif (ac->ac_flags & EXT4_MB_HINT_NOPREALLOC)\n\t\treturn;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC) {\n\t\text4_mb_normalize_group_request(ac);\n\t\treturn ;\n\t}\n\n\tbsbits = ac->ac_sb->s_blocksize_bits;\n\n\t/* first, let's learn actual file size\n\t * given current request is allocated */\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tsize = size << bsbits;\n\tif (size < i_size_read(ac->ac_inode))\n\t\tsize = i_size_read(ac->ac_inode);\n\torig_size = size;\n\n\t/* max size of free chunks */\n\tmax = 2 << bsbits;\n\n#define NRL_CHECK_SIZE(req, size, max, chunk_size)\t\\\n\t\t(req <= (size) || max <= (chunk_size))\n\n\t/* first, try to predict filesize */\n\t/* XXX: should this table be tunable? */\n\tstart_off = 0;\n\tif (size <= 16 * 1024) {\n\t\tsize = 16 * 1024;\n\t} else if (size <= 32 * 1024) {\n\t\tsize = 32 * 1024;\n\t} else if (size <= 64 * 1024) {\n\t\tsize = 64 * 1024;\n\t} else if (size <= 128 * 1024) {\n\t\tsize = 128 * 1024;\n\t} else if (size <= 256 * 1024) {\n\t\tsize = 256 * 1024;\n\t} else if (size <= 512 * 1024) {\n\t\tsize = 512 * 1024;\n\t} else if (size <= 1024 * 1024) {\n\t\tsize = 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 4 * 1024 * 1024, max, 2 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t(21 - bsbits)) << 21;\n\t\tsize = 2 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 8 * 1024 * 1024, max, 4 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(22 - bsbits)) << 22;\n\t\tsize = 4 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(ac->ac_o_ex.fe_len,\n\t\t\t\t\t(8<<20)>>bsbits, max, 8 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(23 - bsbits)) << 23;\n\t\tsize = 8 * 1024 * 1024;\n\t} else {\n\t\tstart_off = (loff_t) ac->ac_o_ex.fe_logical << bsbits;\n\t\tsize\t  = (loff_t) EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t      ac->ac_o_ex.fe_len) << bsbits;\n\t}\n\tsize = size >> bsbits;\n\tstart = start_off >> bsbits;\n\n\t/* don't cover already allocated blocks in selected range */\n\tif (ar->pleft && start <= ar->lleft) {\n\t\tsize -= ar->lleft + 1 - start;\n\t\tstart = ar->lleft + 1;\n\t}\n\tif (ar->pright && start + size - 1 >= ar->lright)\n\t\tsize -= start + size - ar->lright;\n\n\tend = start + size;\n\n\t/* check we don't cross already preallocated blocks */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tif (pa->pa_deleted)\n\t\t\tcontinue;\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t  pa->pa_len);\n\n\t\t/* PA must not overlap original request */\n\t\tBUG_ON(!(ac->ac_o_ex.fe_logical >= pa_end ||\n\t\t\tac->ac_o_ex.fe_logical < pa->pa_lstart));\n\n\t\t/* skip PAs this normalized request doesn't overlap with */\n\t\tif (pa->pa_lstart >= end || pa_end <= start) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tBUG_ON(pa->pa_lstart <= start && pa_end >= end);\n\n\t\t/* adjust start or end to be adjacent to this pa */\n\t\tif (pa_end <= ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa_end < start);\n\t\t\tstart = pa_end;\n\t\t} else if (pa->pa_lstart > ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa->pa_lstart > end);\n\t\t\tend = pa->pa_lstart;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\tsize = end - start;\n\n\t/* XXX: extra loop to check we really don't overlap preallocations */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t\t  pa->pa_len);\n\t\t\tBUG_ON(!(start >= pa_end || end <= pa->pa_lstart));\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\tif (start + size <= ac->ac_o_ex.fe_logical &&\n\t\t\tstart > ac->ac_o_ex.fe_logical) {\n\t\text4_msg(ac->ac_sb, KERN_ERR,\n\t\t\t \"start %lu, size %lu, fe_logical %lu\",\n\t\t\t (unsigned long) start, (unsigned long) size,\n\t\t\t (unsigned long) ac->ac_o_ex.fe_logical);\n\t\tBUG();\n\t}\n\tBUG_ON(size <= 0 || size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb));\n\n\t/* now prepare goal request */\n\n\t/* XXX: is it better to align blocks WRT to logical\n\t * placement or satisfy big request as is */\n\tac->ac_g_ex.fe_logical = start;\n\tac->ac_g_ex.fe_len = EXT4_NUM_B2C(sbi, size);\n\n\t/* define goal start in order to merge */\n\tif (ar->pright && (ar->lright == (start + size))) {\n\t\t/* merge to the right */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pright - size,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\tif (ar->pleft && (ar->lleft + 1 == start)) {\n\t\t/* merge to the left */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pleft + 1,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\n\tmb_debug(1, \"goal: %u(was %u) blocks at %u\\n\", (unsigned) size,\n\t\t(unsigned) orig_size, (unsigned) start);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"goal: %u(was %u) blocks at %u\\n\"",
            "(unsigned) size",
            "(unsigned) orig_size",
            "(unsigned) start"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "ac->ac_sb",
            "ar->pleft + 1",
            "&ac->ac_f_ex.fe_group",
            "&ac->ac_f_ex.fe_start"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_NUM_B2C",
          "args": [
            "sbi",
            "size"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size <= 0 || size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb)"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCKS_PER_GROUP",
          "args": [
            "ac->ac_sb"
          ],
          "line": 3159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "ac->ac_sb",
            "KERN_ERR",
            "\"start %lu, size %lu, fe_logical %lu\"",
            "(unsigned long) start",
            "(unsigned long) size",
            "(unsigned long) ac->ac_o_ex.fe_logical"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(start >= pa_end || end <= pa->pa_lstart)"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(ac->ac_sb)",
            "pa->pa_len"
          ],
          "line": 3143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pa->pa_lock"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "pa",
            "&ei->i_prealloc_list",
            "pa_inode_list"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_lstart > end"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa_end < start"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pa->pa_lstart <= start && pa_end >= end"
          ],
          "line": 3121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(ac->ac_o_ex.fe_logical >= pa_end ||\n\t\t\tac->ac_o_ex.fe_logical < pa->pa_lstart)"
          ],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(ac->ac_sb)",
            "pa->pa_len"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "pa",
            "&ei->i_prealloc_list",
            "pa_inode_list"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(ac->ac_sb)",
            "ac->ac_o_ex.fe_len"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NRL_CHECK_SIZE",
          "args": [
            "ac->ac_o_ex.fe_len",
            "(8<<20)>>bsbits",
            "max",
            "8 * 1024"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NRL_CHECK_SIZE",
          "args": [
            "size",
            "8 * 1024 * 1024",
            "max",
            "4 * 1024"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NRL_CHECK_SIZE",
          "args": [
            "size",
            "4 * 1024 * 1024",
            "max",
            "2 * 1024"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ac->ac_inode"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "ac->ac_inode"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ac->ac_o_ex.fe_len"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_normalize_group_request",
          "args": [
            "ac"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_normalize_group_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2985-2994",
          "snippet": "static void ext4_mb_normalize_group_request(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\n\tBUG_ON(lg == NULL);\n\tac->ac_g_ex.fe_len = EXT4_SB(sb)->s_mb_group_prealloc;\n\tmb_debug(1, \"#%u: goal %u blocks for locality group\\n\",\n\t\tcurrent->pid, ac->ac_g_ex.fe_len);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_normalize_group_request(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\n\tBUG_ON(lg == NULL);\n\tac->ac_g_ex.fe_len = EXT4_SB(sb)->s_mb_group_prealloc;\n\tmb_debug(1, \"#%u: goal %u blocks for locality group\\n\",\n\t\tcurrent->pid, ac->ac_g_ex.fe_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "ac->ac_inode"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic noinline_for_stack void\next4_mb_normalize_request(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_allocation_request *ar)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint bsbits, max;\n\text4_lblk_t end;\n\tloff_t size, start_off;\n\tloff_t orig_size __maybe_unused;\n\text4_lblk_t start;\n\tstruct ext4_inode_info *ei = EXT4_I(ac->ac_inode);\n\tstruct ext4_prealloc_space *pa;\n\n\t/* do normalize only data requests, metadata requests\n\t   do not need preallocation */\n\tif (!(ac->ac_flags & EXT4_MB_HINT_DATA))\n\t\treturn;\n\n\t/* sometime caller may want exact blocks */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\treturn;\n\n\t/* caller may indicate that preallocation isn't\n\t * required (it's a tail, for example) */\n\tif (ac->ac_flags & EXT4_MB_HINT_NOPREALLOC)\n\t\treturn;\n\n\tif (ac->ac_flags & EXT4_MB_HINT_GROUP_ALLOC) {\n\t\text4_mb_normalize_group_request(ac);\n\t\treturn ;\n\t}\n\n\tbsbits = ac->ac_sb->s_blocksize_bits;\n\n\t/* first, let's learn actual file size\n\t * given current request is allocated */\n\tsize = ac->ac_o_ex.fe_logical + EXT4_C2B(sbi, ac->ac_o_ex.fe_len);\n\tsize = size << bsbits;\n\tif (size < i_size_read(ac->ac_inode))\n\t\tsize = i_size_read(ac->ac_inode);\n\torig_size = size;\n\n\t/* max size of free chunks */\n\tmax = 2 << bsbits;\n\n#define NRL_CHECK_SIZE(req, size, max, chunk_size)\t\\\n\t\t(req <= (size) || max <= (chunk_size))\n\n\t/* first, try to predict filesize */\n\t/* XXX: should this table be tunable? */\n\tstart_off = 0;\n\tif (size <= 16 * 1024) {\n\t\tsize = 16 * 1024;\n\t} else if (size <= 32 * 1024) {\n\t\tsize = 32 * 1024;\n\t} else if (size <= 64 * 1024) {\n\t\tsize = 64 * 1024;\n\t} else if (size <= 128 * 1024) {\n\t\tsize = 128 * 1024;\n\t} else if (size <= 256 * 1024) {\n\t\tsize = 256 * 1024;\n\t} else if (size <= 512 * 1024) {\n\t\tsize = 512 * 1024;\n\t} else if (size <= 1024 * 1024) {\n\t\tsize = 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 4 * 1024 * 1024, max, 2 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t(21 - bsbits)) << 21;\n\t\tsize = 2 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(size, 8 * 1024 * 1024, max, 4 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(22 - bsbits)) << 22;\n\t\tsize = 4 * 1024 * 1024;\n\t} else if (NRL_CHECK_SIZE(ac->ac_o_ex.fe_len,\n\t\t\t\t\t(8<<20)>>bsbits, max, 8 * 1024)) {\n\t\tstart_off = ((loff_t)ac->ac_o_ex.fe_logical >>\n\t\t\t\t\t\t\t(23 - bsbits)) << 23;\n\t\tsize = 8 * 1024 * 1024;\n\t} else {\n\t\tstart_off = (loff_t) ac->ac_o_ex.fe_logical << bsbits;\n\t\tsize\t  = (loff_t) EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t      ac->ac_o_ex.fe_len) << bsbits;\n\t}\n\tsize = size >> bsbits;\n\tstart = start_off >> bsbits;\n\n\t/* don't cover already allocated blocks in selected range */\n\tif (ar->pleft && start <= ar->lleft) {\n\t\tsize -= ar->lleft + 1 - start;\n\t\tstart = ar->lleft + 1;\n\t}\n\tif (ar->pright && start + size - 1 >= ar->lright)\n\t\tsize -= start + size - ar->lright;\n\n\tend = start + size;\n\n\t/* check we don't cross already preallocated blocks */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tif (pa->pa_deleted)\n\t\t\tcontinue;\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t  pa->pa_len);\n\n\t\t/* PA must not overlap original request */\n\t\tBUG_ON(!(ac->ac_o_ex.fe_logical >= pa_end ||\n\t\t\tac->ac_o_ex.fe_logical < pa->pa_lstart));\n\n\t\t/* skip PAs this normalized request doesn't overlap with */\n\t\tif (pa->pa_lstart >= end || pa_end <= start) {\n\t\t\tspin_unlock(&pa->pa_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tBUG_ON(pa->pa_lstart <= start && pa_end >= end);\n\n\t\t/* adjust start or end to be adjacent to this pa */\n\t\tif (pa_end <= ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa_end < start);\n\t\t\tstart = pa_end;\n\t\t} else if (pa->pa_lstart > ac->ac_o_ex.fe_logical) {\n\t\t\tBUG_ON(pa->pa_lstart > end);\n\t\t\tend = pa->pa_lstart;\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\tsize = end - start;\n\n\t/* XXX: extra loop to check we really don't overlap preallocations */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pa, &ei->i_prealloc_list, pa_inode_list) {\n\t\text4_lblk_t pa_end;\n\n\t\tspin_lock(&pa->pa_lock);\n\t\tif (pa->pa_deleted == 0) {\n\t\t\tpa_end = pa->pa_lstart + EXT4_C2B(EXT4_SB(ac->ac_sb),\n\t\t\t\t\t\t\t  pa->pa_len);\n\t\t\tBUG_ON(!(start >= pa_end || end <= pa->pa_lstart));\n\t\t}\n\t\tspin_unlock(&pa->pa_lock);\n\t}\n\trcu_read_unlock();\n\n\tif (start + size <= ac->ac_o_ex.fe_logical &&\n\t\t\tstart > ac->ac_o_ex.fe_logical) {\n\t\text4_msg(ac->ac_sb, KERN_ERR,\n\t\t\t \"start %lu, size %lu, fe_logical %lu\",\n\t\t\t (unsigned long) start, (unsigned long) size,\n\t\t\t (unsigned long) ac->ac_o_ex.fe_logical);\n\t\tBUG();\n\t}\n\tBUG_ON(size <= 0 || size > EXT4_BLOCKS_PER_GROUP(ac->ac_sb));\n\n\t/* now prepare goal request */\n\n\t/* XXX: is it better to align blocks WRT to logical\n\t * placement or satisfy big request as is */\n\tac->ac_g_ex.fe_logical = start;\n\tac->ac_g_ex.fe_len = EXT4_NUM_B2C(sbi, size);\n\n\t/* define goal start in order to merge */\n\tif (ar->pright && (ar->lright == (start + size))) {\n\t\t/* merge to the right */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pright - size,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\tif (ar->pleft && (ar->lleft + 1 == start)) {\n\t\t/* merge to the left */\n\t\text4_get_group_no_and_offset(ac->ac_sb, ar->pleft + 1,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_group,\n\t\t\t\t\t\t&ac->ac_f_ex.fe_start);\n\t\tac->ac_flags |= EXT4_MB_HINT_TRY_GOAL;\n\t}\n\n\tmb_debug(1, \"goal: %u(was %u) blocks at %u\\n\", (unsigned) size,\n\t\t(unsigned) orig_size, (unsigned) start);\n}"
  },
  {
    "function_name": "ext4_mb_normalize_group_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2985-2994",
    "snippet": "static void ext4_mb_normalize_group_request(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\n\tBUG_ON(lg == NULL);\n\tac->ac_g_ex.fe_len = EXT4_SB(sb)->s_mb_group_prealloc;\n\tmb_debug(1, \"#%u: goal %u blocks for locality group\\n\",\n\t\tcurrent->pid, ac->ac_g_ex.fe_len);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"#%u: goal %u blocks for locality group\\n\"",
            "current->pid",
            "ac->ac_g_ex.fe_len"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lg == NULL"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_normalize_group_request(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_locality_group *lg = ac->ac_lg;\n\n\tBUG_ON(lg == NULL);\n\tac->ac_g_ex.fe_len = EXT4_SB(sb)->s_mb_group_prealloc;\n\tmb_debug(1, \"#%u: goal %u blocks for locality group\\n\",\n\t\tcurrent->pid, ac->ac_g_ex.fe_len);\n}"
  },
  {
    "function_name": "ext4_mb_mark_diskspace_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2865-2974",
    "snippet": "static noinline_for_stack int\next4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,\n\t\t\t\thandle_t *handle, unsigned int reserv_clstrs)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block;\n\tint err, len;\n\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(ac->ac_b_ex.fe_len <= 0);\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\n\terr = -EIO;\n\tbitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);\n\tif (!bitmap_bh)\n\t\tgoto out_err;\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tgdp = ext4_get_group_desc(sb, ac->ac_b_ex.fe_group, &gdp_bh);\n\tif (!gdp)\n\t\tgoto out_err;\n\n\text4_debug(\"using block group %u(%d)\\n\", ac->ac_b_ex.fe_group,\n\t\t\text4_free_group_clusters(sb, gdp));\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\n\tlen = EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\tif (!ext4_data_block_valid(sbi, block, len)) {\n\t\text4_error(sb, \"Allocating blocks %llu-%llu which overlap \"\n\t\t\t   \"fs metadata\", block, block+len);\n\t\t/* File system mounted not to panic on error\n\t\t * Fix the bitmap and repeat the block allocation\n\t\t * We leak some of the blocks here.\n\t\t */\n\t\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\t\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t\t      ac->ac_b_ex.fe_len);\n\t\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!err)\n\t\t\terr = -EAGAIN;\n\t\tgoto out_err;\n\t}\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < ac->ac_b_ex.fe_len; i++) {\n\t\t\tBUG_ON(mb_test_bit(ac->ac_b_ex.fe_start + i,\n\t\t\t\t\t\tbitmap_bh->b_data));\n\t\t}\n\t}\n#endif\n\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t      ac->ac_b_ex.fe_len);\n\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     ext4_free_clusters_after_init(sb,\n\t\t\t\t\t\tac->ac_b_ex.fe_group, gdp));\n\t}\n\tlen = ext4_free_group_clusters(sb, gdp) - ac->ac_b_ex.fe_len;\n\text4_free_group_clusters_set(sb, gdp, len);\n\text4_block_bitmap_csum_set(sb, ac->ac_b_ex.fe_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, ac->ac_b_ex.fe_group, gdp);\n\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\tpercpu_counter_sub(&sbi->s_freeclusters_counter, ac->ac_b_ex.fe_len);\n\t/*\n\t * Now reduce the dirty block count also. Should not go negative\n\t */\n\tif (!(ac->ac_flags & EXT4_MB_DELALLOC_RESERVED))\n\t\t/* release all the reserved blocks if non delalloc */\n\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t   reserv_clstrs);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi,\n\t\t\t\t\t\t\t  ac->ac_b_ex.fe_group);\n\t\tatomic64_sub(ac->ac_b_ex.fe_len,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);\n\nout_err:\n\tbrelse(bitmap_bh);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "gdp_bh"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bitmap_bh"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_sub",
          "args": [
            "ac->ac_b_ex.fe_len",
            "&sbi->s_flex_groups[flex_group].free_clusters"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_group",
          "args": [
            "sbi",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_dirtyclusters_counter",
            "reserv_clstrs"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeclusters_counter",
            "ac->ac_b_ex.fe_len"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_desc_csum_set",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group",
            "gdp"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_desc_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "2050-2056",
          "snippet": "void ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_group_desc_csum_set(struct super_block *sb, __u32 block_group,\n\t\t\t      struct ext4_group_desc *gdp)\n{\n\tif (!ext4_has_group_desc_csum(sb))\n\t\treturn;\n\tgdp->bg_checksum = ext4_group_desc_csum(EXT4_SB(sb), block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_block_bitmap_csum_set",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group",
            "gdp",
            "bitmap_bh"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_block_bitmap_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/bitmap.c",
          "lines": "83-98",
          "snippet": "void ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/buffer_head.h>\n\nvoid ext4_block_bitmap_csum_set(struct super_block *sb, ext4_group_t group,\n\t\t\t\tstruct ext4_group_desc *gdp,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint sz = EXT4_CLUSTERS_PER_GROUP(sb) / 8;\n\t__u32 csum;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (!ext4_has_metadata_csum(sb))\n\t\treturn;\n\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)bh->b_data, sz);\n\tgdp->bg_block_bitmap_csum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (sbi->s_desc_size >= EXT4_BG_BLOCK_BITMAP_CSUM_HI_END)\n\t\tgdp->bg_block_bitmap_csum_hi = cpu_to_le16(csum >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters_set",
          "args": [
            "sb",
            "gdp",
            "len"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "259-265",
          "snippet": "void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, __u32 count)\n{\n\tbg->bg_free_blocks_count_lo = cpu_to_le16((__u16)count);\n\tif (EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT)\n\t\tbg->bg_free_blocks_count_hi = cpu_to_le16(count >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "203-209",
          "snippet": "__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_clusters_after_init",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group",
            "gdp"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_clusters_after_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "251-257",
          "snippet": "unsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct ext4_group_desc *gdp)\n{\n\treturn num_clusters_in_group(sb, block_group) - \n\t\text4_num_overhead_clusters(sb, block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nunsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct ext4_group_desc *gdp)\n{\n\treturn num_clusters_in_group(sb, block_group) - \n\t\text4_num_overhead_clusters(sb, block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~EXT4_BG_BLOCK_UNINIT"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_BG_BLOCK_UNINIT"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bits",
          "args": [
            "bitmap_bh->b_data",
            "ac->ac_b_ex.fe_start",
            "ac->ac_b_ex.fe_len"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1314-1330",
          "snippet": "void ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mb_test_bit(ac->ac_b_ex.fe_start + i,\n\t\t\t\t\t\tbitmap_bh->b_data)"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "ac->ac_b_ex.fe_start + i",
            "bitmap_bh->b_data"
          ],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "NULL",
            "bitmap_bh"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_error",
          "args": [
            "sb",
            "\"Allocating blocks %llu-%llu which overlap \"\n\t\t\t   \"fs metadata\"",
            "block",
            "block+len"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "407-424",
          "snippet": "void __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_error(struct super_block *sb, const char *function,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT\n\t\t       \"EXT4-fs error (device %s): %s:%d: comm %s: %pV\\n\",\n\t\t       sb->s_id, function, line, current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(sb, function, line);\n\text4_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_data_block_valid",
          "args": [
            "sbi",
            "block",
            "len"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_data_block_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/block_validity.c",
          "lines": "197-221",
          "snippet": "int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,\n\t\t\t  unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n = sbi->system_blks.rb_node;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es))) {\n\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\treturn 0;\n\t}\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse {\n\t\t\tsbi->s_es->s_last_error_block = cpu_to_le64(start_blk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "sbi",
            "ac->ac_b_ex.fe_len"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_offs_to_block",
          "args": [
            "sb",
            "&ac->ac_b_ex"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_grp_offs_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.h",
          "lines": "209-214",
          "snippet": "static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/mutex.h>\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <linux/pagemap.h>\n#include <linux/proc_fs.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n\t\t\t\t\tstruct ext4_free_extent *fex)\n{\n\treturn ext4_group_first_block_no(sb, fex->fe_group) +\n\t\t(fex->fe_start << EXT4_SB(sb)->s_cluster_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "gdp_bh"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdp_bh",
            "\"get_write_access\""
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"using block group %u(%d)\\n\"",
            "ac->ac_b_ex.fe_group",
            "ext4_free_group_clusters(sb, gdp)"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group",
            "&gdp_bh"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"getting write access\""
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap",
          "args": [
            "sb",
            "ac->ac_b_ex.fe_group"
          ],
          "line": 2884
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "504-517",
          "snippet": "struct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_b_ex.fe_len <= 0"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_status != AC_STATUS_FOUND"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,\n\t\t\t\thandle_t *handle, unsigned int reserv_clstrs)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct ext4_group_desc *gdp;\n\tstruct buffer_head *gdp_bh;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\text4_fsblk_t block;\n\tint err, len;\n\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(ac->ac_b_ex.fe_len <= 0);\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\n\terr = -EIO;\n\tbitmap_bh = ext4_read_block_bitmap(sb, ac->ac_b_ex.fe_group);\n\tif (!bitmap_bh)\n\t\tgoto out_err;\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tgdp = ext4_get_group_desc(sb, ac->ac_b_ex.fe_group, &gdp_bh);\n\tif (!gdp)\n\t\tgoto out_err;\n\n\text4_debug(\"using block group %u(%d)\\n\", ac->ac_b_ex.fe_group,\n\t\t\text4_free_group_clusters(sb, gdp));\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto out_err;\n\n\tblock = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\n\tlen = EXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\tif (!ext4_data_block_valid(sbi, block, len)) {\n\t\text4_error(sb, \"Allocating blocks %llu-%llu which overlap \"\n\t\t\t   \"fs metadata\", block, block+len);\n\t\t/* File system mounted not to panic on error\n\t\t * Fix the bitmap and repeat the block allocation\n\t\t * We leak some of the blocks here.\n\t\t */\n\t\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\t\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t\t      ac->ac_b_ex.fe_len);\n\t\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\t\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\t\tif (!err)\n\t\t\terr = -EAGAIN;\n\t\tgoto out_err;\n\t}\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < ac->ac_b_ex.fe_len; i++) {\n\t\t\tBUG_ON(mb_test_bit(ac->ac_b_ex.fe_start + i,\n\t\t\t\t\t\tbitmap_bh->b_data));\n\t\t}\n\t}\n#endif\n\text4_set_bits(bitmap_bh->b_data, ac->ac_b_ex.fe_start,\n\t\t      ac->ac_b_ex.fe_len);\n\tif (gdp->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tgdp->bg_flags &= cpu_to_le16(~EXT4_BG_BLOCK_UNINIT);\n\t\text4_free_group_clusters_set(sb, gdp,\n\t\t\t\t\t     ext4_free_clusters_after_init(sb,\n\t\t\t\t\t\tac->ac_b_ex.fe_group, gdp));\n\t}\n\tlen = ext4_free_group_clusters(sb, gdp) - ac->ac_b_ex.fe_len;\n\text4_free_group_clusters_set(sb, gdp, len);\n\text4_block_bitmap_csum_set(sb, ac->ac_b_ex.fe_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, ac->ac_b_ex.fe_group, gdp);\n\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\tpercpu_counter_sub(&sbi->s_freeclusters_counter, ac->ac_b_ex.fe_len);\n\t/*\n\t * Now reduce the dirty block count also. Should not go negative\n\t */\n\tif (!(ac->ac_flags & EXT4_MB_DELALLOC_RESERVED))\n\t\t/* release all the reserved blocks if non delalloc */\n\t\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter,\n\t\t\t\t   reserv_clstrs);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi,\n\t\t\t\t\t\t\t  ac->ac_b_ex.fe_group);\n\t\tatomic64_sub(ac->ac_b_ex.fe_len,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\tif (err)\n\t\tgoto out_err;\n\terr = ext4_handle_dirty_metadata(handle, NULL, gdp_bh);\n\nout_err:\n\tbrelse(bitmap_bh);\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_exit_mballoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2847-2858",
    "snippet": "void ext4_exit_mballoc(void)\n{\n\t/*\n\t * Wait for completion of call_rcu()'s on ext4_pspace_cachep\n\t * before destroying the slab cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_pspace_cachep);\n\tkmem_cache_destroy(ext4_ac_cachep);\n\tkmem_cache_destroy(ext4_free_data_cachep);\n\text4_groupinfo_destroy_slabs();\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_pspace_cachep;",
      "static struct kmem_cache *ext4_ac_cachep;",
      "static struct kmem_cache *ext4_free_data_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_groupinfo_destroy_slabs",
          "args": [],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_groupinfo_destroy_slabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2502-2511",
          "snippet": "static void ext4_groupinfo_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_GRPINFO_CACHES; i++) {\n\t\tif (ext4_groupinfo_caches[i])\n\t\t\tkmem_cache_destroy(ext4_groupinfo_caches[i]);\n\t\text4_groupinfo_caches[i] = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define NR_GRPINFO_CACHES 8"
          ],
          "globals_used": [
            "static struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\n#define NR_GRPINFO_CACHES 8\n\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\n\nstatic void ext4_groupinfo_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_GRPINFO_CACHES; i++) {\n\t\tif (ext4_groupinfo_caches[i])\n\t\t\tkmem_cache_destroy(ext4_groupinfo_caches[i]);\n\t\text4_groupinfo_caches[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_free_data_cachep"
          ],
          "line": 2856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_ac_cachep"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_pspace_cachep"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic struct kmem_cache *ext4_ac_cachep;\nstatic struct kmem_cache *ext4_free_data_cachep;\n\nvoid ext4_exit_mballoc(void)\n{\n\t/*\n\t * Wait for completion of call_rcu()'s on ext4_pspace_cachep\n\t * before destroying the slab cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext4_pspace_cachep);\n\tkmem_cache_destroy(ext4_ac_cachep);\n\tkmem_cache_destroy(ext4_free_data_cachep);\n\text4_groupinfo_destroy_slabs();\n}"
  },
  {
    "function_name": "ext4_init_mballoc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2823-2845",
    "snippet": "int __init ext4_init_mballoc(void)\n{\n\text4_pspace_cachep = KMEM_CACHE(ext4_prealloc_space,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT);\n\tif (ext4_pspace_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\text4_ac_cachep = KMEM_CACHE(ext4_allocation_context,\n\t\t\t\t    SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_ac_cachep == NULL) {\n\t\tkmem_cache_destroy(ext4_pspace_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\text4_free_data_cachep = KMEM_CACHE(ext4_free_data,\n\t\t\t\t\t   SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_free_data_cachep == NULL) {\n\t\tkmem_cache_destroy(ext4_pspace_cachep);\n\t\tkmem_cache_destroy(ext4_ac_cachep);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_pspace_cachep;",
      "static struct kmem_cache *ext4_ac_cachep;",
      "static struct kmem_cache *ext4_free_data_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_ac_cachep"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_pspace_cachep"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ext4_free_data",
            "SLAB_RECLAIM_ACCOUNT"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_pspace_cachep"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ext4_allocation_context",
            "SLAB_RECLAIM_ACCOUNT"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "ext4_prealloc_space",
            "SLAB_RECLAIM_ACCOUNT"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\nstatic struct kmem_cache *ext4_ac_cachep;\nstatic struct kmem_cache *ext4_free_data_cachep;\n\nint __init ext4_init_mballoc(void)\n{\n\text4_pspace_cachep = KMEM_CACHE(ext4_prealloc_space,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT);\n\tif (ext4_pspace_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\text4_ac_cachep = KMEM_CACHE(ext4_allocation_context,\n\t\t\t\t    SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_ac_cachep == NULL) {\n\t\tkmem_cache_destroy(ext4_pspace_cachep);\n\t\treturn -ENOMEM;\n\t}\n\n\text4_free_data_cachep = KMEM_CACHE(ext4_free_data,\n\t\t\t\t\t   SLAB_RECLAIM_ACCOUNT);\n\tif (ext4_free_data_cachep == NULL) {\n\t\tkmem_cache_destroy(ext4_pspace_cachep);\n\t\tkmem_cache_destroy(ext4_ac_cachep);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_free_data_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2762-2821",
    "snippet": "static void ext4_free_data_callback(struct super_block *sb,\n\t\t\t\t    struct ext4_journal_cb_entry *jce,\n\t\t\t\t    int rc)\n{\n\tstruct ext4_free_data *entry = (struct ext4_free_data *)jce;\n\tstruct ext4_buddy e4b;\n\tstruct ext4_group_info *db;\n\tint err, count = 0, count2 = 0;\n\n\tmb_debug(1, \"gonna free %u blocks in group %u (0x%p):\",\n\t\t entry->efd_count, entry->efd_group, entry);\n\n\tif (test_opt(sb, DISCARD)) {\n\t\terr = ext4_issue_discard(sb, entry->efd_group,\n\t\t\t\t\t entry->efd_start_cluster,\n\t\t\t\t\t entry->efd_count);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t \" group:%d block:%d count:%d failed\"\n\t\t\t\t \" with %d\", entry->efd_group,\n\t\t\t\t entry->efd_start_cluster,\n\t\t\t\t entry->efd_count, err);\n\t}\n\n\terr = ext4_mb_load_buddy(sb, entry->efd_group, &e4b);\n\t/* we expect to find existing buddy because it's pinned */\n\tBUG_ON(err != 0);\n\n\n\tdb = e4b.bd_info;\n\t/* there are blocks to put in buddy to make them really free */\n\tcount += entry->efd_count;\n\tcount2++;\n\text4_lock_group(sb, entry->efd_group);\n\t/* Take it out of per group rb tree */\n\trb_erase(&entry->efd_node, &(db->bb_free_root));\n\tmb_free_blocks(NULL, &e4b, entry->efd_start_cluster, entry->efd_count);\n\n\t/*\n\t * Clear the trimmed flag for the group so that the next\n\t * ext4_trim_fs can trim it.\n\t * If the volume is mounted with -o discard, online discard\n\t * is supported and the free blocks will be trimmed online.\n\t */\n\tif (!test_opt(sb, DISCARD))\n\t\tEXT4_MB_GRP_CLEAR_TRIMMED(db);\n\n\tif (!db->bb_free_root.rb_node) {\n\t\t/* No more items in the per group rb tree\n\t\t * balance refcounts from ext4_mb_free_metadata()\n\t\t */\n\t\tpage_cache_release(e4b.bd_buddy_page);\n\t\tpage_cache_release(e4b.bd_bitmap_page);\n\t}\n\text4_unlock_group(sb, entry->efd_group);\n\tkmem_cache_free(ext4_free_data_cachep, entry);\n\text4_mb_unload_buddy(&e4b);\n\n\tmb_debug(1, \"freed %u blocks in %u structures\\n\", count, count2);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_free_data_cachep;",
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);",
      "static void ext4_free_data_callback(struct super_block *sb,\n\t\t\t\tstruct ext4_journal_cb_entry *jce, int rc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"freed %u blocks in %u structures\\n\"",
            "count",
            "count2"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_free_data_cachep",
            "entry"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "entry->efd_group"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "e4b.bd_bitmap_page"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "e4b.bd_buddy_page"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_CLEAR_TRIMMED",
          "args": [
            "db"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DISCARD"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_free_blocks",
          "args": [
            "NULL",
            "&e4b",
            "entry->efd_start_cluster",
            "entry->efd_count"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "mb_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1406-1488",
          "snippet": "static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&entry->efd_node",
            "&(db->bb_free_root)"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "entry->efd_group"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != 0"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "entry->efd_group",
            "&e4b"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"discard request in\"\n\t\t\t\t \" group:%d block:%d count:%d failed\"\n\t\t\t\t \" with %d\"",
            "entry->efd_group",
            "entry->efd_start_cluster",
            "entry->efd_count",
            "err"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_issue_discard",
          "args": [
            "sb",
            "entry->efd_group",
            "entry->efd_start_cluster",
            "entry->efd_count"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_issue_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2745-2756",
          "snippet": "static inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DISCARD"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"gonna free %u blocks in group %u (0x%p):\"",
            "entry->efd_count",
            "entry->efd_group",
            "entry"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\nstatic void ext4_free_data_callback(struct super_block *sb,\n\t\t\t\tstruct ext4_journal_cb_entry *jce, int rc);\n\nstatic void ext4_free_data_callback(struct super_block *sb,\n\t\t\t\t    struct ext4_journal_cb_entry *jce,\n\t\t\t\t    int rc)\n{\n\tstruct ext4_free_data *entry = (struct ext4_free_data *)jce;\n\tstruct ext4_buddy e4b;\n\tstruct ext4_group_info *db;\n\tint err, count = 0, count2 = 0;\n\n\tmb_debug(1, \"gonna free %u blocks in group %u (0x%p):\",\n\t\t entry->efd_count, entry->efd_group, entry);\n\n\tif (test_opt(sb, DISCARD)) {\n\t\terr = ext4_issue_discard(sb, entry->efd_group,\n\t\t\t\t\t entry->efd_start_cluster,\n\t\t\t\t\t entry->efd_count);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t \" group:%d block:%d count:%d failed\"\n\t\t\t\t \" with %d\", entry->efd_group,\n\t\t\t\t entry->efd_start_cluster,\n\t\t\t\t entry->efd_count, err);\n\t}\n\n\terr = ext4_mb_load_buddy(sb, entry->efd_group, &e4b);\n\t/* we expect to find existing buddy because it's pinned */\n\tBUG_ON(err != 0);\n\n\n\tdb = e4b.bd_info;\n\t/* there are blocks to put in buddy to make them really free */\n\tcount += entry->efd_count;\n\tcount2++;\n\text4_lock_group(sb, entry->efd_group);\n\t/* Take it out of per group rb tree */\n\trb_erase(&entry->efd_node, &(db->bb_free_root));\n\tmb_free_blocks(NULL, &e4b, entry->efd_start_cluster, entry->efd_count);\n\n\t/*\n\t * Clear the trimmed flag for the group so that the next\n\t * ext4_trim_fs can trim it.\n\t * If the volume is mounted with -o discard, online discard\n\t * is supported and the free blocks will be trimmed online.\n\t */\n\tif (!test_opt(sb, DISCARD))\n\t\tEXT4_MB_GRP_CLEAR_TRIMMED(db);\n\n\tif (!db->bb_free_root.rb_node) {\n\t\t/* No more items in the per group rb tree\n\t\t * balance refcounts from ext4_mb_free_metadata()\n\t\t */\n\t\tpage_cache_release(e4b.bd_buddy_page);\n\t\tpage_cache_release(e4b.bd_bitmap_page);\n\t}\n\text4_unlock_group(sb, entry->efd_group);\n\tkmem_cache_free(ext4_free_data_cachep, entry);\n\text4_mb_unload_buddy(&e4b);\n\n\tmb_debug(1, \"freed %u blocks in %u structures\\n\", count, count2);\n}"
  },
  {
    "function_name": "ext4_issue_discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2745-2756",
    "snippet": "static inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_issue_discard",
          "args": [
            "sb",
            "discard_block",
            "count",
            "GFP_NOFS",
            "0"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_discard_blocks",
          "args": [
            "sb",
            "(unsigned long long) discard_block",
            "count"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "count"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "cluster"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int ext4_issue_discard(struct super_block *sb,\n\t\text4_group_t block_group, ext4_grpblk_t cluster, int count)\n{\n\text4_fsblk_t discard_block;\n\n\tdiscard_block = (EXT4_C2B(EXT4_SB(sb), cluster) +\n\t\t\t ext4_group_first_block_no(sb, block_group));\n\tcount = EXT4_C2B(EXT4_SB(sb), count);\n\ttrace_ext4_discard_blocks(sb,\n\t\t\t(unsigned long long) discard_block, count);\n\treturn sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);\n}"
  },
  {
    "function_name": "ext4_mb_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2683-2743",
    "snippet": "int ext4_mb_release(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tint num_meta_group_infos;\n\tstruct ext4_group_info *grinfo;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"mb_groups\", sbi->s_proc);\n\n\tif (sbi->s_group_info) {\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgrinfo = ext4_get_group_info(sb, i);\n#ifdef DOUBLE_CHECK\n\t\t\tkfree(grinfo->bb_bitmap);\n#endif\n\t\t\text4_lock_group(sb, i);\n\t\t\text4_mb_cleanup_pa(grinfo);\n\t\t\text4_unlock_group(sb, i);\n\t\t\tkmem_cache_free(cachep, grinfo);\n\t\t}\n\t\tnum_meta_group_infos = (ngroups +\n\t\t\t\tEXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tfor (i = 0; i < num_meta_group_infos; i++)\n\t\t\tkfree(sbi->s_group_info[i]);\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tkfree(sbi->s_mb_offsets);\n\tkfree(sbi->s_mb_maxs);\n\tiput(sbi->s_buddy_cache);\n\tif (sbi->s_mb_stats) {\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u blocks %u reqs (%u success)\",\n\t\t\t\tatomic_read(&sbi->s_bal_allocated),\n\t\t\t\tatomic_read(&sbi->s_bal_reqs),\n\t\t\t\tatomic_read(&sbi->s_bal_success));\n\t\text4_msg(sb, KERN_INFO,\n\t\t      \"mballoc: %u extents scanned, %u goal hits, \"\n\t\t\t\t\"%u 2^N hits, %u breaks, %u lost\",\n\t\t\t\tatomic_read(&sbi->s_bal_ex_scanned),\n\t\t\t\tatomic_read(&sbi->s_bal_goals),\n\t\t\t\tatomic_read(&sbi->s_bal_2orders),\n\t\t\t\tatomic_read(&sbi->s_bal_breaks),\n\t\t\t\tatomic_read(&sbi->s_mb_lost_chunks));\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %lu generated and it took %Lu\",\n\t\t\t\tsbi->s_mb_buddies_generated,\n\t\t\t\tsbi->s_mb_generation_time);\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u preallocated, %u discarded\",\n\t\t\t\tatomic_read(&sbi->s_mb_preallocated),\n\t\t\t\tatomic_read(&sbi->s_mb_discarded));\n\t}\n\n\tfree_percpu(sbi->s_locality_groups);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sbi->s_locality_groups"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"mballoc: %u preallocated, %u discarded\"",
            "atomic_read(&sbi->s_mb_preallocated)",
            "atomic_read(&sbi->s_mb_discarded)"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_mb_discarded"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_mb_preallocated"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_mb_lost_chunks"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_bal_breaks"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_bal_2orders"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_bal_goals"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_bal_ex_scanned"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_bal_success"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_bal_reqs"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_bal_allocated"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->s_buddy_cache"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_mb_maxs"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_mb_offsets"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sbi->s_group_info"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_group_info[i]"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cachep",
            "grinfo"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "i"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_cleanup_pa",
          "args": [
            "grinfo"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_cleanup_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2666-2681",
          "snippet": "static void ext4_mb_cleanup_pa(struct ext4_group_info *grp)\n{\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur, *tmp;\n\tint count = 0;\n\n\tlist_for_each_safe(cur, tmp, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tlist_del(&pa->pa_group_list);\n\t\tcount++;\n\t\tkmem_cache_free(ext4_pspace_cachep, pa);\n\t}\n\tif (count)\n\t\tmb_debug(1, \"mballoc: %u PAs left\\n\", count);\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_pspace_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\n\nstatic void ext4_mb_cleanup_pa(struct ext4_group_info *grp)\n{\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur, *tmp;\n\tint count = 0;\n\n\tlist_for_each_safe(cur, tmp, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tlist_del(&pa->pa_group_list);\n\t\tcount++;\n\t\tkmem_cache_free(ext4_pspace_cachep, pa);\n\t}\n\tif (count)\n\t\tmb_debug(1, \"mballoc: %u PAs left\\n\", count);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "i"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "grinfo->bb_bitmap"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "i"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"mb_groups\"",
            "sbi->s_proc"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_groupinfo_cache",
          "args": [
            "sb->s_blocksize_bits"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "get_groupinfo_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2328-2335",
          "snippet": "static struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\n\nstatic struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_mb_release(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tint num_meta_group_infos;\n\tstruct ext4_group_info *grinfo;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"mb_groups\", sbi->s_proc);\n\n\tif (sbi->s_group_info) {\n\t\tfor (i = 0; i < ngroups; i++) {\n\t\t\tgrinfo = ext4_get_group_info(sb, i);\n#ifdef DOUBLE_CHECK\n\t\t\tkfree(grinfo->bb_bitmap);\n#endif\n\t\t\text4_lock_group(sb, i);\n\t\t\text4_mb_cleanup_pa(grinfo);\n\t\t\text4_unlock_group(sb, i);\n\t\t\tkmem_cache_free(cachep, grinfo);\n\t\t}\n\t\tnum_meta_group_infos = (ngroups +\n\t\t\t\tEXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tfor (i = 0; i < num_meta_group_infos; i++)\n\t\t\tkfree(sbi->s_group_info[i]);\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tkfree(sbi->s_mb_offsets);\n\tkfree(sbi->s_mb_maxs);\n\tiput(sbi->s_buddy_cache);\n\tif (sbi->s_mb_stats) {\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u blocks %u reqs (%u success)\",\n\t\t\t\tatomic_read(&sbi->s_bal_allocated),\n\t\t\t\tatomic_read(&sbi->s_bal_reqs),\n\t\t\t\tatomic_read(&sbi->s_bal_success));\n\t\text4_msg(sb, KERN_INFO,\n\t\t      \"mballoc: %u extents scanned, %u goal hits, \"\n\t\t\t\t\"%u 2^N hits, %u breaks, %u lost\",\n\t\t\t\tatomic_read(&sbi->s_bal_ex_scanned),\n\t\t\t\tatomic_read(&sbi->s_bal_goals),\n\t\t\t\tatomic_read(&sbi->s_bal_2orders),\n\t\t\t\tatomic_read(&sbi->s_bal_breaks),\n\t\t\t\tatomic_read(&sbi->s_mb_lost_chunks));\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %lu generated and it took %Lu\",\n\t\t\t\tsbi->s_mb_buddies_generated,\n\t\t\t\tsbi->s_mb_generation_time);\n\t\text4_msg(sb, KERN_INFO,\n\t\t       \"mballoc: %u preallocated, %u discarded\",\n\t\t\t\tatomic_read(&sbi->s_mb_preallocated),\n\t\t\t\tatomic_read(&sbi->s_mb_discarded));\n\t}\n\n\tfree_percpu(sbi->s_locality_groups);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_cleanup_pa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2666-2681",
    "snippet": "static void ext4_mb_cleanup_pa(struct ext4_group_info *grp)\n{\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur, *tmp;\n\tint count = 0;\n\n\tlist_for_each_safe(cur, tmp, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tlist_del(&pa->pa_group_list);\n\t\tcount++;\n\t\tkmem_cache_free(ext4_pspace_cachep, pa);\n\t}\n\tif (count)\n\t\tmb_debug(1, \"mballoc: %u PAs left\\n\", count);\n\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_pspace_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"mballoc: %u PAs left\\n\"",
            "count"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext4_pspace_cachep",
            "pa"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pa->pa_group_list"
          ],
          "line": 2674
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "316-328",
          "snippet": "static void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nstatic void ext4_es_list_del(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\tspin_lock(&sbi->s_es_lock);\n\tif (!list_empty(&ei->i_es_list)) {\n\t\tlist_del_init(&ei->i_es_list);\n\t\tsbi->s_es_nr_inode--;\n\t\tWARN_ON_ONCE(sbi->s_es_nr_inode < 0);\n\t}\n\tspin_unlock(&sbi->s_es_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur",
            "structext4_prealloc_space",
            "pa_group_list"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "cur",
            "tmp",
            "&grp->bb_prealloc_list"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\n\nstatic void ext4_mb_cleanup_pa(struct ext4_group_info *grp)\n{\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur, *tmp;\n\tint count = 0;\n\n\tlist_for_each_safe(cur, tmp, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tlist_del(&pa->pa_group_list);\n\t\tcount++;\n\t\tkmem_cache_free(ext4_pspace_cachep, pa);\n\t}\n\tif (count)\n\t\tmb_debug(1, \"mballoc: %u PAs left\\n\", count);\n\n}"
  },
  {
    "function_name": "ext4_mb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2552-2663",
    "snippet": "int ext4_mb_init(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned i, j;\n\tunsigned offset;\n\tunsigned max;\n\tint ret;\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_offsets);\n\n\tsbi->s_mb_offsets = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_offsets == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_maxs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ext4_groupinfo_create_slab(sb->s_blocksize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* order 0 is regular bitmap */\n\tsbi->s_mb_maxs[0] = sb->s_blocksize << 3;\n\tsbi->s_mb_offsets[0] = 0;\n\n\ti = 1;\n\toffset = 0;\n\tmax = sb->s_blocksize << 2;\n\tdo {\n\t\tsbi->s_mb_offsets[i] = offset;\n\t\tsbi->s_mb_maxs[i] = max;\n\t\toffset += 1 << (sb->s_blocksize_bits - i);\n\t\tmax = max >> 1;\n\t\ti++;\n\t} while (i <= sb->s_blocksize_bits + 1);\n\n\tspin_lock_init(&sbi->s_md_lock);\n\tspin_lock_init(&sbi->s_bal_lock);\n\n\tsbi->s_mb_max_to_scan = MB_DEFAULT_MAX_TO_SCAN;\n\tsbi->s_mb_min_to_scan = MB_DEFAULT_MIN_TO_SCAN;\n\tsbi->s_mb_stats = MB_DEFAULT_STATS;\n\tsbi->s_mb_stream_request = MB_DEFAULT_STREAM_THRESHOLD;\n\tsbi->s_mb_order2_reqs = MB_DEFAULT_ORDER2_REQS;\n\t/*\n\t * The default group preallocation is 512, which for 4k block\n\t * sizes translates to 2 megabytes.  However for bigalloc file\n\t * systems, this is probably too big (i.e, if the cluster size\n\t * is 1 megabyte, then group preallocation size becomes half a\n\t * gigabyte!).  As a default, we will keep a two megabyte\n\t * group pralloc size for cluster sizes up to 64k, and after\n\t * that, we will force a minimum group preallocation size of\n\t * 32 clusters.  This translates to 8 megs when the cluster\n\t * size is 256k, and 32 megs when the cluster size is 1 meg,\n\t * which seems reasonable as a default.\n\t */\n\tsbi->s_mb_group_prealloc = max(MB_DEFAULT_GROUP_PREALLOC >>\n\t\t\t\t       sbi->s_cluster_bits, 32);\n\t/*\n\t * If there is a s_stripe > 1, then we set the s_mb_group_prealloc\n\t * to the lowest multiple of s_stripe which is bigger than\n\t * the s_mb_group_prealloc as determined above. We want\n\t * the preallocation size to be an exact multiple of the\n\t * RAID stripe size so that preallocations don't fragment\n\t * the stripes.\n\t */\n\tif (sbi->s_stripe > 1) {\n\t\tsbi->s_mb_group_prealloc = roundup(\n\t\t\tsbi->s_mb_group_prealloc, sbi->s_stripe);\n\t}\n\n\tsbi->s_locality_groups = alloc_percpu(struct ext4_locality_group);\n\tif (sbi->s_locality_groups == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor_each_possible_cpu(i) {\n\t\tstruct ext4_locality_group *lg;\n\t\tlg = per_cpu_ptr(sbi->s_locality_groups, i);\n\t\tmutex_init(&lg->lg_mutex);\n\t\tfor (j = 0; j < PREALLOC_TB_SIZE; j++)\n\t\t\tINIT_LIST_HEAD(&lg->lg_prealloc_list[j]);\n\t\tspin_lock_init(&lg->lg_prealloc_lock);\n\t}\n\n\t/* init file for buddy data */\n\tret = ext4_mb_init_backend(sb);\n\tif (ret != 0)\n\t\tgoto out_free_locality_groups;\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"mb_groups\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_mb_seq_groups_fops, sb);\n\n\treturn 0;\n\nout_free_locality_groups:\n\tfree_percpu(sbi->s_locality_groups);\n\tsbi->s_locality_groups = NULL;\nout:\n\tkfree(sbi->s_mb_offsets);\n\tsbi->s_mb_offsets = NULL;\n\tkfree(sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);",
      "static const struct file_operations ext4_mb_seq_groups_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ext4_mb_seq_groups_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_mb_maxs"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_mb_offsets"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "sbi->s_locality_groups"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"mb_groups\"",
            "S_IRUGO",
            "sbi->s_proc",
            "&ext4_mb_seq_groups_fops",
            "sb"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "458-489",
          "snippet": "struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_init_backend",
          "args": [
            "sb"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_init_backend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2453-2500",
          "snippet": "static int ext4_mb_init_backend(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\tstruct ext4_group_desc *desc;\n\tstruct kmem_cache *cachep;\n\n\terr = ext4_mb_alloc_groupinfo(sb, ngroups);\n\tif (err)\n\t\treturn err;\n\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't get new inode\");\n\t\tgoto err_freesgi;\n\t}\n\t/* To avoid potentially colliding with an valid on-disk inode number,\n\t * use EXT4_BAD_INO for the buddy cache inode number.  This inode is\n\t * not in the inode hash, so it should never be found by iget(), but\n\t * this will avoid confusion if it ever shows up during debugging. */\n\tsbi->s_buddy_cache->i_ino = EXT4_BAD_INO;\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't read descriptor %u\", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0)\n\t\tkmem_cache_free(cachep, ext4_get_group_info(sb, i));\n\ti = sbi->s_group_info_size;\n\twhile (i-- > 0)\n\t\tkfree(sbi->s_group_info[i]);\n\tiput(sbi->s_buddy_cache);\nerr_freesgi:\n\tkvfree(sbi->s_group_info);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_init_backend(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\tstruct ext4_group_desc *desc;\n\tstruct kmem_cache *cachep;\n\n\terr = ext4_mb_alloc_groupinfo(sb, ngroups);\n\tif (err)\n\t\treturn err;\n\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't get new inode\");\n\t\tgoto err_freesgi;\n\t}\n\t/* To avoid potentially colliding with an valid on-disk inode number,\n\t * use EXT4_BAD_INO for the buddy cache inode number.  This inode is\n\t * not in the inode hash, so it should never be found by iget(), but\n\t * this will avoid confusion if it ever shows up during debugging. */\n\tsbi->s_buddy_cache->i_ino = EXT4_BAD_INO;\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't read descriptor %u\", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0)\n\t\tkmem_cache_free(cachep, ext4_get_group_info(sb, i));\n\ti = sbi->s_group_info_size;\n\twhile (i-- > 0)\n\t\tkfree(sbi->s_group_info[i]);\n\tiput(sbi->s_buddy_cache);\nerr_freesgi:\n\tkvfree(sbi->s_group_info);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&lg->lg_prealloc_lock"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lg->lg_prealloc_list[j]"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&lg->lg_mutex"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "sbi->s_locality_groups",
            "i"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structext4_locality_group"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "sbi->s_mb_group_prealloc",
            "sbi->s_stripe"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "MB_DEFAULT_GROUP_PREALLOC >>\n\t\t\t\t       sbi->s_cluster_bits",
            "32"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_ext_max_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents.c",
          "lines": "353-371",
          "snippet": "static int\next4_ext_max_entries(struct inode *inode, int depth)\n{\n\tint max;\n\n\tif (depth == ext_depth(inode)) {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_root(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_root_idx(inode, 1);\n\t} else {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_block(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_block_idx(inode, 1);\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"xattr.h\"",
            "#include \"ext4_extents.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fiemap.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"xattr.h\"\n#include \"ext4_extents.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fiemap.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int\next4_ext_max_entries(struct inode *inode, int depth)\n{\n\tint max;\n\n\tif (depth == ext_depth(inode)) {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_root(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_root_idx(inode, 1);\n\t} else {\n\t\tif (depth == 0)\n\t\t\tmax = ext4_ext_space_block(inode, 1);\n\t\telse\n\t\t\tmax = ext4_ext_space_block_idx(inode, 1);\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_bal_lock"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_md_lock"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_groupinfo_create_slab",
          "args": [
            "sb->s_blocksize"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_groupinfo_create_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2513-2550",
          "snippet": "static int ext4_groupinfo_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(ext4_grpinfo_slab_create_mutex);\n\tint slab_size;\n\tint blocksize_bits = order_base_2(size);\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep;\n\n\tif (cache_index >= NR_GRPINFO_CACHES)\n\t\treturn -EINVAL;\n\n\tif (unlikely(cache_index < 0))\n\t\tcache_index = 0;\n\n\tmutex_lock(&ext4_grpinfo_slab_create_mutex);\n\tif (ext4_groupinfo_caches[cache_index]) {\n\t\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = offsetof(struct ext4_group_info,\n\t\t\t\tbb_counters[blocksize_bits + 2]);\n\n\tcachep = kmem_cache_create(ext4_groupinfo_slab_names[cache_index],\n\t\t\t\t\tslab_size, 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t\tNULL);\n\n\text4_groupinfo_caches[cache_index] = cachep;\n\n\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\tif (!cachep) {\n\t\tprintk(KERN_EMERG\n\t\t       \"EXT4-fs: no memory for groupinfo slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define NR_GRPINFO_CACHES 8"
          ],
          "globals_used": [
            "static struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];",
            "static const char *ext4_groupinfo_slab_names[NR_GRPINFO_CACHES] = {\n\t\"ext4_groupinfo_1k\", \"ext4_groupinfo_2k\", \"ext4_groupinfo_4k\",\n\t\"ext4_groupinfo_8k\", \"ext4_groupinfo_16k\", \"ext4_groupinfo_32k\",\n\t\"ext4_groupinfo_64k\", \"ext4_groupinfo_128k\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\n#define NR_GRPINFO_CACHES 8\n\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\nstatic const char *ext4_groupinfo_slab_names[NR_GRPINFO_CACHES] = {\n\t\"ext4_groupinfo_1k\", \"ext4_groupinfo_2k\", \"ext4_groupinfo_4k\",\n\t\"ext4_groupinfo_8k\", \"ext4_groupinfo_16k\", \"ext4_groupinfo_32k\",\n\t\"ext4_groupinfo_64k\", \"ext4_groupinfo_128k\"\n};\n\nstatic int ext4_groupinfo_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(ext4_grpinfo_slab_create_mutex);\n\tint slab_size;\n\tint blocksize_bits = order_base_2(size);\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep;\n\n\tif (cache_index >= NR_GRPINFO_CACHES)\n\t\treturn -EINVAL;\n\n\tif (unlikely(cache_index < 0))\n\t\tcache_index = 0;\n\n\tmutex_lock(&ext4_grpinfo_slab_create_mutex);\n\tif (ext4_groupinfo_caches[cache_index]) {\n\t\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = offsetof(struct ext4_group_info,\n\t\t\t\tbb_counters[blocksize_bits + 2]);\n\n\tcachep = kmem_cache_create(ext4_groupinfo_slab_names[cache_index],\n\t\t\t\t\tslab_size, 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t\tNULL);\n\n\text4_groupinfo_caches[cache_index] = cachep;\n\n\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\tif (!cachep) {\n\t\tprintk(KERN_EMERG\n\t\t       \"EXT4-fs: no memory for groupinfo slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "i",
            "GFP_KERNEL"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\nstatic const struct file_operations ext4_mb_seq_groups_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= ext4_mb_seq_groups_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nint ext4_mb_init(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned i, j;\n\tunsigned offset;\n\tunsigned max;\n\tint ret;\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_offsets);\n\n\tsbi->s_mb_offsets = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_offsets == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(*sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = kmalloc(i, GFP_KERNEL);\n\tif (sbi->s_mb_maxs == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ext4_groupinfo_create_slab(sb->s_blocksize);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* order 0 is regular bitmap */\n\tsbi->s_mb_maxs[0] = sb->s_blocksize << 3;\n\tsbi->s_mb_offsets[0] = 0;\n\n\ti = 1;\n\toffset = 0;\n\tmax = sb->s_blocksize << 2;\n\tdo {\n\t\tsbi->s_mb_offsets[i] = offset;\n\t\tsbi->s_mb_maxs[i] = max;\n\t\toffset += 1 << (sb->s_blocksize_bits - i);\n\t\tmax = max >> 1;\n\t\ti++;\n\t} while (i <= sb->s_blocksize_bits + 1);\n\n\tspin_lock_init(&sbi->s_md_lock);\n\tspin_lock_init(&sbi->s_bal_lock);\n\n\tsbi->s_mb_max_to_scan = MB_DEFAULT_MAX_TO_SCAN;\n\tsbi->s_mb_min_to_scan = MB_DEFAULT_MIN_TO_SCAN;\n\tsbi->s_mb_stats = MB_DEFAULT_STATS;\n\tsbi->s_mb_stream_request = MB_DEFAULT_STREAM_THRESHOLD;\n\tsbi->s_mb_order2_reqs = MB_DEFAULT_ORDER2_REQS;\n\t/*\n\t * The default group preallocation is 512, which for 4k block\n\t * sizes translates to 2 megabytes.  However for bigalloc file\n\t * systems, this is probably too big (i.e, if the cluster size\n\t * is 1 megabyte, then group preallocation size becomes half a\n\t * gigabyte!).  As a default, we will keep a two megabyte\n\t * group pralloc size for cluster sizes up to 64k, and after\n\t * that, we will force a minimum group preallocation size of\n\t * 32 clusters.  This translates to 8 megs when the cluster\n\t * size is 256k, and 32 megs when the cluster size is 1 meg,\n\t * which seems reasonable as a default.\n\t */\n\tsbi->s_mb_group_prealloc = max(MB_DEFAULT_GROUP_PREALLOC >>\n\t\t\t\t       sbi->s_cluster_bits, 32);\n\t/*\n\t * If there is a s_stripe > 1, then we set the s_mb_group_prealloc\n\t * to the lowest multiple of s_stripe which is bigger than\n\t * the s_mb_group_prealloc as determined above. We want\n\t * the preallocation size to be an exact multiple of the\n\t * RAID stripe size so that preallocations don't fragment\n\t * the stripes.\n\t */\n\tif (sbi->s_stripe > 1) {\n\t\tsbi->s_mb_group_prealloc = roundup(\n\t\t\tsbi->s_mb_group_prealloc, sbi->s_stripe);\n\t}\n\n\tsbi->s_locality_groups = alloc_percpu(struct ext4_locality_group);\n\tif (sbi->s_locality_groups == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor_each_possible_cpu(i) {\n\t\tstruct ext4_locality_group *lg;\n\t\tlg = per_cpu_ptr(sbi->s_locality_groups, i);\n\t\tmutex_init(&lg->lg_mutex);\n\t\tfor (j = 0; j < PREALLOC_TB_SIZE; j++)\n\t\t\tINIT_LIST_HEAD(&lg->lg_prealloc_list[j]);\n\t\tspin_lock_init(&lg->lg_prealloc_lock);\n\t}\n\n\t/* init file for buddy data */\n\tret = ext4_mb_init_backend(sb);\n\tif (ret != 0)\n\t\tgoto out_free_locality_groups;\n\n\tif (sbi->s_proc)\n\t\tproc_create_data(\"mb_groups\", S_IRUGO, sbi->s_proc,\n\t\t\t\t &ext4_mb_seq_groups_fops, sb);\n\n\treturn 0;\n\nout_free_locality_groups:\n\tfree_percpu(sbi->s_locality_groups);\n\tsbi->s_locality_groups = NULL;\nout:\n\tkfree(sbi->s_mb_offsets);\n\tsbi->s_mb_offsets = NULL;\n\tkfree(sbi->s_mb_maxs);\n\tsbi->s_mb_maxs = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_groupinfo_create_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2513-2550",
    "snippet": "static int ext4_groupinfo_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(ext4_grpinfo_slab_create_mutex);\n\tint slab_size;\n\tint blocksize_bits = order_base_2(size);\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep;\n\n\tif (cache_index >= NR_GRPINFO_CACHES)\n\t\treturn -EINVAL;\n\n\tif (unlikely(cache_index < 0))\n\t\tcache_index = 0;\n\n\tmutex_lock(&ext4_grpinfo_slab_create_mutex);\n\tif (ext4_groupinfo_caches[cache_index]) {\n\t\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = offsetof(struct ext4_group_info,\n\t\t\t\tbb_counters[blocksize_bits + 2]);\n\n\tcachep = kmem_cache_create(ext4_groupinfo_slab_names[cache_index],\n\t\t\t\t\tslab_size, 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t\tNULL);\n\n\text4_groupinfo_caches[cache_index] = cachep;\n\n\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\tif (!cachep) {\n\t\tprintk(KERN_EMERG\n\t\t       \"EXT4-fs: no memory for groupinfo slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define NR_GRPINFO_CACHES 8"
    ],
    "globals_used": [
      "static struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];",
      "static const char *ext4_groupinfo_slab_names[NR_GRPINFO_CACHES] = {\n\t\"ext4_groupinfo_1k\", \"ext4_groupinfo_2k\", \"ext4_groupinfo_4k\",\n\t\"ext4_groupinfo_8k\", \"ext4_groupinfo_16k\", \"ext4_groupinfo_32k\",\n\t\"ext4_groupinfo_64k\", \"ext4_groupinfo_128k\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG\n\t\t       \"EXT4-fs: no memory for groupinfo slab cache\\n\""
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_grpinfo_slab_create_mutex"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "ext4_groupinfo_slab_names[cache_index]",
            "slab_size",
            "0",
            "SLAB_RECLAIM_ACCOUNT",
            "NULL"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ext4_grpinfo_slab_create_mutex"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ext4_grpinfo_slab_create_mutex"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cache_index < 0"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_base_2",
          "args": [
            "size"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\n#define NR_GRPINFO_CACHES 8\n\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\nstatic const char *ext4_groupinfo_slab_names[NR_GRPINFO_CACHES] = {\n\t\"ext4_groupinfo_1k\", \"ext4_groupinfo_2k\", \"ext4_groupinfo_4k\",\n\t\"ext4_groupinfo_8k\", \"ext4_groupinfo_16k\", \"ext4_groupinfo_32k\",\n\t\"ext4_groupinfo_64k\", \"ext4_groupinfo_128k\"\n};\n\nstatic int ext4_groupinfo_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(ext4_grpinfo_slab_create_mutex);\n\tint slab_size;\n\tint blocksize_bits = order_base_2(size);\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep;\n\n\tif (cache_index >= NR_GRPINFO_CACHES)\n\t\treturn -EINVAL;\n\n\tif (unlikely(cache_index < 0))\n\t\tcache_index = 0;\n\n\tmutex_lock(&ext4_grpinfo_slab_create_mutex);\n\tif (ext4_groupinfo_caches[cache_index]) {\n\t\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = offsetof(struct ext4_group_info,\n\t\t\t\tbb_counters[blocksize_bits + 2]);\n\n\tcachep = kmem_cache_create(ext4_groupinfo_slab_names[cache_index],\n\t\t\t\t\tslab_size, 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\t\t\tNULL);\n\n\text4_groupinfo_caches[cache_index] = cachep;\n\n\tmutex_unlock(&ext4_grpinfo_slab_create_mutex);\n\tif (!cachep) {\n\t\tprintk(KERN_EMERG\n\t\t       \"EXT4-fs: no memory for groupinfo slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_groupinfo_destroy_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2502-2511",
    "snippet": "static void ext4_groupinfo_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_GRPINFO_CACHES; i++) {\n\t\tif (ext4_groupinfo_caches[i])\n\t\t\tkmem_cache_destroy(ext4_groupinfo_caches[i]);\n\t\text4_groupinfo_caches[i] = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [
      "#define NR_GRPINFO_CACHES 8"
    ],
    "globals_used": [
      "static struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext4_groupinfo_caches[i]"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\n#define NR_GRPINFO_CACHES 8\n\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\n\nstatic void ext4_groupinfo_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_GRPINFO_CACHES; i++) {\n\t\tif (ext4_groupinfo_caches[i])\n\t\t\tkmem_cache_destroy(ext4_groupinfo_caches[i]);\n\t\text4_groupinfo_caches[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "ext4_mb_init_backend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2453-2500",
    "snippet": "static int ext4_mb_init_backend(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\tstruct ext4_group_desc *desc;\n\tstruct kmem_cache *cachep;\n\n\terr = ext4_mb_alloc_groupinfo(sb, ngroups);\n\tif (err)\n\t\treturn err;\n\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't get new inode\");\n\t\tgoto err_freesgi;\n\t}\n\t/* To avoid potentially colliding with an valid on-disk inode number,\n\t * use EXT4_BAD_INO for the buddy cache inode number.  This inode is\n\t * not in the inode hash, so it should never be found by iget(), but\n\t * this will avoid confusion if it ever shows up during debugging. */\n\tsbi->s_buddy_cache->i_ino = EXT4_BAD_INO;\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't read descriptor %u\", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0)\n\t\tkmem_cache_free(cachep, ext4_get_group_info(sb, i));\n\ti = sbi->s_group_info_size;\n\twhile (i-- > 0)\n\t\tkfree(sbi->s_group_info[i]);\n\tiput(sbi->s_buddy_cache);\nerr_freesgi:\n\tkvfree(sbi->s_group_info);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sbi->s_group_info"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "sbi->s_buddy_cache"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_group_info[i]"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cachep",
            "ext4_get_group_info(sb, i)"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "i"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_groupinfo_cache",
          "args": [
            "sb->s_blocksize_bits"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "get_groupinfo_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2328-2335",
          "snippet": "static struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\n\nstatic struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_add_groupinfo",
          "args": [
            "sb",
            "i",
            "desc"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_add_groupinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2371-2451",
          "snippet": "int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t/*\n\t * First check if this group is the first of a reserved block.\n\t * If it's true, we have to allocate a new table of pointers\n\t * to ext4_group_info structures\n\t */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\tgoto exit_meta_group_info;\n\t\t}\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =\n\t\t\tmeta_group_info;\n\t}\n\n\tmeta_group_info =\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t/*\n\t * initialize bb_free to be able to skip\n\t * empty groups without initialization\n\t */\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tmeta_group_info[i]->bb_largest_free_order = -1;  /* uninit */\n\n#ifdef DOUBLE_CHECK\n\t{\n\t\tstruct buffer_head *bh;\n\t\tmeta_group_info[i]->bb_bitmap =\n\t\t\tkmalloc(sb->s_blocksize, GFP_NOFS);\n\t\tBUG_ON(meta_group_info[i]->bb_bitmap == NULL);\n\t\tbh = ext4_read_block_bitmap(sb, group);\n\t\tBUG_ON(bh == NULL);\n\t\tmemcpy(meta_group_info[i]->bb_bitmap, bh->b_data,\n\t\t\tsb->s_blocksize);\n\t\tput_bh(bh);\n\t}\n#endif\n\n\treturn 0;\n\nexit_group_info:\n\t/* If a meta_group_info table has been allocated, release it now */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tkfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;\n\t}\nexit_meta_group_info:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t/*\n\t * First check if this group is the first of a reserved block.\n\t * If it's true, we have to allocate a new table of pointers\n\t * to ext4_group_info structures\n\t */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\tgoto exit_meta_group_info;\n\t\t}\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =\n\t\t\tmeta_group_info;\n\t}\n\n\tmeta_group_info =\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t/*\n\t * initialize bb_free to be able to skip\n\t * empty groups without initialization\n\t */\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tmeta_group_info[i]->bb_largest_free_order = -1;  /* uninit */\n\n#ifdef DOUBLE_CHECK\n\t{\n\t\tstruct buffer_head *bh;\n\t\tmeta_group_info[i]->bb_bitmap =\n\t\t\tkmalloc(sb->s_blocksize, GFP_NOFS);\n\t\tBUG_ON(meta_group_info[i]->bb_bitmap == NULL);\n\t\tbh = ext4_read_block_bitmap(sb, group);\n\t\tBUG_ON(bh == NULL);\n\t\tmemcpy(meta_group_info[i]->bb_bitmap, bh->b_data,\n\t\t\tsb->s_blocksize);\n\t\tput_bh(bh);\n\t}\n#endif\n\n\treturn 0;\n\nexit_group_info:\n\t/* If a meta_group_info table has been allocated, release it now */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tkfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;\n\t}\nexit_meta_group_info:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"can't read descriptor %u\"",
            "i"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "277-309",
          "snippet": "struct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct ext4_group_desc * ext4_get_group_desc(struct super_block *sb,\n\t\t\t\t\t     ext4_group_t block_group,\n\t\t\t\t\t     struct buffer_head **bh)\n{\n\tunsigned int group_desc;\n\tunsigned int offset;\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_group_desc *desc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\tif (block_group >= ngroups) {\n\t\text4_error(sb, \"block_group >= groups_count - block_group = %u,\"\n\t\t\t   \" groups_count = %u\", block_group, ngroups);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT4_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text4_error(sb, \"Group descriptor not loaded - \"\n\t\t\t   \"block_group = %u, group_desc = %u, desc = %u\",\n\t\t\t   block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext4_group_desc *)(\n\t\t(__u8 *)sbi->s_group_desc[group_desc]->b_data +\n\t\toffset * EXT4_DESC_SIZE(sb));\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "sbi->s_buddy_cache"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_new_inode_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3557-3646",
          "snippet": "static noinline_for_stack int\next4_mb_new_inode_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_inode_info *ei;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ac->ac_b_ex.fe_len < ac->ac_g_ex.fe_len) {\n\t\tint winl;\n\t\tint wins;\n\t\tint win;\n\t\tint offs;\n\n\t\t/* we can't allocate as much as normalizer wants.\n\t\t * so, found space must get proper lstart\n\t\t * to cover original request */\n\t\tBUG_ON(ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical);\n\t\tBUG_ON(ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len);\n\n\t\t/* we're limited by original request in that\n\t\t * logical block must be covered any way\n\t\t * winl is window we can move our chunk within */\n\t\twinl = ac->ac_o_ex.fe_logical - ac->ac_g_ex.fe_logical;\n\n\t\t/* also, we should cover whole original request */\n\t\twins = EXT4_C2B(sbi, ac->ac_b_ex.fe_len - ac->ac_o_ex.fe_len);\n\n\t\t/* the smallest one defines real window */\n\t\twin = min(winl, wins);\n\n\t\toffs = ac->ac_o_ex.fe_logical %\n\t\t\tEXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\tif (offs && offs < win)\n\t\t\twin = offs;\n\n\t\tac->ac_b_ex.fe_logical = ac->ac_o_ex.fe_logical -\n\t\t\tEXT4_NUM_B2C(sbi, win);\n\t\tBUG_ON(ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical);\n\t\tBUG_ON(ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len);\n\t}\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_lstart = ac->ac_b_ex.fe_logical;\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_INODE_PA;\n\n\tmb_debug(1, \"new inode pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_inode_pa(ac, pa);\n\n\text4_mb_use_inode_pa(ac, pa);\n\tatomic_add(pa->pa_free, &sbi->s_mb_preallocated);\n\n\tei = EXT4_I(ac->ac_inode);\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\n\tpa->pa_obj_lock = &ei->i_prealloc_lock;\n\tpa->pa_inode = ac->ac_inode;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_add_rcu(&pa->pa_inode_list, &ei->i_prealloc_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_pspace_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_pspace_cachep;\n\nstatic noinline_for_stack int\next4_mb_new_inode_pa(struct ext4_allocation_context *ac)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_prealloc_space *pa;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_inode_info *ei;\n\n\t/* preallocate only when found space is larger then requested */\n\tBUG_ON(ac->ac_o_ex.fe_len >= ac->ac_b_ex.fe_len);\n\tBUG_ON(ac->ac_status != AC_STATUS_FOUND);\n\tBUG_ON(!S_ISREG(ac->ac_inode->i_mode));\n\n\tpa = kmem_cache_alloc(ext4_pspace_cachep, GFP_NOFS);\n\tif (pa == NULL)\n\t\treturn -ENOMEM;\n\n\tif (ac->ac_b_ex.fe_len < ac->ac_g_ex.fe_len) {\n\t\tint winl;\n\t\tint wins;\n\t\tint win;\n\t\tint offs;\n\n\t\t/* we can't allocate as much as normalizer wants.\n\t\t * so, found space must get proper lstart\n\t\t * to cover original request */\n\t\tBUG_ON(ac->ac_g_ex.fe_logical > ac->ac_o_ex.fe_logical);\n\t\tBUG_ON(ac->ac_g_ex.fe_len < ac->ac_o_ex.fe_len);\n\n\t\t/* we're limited by original request in that\n\t\t * logical block must be covered any way\n\t\t * winl is window we can move our chunk within */\n\t\twinl = ac->ac_o_ex.fe_logical - ac->ac_g_ex.fe_logical;\n\n\t\t/* also, we should cover whole original request */\n\t\twins = EXT4_C2B(sbi, ac->ac_b_ex.fe_len - ac->ac_o_ex.fe_len);\n\n\t\t/* the smallest one defines real window */\n\t\twin = min(winl, wins);\n\n\t\toffs = ac->ac_o_ex.fe_logical %\n\t\t\tEXT4_C2B(sbi, ac->ac_b_ex.fe_len);\n\t\tif (offs && offs < win)\n\t\t\twin = offs;\n\n\t\tac->ac_b_ex.fe_logical = ac->ac_o_ex.fe_logical -\n\t\t\tEXT4_NUM_B2C(sbi, win);\n\t\tBUG_ON(ac->ac_o_ex.fe_logical < ac->ac_b_ex.fe_logical);\n\t\tBUG_ON(ac->ac_o_ex.fe_len > ac->ac_b_ex.fe_len);\n\t}\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tpa->pa_lstart = ac->ac_b_ex.fe_logical;\n\tpa->pa_pstart = ext4_grp_offs_to_block(sb, &ac->ac_b_ex);\n\tpa->pa_len = ac->ac_b_ex.fe_len;\n\tpa->pa_free = pa->pa_len;\n\tatomic_set(&pa->pa_count, 1);\n\tspin_lock_init(&pa->pa_lock);\n\tINIT_LIST_HEAD(&pa->pa_inode_list);\n\tINIT_LIST_HEAD(&pa->pa_group_list);\n\tpa->pa_deleted = 0;\n\tpa->pa_type = MB_INODE_PA;\n\n\tmb_debug(1, \"new inode pa %p: %llu/%u for %u\\n\", pa,\n\t\t\tpa->pa_pstart, pa->pa_len, pa->pa_lstart);\n\ttrace_ext4_mb_new_inode_pa(ac, pa);\n\n\text4_mb_use_inode_pa(ac, pa);\n\tatomic_add(pa->pa_free, &sbi->s_mb_preallocated);\n\n\tei = EXT4_I(ac->ac_inode);\n\tgrp = ext4_get_group_info(sb, ac->ac_b_ex.fe_group);\n\n\tpa->pa_obj_lock = &ei->i_prealloc_lock;\n\tpa->pa_inode = ac->ac_inode;\n\n\text4_lock_group(sb, ac->ac_b_ex.fe_group);\n\tlist_add(&pa->pa_group_list, &grp->bb_prealloc_list);\n\text4_unlock_group(sb, ac->ac_b_ex.fe_group);\n\n\tspin_lock(pa->pa_obj_lock);\n\tlist_add_rcu(&pa->pa_inode_list, &ei->i_prealloc_list);\n\tspin_unlock(pa->pa_obj_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_alloc_groupinfo",
          "args": [
            "sb",
            "ngroups"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_alloc_groupinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2341-2368",
          "snippet": "int ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\tif (sbi->s_group_info) {\n\t\tmemcpy(new_groupinfo, sbi->s_group_info,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tsbi->s_group_info = new_groupinfo;\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\tif (sbi->s_group_info) {\n\t\tmemcpy(new_groupinfo, sbi->s_group_info,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tsbi->s_group_info = new_groupinfo;\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int ext4_mb_init_backend(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\text4_group_t i;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tint err;\n\tstruct ext4_group_desc *desc;\n\tstruct kmem_cache *cachep;\n\n\terr = ext4_mb_alloc_groupinfo(sb, ngroups);\n\tif (err)\n\t\treturn err;\n\n\tsbi->s_buddy_cache = new_inode(sb);\n\tif (sbi->s_buddy_cache == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't get new inode\");\n\t\tgoto err_freesgi;\n\t}\n\t/* To avoid potentially colliding with an valid on-disk inode number,\n\t * use EXT4_BAD_INO for the buddy cache inode number.  This inode is\n\t * not in the inode hash, so it should never be found by iget(), but\n\t * this will avoid confusion if it ever shows up during debugging. */\n\tsbi->s_buddy_cache->i_ino = EXT4_BAD_INO;\n\tEXT4_I(sbi->s_buddy_cache)->i_disksize = 0;\n\tfor (i = 0; i < ngroups; i++) {\n\t\tdesc = ext4_get_group_desc(sb, i, NULL);\n\t\tif (desc == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't read descriptor %u\", i);\n\t\t\tgoto err_freebuddy;\n\t\t}\n\t\tif (ext4_mb_add_groupinfo(sb, i, desc) != 0)\n\t\t\tgoto err_freebuddy;\n\t}\n\n\treturn 0;\n\nerr_freebuddy:\n\tcachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\twhile (i-- > 0)\n\t\tkmem_cache_free(cachep, ext4_get_group_info(sb, i));\n\ti = sbi->s_group_info_size;\n\twhile (i-- > 0)\n\t\tkfree(sbi->s_group_info[i]);\n\tiput(sbi->s_buddy_cache);\nerr_freesgi:\n\tkvfree(sbi->s_group_info);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ext4_mb_add_groupinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2371-2451",
    "snippet": "int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t/*\n\t * First check if this group is the first of a reserved block.\n\t * If it's true, we have to allocate a new table of pointers\n\t * to ext4_group_info structures\n\t */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\tgoto exit_meta_group_info;\n\t\t}\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =\n\t\t\tmeta_group_info;\n\t}\n\n\tmeta_group_info =\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t/*\n\t * initialize bb_free to be able to skip\n\t * empty groups without initialization\n\t */\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tmeta_group_info[i]->bb_largest_free_order = -1;  /* uninit */\n\n#ifdef DOUBLE_CHECK\n\t{\n\t\tstruct buffer_head *bh;\n\t\tmeta_group_info[i]->bb_bitmap =\n\t\t\tkmalloc(sb->s_blocksize, GFP_NOFS);\n\t\tBUG_ON(meta_group_info[i]->bb_bitmap == NULL);\n\t\tbh = ext4_read_block_bitmap(sb, group);\n\t\tBUG_ON(bh == NULL);\n\t\tmemcpy(meta_group_info[i]->bb_bitmap, bh->b_data,\n\t\t\tsb->s_blocksize);\n\t\tput_bh(bh);\n\t}\n#endif\n\n\treturn 0;\n\nexit_group_info:\n\t/* If a meta_group_info table has been allocated, release it now */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tkfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;\n\t}\nexit_meta_group_info:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "meta_group_info[i]->bb_bitmap",
            "bh->b_data",
            "sb->s_blocksize"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bh == NULL"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap",
          "args": [
            "sb",
            "group"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "504-517",
          "snippet": "struct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_read_block_bitmap_nowait(sb, block_group);\n\tif (!bh)\n\t\treturn NULL;\n\tif (ext4_wait_block_bitmap(sb, block_group, bh)) {\n\t\tput_bh(bh);\n\t\treturn NULL;\n\t}\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "meta_group_info[i]->bb_bitmap == NULL"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sb->s_blocksize",
            "GFP_NOFS"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&meta_group_info[i]->alloc_sem"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&meta_group_info[i]->bb_prealloc_list"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_group_clusters",
          "args": [
            "sb",
            "desc"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_group_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "203-209",
          "snippet": "__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\n__u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t       struct ext4_group_desc *bg)\n{\n\treturn le16_to_cpu(bg->bg_free_blocks_count_lo) |\n\t\t(EXT4_DESC_SIZE(sb) >= EXT4_MIN_DESC_SIZE_64BIT ?\n\t\t (__u32)le16_to_cpu(bg->bg_free_blocks_count_hi) << 16 : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_free_clusters_after_init",
          "args": [
            "sb",
            "group",
            "desc"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_clusters_after_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "251-257",
          "snippet": "unsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct ext4_group_desc *gdp)\n{\n\treturn num_clusters_in_group(sb, block_group) - \n\t\text4_num_overhead_clusters(sb, block_group, gdp);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nunsigned ext4_free_clusters_after_init(struct super_block *sb,\n\t\t\t\t       ext4_group_t block_group,\n\t\t\t\t       struct ext4_group_desc *gdp)\n{\n\treturn num_clusters_in_group(sb, block_group) - \n\t\text4_num_overhead_clusters(sb, block_group, gdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT4_BG_BLOCK_UNINIT"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXT4_GROUP_INFO_NEED_INIT_BIT",
            "&(meta_group_info[i]->bb_state)"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"can't allocate buddy mem\""
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "cachep",
            "GFP_NOFS"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_groupinfo_cache",
          "args": [
            "sb->s_blocksize_bits"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "get_groupinfo_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2328-2335",
          "snippet": "static struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\n\nstatic struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,\n\t\t\t  struct ext4_group_desc *desc)\n{\n\tint i;\n\tint metalen = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_info **meta_group_info;\n\tstruct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits);\n\n\t/*\n\t * First check if this group is the first of a reserved block.\n\t * If it's true, we have to allocate a new table of pointers\n\t * to ext4_group_info structures\n\t */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tmetalen = sizeof(*meta_group_info) <<\n\t\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\t\tmeta_group_info = kmalloc(metalen, GFP_NOFS);\n\t\tif (meta_group_info == NULL) {\n\t\t\text4_msg(sb, KERN_ERR, \"can't allocate mem \"\n\t\t\t\t \"for a buddy group\");\n\t\t\tgoto exit_meta_group_info;\n\t\t}\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] =\n\t\t\tmeta_group_info;\n\t}\n\n\tmeta_group_info =\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)];\n\ti = group & (EXT4_DESC_PER_BLOCK(sb) - 1);\n\n\tmeta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS);\n\tif (meta_group_info[i] == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy mem\");\n\t\tgoto exit_group_info;\n\t}\n\tset_bit(EXT4_GROUP_INFO_NEED_INIT_BIT,\n\t\t&(meta_group_info[i]->bb_state));\n\n\t/*\n\t * initialize bb_free to be able to skip\n\t * empty groups without initialization\n\t */\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_clusters_after_init(sb, group, desc);\n\t} else {\n\t\tmeta_group_info[i]->bb_free =\n\t\t\text4_free_group_clusters(sb, desc);\n\t}\n\n\tINIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list);\n\tinit_rwsem(&meta_group_info[i]->alloc_sem);\n\tmeta_group_info[i]->bb_free_root = RB_ROOT;\n\tmeta_group_info[i]->bb_largest_free_order = -1;  /* uninit */\n\n#ifdef DOUBLE_CHECK\n\t{\n\t\tstruct buffer_head *bh;\n\t\tmeta_group_info[i]->bb_bitmap =\n\t\t\tkmalloc(sb->s_blocksize, GFP_NOFS);\n\t\tBUG_ON(meta_group_info[i]->bb_bitmap == NULL);\n\t\tbh = ext4_read_block_bitmap(sb, group);\n\t\tBUG_ON(bh == NULL);\n\t\tmemcpy(meta_group_info[i]->bb_bitmap, bh->b_data,\n\t\t\tsb->s_blocksize);\n\t\tput_bh(bh);\n\t}\n#endif\n\n\treturn 0;\n\nexit_group_info:\n\t/* If a meta_group_info table has been allocated, release it now */\n\tif (group % EXT4_DESC_PER_BLOCK(sb) == 0) {\n\t\tkfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]);\n\t\tsbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL;\n\t}\nexit_meta_group_info:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ext4_mb_alloc_groupinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2341-2368",
    "snippet": "int ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\tif (sbi->s_group_info) {\n\t\tmemcpy(new_groupinfo, sbi->s_group_info,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tsbi->s_group_info = new_groupinfo;\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_debug",
          "args": [
            "\"allocated s_groupinfo array for %d meta_bg's\\n\"",
            "sbi->s_group_info_size"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "sbi->s_group_info"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_groupinfo",
            "sbi->s_group_info",
            "sbi->s_group_info_size * sizeof(*sbi->s_group_info)"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"can't allocate buddy meta group\""
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_kvzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvzalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "169-177",
          "snippet": "void *ext4_kvzalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kzalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags | __GFP_ZERO, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvzalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kzalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags | __GFP_ZERO, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "sizeof(*sbi->s_group_info) * size"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 2347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nint ext4_mb_alloc_groupinfo(struct super_block *sb, ext4_group_t ngroups)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tunsigned size;\n\tstruct ext4_group_info ***new_groupinfo;\n\n\tsize = (ngroups + EXT4_DESC_PER_BLOCK(sb) - 1) >>\n\t\tEXT4_DESC_PER_BLOCK_BITS(sb);\n\tif (size <= sbi->s_group_info_size)\n\t\treturn 0;\n\n\tsize = roundup_pow_of_two(sizeof(*sbi->s_group_info) * size);\n\tnew_groupinfo = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (!new_groupinfo) {\n\t\text4_msg(sb, KERN_ERR, \"can't allocate buddy meta group\");\n\t\treturn -ENOMEM;\n\t}\n\tif (sbi->s_group_info) {\n\t\tmemcpy(new_groupinfo, sbi->s_group_info,\n\t\t       sbi->s_group_info_size * sizeof(*sbi->s_group_info));\n\t\tkvfree(sbi->s_group_info);\n\t}\n\tsbi->s_group_info = new_groupinfo;\n\tsbi->s_group_info_size = size / sizeof(*sbi->s_group_info);\n\text4_debug(\"allocated s_groupinfo array for %d meta_bg's\\n\", \n\t\t   sbi->s_group_info_size);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_groupinfo_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2328-2335",
    "snippet": "static struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cachep"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_groupinfo_caches[NR_GRPINFO_CACHES];\n\nstatic struct kmem_cache *get_groupinfo_cache(int blocksize_bits)\n{\n\tint cache_index = blocksize_bits - EXT4_MIN_BLOCK_LOG_SIZE;\n\tstruct kmem_cache *cachep = ext4_groupinfo_caches[cache_index];\n\n\tBUG_ON(!cachep);\n\treturn cachep;\n}"
  },
  {
    "function_name": "ext4_mb_seq_groups_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2306-2318",
    "snippet": "static int ext4_mb_seq_groups_open(struct inode *inode, struct file *file)\n{\n\tstruct super_block *sb = PDE_DATA(inode);\n\tint rc;\n\n\trc = seq_open(file, &ext4_mb_seq_groups_ops);\n\tif (rc == 0) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = sb;\n\t}\n\treturn rc;\n\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_free_data_callback(struct super_block *sb,\n\t\t\t\tstruct ext4_journal_cb_entry *jce, int rc);",
      "static const struct seq_operations ext4_mb_seq_groups_ops = {\n\t.start  = ext4_mb_seq_groups_start,\n\t.next   = ext4_mb_seq_groups_next,\n\t.stop   = ext4_mb_seq_groups_stop,\n\t.show   = ext4_mb_seq_groups_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&ext4_mb_seq_groups_ops"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_free_data_callback(struct super_block *sb,\n\t\t\t\tstruct ext4_journal_cb_entry *jce, int rc);\nstatic const struct seq_operations ext4_mb_seq_groups_ops = {\n\t.start  = ext4_mb_seq_groups_start,\n\t.next   = ext4_mb_seq_groups_next,\n\t.stop   = ext4_mb_seq_groups_stop,\n\t.show   = ext4_mb_seq_groups_show,\n};\n\nstatic int ext4_mb_seq_groups_open(struct inode *inode, struct file *file)\n{\n\tstruct super_block *sb = PDE_DATA(inode);\n\tint rc;\n\n\trc = seq_open(file, &ext4_mb_seq_groups_ops);\n\tif (rc == 0) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = sb;\n\t}\n\treturn rc;\n\n}"
  },
  {
    "function_name": "ext4_mb_seq_groups_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2295-2297",
    "snippet": "static void ext4_mb_seq_groups_stop(struct seq_file *seq, void *v)\n{\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_seq_groups_stop(struct seq_file *seq, void *v)\n{\n}"
  },
  {
    "function_name": "ext4_mb_seq_groups_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2245-2293",
    "snippet": "static int ext4_mb_seq_groups_show(struct seq_file *seq, void *v)\n{\n\tstruct super_block *sb = seq->private;\n\text4_group_t group = (ext4_group_t) ((unsigned long) v);\n\tint i;\n\tint err, buddy_loaded = 0;\n\tstruct ext4_buddy e4b;\n\tstruct ext4_group_info *grinfo;\n\tstruct sg {\n\t\tstruct ext4_group_info info;\n\t\text4_grpblk_t counters[16];\n\t} sg;\n\n\tgroup--;\n\tif (group == 0)\n\t\tseq_printf(seq, \"#%-5s: %-5s %-5s %-5s \"\n\t\t\t\t\"[ %-5s %-5s %-5s %-5s %-5s %-5s %-5s \"\n\t\t\t\t  \"%-5s %-5s %-5s %-5s %-5s %-5s %-5s ]\\n\",\n\t\t\t   \"group\", \"free\", \"frags\", \"first\",\n\t\t\t   \"2^0\", \"2^1\", \"2^2\", \"2^3\", \"2^4\", \"2^5\", \"2^6\",\n\t\t\t   \"2^7\", \"2^8\", \"2^9\", \"2^10\", \"2^11\", \"2^12\", \"2^13\");\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(sg.info.bb_counters[0]) +\n\t\tsizeof(struct ext4_group_info);\n\tgrinfo = ext4_get_group_info(sb, group);\n\t/* Load the group info in memory only if not already loaded. */\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grinfo))) {\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\tseq_printf(seq, \"#%-5u: I/O error\\n\", group);\n\t\t\treturn 0;\n\t\t}\n\t\tbuddy_loaded = 1;\n\t}\n\n\tmemcpy(&sg, ext4_get_group_info(sb, group), i);\n\n\tif (buddy_loaded)\n\t\text4_mb_unload_buddy(&e4b);\n\n\tseq_printf(seq, \"#%-5u: %-5u %-5u %-5u [\", group, sg.info.bb_free,\n\t\t\tsg.info.bb_fragments, sg.info.bb_first_free);\n\tfor (i = 0; i <= 13; i++)\n\t\tseq_printf(seq, \" %-5u\", i <= sb->s_blocksize_bits + 1 ?\n\t\t\t\tsg.info.bb_counters[i] : 0);\n\tseq_printf(seq, \" ]\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\" ]\\n\""
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sg",
            "ext4_get_group_info(sb, group)",
            "i"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "group",
            "&e4b"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_MB_GRP_NEED_INIT(grinfo)"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_NEED_INIT",
          "args": [
            "grinfo"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(unsigned long) v"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_mb_seq_groups_show(struct seq_file *seq, void *v)\n{\n\tstruct super_block *sb = seq->private;\n\text4_group_t group = (ext4_group_t) ((unsigned long) v);\n\tint i;\n\tint err, buddy_loaded = 0;\n\tstruct ext4_buddy e4b;\n\tstruct ext4_group_info *grinfo;\n\tstruct sg {\n\t\tstruct ext4_group_info info;\n\t\text4_grpblk_t counters[16];\n\t} sg;\n\n\tgroup--;\n\tif (group == 0)\n\t\tseq_printf(seq, \"#%-5s: %-5s %-5s %-5s \"\n\t\t\t\t\"[ %-5s %-5s %-5s %-5s %-5s %-5s %-5s \"\n\t\t\t\t  \"%-5s %-5s %-5s %-5s %-5s %-5s %-5s ]\\n\",\n\t\t\t   \"group\", \"free\", \"frags\", \"first\",\n\t\t\t   \"2^0\", \"2^1\", \"2^2\", \"2^3\", \"2^4\", \"2^5\", \"2^6\",\n\t\t\t   \"2^7\", \"2^8\", \"2^9\", \"2^10\", \"2^11\", \"2^12\", \"2^13\");\n\n\ti = (sb->s_blocksize_bits + 2) * sizeof(sg.info.bb_counters[0]) +\n\t\tsizeof(struct ext4_group_info);\n\tgrinfo = ext4_get_group_info(sb, group);\n\t/* Load the group info in memory only if not already loaded. */\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grinfo))) {\n\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\tif (err) {\n\t\t\tseq_printf(seq, \"#%-5u: I/O error\\n\", group);\n\t\t\treturn 0;\n\t\t}\n\t\tbuddy_loaded = 1;\n\t}\n\n\tmemcpy(&sg, ext4_get_group_info(sb, group), i);\n\n\tif (buddy_loaded)\n\t\text4_mb_unload_buddy(&e4b);\n\n\tseq_printf(seq, \"#%-5u: %-5u %-5u %-5u [\", group, sg.info.bb_free,\n\t\t\tsg.info.bb_fragments, sg.info.bb_first_free);\n\tfor (i = 0; i <= 13; i++)\n\t\tseq_printf(seq, \" %-5u\", i <= sb->s_blocksize_bits + 1 ?\n\t\t\t\tsg.info.bb_counters[i] : 0);\n\tseq_printf(seq, \" ]\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_seq_groups_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2233-2243",
    "snippet": "static void *ext4_mb_seq_groups_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct super_block *sb = seq->private;\n\text4_group_t group;\n\n\t++*pos;\n\tif (*pos < 0 || *pos >= ext4_get_groups_count(sb))\n\t\treturn NULL;\n\tgroup = *pos + 1;\n\treturn (void *) ((unsigned long) group);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void *ext4_mb_seq_groups_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct super_block *sb = seq->private;\n\text4_group_t group;\n\n\t++*pos;\n\tif (*pos < 0 || *pos >= ext4_get_groups_count(sb))\n\t\treturn NULL;\n\tgroup = *pos + 1;\n\treturn (void *) ((unsigned long) group);\n}"
  },
  {
    "function_name": "ext4_mb_seq_groups_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2222-2231",
    "snippet": "static void *ext4_mb_seq_groups_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct super_block *sb = seq->private;\n\text4_group_t group;\n\n\tif (*pos < 0 || *pos >= ext4_get_groups_count(sb))\n\t\treturn NULL;\n\tgroup = *pos + 1;\n\treturn (void *) ((unsigned long) group);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void *ext4_mb_seq_groups_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct super_block *sb = seq->private;\n\text4_group_t group;\n\n\tif (*pos < 0 || *pos >= ext4_get_groups_count(sb))\n\t\treturn NULL;\n\tgroup = *pos + 1;\n\treturn (void *) ((unsigned long) group);\n}"
  },
  {
    "function_name": "ext4_mb_regular_allocator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2076-2220",
    "snippet": "static noinline_for_stack int\next4_mb_regular_allocator(struct ext4_allocation_context *ac)\n{\n\text4_group_t ngroups, group, i;\n\tint cr;\n\tint err = 0;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\tstruct ext4_buddy e4b;\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\tngroups = ext4_get_groups_count(sb);\n\t/* non-extent files are limited to low blocks/groups */\n\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)))\n\t\tngroups = sbi->s_blockfile_groups;\n\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\t/* first, try the goal */\n\terr = ext4_mb_find_by_goal(ac, &e4b);\n\tif (err || ac->ac_status == AC_STATUS_FOUND)\n\t\tgoto out;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\tgoto out;\n\n\t/*\n\t * ac->ac2_order is set only if the fe_len is a power of 2\n\t * if ac2_order is set we also set criteria to 0 so that we\n\t * try exact allocation using buddy.\n\t */\n\ti = fls(ac->ac_g_ex.fe_len);\n\tac->ac_2order = 0;\n\t/*\n\t * We search using buddy data only if the order of the request\n\t * is greater than equal to the sbi_s_mb_order2_reqs\n\t * You can tune it via /sys/fs/ext4/<partition>/mb_order2_req\n\t */\n\tif (i >= sbi->s_mb_order2_reqs) {\n\t\t/*\n\t\t * This should tell if fe_len is exactly power of 2\n\t\t */\n\t\tif ((ac->ac_g_ex.fe_len & (~(1 << (i - 1)))) == 0)\n\t\t\tac->ac_2order = i - 1;\n\t}\n\n\t/* if stream allocation is enabled, use global goal */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\t/* TBD: may be hot point */\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tac->ac_g_ex.fe_group = sbi->s_mb_last_group;\n\t\tac->ac_g_ex.fe_start = sbi->s_mb_last_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n\n\t/* Let's just scan groups to find more-less suitable blocks */\n\tcr = ac->ac_2order ? 0 : 1;\n\t/*\n\t * cr == 0 try to get exact allocation,\n\t * cr == 3  try to get anything\n\t */\nrepeat:\n\tfor (; cr < 4 && ac->ac_status == AC_STATUS_CONTINUE; cr++) {\n\t\tac->ac_criteria = cr;\n\t\t/*\n\t\t * searching for the right group start\n\t\t * from the goal value specified\n\t\t */\n\t\tgroup = ac->ac_g_ex.fe_group;\n\n\t\tfor (i = 0; i < ngroups; group++, i++) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Artificially restricted ngroups for non-extent\n\t\t\t * files makes group > ngroups possible on first loop.\n\t\t\t */\n\t\t\tif (group >= ngroups)\n\t\t\t\tgroup = 0;\n\n\t\t\t/* This now checks without needing the buddy page */\n\t\t\tif (!ext4_mb_good_group(ac, group, cr))\n\t\t\t\tcontinue;\n\n\t\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\text4_lock_group(sb, group);\n\n\t\t\t/*\n\t\t\t * We need to check again after locking the\n\t\t\t * block group\n\t\t\t */\n\t\t\tif (!ext4_mb_good_group(ac, group, cr)) {\n\t\t\t\text4_unlock_group(sb, group);\n\t\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tac->ac_groups_scanned++;\n\t\t\tif (cr == 0 && ac->ac_2order < sb->s_blocksize_bits+2)\n\t\t\t\text4_mb_simple_scan_group(ac, &e4b);\n\t\t\telse if (cr == 1 && sbi->s_stripe &&\n\t\t\t\t\t!(ac->ac_g_ex.fe_len % sbi->s_stripe))\n\t\t\t\text4_mb_scan_aligned(ac, &e4b);\n\t\t\telse\n\t\t\t\text4_mb_complex_scan_group(ac, &e4b);\n\n\t\t\text4_unlock_group(sb, group);\n\t\t\text4_mb_unload_buddy(&e4b);\n\n\t\t\tif (ac->ac_status != AC_STATUS_CONTINUE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ac->ac_b_ex.fe_len > 0 && ac->ac_status != AC_STATUS_FOUND &&\n\t    !(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t/*\n\t\t * We've been searching too long. Let's try to allocate\n\t\t * the best chunk we've found so far\n\t\t */\n\n\t\text4_mb_try_best_found(ac, &e4b);\n\t\tif (ac->ac_status != AC_STATUS_FOUND) {\n\t\t\t/*\n\t\t\t * Someone more lucky has already allocated it.\n\t\t\t * The only thing we can do is just take first\n\t\t\t * found block(s)\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: someone won our chunk\\n\");\n\t\t\t */\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tac->ac_flags |= EXT4_MB_HINT_FIRST;\n\t\t\tcr = 3;\n\t\t\tatomic_inc(&sbi->s_mb_lost_chunks);\n\t\t\tgoto repeat;\n\t\t}\n\t}\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sbi->s_mb_lost_chunks"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_try_best_found",
          "args": [
            "ac",
            "&e4b"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_try_best_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1775-1801",
          "snippet": "static noinline_for_stack\nint ext4_mb_try_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent ex = ac->ac_b_ex;\n\text4_group_t group = ex.fe_group;\n\tint max;\n\tint err;\n\n\tBUG_ON(ex.fe_len <= 0);\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ex.fe_start, ex.fe_len, &ex);\n\n\tif (max > 0) {\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nint ext4_mb_try_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent ex = ac->ac_b_ex;\n\text4_group_t group = ex.fe_group;\n\tint max;\n\tint err;\n\n\tBUG_ON(ex.fe_len <= 0);\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ex.fe_start, ex.fe_len, &ex);\n\n\tif (max > 0) {\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "&e4b"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_complex_scan_group",
          "args": [
            "ac",
            "&e4b"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_complex_scan_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1915-1968",
          "snippet": "static noinline_for_stack\nvoid ext4_mb_complex_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\tint i;\n\tint free;\n\n\tfree = e4b->bd_info->bb_free;\n\tBUG_ON(free <= 0);\n\n\ti = e4b->bd_info->bb_first_free;\n\n\twhile (free && ac->ac_status == AC_STATUS_CONTINUE) {\n\t\ti = mb_find_next_zero_bit(bitmap,\n\t\t\t\t\t\tEXT4_CLUSTERS_PER_GROUP(sb), i);\n\t\tif (i >= EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * IF we have corrupt bitmap, we won't find any\n\t\t\t * free blocks even though group info says we\n\t\t\t * we have free blocks\n\t\t\t */\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But bitmap says 0\",\n\t\t\t\t\tfree);\n\t\t\tbreak;\n\t\t}\n\n\t\tmb_find_extent(e4b, i, ac->ac_g_ex.fe_len, &ex);\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tif (free < ex.fe_len) {\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But got %d blocks\",\n\t\t\t\t\tfree, ex.fe_len);\n\t\t\t/*\n\t\t\t * The number of free blocks differs. This mostly\n\t\t\t * indicate that the bitmap is corrupt. So exit\n\t\t\t * without claiming the space.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tex.fe_logical = 0xDEADC0DE; /* debug value */\n\t\text4_mb_measure_extent(ac, &ex, e4b);\n\n\t\ti += ex.fe_len;\n\t\tfree -= ex.fe_len;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 1);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_complex_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\tint i;\n\tint free;\n\n\tfree = e4b->bd_info->bb_free;\n\tBUG_ON(free <= 0);\n\n\ti = e4b->bd_info->bb_first_free;\n\n\twhile (free && ac->ac_status == AC_STATUS_CONTINUE) {\n\t\ti = mb_find_next_zero_bit(bitmap,\n\t\t\t\t\t\tEXT4_CLUSTERS_PER_GROUP(sb), i);\n\t\tif (i >= EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * IF we have corrupt bitmap, we won't find any\n\t\t\t * free blocks even though group info says we\n\t\t\t * we have free blocks\n\t\t\t */\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But bitmap says 0\",\n\t\t\t\t\tfree);\n\t\t\tbreak;\n\t\t}\n\n\t\tmb_find_extent(e4b, i, ac->ac_g_ex.fe_len, &ex);\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tif (free < ex.fe_len) {\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But got %d blocks\",\n\t\t\t\t\tfree, ex.fe_len);\n\t\t\t/*\n\t\t\t * The number of free blocks differs. This mostly\n\t\t\t * indicate that the bitmap is corrupt. So exit\n\t\t\t * without claiming the space.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tex.fe_logical = 0xDEADC0DE; /* debug value */\n\t\text4_mb_measure_extent(ac, &ex, e4b);\n\n\t\ti += ex.fe_len;\n\t\tfree -= ex.fe_len;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_scan_aligned",
          "args": [
            "ac",
            "&e4b"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_scan_aligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1974-2009",
          "snippet": "static noinline_for_stack\nvoid ext4_mb_scan_aligned(struct ext4_allocation_context *ac,\n\t\t\t\t struct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\text4_fsblk_t first_group_block;\n\text4_fsblk_t a;\n\text4_grpblk_t i;\n\tint max;\n\n\tBUG_ON(sbi->s_stripe == 0);\n\n\t/* find first stripe-aligned block in group */\n\tfirst_group_block = ext4_group_first_block_no(sb, e4b->bd_group);\n\n\ta = first_group_block + sbi->s_stripe - 1;\n\tdo_div(a, sbi->s_stripe);\n\ti = (a * sbi->s_stripe) - first_group_block;\n\n\twhile (i < EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\tif (!mb_test_bit(i, bitmap)) {\n\t\t\tmax = mb_find_extent(e4b, i, sbi->s_stripe, &ex);\n\t\t\tif (max >= sbi->s_stripe) {\n\t\t\t\tac->ac_found++;\n\t\t\t\tex.fe_logical = 0xDEADF00D; /* debug value */\n\t\t\t\tac->ac_b_ex = ex;\n\t\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti += sbi->s_stripe;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_scan_aligned(struct ext4_allocation_context *ac,\n\t\t\t\t struct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\text4_fsblk_t first_group_block;\n\text4_fsblk_t a;\n\text4_grpblk_t i;\n\tint max;\n\n\tBUG_ON(sbi->s_stripe == 0);\n\n\t/* find first stripe-aligned block in group */\n\tfirst_group_block = ext4_group_first_block_no(sb, e4b->bd_group);\n\n\ta = first_group_block + sbi->s_stripe - 1;\n\tdo_div(a, sbi->s_stripe);\n\ti = (a * sbi->s_stripe) - first_group_block;\n\n\twhile (i < EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\tif (!mb_test_bit(i, bitmap)) {\n\t\t\tmax = mb_find_extent(e4b, i, sbi->s_stripe, &ex);\n\t\t\tif (max >= sbi->s_stripe) {\n\t\t\t\tac->ac_found++;\n\t\t\t\tex.fe_logical = 0xDEADF00D; /* debug value */\n\t\t\t\tac->ac_b_ex = ex;\n\t\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti += sbi->s_stripe;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_simple_scan_group",
          "args": [
            "ac",
            "&e4b"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_simple_scan_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1871-1908",
          "snippet": "static noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i <= sb->s_blocksize_bits + 1; i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tBUG_ON(buddy == NULL);\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tBUG_ON(k >= max);\n\n\t\tac->ac_found++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i <= sb->s_blocksize_bits + 1; i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tBUG_ON(buddy == NULL);\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tBUG_ON(k >= max);\n\n\t\tac->ac_found++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_good_group",
          "args": [
            "ac",
            "group",
            "cr"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_good_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "2012-2074",
          "snippet": "static int ext4_mb_good_group(struct ext4_allocation_context *ac,\n\t\t\t\text4_group_t group, int cr)\n{\n\tunsigned free, fragments;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(ac->ac_sb));\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\n\tBUG_ON(cr < 0 || cr >= 4);\n\n\tfree = grp->bb_free;\n\tif (free == 0)\n\t\treturn 0;\n\tif (cr <= 2 && free < ac->ac_g_ex.fe_len)\n\t\treturn 0;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\treturn 0;\n\n\t/* We only do this if the grp has never been initialized */\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\tint ret = ext4_mb_init_group(ac->ac_sb, group);\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tfragments = grp->bb_fragments;\n\tif (fragments == 0)\n\t\treturn 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tBUG_ON(ac->ac_2order == 0);\n\n\t\t/* Avoid using the first bg of a flexgroup for data files */\n\t\tif ((ac->ac_flags & EXT4_MB_HINT_DATA) &&\n\t\t    (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &&\n\t\t    ((group % flex_size) == 0))\n\t\t\treturn 0;\n\n\t\tif ((ac->ac_2order > ac->ac_sb->s_blocksize_bits+1) ||\n\t\t    (free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\n\t\tif (grp->bb_largest_free_order < ac->ac_2order)\n\t\t\treturn 0;\n\n\t\treturn 1;\n\tcase 1:\n\t\tif ((free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 2:\n\t\tif (free >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 3:\n\t\treturn 1;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_mb_good_group(struct ext4_allocation_context *ac,\n\t\t\t\text4_group_t group, int cr)\n{\n\tunsigned free, fragments;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(ac->ac_sb));\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\n\tBUG_ON(cr < 0 || cr >= 4);\n\n\tfree = grp->bb_free;\n\tif (free == 0)\n\t\treturn 0;\n\tif (cr <= 2 && free < ac->ac_g_ex.fe_len)\n\t\treturn 0;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\treturn 0;\n\n\t/* We only do this if the grp has never been initialized */\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\tint ret = ext4_mb_init_group(ac->ac_sb, group);\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tfragments = grp->bb_fragments;\n\tif (fragments == 0)\n\t\treturn 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tBUG_ON(ac->ac_2order == 0);\n\n\t\t/* Avoid using the first bg of a flexgroup for data files */\n\t\tif ((ac->ac_flags & EXT4_MB_HINT_DATA) &&\n\t\t    (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &&\n\t\t    ((group % flex_size) == 0))\n\t\t\treturn 0;\n\n\t\tif ((ac->ac_2order > ac->ac_sb->s_blocksize_bits+1) ||\n\t\t    (free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\n\t\tif (grp->bb_largest_free_order < ac->ac_2order)\n\t\t\treturn 0;\n\n\t\treturn 1;\n\tcase 1:\n\t\tif ((free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 2:\n\t\tif (free >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 3:\n\t\treturn 1;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "sb",
            "group",
            "&e4b"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_md_lock"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_md_lock"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "ac->ac_g_ex.fe_len"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_find_by_goal",
          "args": [
            "ac",
            "&e4b"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_find_by_goal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1803-1865",
          "snippet": "static noinline_for_stack\nint ext4_mb_find_by_goal(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_buddy *e4b)\n{\n\text4_group_t group = ac->ac_g_ex.fe_group;\n\tint max;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\tstruct ext4_free_extent ex;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_TRY_GOAL))\n\t\treturn 0;\n\tif (grp->bb_free == 0)\n\t\treturn 0;\n\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))) {\n\t\text4_mb_unload_buddy(e4b);\n\t\treturn 0;\n\t}\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ac->ac_g_ex.fe_start,\n\t\t\t     ac->ac_g_ex.fe_len, &ex);\n\tex.fe_logical = 0xDEADFA11; /* debug value */\n\n\tif (max >= ac->ac_g_ex.fe_len && ac->ac_g_ex.fe_len == sbi->s_stripe) {\n\t\text4_fsblk_t start;\n\n\t\tstart = ext4_group_first_block_no(ac->ac_sb, e4b->bd_group) +\n\t\t\tex.fe_start;\n\t\t/* use do_div to get remainder (would be 64-bit modulo) */\n\t\tif (do_div(start, sbi->s_stripe) == 0) {\n\t\t\tac->ac_found++;\n\t\t\tac->ac_b_ex = ex;\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t}\n\t} else if (max >= ac->ac_g_ex.fe_len) {\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t} else if (max > 0 && (ac->ac_flags & EXT4_MB_HINT_MERGE)) {\n\t\t/* Sometimes, caller may want to merge even small\n\t\t * number of blocks to an existing extent */\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nint ext4_mb_find_by_goal(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_buddy *e4b)\n{\n\text4_group_t group = ac->ac_g_ex.fe_group;\n\tint max;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\tstruct ext4_free_extent ex;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_TRY_GOAL))\n\t\treturn 0;\n\tif (grp->bb_free == 0)\n\t\treturn 0;\n\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))) {\n\t\text4_mb_unload_buddy(e4b);\n\t\treturn 0;\n\t}\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ac->ac_g_ex.fe_start,\n\t\t\t     ac->ac_g_ex.fe_len, &ex);\n\tex.fe_logical = 0xDEADFA11; /* debug value */\n\n\tif (max >= ac->ac_g_ex.fe_len && ac->ac_g_ex.fe_len == sbi->s_stripe) {\n\t\text4_fsblk_t start;\n\n\t\tstart = ext4_group_first_block_no(ac->ac_sb, e4b->bd_group) +\n\t\t\tex.fe_start;\n\t\t/* use do_div to get remainder (would be 64-bit modulo) */\n\t\tif (do_div(start, sbi->s_stripe) == 0) {\n\t\t\tac->ac_found++;\n\t\t\tac->ac_b_ex = ex;\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t}\n\t} else if (max >= ac->ac_g_ex.fe_len) {\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t} else if (max > 0 && (ac->ac_flags & EXT4_MB_HINT_MERGE)) {\n\t\t/* Sometimes, caller may want to merge even small\n\t\t * number of blocks to an existing extent */\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_status == AC_STATUS_FOUND"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "ac->ac_inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_regular_allocator(struct ext4_allocation_context *ac)\n{\n\text4_group_t ngroups, group, i;\n\tint cr;\n\tint err = 0;\n\tstruct ext4_sb_info *sbi;\n\tstruct super_block *sb;\n\tstruct ext4_buddy e4b;\n\n\tsb = ac->ac_sb;\n\tsbi = EXT4_SB(sb);\n\tngroups = ext4_get_groups_count(sb);\n\t/* non-extent files are limited to low blocks/groups */\n\tif (!(ext4_test_inode_flag(ac->ac_inode, EXT4_INODE_EXTENTS)))\n\t\tngroups = sbi->s_blockfile_groups;\n\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\t/* first, try the goal */\n\terr = ext4_mb_find_by_goal(ac, &e4b);\n\tif (err || ac->ac_status == AC_STATUS_FOUND)\n\t\tgoto out;\n\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_GOAL_ONLY))\n\t\tgoto out;\n\n\t/*\n\t * ac->ac2_order is set only if the fe_len is a power of 2\n\t * if ac2_order is set we also set criteria to 0 so that we\n\t * try exact allocation using buddy.\n\t */\n\ti = fls(ac->ac_g_ex.fe_len);\n\tac->ac_2order = 0;\n\t/*\n\t * We search using buddy data only if the order of the request\n\t * is greater than equal to the sbi_s_mb_order2_reqs\n\t * You can tune it via /sys/fs/ext4/<partition>/mb_order2_req\n\t */\n\tif (i >= sbi->s_mb_order2_reqs) {\n\t\t/*\n\t\t * This should tell if fe_len is exactly power of 2\n\t\t */\n\t\tif ((ac->ac_g_ex.fe_len & (~(1 << (i - 1)))) == 0)\n\t\t\tac->ac_2order = i - 1;\n\t}\n\n\t/* if stream allocation is enabled, use global goal */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\t/* TBD: may be hot point */\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tac->ac_g_ex.fe_group = sbi->s_mb_last_group;\n\t\tac->ac_g_ex.fe_start = sbi->s_mb_last_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n\n\t/* Let's just scan groups to find more-less suitable blocks */\n\tcr = ac->ac_2order ? 0 : 1;\n\t/*\n\t * cr == 0 try to get exact allocation,\n\t * cr == 3  try to get anything\n\t */\nrepeat:\n\tfor (; cr < 4 && ac->ac_status == AC_STATUS_CONTINUE; cr++) {\n\t\tac->ac_criteria = cr;\n\t\t/*\n\t\t * searching for the right group start\n\t\t * from the goal value specified\n\t\t */\n\t\tgroup = ac->ac_g_ex.fe_group;\n\n\t\tfor (i = 0; i < ngroups; group++, i++) {\n\t\t\tcond_resched();\n\t\t\t/*\n\t\t\t * Artificially restricted ngroups for non-extent\n\t\t\t * files makes group > ngroups possible on first loop.\n\t\t\t */\n\t\t\tif (group >= ngroups)\n\t\t\t\tgroup = 0;\n\n\t\t\t/* This now checks without needing the buddy page */\n\t\t\tif (!ext4_mb_good_group(ac, group, cr))\n\t\t\t\tcontinue;\n\n\t\t\terr = ext4_mb_load_buddy(sb, group, &e4b);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\text4_lock_group(sb, group);\n\n\t\t\t/*\n\t\t\t * We need to check again after locking the\n\t\t\t * block group\n\t\t\t */\n\t\t\tif (!ext4_mb_good_group(ac, group, cr)) {\n\t\t\t\text4_unlock_group(sb, group);\n\t\t\t\text4_mb_unload_buddy(&e4b);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tac->ac_groups_scanned++;\n\t\t\tif (cr == 0 && ac->ac_2order < sb->s_blocksize_bits+2)\n\t\t\t\text4_mb_simple_scan_group(ac, &e4b);\n\t\t\telse if (cr == 1 && sbi->s_stripe &&\n\t\t\t\t\t!(ac->ac_g_ex.fe_len % sbi->s_stripe))\n\t\t\t\text4_mb_scan_aligned(ac, &e4b);\n\t\t\telse\n\t\t\t\text4_mb_complex_scan_group(ac, &e4b);\n\n\t\t\text4_unlock_group(sb, group);\n\t\t\text4_mb_unload_buddy(&e4b);\n\n\t\t\tif (ac->ac_status != AC_STATUS_CONTINUE)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ac->ac_b_ex.fe_len > 0 && ac->ac_status != AC_STATUS_FOUND &&\n\t    !(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t/*\n\t\t * We've been searching too long. Let's try to allocate\n\t\t * the best chunk we've found so far\n\t\t */\n\n\t\text4_mb_try_best_found(ac, &e4b);\n\t\tif (ac->ac_status != AC_STATUS_FOUND) {\n\t\t\t/*\n\t\t\t * Someone more lucky has already allocated it.\n\t\t\t * The only thing we can do is just take first\n\t\t\t * found block(s)\n\t\t\tprintk(KERN_DEBUG \"EXT4-fs: someone won our chunk\\n\");\n\t\t\t */\n\t\t\tac->ac_b_ex.fe_group = 0;\n\t\t\tac->ac_b_ex.fe_start = 0;\n\t\t\tac->ac_b_ex.fe_len = 0;\n\t\t\tac->ac_status = AC_STATUS_CONTINUE;\n\t\t\tac->ac_flags |= EXT4_MB_HINT_FIRST;\n\t\t\tcr = 3;\n\t\t\tatomic_inc(&sbi->s_mb_lost_chunks);\n\t\t\tgoto repeat;\n\t\t}\n\t}\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_mb_good_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "2012-2074",
    "snippet": "static int ext4_mb_good_group(struct ext4_allocation_context *ac,\n\t\t\t\text4_group_t group, int cr)\n{\n\tunsigned free, fragments;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(ac->ac_sb));\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\n\tBUG_ON(cr < 0 || cr >= 4);\n\n\tfree = grp->bb_free;\n\tif (free == 0)\n\t\treturn 0;\n\tif (cr <= 2 && free < ac->ac_g_ex.fe_len)\n\t\treturn 0;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\treturn 0;\n\n\t/* We only do this if the grp has never been initialized */\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\tint ret = ext4_mb_init_group(ac->ac_sb, group);\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tfragments = grp->bb_fragments;\n\tif (fragments == 0)\n\t\treturn 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tBUG_ON(ac->ac_2order == 0);\n\n\t\t/* Avoid using the first bg of a flexgroup for data files */\n\t\tif ((ac->ac_flags & EXT4_MB_HINT_DATA) &&\n\t\t    (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &&\n\t\t    ((group % flex_size) == 0))\n\t\t\treturn 0;\n\n\t\tif ((ac->ac_2order > ac->ac_sb->s_blocksize_bits+1) ||\n\t\t    (free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\n\t\tif (grp->bb_largest_free_order < ac->ac_2order)\n\t\t\treturn 0;\n\n\t\treturn 1;\n\tcase 1:\n\t\tif ((free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 2:\n\t\tif (free >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 3:\n\t\treturn 1;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_2order == 0"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_init_group",
          "args": [
            "ac->ac_sb",
            "group"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_init_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1033-1093",
          "snippet": "static noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(1, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(1, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_MB_GRP_NEED_INIT(grp)"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_NEED_INIT",
          "args": [
            "grp"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_MB_GRP_BBITMAP_CORRUPT(grp)"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "grp"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cr < 0 || cr >= 4"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "ac->ac_sb",
            "group"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_flex_bg_size",
          "args": [
            "EXT4_SB(ac->ac_sb)"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_mb_good_group(struct ext4_allocation_context *ac,\n\t\t\t\text4_group_t group, int cr)\n{\n\tunsigned free, fragments;\n\tint flex_size = ext4_flex_bg_size(EXT4_SB(ac->ac_sb));\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\n\tBUG_ON(cr < 0 || cr >= 4);\n\n\tfree = grp->bb_free;\n\tif (free == 0)\n\t\treturn 0;\n\tif (cr <= 2 && free < ac->ac_g_ex.fe_len)\n\t\treturn 0;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(grp)))\n\t\treturn 0;\n\n\t/* We only do this if the grp has never been initialized */\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\tint ret = ext4_mb_init_group(ac->ac_sb, group);\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tfragments = grp->bb_fragments;\n\tif (fragments == 0)\n\t\treturn 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tBUG_ON(ac->ac_2order == 0);\n\n\t\t/* Avoid using the first bg of a flexgroup for data files */\n\t\tif ((ac->ac_flags & EXT4_MB_HINT_DATA) &&\n\t\t    (flex_size >= EXT4_FLEX_SIZE_DIR_ALLOC_SCHEME) &&\n\t\t    ((group % flex_size) == 0))\n\t\t\treturn 0;\n\n\t\tif ((ac->ac_2order > ac->ac_sb->s_blocksize_bits+1) ||\n\t\t    (free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\n\t\tif (grp->bb_largest_free_order < ac->ac_2order)\n\t\t\treturn 0;\n\n\t\treturn 1;\n\tcase 1:\n\t\tif ((free / fragments) >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 2:\n\t\tif (free >= ac->ac_g_ex.fe_len)\n\t\t\treturn 1;\n\t\tbreak;\n\tcase 3:\n\t\treturn 1;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_scan_aligned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1974-2009",
    "snippet": "static noinline_for_stack\nvoid ext4_mb_scan_aligned(struct ext4_allocation_context *ac,\n\t\t\t\t struct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\text4_fsblk_t first_group_block;\n\text4_fsblk_t a;\n\text4_grpblk_t i;\n\tint max;\n\n\tBUG_ON(sbi->s_stripe == 0);\n\n\t/* find first stripe-aligned block in group */\n\tfirst_group_block = ext4_group_first_block_no(sb, e4b->bd_group);\n\n\ta = first_group_block + sbi->s_stripe - 1;\n\tdo_div(a, sbi->s_stripe);\n\ti = (a * sbi->s_stripe) - first_group_block;\n\n\twhile (i < EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\tif (!mb_test_bit(i, bitmap)) {\n\t\t\tmax = mb_find_extent(e4b, i, sbi->s_stripe, &ex);\n\t\t\tif (max >= sbi->s_stripe) {\n\t\t\t\tac->ac_found++;\n\t\t\t\tex.fe_logical = 0xDEADF00D; /* debug value */\n\t\t\t\tac->ac_b_ex = ex;\n\t\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti += sbi->s_stripe;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_use_best_found",
          "args": [
            "ac",
            "e4b"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_best_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1621-1660",
          "snippet": "static void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_extent",
          "args": [
            "e4b",
            "i",
            "sbi->s_stripe",
            "&ex"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1490-1541",
          "snippet": "static int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "i",
            "bitmap"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "a",
            "sbi->s_stripe"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "e4b->bd_group"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sbi->s_stripe == 0"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_scan_aligned(struct ext4_allocation_context *ac,\n\t\t\t\t struct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\text4_fsblk_t first_group_block;\n\text4_fsblk_t a;\n\text4_grpblk_t i;\n\tint max;\n\n\tBUG_ON(sbi->s_stripe == 0);\n\n\t/* find first stripe-aligned block in group */\n\tfirst_group_block = ext4_group_first_block_no(sb, e4b->bd_group);\n\n\ta = first_group_block + sbi->s_stripe - 1;\n\tdo_div(a, sbi->s_stripe);\n\ti = (a * sbi->s_stripe) - first_group_block;\n\n\twhile (i < EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\tif (!mb_test_bit(i, bitmap)) {\n\t\t\tmax = mb_find_extent(e4b, i, sbi->s_stripe, &ex);\n\t\t\tif (max >= sbi->s_stripe) {\n\t\t\t\tac->ac_found++;\n\t\t\t\tex.fe_logical = 0xDEADF00D; /* debug value */\n\t\t\t\tac->ac_b_ex = ex;\n\t\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti += sbi->s_stripe;\n\t}\n}"
  },
  {
    "function_name": "ext4_mb_complex_scan_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1915-1968",
    "snippet": "static noinline_for_stack\nvoid ext4_mb_complex_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\tint i;\n\tint free;\n\n\tfree = e4b->bd_info->bb_free;\n\tBUG_ON(free <= 0);\n\n\ti = e4b->bd_info->bb_first_free;\n\n\twhile (free && ac->ac_status == AC_STATUS_CONTINUE) {\n\t\ti = mb_find_next_zero_bit(bitmap,\n\t\t\t\t\t\tEXT4_CLUSTERS_PER_GROUP(sb), i);\n\t\tif (i >= EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * IF we have corrupt bitmap, we won't find any\n\t\t\t * free blocks even though group info says we\n\t\t\t * we have free blocks\n\t\t\t */\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But bitmap says 0\",\n\t\t\t\t\tfree);\n\t\t\tbreak;\n\t\t}\n\n\t\tmb_find_extent(e4b, i, ac->ac_g_ex.fe_len, &ex);\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tif (free < ex.fe_len) {\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But got %d blocks\",\n\t\t\t\t\tfree, ex.fe_len);\n\t\t\t/*\n\t\t\t * The number of free blocks differs. This mostly\n\t\t\t * indicate that the bitmap is corrupt. So exit\n\t\t\t * without claiming the space.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tex.fe_logical = 0xDEADC0DE; /* debug value */\n\t\text4_mb_measure_extent(ac, &ex, e4b);\n\n\t\ti += ex.fe_len;\n\t\tfree -= ex.fe_len;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 1);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_check_limits",
          "args": [
            "ac",
            "e4b",
            "1"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_check_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1666-1704",
          "snippet": "static void ext4_mb_check_limits(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b,\n\t\t\t\t\tint finish_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_check_limits(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b,\n\t\t\t\t\tint finish_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_measure_extent",
          "args": [
            "ac",
            "&ex",
            "e4b"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_measure_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1716-1773",
          "snippet": "static void ext4_mb_measure_extent(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_free_extent *ex,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\n\tBUG_ON(ex->fe_len <= 0);\n\tBUG_ON(ex->fe_len > EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ex->fe_start >= EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ac->ac_status != AC_STATUS_CONTINUE);\n\n\tac->ac_found++;\n\n\t/*\n\t * The special case - take what you catch first\n\t */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * Let's check whether the chuck is good enough\n\t */\n\tif (ex->fe_len == gex->fe_len) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is first found extent, just store it in the context\n\t */\n\tif (bex->fe_len == 0) {\n\t\t*bex = *ex;\n\t\treturn;\n\t}\n\n\t/*\n\t * If new found extent is better, store it in the context\n\t */\n\tif (bex->fe_len < gex->fe_len) {\n\t\t/* if the request isn't satisfied, any found extent\n\t\t * larger than previous best one is better */\n\t\tif (ex->fe_len > bex->fe_len)\n\t\t\t*bex = *ex;\n\t} else if (ex->fe_len > gex->fe_len) {\n\t\t/* if the request is satisfied, then we try to find\n\t\t * an extent that still satisfy the request, but is\n\t\t * smaller than previous one */\n\t\tif (ex->fe_len < bex->fe_len)\n\t\t\t*bex = *ex;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 0);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_measure_extent(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_free_extent *ex,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\n\tBUG_ON(ex->fe_len <= 0);\n\tBUG_ON(ex->fe_len > EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ex->fe_start >= EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ac->ac_status != AC_STATUS_CONTINUE);\n\n\tac->ac_found++;\n\n\t/*\n\t * The special case - take what you catch first\n\t */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * Let's check whether the chuck is good enough\n\t */\n\tif (ex->fe_len == gex->fe_len) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is first found extent, just store it in the context\n\t */\n\tif (bex->fe_len == 0) {\n\t\t*bex = *ex;\n\t\treturn;\n\t}\n\n\t/*\n\t * If new found extent is better, store it in the context\n\t */\n\tif (bex->fe_len < gex->fe_len) {\n\t\t/* if the request isn't satisfied, any found extent\n\t\t * larger than previous best one is better */\n\t\tif (ex->fe_len > bex->fe_len)\n\t\t\t*bex = *ex;\n\t} else if (ex->fe_len > gex->fe_len) {\n\t\t/* if the request is satisfied, then we try to find\n\t\t * an extent that still satisfy the request, but is\n\t\t * smaller than previous one */\n\t\tif (ex->fe_len < bex->fe_len)\n\t\t\t*bex = *ex;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_grp_locked_error",
          "args": [
            "sb",
            "e4b->bd_group",
            "0",
            "0",
            "\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But got %d blocks\"",
            "free",
            "ex.fe_len"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_grp_locked_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "627-677",
          "snippet": "void __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex.fe_len <= 0"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_find_extent",
          "args": [
            "e4b",
            "i",
            "ac->ac_g_ex.fe_len",
            "&ex"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1490-1541",
          "snippet": "static int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_grp_locked_error",
          "args": [
            "sb",
            "e4b->bd_group",
            "0",
            "0",
            "\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But bitmap says 0\"",
            "free"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_find_next_zero_bit",
          "args": [
            "bitmap",
            "EXT4_CLUSTERS_PER_GROUP(sb)",
            "i"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "414-425",
          "snippet": "static inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "free <= 0"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_complex_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tvoid *bitmap = e4b->bd_bitmap;\n\tstruct ext4_free_extent ex;\n\tint i;\n\tint free;\n\n\tfree = e4b->bd_info->bb_free;\n\tBUG_ON(free <= 0);\n\n\ti = e4b->bd_info->bb_first_free;\n\n\twhile (free && ac->ac_status == AC_STATUS_CONTINUE) {\n\t\ti = mb_find_next_zero_bit(bitmap,\n\t\t\t\t\t\tEXT4_CLUSTERS_PER_GROUP(sb), i);\n\t\tif (i >= EXT4_CLUSTERS_PER_GROUP(sb)) {\n\t\t\t/*\n\t\t\t * IF we have corrupt bitmap, we won't find any\n\t\t\t * free blocks even though group info says we\n\t\t\t * we have free blocks\n\t\t\t */\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But bitmap says 0\",\n\t\t\t\t\tfree);\n\t\t\tbreak;\n\t\t}\n\n\t\tmb_find_extent(e4b, i, ac->ac_g_ex.fe_len, &ex);\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tif (free < ex.fe_len) {\n\t\t\text4_grp_locked_error(sb, e4b->bd_group, 0, 0,\n\t\t\t\t\t\"%d free clusters as per \"\n\t\t\t\t\t\"group info. But got %d blocks\",\n\t\t\t\t\tfree, ex.fe_len);\n\t\t\t/*\n\t\t\t * The number of free blocks differs. This mostly\n\t\t\t * indicate that the bitmap is corrupt. So exit\n\t\t\t * without claiming the space.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tex.fe_logical = 0xDEADC0DE; /* debug value */\n\t\text4_mb_measure_extent(ac, &ex, e4b);\n\n\t\ti += ex.fe_len;\n\t\tfree -= ex.fe_len;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 1);\n}"
  },
  {
    "function_name": "ext4_mb_simple_scan_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1871-1908",
    "snippet": "static noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i <= sb->s_blocksize_bits + 1; i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tBUG_ON(buddy == NULL);\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tBUG_ON(k >= max);\n\n\t\tac->ac_found++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&EXT4_SB(sb)->s_bal_2orders"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_use_best_found",
          "args": [
            "ac",
            "e4b"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_best_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1621-1660",
          "snippet": "static void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "k >= max"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_find_next_zero_bit",
          "args": [
            "buddy",
            "max",
            "0"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "414-425",
          "snippet": "static inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buddy == NULL"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_find_buddy",
          "args": [
            "e4b",
            "i",
            "&max"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "440-462",
          "snippet": "static void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_2order <= 0"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic noinline_for_stack\nvoid ext4_mb_simple_scan_group(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct super_block *sb = ac->ac_sb;\n\tstruct ext4_group_info *grp = e4b->bd_info;\n\tvoid *buddy;\n\tint i;\n\tint k;\n\tint max;\n\n\tBUG_ON(ac->ac_2order <= 0);\n\tfor (i = ac->ac_2order; i <= sb->s_blocksize_bits + 1; i++) {\n\t\tif (grp->bb_counters[i] == 0)\n\t\t\tcontinue;\n\n\t\tbuddy = mb_find_buddy(e4b, i, &max);\n\t\tBUG_ON(buddy == NULL);\n\n\t\tk = mb_find_next_zero_bit(buddy, max, 0);\n\t\tBUG_ON(k >= max);\n\n\t\tac->ac_found++;\n\n\t\tac->ac_b_ex.fe_len = 1 << i;\n\t\tac->ac_b_ex.fe_start = k << i;\n\t\tac->ac_b_ex.fe_group = e4b->bd_group;\n\n\t\text4_mb_use_best_found(ac, e4b);\n\n\t\tBUG_ON(ac->ac_b_ex.fe_len != ac->ac_g_ex.fe_len);\n\n\t\tif (EXT4_SB(sb)->s_mb_stats)\n\t\t\tatomic_inc(&EXT4_SB(sb)->s_bal_2orders);\n\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ext4_mb_find_by_goal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1803-1865",
    "snippet": "static noinline_for_stack\nint ext4_mb_find_by_goal(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_buddy *e4b)\n{\n\text4_group_t group = ac->ac_g_ex.fe_group;\n\tint max;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\tstruct ext4_free_extent ex;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_TRY_GOAL))\n\t\treturn 0;\n\tif (grp->bb_free == 0)\n\t\treturn 0;\n\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))) {\n\t\text4_mb_unload_buddy(e4b);\n\t\treturn 0;\n\t}\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ac->ac_g_ex.fe_start,\n\t\t\t     ac->ac_g_ex.fe_len, &ex);\n\tex.fe_logical = 0xDEADFA11; /* debug value */\n\n\tif (max >= ac->ac_g_ex.fe_len && ac->ac_g_ex.fe_len == sbi->s_stripe) {\n\t\text4_fsblk_t start;\n\n\t\tstart = ext4_group_first_block_no(ac->ac_sb, e4b->bd_group) +\n\t\t\tex.fe_start;\n\t\t/* use do_div to get remainder (would be 64-bit modulo) */\n\t\tif (do_div(start, sbi->s_stripe) == 0) {\n\t\t\tac->ac_found++;\n\t\t\tac->ac_b_ex = ex;\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t}\n\t} else if (max >= ac->ac_g_ex.fe_len) {\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t} else if (max > 0 && (ac->ac_flags & EXT4_MB_HINT_MERGE)) {\n\t\t/* Sometimes, caller may want to merge even small\n\t\t * number of blocks to an existing extent */\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "e4b"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "ac->ac_sb",
            "group"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_use_best_found",
          "args": [
            "ac",
            "e4b"
          ],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_best_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1621-1660",
          "snippet": "static void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex.fe_start != ac->ac_g_ex.fe_start"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex.fe_group != ac->ac_g_ex.fe_group"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex.fe_len <= 0"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex.fe_start != ac->ac_g_ex.fe_start"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex.fe_group != ac->ac_g_ex.fe_group"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex.fe_len <= 0"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "start",
            "sbi->s_stripe"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "ac->ac_sb",
            "e4b->bd_group"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_extent",
          "args": [
            "e4b",
            "ac->ac_g_ex.fe_start",
            "ac->ac_g_ex.fe_len",
            "&ex"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1490-1541",
          "snippet": "static int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "ac->ac_sb",
            "group"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "e4b->bd_info"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "ac->ac_sb",
            "group",
            "e4b"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "ac->ac_sb",
            "group"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nint ext4_mb_find_by_goal(struct ext4_allocation_context *ac,\n\t\t\t\tstruct ext4_buddy *e4b)\n{\n\text4_group_t group = ac->ac_g_ex.fe_group;\n\tint max;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_group_info *grp = ext4_get_group_info(ac->ac_sb, group);\n\tstruct ext4_free_extent ex;\n\n\tif (!(ac->ac_flags & EXT4_MB_HINT_TRY_GOAL))\n\t\treturn 0;\n\tif (grp->bb_free == 0)\n\t\treturn 0;\n\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))) {\n\t\text4_mb_unload_buddy(e4b);\n\t\treturn 0;\n\t}\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ac->ac_g_ex.fe_start,\n\t\t\t     ac->ac_g_ex.fe_len, &ex);\n\tex.fe_logical = 0xDEADFA11; /* debug value */\n\n\tif (max >= ac->ac_g_ex.fe_len && ac->ac_g_ex.fe_len == sbi->s_stripe) {\n\t\text4_fsblk_t start;\n\n\t\tstart = ext4_group_first_block_no(ac->ac_sb, e4b->bd_group) +\n\t\t\tex.fe_start;\n\t\t/* use do_div to get remainder (would be 64-bit modulo) */\n\t\tif (do_div(start, sbi->s_stripe) == 0) {\n\t\t\tac->ac_found++;\n\t\t\tac->ac_b_ex = ex;\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t}\n\t} else if (max >= ac->ac_g_ex.fe_len) {\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t} else if (max > 0 && (ac->ac_flags & EXT4_MB_HINT_MERGE)) {\n\t\t/* Sometimes, caller may want to merge even small\n\t\t * number of blocks to an existing extent */\n\t\tBUG_ON(ex.fe_len <= 0);\n\t\tBUG_ON(ex.fe_group != ac->ac_g_ex.fe_group);\n\t\tBUG_ON(ex.fe_start != ac->ac_g_ex.fe_start);\n\t\tac->ac_found++;\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_try_best_found",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1775-1801",
    "snippet": "static noinline_for_stack\nint ext4_mb_try_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent ex = ac->ac_b_ex;\n\text4_group_t group = ex.fe_group;\n\tint max;\n\tint err;\n\n\tBUG_ON(ex.fe_len <= 0);\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ex.fe_start, ex.fe_len, &ex);\n\n\tif (max > 0) {\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_unload_buddy",
          "args": [
            "e4b"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_unload_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1239-1245",
          "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "ac->ac_sb",
            "group"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_use_best_found",
          "args": [
            "ac",
            "e4b"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_best_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1621-1660",
          "snippet": "static void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_extent",
          "args": [
            "e4b",
            "ex.fe_start",
            "ex.fe_len",
            "&ex"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1490-1541",
          "snippet": "static int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "ac->ac_sb",
            "group"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_load_buddy",
          "args": [
            "ac->ac_sb",
            "group",
            "e4b"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_load_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1100-1237",
          "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex.fe_len <= 0"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nint ext4_mb_try_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent ex = ac->ac_b_ex;\n\text4_group_t group = ex.fe_group;\n\tint max;\n\tint err;\n\n\tBUG_ON(ex.fe_len <= 0);\n\terr = ext4_mb_load_buddy(ac->ac_sb, group, e4b);\n\tif (err)\n\t\treturn err;\n\n\text4_lock_group(ac->ac_sb, group);\n\tmax = mb_find_extent(e4b, ex.fe_start, ex.fe_len, &ex);\n\n\tif (max > 0) {\n\t\tac->ac_b_ex = ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t}\n\n\text4_unlock_group(ac->ac_sb, group);\n\text4_mb_unload_buddy(e4b);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_measure_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1716-1773",
    "snippet": "static void ext4_mb_measure_extent(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_free_extent *ex,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\n\tBUG_ON(ex->fe_len <= 0);\n\tBUG_ON(ex->fe_len > EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ex->fe_start >= EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ac->ac_status != AC_STATUS_CONTINUE);\n\n\tac->ac_found++;\n\n\t/*\n\t * The special case - take what you catch first\n\t */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * Let's check whether the chuck is good enough\n\t */\n\tif (ex->fe_len == gex->fe_len) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is first found extent, just store it in the context\n\t */\n\tif (bex->fe_len == 0) {\n\t\t*bex = *ex;\n\t\treturn;\n\t}\n\n\t/*\n\t * If new found extent is better, store it in the context\n\t */\n\tif (bex->fe_len < gex->fe_len) {\n\t\t/* if the request isn't satisfied, any found extent\n\t\t * larger than previous best one is better */\n\t\tif (ex->fe_len > bex->fe_len)\n\t\t\t*bex = *ex;\n\t} else if (ex->fe_len > gex->fe_len) {\n\t\t/* if the request is satisfied, then we try to find\n\t\t * an extent that still satisfy the request, but is\n\t\t * smaller than previous one */\n\t\tif (ex->fe_len < bex->fe_len)\n\t\t\t*bex = *ex;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 0);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_check_limits",
          "args": [
            "ac",
            "e4b",
            "0"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_check_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1666-1704",
          "snippet": "static void ext4_mb_check_limits(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b,\n\t\t\t\t\tint finish_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_check_limits(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b,\n\t\t\t\t\tint finish_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_use_best_found",
          "args": [
            "ac",
            "e4b"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_best_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1621-1660",
          "snippet": "static void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ac->ac_flags & EXT4_MB_HINT_FIRST"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_status != AC_STATUS_CONTINUE"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex->fe_start >= EXT4_CLUSTERS_PER_GROUP(ac->ac_sb)"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "ac->ac_sb"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex->fe_len > EXT4_CLUSTERS_PER_GROUP(ac->ac_sb)"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "ac->ac_sb"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex->fe_len <= 0"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_measure_extent(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_free_extent *ex,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\n\tBUG_ON(ex->fe_len <= 0);\n\tBUG_ON(ex->fe_len > EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ex->fe_start >= EXT4_CLUSTERS_PER_GROUP(ac->ac_sb));\n\tBUG_ON(ac->ac_status != AC_STATUS_CONTINUE);\n\n\tac->ac_found++;\n\n\t/*\n\t * The special case - take what you catch first\n\t */\n\tif (unlikely(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * Let's check whether the chuck is good enough\n\t */\n\tif (ex->fe_len == gex->fe_len) {\n\t\t*bex = *ex;\n\t\text4_mb_use_best_found(ac, e4b);\n\t\treturn;\n\t}\n\n\t/*\n\t * If this is first found extent, just store it in the context\n\t */\n\tif (bex->fe_len == 0) {\n\t\t*bex = *ex;\n\t\treturn;\n\t}\n\n\t/*\n\t * If new found extent is better, store it in the context\n\t */\n\tif (bex->fe_len < gex->fe_len) {\n\t\t/* if the request isn't satisfied, any found extent\n\t\t * larger than previous best one is better */\n\t\tif (ex->fe_len > bex->fe_len)\n\t\t\t*bex = *ex;\n\t} else if (ex->fe_len > gex->fe_len) {\n\t\t/* if the request is satisfied, then we try to find\n\t\t * an extent that still satisfy the request, but is\n\t\t * smaller than previous one */\n\t\tif (ex->fe_len < bex->fe_len)\n\t\t\t*bex = *ex;\n\t}\n\n\text4_mb_check_limits(ac, e4b, 0);\n}"
  },
  {
    "function_name": "ext4_mb_check_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1666-1704",
    "snippet": "static void ext4_mb_check_limits(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b,\n\t\t\t\t\tint finish_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_use_best_found",
          "args": [
            "ac",
            "e4b"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_use_best_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1621-1660",
          "snippet": "static void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_extent",
          "args": [
            "e4b",
            "bex->fe_start",
            "gex->fe_len",
            "&ex"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1490-1541",
          "snippet": "static int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_check_limits(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b,\n\t\t\t\t\tint finish_group)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tstruct ext4_free_extent *bex = &ac->ac_b_ex;\n\tstruct ext4_free_extent *gex = &ac->ac_g_ex;\n\tstruct ext4_free_extent ex;\n\tint max;\n\n\tif (ac->ac_status == AC_STATUS_FOUND)\n\t\treturn;\n\t/*\n\t * We don't want to scan for a whole year\n\t */\n\tif (ac->ac_found > sbi->s_mb_max_to_scan &&\n\t\t\t!(ac->ac_flags & EXT4_MB_HINT_FIRST)) {\n\t\tac->ac_status = AC_STATUS_BREAK;\n\t\treturn;\n\t}\n\n\t/*\n\t * Haven't found good chunk so far, let's continue\n\t */\n\tif (bex->fe_len < gex->fe_len)\n\t\treturn;\n\n\tif ((finish_group || ac->ac_found > sbi->s_mb_min_to_scan)\n\t\t\t&& bex->fe_group == e4b->bd_group) {\n\t\t/* recheck chunk's availability - we don't know\n\t\t * when it was found (within this lock-unlock\n\t\t * period or not) */\n\t\tmax = mb_find_extent(e4b, bex->fe_start, gex->fe_len, &ex);\n\t\tif (max >= gex->fe_len) {\n\t\t\text4_mb_use_best_found(ac, e4b);\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ext4_mb_use_best_found",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1621-1660",
    "snippet": "static void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_md_lock"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_md_lock"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "ac->ac_buddy_page"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_page",
          "args": [
            "ac->ac_bitmap_page"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_mark_used",
          "args": [
            "e4b",
            "&ac->ac_b_ex"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "mb_mark_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1543-1616",
          "snippet": "static int mb_mark_used(struct ext4_buddy *e4b, struct ext4_free_extent *ex)\n{\n\tint ord;\n\tint mlen = 0;\n\tint max = 0;\n\tint cur;\n\tint start = ex->fe_start;\n\tint len = ex->fe_len;\n\tunsigned ret = 0;\n\tint len0 = len;\n\tvoid *buddy;\n\n\tBUG_ON(start + len > (e4b->bd_sb->s_blocksize << 3));\n\tBUG_ON(e4b->bd_group != ex->fe_group);\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tmb_check_buddy(e4b);\n\tmb_mark_used_double(e4b, start, len);\n\n\te4b->bd_info->bb_free -= len;\n\tif (e4b->bd_info->bb_first_free == start)\n\t\te4b->bd_info->bb_first_free += len;\n\n\t/* let's maintain fragments counter */\n\tif (start != 0)\n\t\tmlen = !mb_test_bit(start - 1, e4b->bd_bitmap);\n\tif (start + len < EXT4_SB(e4b->bd_sb)->s_mb_maxs[0])\n\t\tmax = !mb_test_bit(start + len, e4b->bd_bitmap);\n\tif (mlen && max)\n\t\te4b->bd_info->bb_fragments++;\n\telse if (!mlen && !max)\n\t\te4b->bd_info->bb_fragments--;\n\n\t/* let's maintain buddy itself */\n\twhile (len) {\n\t\tord = mb_find_order_for_block(e4b, start);\n\n\t\tif (((start >> ord) << ord) == start && len >= (1 << ord)) {\n\t\t\t/* the whole chunk may be allocated at once! */\n\t\t\tmlen = 1 << ord;\n\t\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\t\tBUG_ON((start >> ord) >= max);\n\t\t\tmb_set_bit(start >> ord, buddy);\n\t\t\te4b->bd_info->bb_counters[ord]--;\n\t\t\tstart += mlen;\n\t\t\tlen -= mlen;\n\t\t\tBUG_ON(len < 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* store for history */\n\t\tif (ret == 0)\n\t\t\tret = len | (ord << 16);\n\n\t\t/* we have to split large buddy */\n\t\tBUG_ON(ord <= 0);\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_set_bit(start >> ord, buddy);\n\t\te4b->bd_info->bb_counters[ord]--;\n\n\t\tord--;\n\t\tcur = (start >> ord) & ~1U;\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_clear_bit(cur, buddy);\n\t\tmb_clear_bit(cur + 1, buddy);\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\te4b->bd_info->bb_counters[ord]++;\n\t}\n\tmb_set_largest_free_order(e4b->bd_sb, e4b->bd_info);\n\n\text4_set_bits(e4b->bd_bitmap, ex->fe_start, len0);\n\tmb_check_buddy(e4b);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_mark_used(struct ext4_buddy *e4b, struct ext4_free_extent *ex)\n{\n\tint ord;\n\tint mlen = 0;\n\tint max = 0;\n\tint cur;\n\tint start = ex->fe_start;\n\tint len = ex->fe_len;\n\tunsigned ret = 0;\n\tint len0 = len;\n\tvoid *buddy;\n\n\tBUG_ON(start + len > (e4b->bd_sb->s_blocksize << 3));\n\tBUG_ON(e4b->bd_group != ex->fe_group);\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tmb_check_buddy(e4b);\n\tmb_mark_used_double(e4b, start, len);\n\n\te4b->bd_info->bb_free -= len;\n\tif (e4b->bd_info->bb_first_free == start)\n\t\te4b->bd_info->bb_first_free += len;\n\n\t/* let's maintain fragments counter */\n\tif (start != 0)\n\t\tmlen = !mb_test_bit(start - 1, e4b->bd_bitmap);\n\tif (start + len < EXT4_SB(e4b->bd_sb)->s_mb_maxs[0])\n\t\tmax = !mb_test_bit(start + len, e4b->bd_bitmap);\n\tif (mlen && max)\n\t\te4b->bd_info->bb_fragments++;\n\telse if (!mlen && !max)\n\t\te4b->bd_info->bb_fragments--;\n\n\t/* let's maintain buddy itself */\n\twhile (len) {\n\t\tord = mb_find_order_for_block(e4b, start);\n\n\t\tif (((start >> ord) << ord) == start && len >= (1 << ord)) {\n\t\t\t/* the whole chunk may be allocated at once! */\n\t\t\tmlen = 1 << ord;\n\t\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\t\tBUG_ON((start >> ord) >= max);\n\t\t\tmb_set_bit(start >> ord, buddy);\n\t\t\te4b->bd_info->bb_counters[ord]--;\n\t\t\tstart += mlen;\n\t\t\tlen -= mlen;\n\t\t\tBUG_ON(len < 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* store for history */\n\t\tif (ret == 0)\n\t\t\tret = len | (ord << 16);\n\n\t\t/* we have to split large buddy */\n\t\tBUG_ON(ord <= 0);\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_set_bit(start >> ord, buddy);\n\t\te4b->bd_info->bb_counters[ord]--;\n\n\t\tord--;\n\t\tcur = (start >> ord) & ~1U;\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_clear_bit(cur, buddy);\n\t\tmb_clear_bit(cur + 1, buddy);\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\te4b->bd_info->bb_counters[ord]++;\n\t}\n\tmb_set_largest_free_order(e4b->bd_sb, e4b->bd_info);\n\n\text4_set_bits(e4b->bd_bitmap, ex->fe_start, len0);\n\tmb_check_buddy(e4b);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ac->ac_b_ex.fe_len",
            "ac->ac_g_ex.fe_len"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "286-293",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_status == AC_STATUS_FOUND"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ac->ac_b_ex.fe_group != e4b->bd_group"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "ac->ac_sb"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_use_best_found(struct ext4_allocation_context *ac,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(ac->ac_sb);\n\tint ret;\n\n\tBUG_ON(ac->ac_b_ex.fe_group != e4b->bd_group);\n\tBUG_ON(ac->ac_status == AC_STATUS_FOUND);\n\n\tac->ac_b_ex.fe_len = min(ac->ac_b_ex.fe_len, ac->ac_g_ex.fe_len);\n\tac->ac_b_ex.fe_logical = ac->ac_g_ex.fe_logical;\n\tret = mb_mark_used(e4b, &ac->ac_b_ex);\n\n\t/* preallocation can change ac_b_ex, thus we store actually\n\t * allocated blocks for history */\n\tac->ac_f_ex = ac->ac_b_ex;\n\n\tac->ac_status = AC_STATUS_FOUND;\n\tac->ac_tail = ret & 0xffff;\n\tac->ac_buddy = ret >> 16;\n\n\t/*\n\t * take the page reference. We want the page to be pinned\n\t * so that we don't get a ext4_mb_init_cache_call for this\n\t * group until we update the bitmap. That would mean we\n\t * double allocate blocks. The reference is dropped\n\t * in ext4_mb_release_context\n\t */\n\tac->ac_bitmap_page = e4b->bd_bitmap_page;\n\tget_page(ac->ac_bitmap_page);\n\tac->ac_buddy_page = e4b->bd_buddy_page;\n\tget_page(ac->ac_buddy_page);\n\t/* store last allocated for subsequent stream allocation */\n\tif (ac->ac_flags & EXT4_MB_STREAM_ALLOC) {\n\t\tspin_lock(&sbi->s_md_lock);\n\t\tsbi->s_mb_last_group = ac->ac_f_ex.fe_group;\n\t\tsbi->s_mb_last_start = ac->ac_f_ex.fe_start;\n\t\tspin_unlock(&sbi->s_md_lock);\n\t}\n}"
  },
  {
    "function_name": "mb_mark_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1543-1616",
    "snippet": "static int mb_mark_used(struct ext4_buddy *e4b, struct ext4_free_extent *ex)\n{\n\tint ord;\n\tint mlen = 0;\n\tint max = 0;\n\tint cur;\n\tint start = ex->fe_start;\n\tint len = ex->fe_len;\n\tunsigned ret = 0;\n\tint len0 = len;\n\tvoid *buddy;\n\n\tBUG_ON(start + len > (e4b->bd_sb->s_blocksize << 3));\n\tBUG_ON(e4b->bd_group != ex->fe_group);\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tmb_check_buddy(e4b);\n\tmb_mark_used_double(e4b, start, len);\n\n\te4b->bd_info->bb_free -= len;\n\tif (e4b->bd_info->bb_first_free == start)\n\t\te4b->bd_info->bb_first_free += len;\n\n\t/* let's maintain fragments counter */\n\tif (start != 0)\n\t\tmlen = !mb_test_bit(start - 1, e4b->bd_bitmap);\n\tif (start + len < EXT4_SB(e4b->bd_sb)->s_mb_maxs[0])\n\t\tmax = !mb_test_bit(start + len, e4b->bd_bitmap);\n\tif (mlen && max)\n\t\te4b->bd_info->bb_fragments++;\n\telse if (!mlen && !max)\n\t\te4b->bd_info->bb_fragments--;\n\n\t/* let's maintain buddy itself */\n\twhile (len) {\n\t\tord = mb_find_order_for_block(e4b, start);\n\n\t\tif (((start >> ord) << ord) == start && len >= (1 << ord)) {\n\t\t\t/* the whole chunk may be allocated at once! */\n\t\t\tmlen = 1 << ord;\n\t\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\t\tBUG_ON((start >> ord) >= max);\n\t\t\tmb_set_bit(start >> ord, buddy);\n\t\t\te4b->bd_info->bb_counters[ord]--;\n\t\t\tstart += mlen;\n\t\t\tlen -= mlen;\n\t\t\tBUG_ON(len < 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* store for history */\n\t\tif (ret == 0)\n\t\t\tret = len | (ord << 16);\n\n\t\t/* we have to split large buddy */\n\t\tBUG_ON(ord <= 0);\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_set_bit(start >> ord, buddy);\n\t\te4b->bd_info->bb_counters[ord]--;\n\n\t\tord--;\n\t\tcur = (start >> ord) & ~1U;\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_clear_bit(cur, buddy);\n\t\tmb_clear_bit(cur + 1, buddy);\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\te4b->bd_info->bb_counters[ord]++;\n\t}\n\tmb_set_largest_free_order(e4b->bd_sb, e4b->bd_info);\n\n\text4_set_bits(e4b->bd_bitmap, ex->fe_start, len0);\n\tmb_check_buddy(e4b);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_check_buddy",
          "args": [
            "e4b"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bits",
          "args": [
            "e4b->bd_bitmap",
            "ex->fe_start",
            "len0"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1314-1330",
          "snippet": "void ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_set_largest_free_order",
          "args": [
            "e4b->bd_sb",
            "e4b->bd_info"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_largest_free_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "703-718",
          "snippet": "static void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_clear_bit",
          "args": [
            "cur + 1",
            "buddy"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "mb_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "402-406",
          "snippet": "static inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_buddy",
          "args": [
            "e4b",
            "ord",
            "&max"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "440-462",
          "snippet": "static void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_set_bit",
          "args": [
            "start >> ord",
            "buddy"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ord <= 0"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len < 0"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(start >> ord) >= max"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_find_order_for_block",
          "args": [
            "e4b",
            "start"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_order_for_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1248-1267",
          "snippet": "static int mb_find_order_for_block(struct ext4_buddy *e4b, int block)\n{\n\tint order = 1;\n\tvoid *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(block >= (1 << (e4b->bd_blkbits + 3)));\n\n\tbb = e4b->bd_buddy;\n\twhile (order <= e4b->bd_blkbits + 1) {\n\t\tblock = block >> 1;\n\t\tif (!mb_test_bit(block, bb)) {\n\t\t\t/* this block is part of buddy of order 'order' */\n\t\t\treturn order;\n\t\t}\n\t\tbb += 1 << (e4b->bd_blkbits - order);\n\t\torder++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_order_for_block(struct ext4_buddy *e4b, int block)\n{\n\tint order = 1;\n\tvoid *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(block >= (1 << (e4b->bd_blkbits + 3)));\n\n\tbb = e4b->bd_buddy;\n\twhile (order <= e4b->bd_blkbits + 1) {\n\t\tblock = block >> 1;\n\t\tif (!mb_test_bit(block, bb)) {\n\t\t\t/* this block is part of buddy of order 'order' */\n\t\t\treturn order;\n\t\t}\n\t\tbb += 1 << (e4b->bd_blkbits - order);\n\t\torder++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "start + len",
            "e4b->bd_bitmap"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "e4b->bd_sb"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_mark_used_double",
          "args": [
            "e4b",
            "start",
            "len"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "mb_mark_used_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "530-534",
          "snippet": "static inline void mb_mark_used_double(struct ext4_buddy *e4b,\n\t\t\t\t\t\tint first, int count)\n{\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_mark_used_double(struct ext4_buddy *e4b,\n\t\t\t\t\t\tint first, int count)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_check_buddy",
          "args": [
            "e4b"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group)"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_lock_ptr",
          "args": [
            "e4b->bd_sb",
            "e4b->bd_group"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2211-2536",
          "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
            "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "e4b->bd_group != ex->fe_group"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start + len > (e4b->bd_sb->s_blocksize << 3)"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_mark_used(struct ext4_buddy *e4b, struct ext4_free_extent *ex)\n{\n\tint ord;\n\tint mlen = 0;\n\tint max = 0;\n\tint cur;\n\tint start = ex->fe_start;\n\tint len = ex->fe_len;\n\tunsigned ret = 0;\n\tint len0 = len;\n\tvoid *buddy;\n\n\tBUG_ON(start + len > (e4b->bd_sb->s_blocksize << 3));\n\tBUG_ON(e4b->bd_group != ex->fe_group);\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tmb_check_buddy(e4b);\n\tmb_mark_used_double(e4b, start, len);\n\n\te4b->bd_info->bb_free -= len;\n\tif (e4b->bd_info->bb_first_free == start)\n\t\te4b->bd_info->bb_first_free += len;\n\n\t/* let's maintain fragments counter */\n\tif (start != 0)\n\t\tmlen = !mb_test_bit(start - 1, e4b->bd_bitmap);\n\tif (start + len < EXT4_SB(e4b->bd_sb)->s_mb_maxs[0])\n\t\tmax = !mb_test_bit(start + len, e4b->bd_bitmap);\n\tif (mlen && max)\n\t\te4b->bd_info->bb_fragments++;\n\telse if (!mlen && !max)\n\t\te4b->bd_info->bb_fragments--;\n\n\t/* let's maintain buddy itself */\n\twhile (len) {\n\t\tord = mb_find_order_for_block(e4b, start);\n\n\t\tif (((start >> ord) << ord) == start && len >= (1 << ord)) {\n\t\t\t/* the whole chunk may be allocated at once! */\n\t\t\tmlen = 1 << ord;\n\t\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\t\tBUG_ON((start >> ord) >= max);\n\t\t\tmb_set_bit(start >> ord, buddy);\n\t\t\te4b->bd_info->bb_counters[ord]--;\n\t\t\tstart += mlen;\n\t\t\tlen -= mlen;\n\t\t\tBUG_ON(len < 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* store for history */\n\t\tif (ret == 0)\n\t\t\tret = len | (ord << 16);\n\n\t\t/* we have to split large buddy */\n\t\tBUG_ON(ord <= 0);\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_set_bit(start >> ord, buddy);\n\t\te4b->bd_info->bb_counters[ord]--;\n\n\t\tord--;\n\t\tcur = (start >> ord) & ~1U;\n\t\tbuddy = mb_find_buddy(e4b, ord, &max);\n\t\tmb_clear_bit(cur, buddy);\n\t\tmb_clear_bit(cur + 1, buddy);\n\t\te4b->bd_info->bb_counters[ord]++;\n\t\te4b->bd_info->bb_counters[ord]++;\n\t}\n\tmb_set_largest_free_order(e4b->bd_sb, e4b->bd_info);\n\n\text4_set_bits(e4b->bd_bitmap, ex->fe_start, len0);\n\tmb_check_buddy(e4b);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mb_find_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1490-1541",
    "snippet": "static int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3))"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_find_order_for_block",
          "args": [
            "e4b",
            "next"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_order_for_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1248-1267",
          "snippet": "static int mb_find_order_for_block(struct ext4_buddy *e4b, int block)\n{\n\tint order = 1;\n\tvoid *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(block >= (1 << (e4b->bd_blkbits + 3)));\n\n\tbb = e4b->bd_buddy;\n\twhile (order <= e4b->bd_blkbits + 1) {\n\t\tblock = block >> 1;\n\t\tif (!mb_test_bit(block, bb)) {\n\t\t\t/* this block is part of buddy of order 'order' */\n\t\t\treturn order;\n\t\t}\n\t\tbb += 1 << (e4b->bd_blkbits - order);\n\t\torder++;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_order_for_block(struct ext4_buddy *e4b, int block)\n{\n\tint order = 1;\n\tvoid *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(block >= (1 << (e4b->bd_blkbits + 3)));\n\n\tbb = e4b->bd_buddy;\n\twhile (order <= e4b->bd_blkbits + 1) {\n\t\tblock = block >> 1;\n\t\tif (!mb_test_bit(block, bb)) {\n\t\t\t/* this block is part of buddy of order 'order' */\n\t\t\treturn order;\n\t\t}\n\t\tbb += 1 << (e4b->bd_blkbits - order);\n\t\torder++;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "next",
            "e4b->bd_bitmap"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_buddy",
          "args": [
            "e4b",
            "order",
            "&max"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "440-462",
          "snippet": "static void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block >= max"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buddy == NULL"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ex == NULL"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group)"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_lock_ptr",
          "args": [
            "e4b->bd_sb",
            "e4b->bd_group"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2211-2536",
          "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
            "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_extent(struct ext4_buddy *e4b, int block,\n\t\t\t\tint needed, struct ext4_free_extent *ex)\n{\n\tint next = block;\n\tint max, order;\n\tvoid *buddy;\n\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tBUG_ON(ex == NULL);\n\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tBUG_ON(buddy == NULL);\n\tBUG_ON(block >= max);\n\tif (mb_test_bit(block, buddy)) {\n\t\tex->fe_len = 0;\n\t\tex->fe_start = 0;\n\t\tex->fe_group = 0;\n\t\treturn 0;\n\t}\n\n\t/* find actual order */\n\torder = mb_find_order_for_block(e4b, block);\n\tblock = block >> order;\n\n\tex->fe_len = 1 << order;\n\tex->fe_start = block << order;\n\tex->fe_group = e4b->bd_group;\n\n\t/* calc difference from given start */\n\tnext = next - ex->fe_start;\n\tex->fe_len -= next;\n\tex->fe_start += next;\n\n\twhile (needed > ex->fe_len &&\n\t       mb_find_buddy(e4b, order, &max)) {\n\n\t\tif (block + 1 >= max)\n\t\t\tbreak;\n\n\t\tnext = (block + 1) * (1 << order);\n\t\tif (mb_test_bit(next, e4b->bd_bitmap))\n\t\t\tbreak;\n\n\t\torder = mb_find_order_for_block(e4b, next);\n\n\t\tblock = next >> order;\n\t\tex->fe_len += 1 << order;\n\t}\n\n\tBUG_ON(ex->fe_start + ex->fe_len > (1 << (e4b->bd_blkbits + 3)));\n\treturn ex->fe_len;\n}"
  },
  {
    "function_name": "mb_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1406-1488",
    "snippet": "static void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_check_buddy",
          "args": [
            "e4b"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_set_largest_free_order",
          "args": [
            "sb",
            "e4b->bd_info"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_largest_free_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "703-718",
          "snippet": "static void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_buddy_mark_free",
          "args": [
            "e4b",
            "first >> 1",
            "last >> 1"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "mb_buddy_mark_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1349-1404",
          "snippet": "static void mb_buddy_mark_free(struct ext4_buddy *e4b, int first, int last)\n{\n\tint max;\n\tint order = 1;\n\tvoid *buddy = mb_find_buddy(e4b, order, &max);\n\n\twhile (buddy) {\n\t\tvoid *buddy2;\n\n\t\t/* Bits in range [first; last] are known to be set since\n\t\t * corresponding blocks were allocated. Bits in range\n\t\t * (first; last) will stay set because they form buddies on\n\t\t * upper layer. We just deal with borders if they don't\n\t\t * align with upper layer and then go up.\n\t\t * Releasing entire group is all about clearing\n\t\t * single bit of highest order buddy.\n\t\t */\n\n\t\t/* Example:\n\t\t * ---------------------------------\n\t\t * |   1   |   1   |   1   |   1   |\n\t\t * ---------------------------------\n\t\t * | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |\n\t\t * ---------------------------------\n\t\t *   0   1   2   3   4   5   6   7\n\t\t *      \\_____________________/\n\t\t *\n\t\t * Neither [1] nor [6] is aligned to above layer.\n\t\t * Left neighbour [0] is free, so mark it busy,\n\t\t * decrease bb_counters and extend range to\n\t\t * [0; 6]\n\t\t * Right neighbour [7] is busy. It can't be coaleasced with [6], so\n\t\t * mark [6] free, increase bb_counters and shrink range to\n\t\t * [0; 5].\n\t\t * Then shift range to [0; 2], go up and do the same.\n\t\t */\n\n\n\t\tif (first & 1)\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&first, buddy, -1);\n\t\tif (!(last & 1))\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&last, buddy, 1);\n\t\tif (first > last)\n\t\t\tbreak;\n\t\torder++;\n\n\t\tif (first == last || !(buddy2 = mb_find_buddy(e4b, order, &max))) {\n\t\t\tmb_clear_bits(buddy, first, last - first + 1);\n\t\t\te4b->bd_info->bb_counters[order - 1] += last - first + 1;\n\t\t\tbreak;\n\t\t}\n\t\tfirst >>= 1;\n\t\tlast >>= 1;\n\t\tbuddy = buddy2;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_buddy_mark_free(struct ext4_buddy *e4b, int first, int last)\n{\n\tint max;\n\tint order = 1;\n\tvoid *buddy = mb_find_buddy(e4b, order, &max);\n\n\twhile (buddy) {\n\t\tvoid *buddy2;\n\n\t\t/* Bits in range [first; last] are known to be set since\n\t\t * corresponding blocks were allocated. Bits in range\n\t\t * (first; last) will stay set because they form buddies on\n\t\t * upper layer. We just deal with borders if they don't\n\t\t * align with upper layer and then go up.\n\t\t * Releasing entire group is all about clearing\n\t\t * single bit of highest order buddy.\n\t\t */\n\n\t\t/* Example:\n\t\t * ---------------------------------\n\t\t * |   1   |   1   |   1   |   1   |\n\t\t * ---------------------------------\n\t\t * | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |\n\t\t * ---------------------------------\n\t\t *   0   1   2   3   4   5   6   7\n\t\t *      \\_____________________/\n\t\t *\n\t\t * Neither [1] nor [6] is aligned to above layer.\n\t\t * Left neighbour [0] is free, so mark it busy,\n\t\t * decrease bb_counters and extend range to\n\t\t * [0; 6]\n\t\t * Right neighbour [7] is busy. It can't be coaleasced with [6], so\n\t\t * mark [6] free, increase bb_counters and shrink range to\n\t\t * [0; 5].\n\t\t * Then shift range to [0; 2], go up and do the same.\n\t\t */\n\n\n\t\tif (first & 1)\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&first, buddy, -1);\n\t\tif (!(last & 1))\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&last, buddy, 1);\n\t\tif (first > last)\n\t\t\tbreak;\n\t\torder++;\n\n\t\tif (first == last || !(buddy2 = mb_find_buddy(e4b, order, &max))) {\n\t\t\tmb_clear_bits(buddy, first, last - first + 1);\n\t\t\te4b->bd_info->bb_counters[order - 1] += last - first + 1;\n\t\t\tbreak;\n\t\t}\n\t\tfirst >>= 1;\n\t\tlast >>= 1;\n\t\tbuddy = buddy2;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_regenerate_buddy",
          "args": [
            "e4b"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "mb_regenerate_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "779-795",
          "snippet": "static void mb_regenerate_buddy(struct ext4_buddy *e4b)\n{\n\tint count;\n\tint order = 1;\n\tvoid *buddy;\n\n\twhile ((buddy = mb_find_buddy(e4b, order++, &count))) {\n\t\text4_set_bits(buddy, 0, count);\n\t}\n\te4b->bd_info->bb_fragments = 0;\n\tmemset(e4b->bd_info->bb_counters, 0,\n\t\tsizeof(*e4b->bd_info->bb_counters) *\n\t\t(e4b->bd_sb->s_blocksize_bits + 2));\n\n\text4_mb_generate_buddy(e4b->bd_sb, e4b->bd_buddy,\n\t\te4b->bd_bitmap, e4b->bd_group);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void mb_regenerate_buddy(struct ext4_buddy *e4b)\n{\n\tint count;\n\tint order = 1;\n\tvoid *buddy;\n\n\twhile ((buddy = mb_find_buddy(e4b, order++, &count))) {\n\t\text4_set_bits(buddy, 0, count);\n\t}\n\te4b->bd_info->bb_fragments = 0;\n\tmemset(e4b->bd_info->bb_counters, 0,\n\t\tsizeof(*e4b->bd_info->bb_counters) *\n\t\t(e4b->bd_sb->s_blocksize_bits + 2));\n\n\text4_mb_generate_buddy(e4b->bd_sb, e4b->bd_buddy,\n\t\te4b->bd_bitmap, e4b->bd_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT",
            "&e4b->bd_info->bb_state"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeclusters_counter",
            "e4b->bd_info->bb_free"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "e4b->bd_info"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_locked_error",
          "args": [
            "sb",
            "e4b->bd_group",
            "inode ? inode->i_ino : 0",
            "blocknr",
            "\"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\"",
            "block"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "block"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "e4b->bd_group"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block != -1"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "last + 1",
            "e4b->bd_bitmap"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_test_and_clear_bits",
          "args": [
            "e4b->bd_bitmap",
            "first",
            "count"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_and_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1290-1312",
          "snippet": "static int mb_test_and_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\tint zero_bit = -1;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\tif (*addr != (__u32)(-1) && zero_bit == -1)\n\t\t\t\tzero_bit = cur + mb_find_next_zero_bit(addr, 32, 0);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mb_test_and_clear_bit(cur, bm) && zero_bit == -1)\n\t\t\tzero_bit = cur;\n\t\tcur++;\n\t}\n\n\treturn zero_bit;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_test_and_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\tint zero_bit = -1;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\tif (*addr != (__u32)(-1) && zero_bit == -1)\n\t\t\t\tzero_bit = cur + mb_find_next_zero_bit(addr, 32, 0);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mb_test_and_clear_bit(cur, bm) && zero_bit == -1)\n\t\t\tzero_bit = cur;\n\t\tcur++;\n\t}\n\n\treturn zero_bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_free_blocks_double",
          "args": [
            "inode",
            "e4b",
            "first",
            "count"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "mb_free_blocks_double",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "525-529",
          "snippet": "static inline void mb_free_blocks_double(struct inode *inode,\n\t\t\t\tstruct ext4_buddy *e4b, int first, int count)\n{\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_free_blocks_double(struct inode *inode,\n\t\t\t\tstruct ext4_buddy *e4b, int first, int count)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_check_buddy",
          "args": [
            "e4b"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "e4b->bd_info"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "ext4_group_lock_ptr(sb, e4b->bd_group)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_lock_ptr",
          "args": [
            "sb",
            "e4b->bd_group"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2211-2536",
          "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
            "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last >= (sb->s_blocksize << 3)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "count == 0"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_free_blocks(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint left_is_free = 0;\n\tint right_is_free = 0;\n\tint block;\n\tint last = first + count - 1;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (WARN_ON(count == 0))\n\t\treturn;\n\tBUG_ON(last >= (sb->s_blocksize << 3));\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\t/* Don't bother if the block group is corrupt. */\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info)))\n\t\treturn;\n\n\tmb_check_buddy(e4b);\n\tmb_free_blocks_double(inode, e4b, first, count);\n\n\te4b->bd_info->bb_free += count;\n\tif (first < e4b->bd_info->bb_first_free)\n\t\te4b->bd_info->bb_first_free = first;\n\n\t/* access memory sequentially: check left neighbour,\n\t * clear range and then check right neighbour\n\t */\n\tif (first != 0)\n\t\tleft_is_free = !mb_test_bit(first - 1, e4b->bd_bitmap);\n\tblock = mb_test_and_clear_bits(e4b->bd_bitmap, first, count);\n\tif (last + 1 < EXT4_SB(sb)->s_mb_maxs[0])\n\t\tright_is_free = !mb_test_bit(last + 1, e4b->bd_bitmap);\n\n\tif (unlikely(block != -1)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\t\text4_fsblk_t blocknr;\n\n\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\tblocknr += EXT4_C2B(EXT4_SB(sb), block);\n\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t      blocknr,\n\t\t\t\t      \"freeing already freed block \"\n\t\t\t\t      \"(bit %u); block bitmap corrupt.\",\n\t\t\t\t      block);\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(e4b->bd_info))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   e4b->bd_info->bb_free);\n\t\t/* Mark the block group as corrupt. */\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT,\n\t\t\t&e4b->bd_info->bb_state);\n\t\tmb_regenerate_buddy(e4b);\n\t\tgoto done;\n\t}\n\n\t/* let's maintain fragments counter */\n\tif (left_is_free && right_is_free)\n\t\te4b->bd_info->bb_fragments--;\n\telse if (!left_is_free && !right_is_free)\n\t\te4b->bd_info->bb_fragments++;\n\n\t/* buddy[0] == bd_bitmap is a special case, so handle\n\t * it right away and let mb_buddy_mark_free stay free of\n\t * zero order checks.\n\t * Check if neighbours are to be coaleasced,\n\t * adjust bitmap bb_counters and borders appropriately.\n\t */\n\tif (first & 1) {\n\t\tfirst += !left_is_free;\n\t\te4b->bd_info->bb_counters[0] += left_is_free ? -1 : 1;\n\t}\n\tif (!(last & 1)) {\n\t\tlast -= !right_is_free;\n\t\te4b->bd_info->bb_counters[0] += right_is_free ? -1 : 1;\n\t}\n\n\tif (first <= last)\n\t\tmb_buddy_mark_free(e4b, first >> 1, last >> 1);\n\ndone:\n\tmb_set_largest_free_order(sb, e4b->bd_info);\n\tmb_check_buddy(e4b);\n}"
  },
  {
    "function_name": "mb_buddy_mark_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1349-1404",
    "snippet": "static void mb_buddy_mark_free(struct ext4_buddy *e4b, int first, int last)\n{\n\tint max;\n\tint order = 1;\n\tvoid *buddy = mb_find_buddy(e4b, order, &max);\n\n\twhile (buddy) {\n\t\tvoid *buddy2;\n\n\t\t/* Bits in range [first; last] are known to be set since\n\t\t * corresponding blocks were allocated. Bits in range\n\t\t * (first; last) will stay set because they form buddies on\n\t\t * upper layer. We just deal with borders if they don't\n\t\t * align with upper layer and then go up.\n\t\t * Releasing entire group is all about clearing\n\t\t * single bit of highest order buddy.\n\t\t */\n\n\t\t/* Example:\n\t\t * ---------------------------------\n\t\t * |   1   |   1   |   1   |   1   |\n\t\t * ---------------------------------\n\t\t * | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |\n\t\t * ---------------------------------\n\t\t *   0   1   2   3   4   5   6   7\n\t\t *      \\_____________________/\n\t\t *\n\t\t * Neither [1] nor [6] is aligned to above layer.\n\t\t * Left neighbour [0] is free, so mark it busy,\n\t\t * decrease bb_counters and extend range to\n\t\t * [0; 6]\n\t\t * Right neighbour [7] is busy. It can't be coaleasced with [6], so\n\t\t * mark [6] free, increase bb_counters and shrink range to\n\t\t * [0; 5].\n\t\t * Then shift range to [0; 2], go up and do the same.\n\t\t */\n\n\n\t\tif (first & 1)\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&first, buddy, -1);\n\t\tif (!(last & 1))\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&last, buddy, 1);\n\t\tif (first > last)\n\t\t\tbreak;\n\t\torder++;\n\n\t\tif (first == last || !(buddy2 = mb_find_buddy(e4b, order, &max))) {\n\t\t\tmb_clear_bits(buddy, first, last - first + 1);\n\t\t\te4b->bd_info->bb_counters[order - 1] += last - first + 1;\n\t\t\tbreak;\n\t\t}\n\t\tfirst >>= 1;\n\t\tlast >>= 1;\n\t\tbuddy = buddy2;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_clear_bits",
          "args": [
            "buddy",
            "first",
            "last - first + 1"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "mb_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1269-1285",
          "snippet": "static void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_buddy",
          "args": [
            "e4b",
            "order",
            "&max"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "440-462",
          "snippet": "static void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_buddy_adjust_border",
          "args": [
            "&last",
            "buddy",
            "1"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "mb_buddy_adjust_border",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1335-1347",
          "snippet": "static inline int mb_buddy_adjust_border(int* bit, void* bitmap, int side)\n{\n\tif (mb_test_bit(*bit + side, bitmap)) {\n\t\tmb_clear_bit(*bit, bitmap);\n\t\t(*bit) -= side;\n\t\treturn 1;\n\t}\n\telse {\n\t\t(*bit) += side;\n\t\tmb_set_bit(*bit, bitmap);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_buddy_adjust_border(int* bit, void* bitmap, int side)\n{\n\tif (mb_test_bit(*bit + side, bitmap)) {\n\t\tmb_clear_bit(*bit, bitmap);\n\t\t(*bit) -= side;\n\t\treturn 1;\n\t}\n\telse {\n\t\t(*bit) += side;\n\t\tmb_set_bit(*bit, bitmap);\n\t\treturn -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_buddy_mark_free(struct ext4_buddy *e4b, int first, int last)\n{\n\tint max;\n\tint order = 1;\n\tvoid *buddy = mb_find_buddy(e4b, order, &max);\n\n\twhile (buddy) {\n\t\tvoid *buddy2;\n\n\t\t/* Bits in range [first; last] are known to be set since\n\t\t * corresponding blocks were allocated. Bits in range\n\t\t * (first; last) will stay set because they form buddies on\n\t\t * upper layer. We just deal with borders if they don't\n\t\t * align with upper layer and then go up.\n\t\t * Releasing entire group is all about clearing\n\t\t * single bit of highest order buddy.\n\t\t */\n\n\t\t/* Example:\n\t\t * ---------------------------------\n\t\t * |   1   |   1   |   1   |   1   |\n\t\t * ---------------------------------\n\t\t * | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |\n\t\t * ---------------------------------\n\t\t *   0   1   2   3   4   5   6   7\n\t\t *      \\_____________________/\n\t\t *\n\t\t * Neither [1] nor [6] is aligned to above layer.\n\t\t * Left neighbour [0] is free, so mark it busy,\n\t\t * decrease bb_counters and extend range to\n\t\t * [0; 6]\n\t\t * Right neighbour [7] is busy. It can't be coaleasced with [6], so\n\t\t * mark [6] free, increase bb_counters and shrink range to\n\t\t * [0; 5].\n\t\t * Then shift range to [0; 2], go up and do the same.\n\t\t */\n\n\n\t\tif (first & 1)\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&first, buddy, -1);\n\t\tif (!(last & 1))\n\t\t\te4b->bd_info->bb_counters[order] += mb_buddy_adjust_border(&last, buddy, 1);\n\t\tif (first > last)\n\t\t\tbreak;\n\t\torder++;\n\n\t\tif (first == last || !(buddy2 = mb_find_buddy(e4b, order, &max))) {\n\t\t\tmb_clear_bits(buddy, first, last - first + 1);\n\t\t\te4b->bd_info->bb_counters[order - 1] += last - first + 1;\n\t\t\tbreak;\n\t\t}\n\t\tfirst >>= 1;\n\t\tlast >>= 1;\n\t\tbuddy = buddy2;\n\t}\n}"
  },
  {
    "function_name": "mb_buddy_adjust_border",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1335-1347",
    "snippet": "static inline int mb_buddy_adjust_border(int* bit, void* bitmap, int side)\n{\n\tif (mb_test_bit(*bit + side, bitmap)) {\n\t\tmb_clear_bit(*bit, bitmap);\n\t\t(*bit) -= side;\n\t\treturn 1;\n\t}\n\telse {\n\t\t(*bit) += side;\n\t\tmb_set_bit(*bit, bitmap);\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_set_bit",
          "args": [
            "*bit",
            "bitmap"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_clear_bit",
          "args": [
            "*bit",
            "bitmap"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "mb_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "402-406",
          "snippet": "static inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "*bit + side",
            "bitmap"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_buddy_adjust_border(int* bit, void* bitmap, int side)\n{\n\tif (mb_test_bit(*bit + side, bitmap)) {\n\t\tmb_clear_bit(*bit, bitmap);\n\t\t(*bit) -= side;\n\t\treturn 1;\n\t}\n\telse {\n\t\t(*bit) += side;\n\t\tmb_set_bit(*bit, bitmap);\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "ext4_set_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1314-1330",
    "snippet": "void ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_set_bit",
          "args": [
            "cur",
            "bm"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
  },
  {
    "function_name": "mb_test_and_clear_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1290-1312",
    "snippet": "static int mb_test_and_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\tint zero_bit = -1;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\tif (*addr != (__u32)(-1) && zero_bit == -1)\n\t\t\t\tzero_bit = cur + mb_find_next_zero_bit(addr, 32, 0);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mb_test_and_clear_bit(cur, bm) && zero_bit == -1)\n\t\t\tzero_bit = cur;\n\t\tcur++;\n\t}\n\n\treturn zero_bit;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_test_and_clear_bit",
          "args": [
            "cur",
            "bm"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "408-412",
          "snippet": "static inline int mb_test_and_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_and_clear_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_and_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_and_clear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_next_zero_bit",
          "args": [
            "addr",
            "32",
            "0"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "414-425",
          "snippet": "static inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_test_and_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\tint zero_bit = -1;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\tif (*addr != (__u32)(-1) && zero_bit == -1)\n\t\t\t\tzero_bit = cur + mb_find_next_zero_bit(addr, 32, 0);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!mb_test_and_clear_bit(cur, bm) && zero_bit == -1)\n\t\t\tzero_bit = cur;\n\t\tcur++;\n\t}\n\n\treturn zero_bit;\n}"
  },
  {
    "function_name": "mb_clear_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1269-1285",
    "snippet": "static void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_clear_bit",
          "args": [
            "cur",
            "bm"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "mb_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "402-406",
          "snippet": "static inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void mb_clear_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: clear whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_clear_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
  },
  {
    "function_name": "mb_find_order_for_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1248-1267",
    "snippet": "static int mb_find_order_for_block(struct ext4_buddy *e4b, int block)\n{\n\tint order = 1;\n\tvoid *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(block >= (1 << (e4b->bd_blkbits + 3)));\n\n\tbb = e4b->bd_buddy;\n\twhile (order <= e4b->bd_blkbits + 1) {\n\t\tblock = block >> 1;\n\t\tif (!mb_test_bit(block, bb)) {\n\t\t\t/* this block is part of buddy of order 'order' */\n\t\t\treturn order;\n\t\t}\n\t\tbb += 1 << (e4b->bd_blkbits - order);\n\t\torder++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "block",
            "bb"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block >= (1 << (e4b->bd_blkbits + 3))"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "e4b->bd_bitmap == e4b->bd_buddy"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int mb_find_order_for_block(struct ext4_buddy *e4b, int block)\n{\n\tint order = 1;\n\tvoid *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(block >= (1 << (e4b->bd_blkbits + 3)));\n\n\tbb = e4b->bd_buddy;\n\twhile (order <= e4b->bd_blkbits + 1) {\n\t\tblock = block >> 1;\n\t\tif (!mb_test_bit(block, bb)) {\n\t\t\t/* this block is part of buddy of order 'order' */\n\t\t\treturn order;\n\t\t}\n\t\tbb += 1 << (e4b->bd_blkbits - order);\n\t\torder++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_unload_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1239-1245",
    "snippet": "static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "e4b->bd_buddy_page"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "e4b->bd_bitmap_page"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_unload_buddy(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n}"
  },
  {
    "function_name": "ext4_mb_load_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1100-1237",
    "snippet": "static noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "e4b->bd_buddy_page"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "e4b->bd_bitmap_page"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "e4b->bd_buddy_page == NULL"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "e4b->bd_bitmap_page == NULL"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_init_cache",
          "args": [
            "page",
            "e4b->bd_bitmap"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_init_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "817-966",
          "snippet": "static int ext4_mb_init_cache(struct page *page, char *incore)\n{\n\text4_group_t ngroups;\n\tint blocksize;\n\tint blocks_per_page;\n\tint groups_per_page;\n\tint err = 0;\n\tint i;\n\text4_group_t first_group, group;\n\tint first_block;\n\tstruct super_block *sb;\n\tstruct buffer_head *bhs;\n\tstruct buffer_head **bh = NULL;\n\tstruct inode *inode;\n\tchar *data;\n\tchar *bitmap;\n\tstruct ext4_group_info *grinfo;\n\n\tmb_debug(1, \"init page %lu\\n\", page->index);\n\n\tinode = page->mapping->host;\n\tsb = inode->i_sb;\n\tngroups = ext4_get_groups_count(sb);\n\tblocksize = 1 << inode->i_blkbits;\n\tblocks_per_page = PAGE_CACHE_SIZE / blocksize;\n\n\tgroups_per_page = blocks_per_page >> 1;\n\tif (groups_per_page == 0)\n\t\tgroups_per_page = 1;\n\n\t/* allocate buffer_heads to read bitmaps */\n\tif (groups_per_page > 1) {\n\t\ti = sizeof(struct buffer_head *) * groups_per_page;\n\t\tbh = kzalloc(i, GFP_NOFS);\n\t\tif (bh == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tbh = &bhs;\n\n\tfirst_group = page->index * blocks_per_page / 2;\n\n\t/* read all groups the page covers into the cache */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t/*\n\t\t * If page is uptodate then we came here after online resize\n\t\t * which added some new uninitialized group info structs, so\n\t\t * we must skip all initialized uptodate buddies on the page,\n\t\t * which may be currently in use by an allocating task.\n\t\t */\n\t\tif (PageUptodate(page) && !EXT4_MB_GRP_NEED_INIT(grinfo)) {\n\t\t\tbh[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(bh[i] = ext4_read_block_bitmap_nowait(sb, group))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmb_debug(1, \"read bitmap for group %u\\n\", group);\n\t}\n\n\t/* wait for I/O completion */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (bh[i] && ext4_wait_block_bitmap(sb, group, bh[i])) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfirst_block = page->index * blocks_per_page;\n\tfor (i = 0; i < blocks_per_page; i++) {\n\t\tgroup = (first_block + i) >> 1;\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tif (!bh[group - first_group])\n\t\t\t/* skip initialized uptodate buddy */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * data carry information regarding this\n\t\t * particular group in the format specified\n\t\t * above\n\t\t *\n\t\t */\n\t\tdata = page_address(page) + (i * blocksize);\n\t\tbitmap = bh[group - first_group]->b_data;\n\n\t\t/*\n\t\t * We place the buddy block and bitmap block\n\t\t * close together\n\t\t */\n\t\tif ((first_block + i) & 1) {\n\t\t\t/* this is block of buddy */\n\t\t\tBUG_ON(incore == NULL);\n\t\t\tmb_debug(1, \"put buddy for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_buddy_bitmap_load(sb, group);\n\t\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t\tgrinfo->bb_fragments = 0;\n\t\t\tmemset(grinfo->bb_counters, 0,\n\t\t\t       sizeof(*grinfo->bb_counters) *\n\t\t\t\t(sb->s_blocksize_bits+2));\n\t\t\t/*\n\t\t\t * incore got set to the group block bitmap below\n\t\t\t */\n\t\t\text4_lock_group(sb, group);\n\t\t\t/* init the buddy */\n\t\t\tmemset(data, 0xff, blocksize);\n\t\t\text4_mb_generate_buddy(sb, data, incore, group);\n\t\t\text4_unlock_group(sb, group);\n\t\t\tincore = NULL;\n\t\t} else {\n\t\t\t/* this is block of bitmap */\n\t\t\tBUG_ON(incore != NULL);\n\t\t\tmb_debug(1, \"put bitmap for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_bitmap_load(sb, group);\n\n\t\t\t/* see comments in ext4_mb_put_pa() */\n\t\t\text4_lock_group(sb, group);\n\t\t\tmemcpy(data, bitmap, blocksize);\n\n\t\t\t/* mark all preallocated blks used in in-core bitmap */\n\t\t\text4_mb_generate_from_pa(sb, data, group);\n\t\t\text4_mb_generate_from_freelist(sb, data, group);\n\t\t\text4_unlock_group(sb, group);\n\n\t\t\t/* set incore so that the buddy information can be\n\t\t\t * generated using this\n\t\t\t */\n\t\t\tincore = data;\n\t\t}\n\t}\n\tSetPageUptodate(page);\n\nout:\n\tif (bh) {\n\t\tfor (i = 0; i < groups_per_page; i++)\n\t\t\tbrelse(bh[i]);\n\t\tif (bh != &bhs)\n\t\t\tkfree(bh);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_mb_init_cache(struct page *page, char *incore)\n{\n\text4_group_t ngroups;\n\tint blocksize;\n\tint blocks_per_page;\n\tint groups_per_page;\n\tint err = 0;\n\tint i;\n\text4_group_t first_group, group;\n\tint first_block;\n\tstruct super_block *sb;\n\tstruct buffer_head *bhs;\n\tstruct buffer_head **bh = NULL;\n\tstruct inode *inode;\n\tchar *data;\n\tchar *bitmap;\n\tstruct ext4_group_info *grinfo;\n\n\tmb_debug(1, \"init page %lu\\n\", page->index);\n\n\tinode = page->mapping->host;\n\tsb = inode->i_sb;\n\tngroups = ext4_get_groups_count(sb);\n\tblocksize = 1 << inode->i_blkbits;\n\tblocks_per_page = PAGE_CACHE_SIZE / blocksize;\n\n\tgroups_per_page = blocks_per_page >> 1;\n\tif (groups_per_page == 0)\n\t\tgroups_per_page = 1;\n\n\t/* allocate buffer_heads to read bitmaps */\n\tif (groups_per_page > 1) {\n\t\ti = sizeof(struct buffer_head *) * groups_per_page;\n\t\tbh = kzalloc(i, GFP_NOFS);\n\t\tif (bh == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tbh = &bhs;\n\n\tfirst_group = page->index * blocks_per_page / 2;\n\n\t/* read all groups the page covers into the cache */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t/*\n\t\t * If page is uptodate then we came here after online resize\n\t\t * which added some new uninitialized group info structs, so\n\t\t * we must skip all initialized uptodate buddies on the page,\n\t\t * which may be currently in use by an allocating task.\n\t\t */\n\t\tif (PageUptodate(page) && !EXT4_MB_GRP_NEED_INIT(grinfo)) {\n\t\t\tbh[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(bh[i] = ext4_read_block_bitmap_nowait(sb, group))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmb_debug(1, \"read bitmap for group %u\\n\", group);\n\t}\n\n\t/* wait for I/O completion */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (bh[i] && ext4_wait_block_bitmap(sb, group, bh[i])) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfirst_block = page->index * blocks_per_page;\n\tfor (i = 0; i < blocks_per_page; i++) {\n\t\tgroup = (first_block + i) >> 1;\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tif (!bh[group - first_group])\n\t\t\t/* skip initialized uptodate buddy */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * data carry information regarding this\n\t\t * particular group in the format specified\n\t\t * above\n\t\t *\n\t\t */\n\t\tdata = page_address(page) + (i * blocksize);\n\t\tbitmap = bh[group - first_group]->b_data;\n\n\t\t/*\n\t\t * We place the buddy block and bitmap block\n\t\t * close together\n\t\t */\n\t\tif ((first_block + i) & 1) {\n\t\t\t/* this is block of buddy */\n\t\t\tBUG_ON(incore == NULL);\n\t\t\tmb_debug(1, \"put buddy for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_buddy_bitmap_load(sb, group);\n\t\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t\tgrinfo->bb_fragments = 0;\n\t\t\tmemset(grinfo->bb_counters, 0,\n\t\t\t       sizeof(*grinfo->bb_counters) *\n\t\t\t\t(sb->s_blocksize_bits+2));\n\t\t\t/*\n\t\t\t * incore got set to the group block bitmap below\n\t\t\t */\n\t\t\text4_lock_group(sb, group);\n\t\t\t/* init the buddy */\n\t\t\tmemset(data, 0xff, blocksize);\n\t\t\text4_mb_generate_buddy(sb, data, incore, group);\n\t\t\text4_unlock_group(sb, group);\n\t\t\tincore = NULL;\n\t\t} else {\n\t\t\t/* this is block of bitmap */\n\t\t\tBUG_ON(incore != NULL);\n\t\t\tmb_debug(1, \"put bitmap for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_bitmap_load(sb, group);\n\n\t\t\t/* see comments in ext4_mb_put_pa() */\n\t\t\text4_lock_group(sb, group);\n\t\t\tmemcpy(data, bitmap, blocksize);\n\n\t\t\t/* mark all preallocated blks used in in-core bitmap */\n\t\t\text4_mb_generate_from_pa(sb, data, group);\n\t\t\text4_mb_generate_from_freelist(sb, data, group);\n\t\t\text4_unlock_group(sb, group);\n\n\t\t\t/* set incore so that the buddy information can be\n\t\t\t * generated using this\n\t\t\t */\n\t\t\tincore = data;\n\t\t}\n\t}\n\tSetPageUptodate(page);\n\nout:\n\tif (bh) {\n\t\tfor (i = 0; i < groups_per_page; i++)\n\t\t\tbrelse(bh[i]);\n\t\tif (bh != &bhs)\n\t\t\tkfree(bh);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->mapping != inode->i_mapping"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "pnum",
            "GFP_NOFS"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page_flags",
          "args": [
            "inode->i_mapping",
            "pnum",
            "FGP_ACCESSED"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cmp_bitmaps",
          "args": [
            "e4b",
            "page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize)"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cmp_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "535-538",
          "snippet": "static inline void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->mapping != inode->i_mapping"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "pnum",
            "GFP_NOFS"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page_flags",
          "args": [
            "inode->i_mapping",
            "pnum",
            "FGP_ACCESSED"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_init_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_init_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1033-1093",
          "snippet": "static noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(1, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(1, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "EXT4_MB_GRP_NEED_INIT(grp)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_NEED_INIT",
          "args": [
            "grp"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"load group %u\\n\"",
            "group"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack int\next4_mb_load_buddy(struct super_block *sb, ext4_group_t group,\n\t\t\t\t\tstruct ext4_buddy *e4b)\n{\n\tint blocks_per_page;\n\tint block;\n\tint pnum;\n\tint poff;\n\tstruct page *page;\n\tint ret;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct inode *inode = sbi->s_buddy_cache;\n\n\tmight_sleep();\n\tmb_debug(1, \"load group %u\\n\", group);\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\tgrp = ext4_get_group_info(sb, group);\n\n\te4b->bd_blkbits = sb->s_blocksize_bits;\n\te4b->bd_info = grp;\n\te4b->bd_sb = sb;\n\te4b->bd_group = group;\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tif (unlikely(EXT4_MB_GRP_NEED_INIT(grp))) {\n\t\t/*\n\t\t * we need full data about the group\n\t\t * to make a good selection\n\t\t */\n\t\tret = ext4_mb_init_group(sb, group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\t/* we could use find_or_create_page(), but it locks page\n\t * what we'd like to avoid in fast path ... */\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\t/*\n\t\t\t * drop the page reference and try\n\t\t\t * to get the page with lock. If we\n\t\t\t * are not uptodate that implies\n\t\t\t * somebody just created the page but\n\t\t\t * is yet to initialize the same. So\n\t\t\t * wait for it to initialize.\n\t\t\t */\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tmb_cmp_bitmaps(e4b, page_address(page) +\n\t\t\t\t\t       (poff * sb->s_blocksize));\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\n\tpage = find_get_page_flags(inode->i_mapping, pnum, FGP_ACCESSED);\n\tif (page == NULL || !PageUptodate(page)) {\n\t\tif (page)\n\t\t\tpage_cache_release(page);\n\t\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\t\tif (page) {\n\t\t\tBUG_ON(page->mapping != inode->i_mapping);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tret = ext4_mb_init_cache(page, e4b->bd_bitmap);\n\t\t\t\tif (ret) {\n\t\t\t\t\tunlock_page(page);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t}\n\tif (page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t/* Pages marked accessed already */\n\te4b->bd_buddy_page = page;\n\te4b->bd_buddy = page_address(page) + (poff * sb->s_blocksize);\n\n\tBUG_ON(e4b->bd_bitmap_page == NULL);\n\tBUG_ON(e4b->bd_buddy_page == NULL);\n\n\treturn 0;\n\nerr:\n\tif (page)\n\t\tpage_cache_release(page);\n\tif (e4b->bd_bitmap_page)\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\tif (e4b->bd_buddy_page)\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\te4b->bd_buddy = NULL;\n\te4b->bd_bitmap = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_mb_init_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1033-1093",
    "snippet": "static noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(1, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_put_buddy_page_lock",
          "args": [
            "&e4b"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_put_buddy_page_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1016-1026",
          "snippet": "static void ext4_mb_put_buddy_page_lock(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page) {\n\t\tunlock_page(e4b->bd_bitmap_page);\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\t}\n\tif (e4b->bd_buddy_page) {\n\t\tunlock_page(e4b->bd_buddy_page);\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_put_buddy_page_lock(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page) {\n\t\tunlock_page(e4b->bd_bitmap_page);\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\t}\n\tif (e4b->bd_buddy_page) {\n\t\tunlock_page(e4b->bd_buddy_page);\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_init_cache",
          "args": [
            "page",
            "e4b.bd_bitmap"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_init_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "817-966",
          "snippet": "static int ext4_mb_init_cache(struct page *page, char *incore)\n{\n\text4_group_t ngroups;\n\tint blocksize;\n\tint blocks_per_page;\n\tint groups_per_page;\n\tint err = 0;\n\tint i;\n\text4_group_t first_group, group;\n\tint first_block;\n\tstruct super_block *sb;\n\tstruct buffer_head *bhs;\n\tstruct buffer_head **bh = NULL;\n\tstruct inode *inode;\n\tchar *data;\n\tchar *bitmap;\n\tstruct ext4_group_info *grinfo;\n\n\tmb_debug(1, \"init page %lu\\n\", page->index);\n\n\tinode = page->mapping->host;\n\tsb = inode->i_sb;\n\tngroups = ext4_get_groups_count(sb);\n\tblocksize = 1 << inode->i_blkbits;\n\tblocks_per_page = PAGE_CACHE_SIZE / blocksize;\n\n\tgroups_per_page = blocks_per_page >> 1;\n\tif (groups_per_page == 0)\n\t\tgroups_per_page = 1;\n\n\t/* allocate buffer_heads to read bitmaps */\n\tif (groups_per_page > 1) {\n\t\ti = sizeof(struct buffer_head *) * groups_per_page;\n\t\tbh = kzalloc(i, GFP_NOFS);\n\t\tif (bh == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tbh = &bhs;\n\n\tfirst_group = page->index * blocks_per_page / 2;\n\n\t/* read all groups the page covers into the cache */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t/*\n\t\t * If page is uptodate then we came here after online resize\n\t\t * which added some new uninitialized group info structs, so\n\t\t * we must skip all initialized uptodate buddies on the page,\n\t\t * which may be currently in use by an allocating task.\n\t\t */\n\t\tif (PageUptodate(page) && !EXT4_MB_GRP_NEED_INIT(grinfo)) {\n\t\t\tbh[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(bh[i] = ext4_read_block_bitmap_nowait(sb, group))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmb_debug(1, \"read bitmap for group %u\\n\", group);\n\t}\n\n\t/* wait for I/O completion */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (bh[i] && ext4_wait_block_bitmap(sb, group, bh[i])) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfirst_block = page->index * blocks_per_page;\n\tfor (i = 0; i < blocks_per_page; i++) {\n\t\tgroup = (first_block + i) >> 1;\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tif (!bh[group - first_group])\n\t\t\t/* skip initialized uptodate buddy */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * data carry information regarding this\n\t\t * particular group in the format specified\n\t\t * above\n\t\t *\n\t\t */\n\t\tdata = page_address(page) + (i * blocksize);\n\t\tbitmap = bh[group - first_group]->b_data;\n\n\t\t/*\n\t\t * We place the buddy block and bitmap block\n\t\t * close together\n\t\t */\n\t\tif ((first_block + i) & 1) {\n\t\t\t/* this is block of buddy */\n\t\t\tBUG_ON(incore == NULL);\n\t\t\tmb_debug(1, \"put buddy for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_buddy_bitmap_load(sb, group);\n\t\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t\tgrinfo->bb_fragments = 0;\n\t\t\tmemset(grinfo->bb_counters, 0,\n\t\t\t       sizeof(*grinfo->bb_counters) *\n\t\t\t\t(sb->s_blocksize_bits+2));\n\t\t\t/*\n\t\t\t * incore got set to the group block bitmap below\n\t\t\t */\n\t\t\text4_lock_group(sb, group);\n\t\t\t/* init the buddy */\n\t\t\tmemset(data, 0xff, blocksize);\n\t\t\text4_mb_generate_buddy(sb, data, incore, group);\n\t\t\text4_unlock_group(sb, group);\n\t\t\tincore = NULL;\n\t\t} else {\n\t\t\t/* this is block of bitmap */\n\t\t\tBUG_ON(incore != NULL);\n\t\t\tmb_debug(1, \"put bitmap for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_bitmap_load(sb, group);\n\n\t\t\t/* see comments in ext4_mb_put_pa() */\n\t\t\text4_lock_group(sb, group);\n\t\t\tmemcpy(data, bitmap, blocksize);\n\n\t\t\t/* mark all preallocated blks used in in-core bitmap */\n\t\t\text4_mb_generate_from_pa(sb, data, group);\n\t\t\text4_mb_generate_from_freelist(sb, data, group);\n\t\t\text4_unlock_group(sb, group);\n\n\t\t\t/* set incore so that the buddy information can be\n\t\t\t * generated using this\n\t\t\t */\n\t\t\tincore = data;\n\t\t}\n\t}\n\tSetPageUptodate(page);\n\nout:\n\tif (bh) {\n\t\tfor (i = 0; i < groups_per_page; i++)\n\t\t\tbrelse(bh[i]);\n\t\tif (bh != &bhs)\n\t\t\tkfree(bh);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_mb_init_cache(struct page *page, char *incore)\n{\n\text4_group_t ngroups;\n\tint blocksize;\n\tint blocks_per_page;\n\tint groups_per_page;\n\tint err = 0;\n\tint i;\n\text4_group_t first_group, group;\n\tint first_block;\n\tstruct super_block *sb;\n\tstruct buffer_head *bhs;\n\tstruct buffer_head **bh = NULL;\n\tstruct inode *inode;\n\tchar *data;\n\tchar *bitmap;\n\tstruct ext4_group_info *grinfo;\n\n\tmb_debug(1, \"init page %lu\\n\", page->index);\n\n\tinode = page->mapping->host;\n\tsb = inode->i_sb;\n\tngroups = ext4_get_groups_count(sb);\n\tblocksize = 1 << inode->i_blkbits;\n\tblocks_per_page = PAGE_CACHE_SIZE / blocksize;\n\n\tgroups_per_page = blocks_per_page >> 1;\n\tif (groups_per_page == 0)\n\t\tgroups_per_page = 1;\n\n\t/* allocate buffer_heads to read bitmaps */\n\tif (groups_per_page > 1) {\n\t\ti = sizeof(struct buffer_head *) * groups_per_page;\n\t\tbh = kzalloc(i, GFP_NOFS);\n\t\tif (bh == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tbh = &bhs;\n\n\tfirst_group = page->index * blocks_per_page / 2;\n\n\t/* read all groups the page covers into the cache */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t/*\n\t\t * If page is uptodate then we came here after online resize\n\t\t * which added some new uninitialized group info structs, so\n\t\t * we must skip all initialized uptodate buddies on the page,\n\t\t * which may be currently in use by an allocating task.\n\t\t */\n\t\tif (PageUptodate(page) && !EXT4_MB_GRP_NEED_INIT(grinfo)) {\n\t\t\tbh[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(bh[i] = ext4_read_block_bitmap_nowait(sb, group))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmb_debug(1, \"read bitmap for group %u\\n\", group);\n\t}\n\n\t/* wait for I/O completion */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (bh[i] && ext4_wait_block_bitmap(sb, group, bh[i])) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfirst_block = page->index * blocks_per_page;\n\tfor (i = 0; i < blocks_per_page; i++) {\n\t\tgroup = (first_block + i) >> 1;\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tif (!bh[group - first_group])\n\t\t\t/* skip initialized uptodate buddy */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * data carry information regarding this\n\t\t * particular group in the format specified\n\t\t * above\n\t\t *\n\t\t */\n\t\tdata = page_address(page) + (i * blocksize);\n\t\tbitmap = bh[group - first_group]->b_data;\n\n\t\t/*\n\t\t * We place the buddy block and bitmap block\n\t\t * close together\n\t\t */\n\t\tif ((first_block + i) & 1) {\n\t\t\t/* this is block of buddy */\n\t\t\tBUG_ON(incore == NULL);\n\t\t\tmb_debug(1, \"put buddy for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_buddy_bitmap_load(sb, group);\n\t\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t\tgrinfo->bb_fragments = 0;\n\t\t\tmemset(grinfo->bb_counters, 0,\n\t\t\t       sizeof(*grinfo->bb_counters) *\n\t\t\t\t(sb->s_blocksize_bits+2));\n\t\t\t/*\n\t\t\t * incore got set to the group block bitmap below\n\t\t\t */\n\t\t\text4_lock_group(sb, group);\n\t\t\t/* init the buddy */\n\t\t\tmemset(data, 0xff, blocksize);\n\t\t\text4_mb_generate_buddy(sb, data, incore, group);\n\t\t\text4_unlock_group(sb, group);\n\t\t\tincore = NULL;\n\t\t} else {\n\t\t\t/* this is block of bitmap */\n\t\t\tBUG_ON(incore != NULL);\n\t\t\tmb_debug(1, \"put bitmap for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_bitmap_load(sb, group);\n\n\t\t\t/* see comments in ext4_mb_put_pa() */\n\t\t\text4_lock_group(sb, group);\n\t\t\tmemcpy(data, bitmap, blocksize);\n\n\t\t\t/* mark all preallocated blks used in in-core bitmap */\n\t\t\text4_mb_generate_from_pa(sb, data, group);\n\t\t\text4_mb_generate_from_freelist(sb, data, group);\n\t\t\text4_unlock_group(sb, group);\n\n\t\t\t/* set incore so that the buddy information can be\n\t\t\t * generated using this\n\t\t\t */\n\t\t\tincore = data;\n\t\t}\n\t}\n\tSetPageUptodate(page);\n\nout:\n\tif (bh) {\n\t\tfor (i = 0; i < groups_per_page; i++)\n\t\t\tbrelse(bh[i]);\n\t\tif (bh != &bhs)\n\t\t\tkfree(bh);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_NEED_INIT",
          "args": [
            "this_grp"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_get_buddy_page_lock",
          "args": [
            "sb",
            "group",
            "&e4b"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_get_buddy_page_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "974-1014",
          "snippet": "static int ext4_mb_get_buddy_page_lock(struct super_block *sb,\n\t\text4_group_t group, struct ext4_buddy *e4b)\n{\n\tstruct inode *inode = EXT4_SB(sb)->s_buddy_cache;\n\tint block, pnum, poff;\n\tint blocks_per_page;\n\tstruct page *page;\n\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tif (blocks_per_page >= 2) {\n\t\t/* buddy and bitmap are on the same page */\n\t\treturn 0;\n\t}\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_buddy_page = page;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_mb_get_buddy_page_lock(struct super_block *sb,\n\t\text4_group_t group, struct ext4_buddy *e4b)\n{\n\tstruct inode *inode = EXT4_SB(sb)->s_buddy_cache;\n\tint block, pnum, poff;\n\tint blocks_per_page;\n\tstruct page *page;\n\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tif (blocks_per_page >= 2) {\n\t\t/* buddy and bitmap are on the same page */\n\t\treturn 0;\n\t}\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_buddy_page = page;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"init group %u\\n\"",
            "group"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nint ext4_mb_init_group(struct super_block *sb, ext4_group_t group)\n{\n\n\tstruct ext4_group_info *this_grp;\n\tstruct ext4_buddy e4b;\n\tstruct page *page;\n\tint ret = 0;\n\n\tmight_sleep();\n\tmb_debug(1, \"init group %u\\n\", group);\n\tthis_grp = ext4_get_group_info(sb, group);\n\t/*\n\t * This ensures that we don't reinit the buddy cache\n\t * page which map to the group from which we are already\n\t * allocating. If we are looking at the buddy cache we would\n\t * have taken a reference using ext4_mb_load_buddy and that\n\t * would have pinned buddy page to page cache.\n\t * The call to ext4_mb_get_buddy_page_lock will mark the\n\t * page accessed.\n\t */\n\tret = ext4_mb_get_buddy_page_lock(sb, group, &e4b);\n\tif (ret || !EXT4_MB_GRP_NEED_INIT(this_grp)) {\n\t\t/*\n\t\t * somebody initialized the group\n\t\t * return without doing anything\n\t\t */\n\t\tgoto err;\n\t}\n\n\tpage = e4b.bd_bitmap_page;\n\tret = ext4_mb_init_cache(page, NULL);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (e4b.bd_buddy_page == NULL) {\n\t\t/*\n\t\t * If both the bitmap and buddy are in\n\t\t * the same page we don't need to force\n\t\t * init the buddy\n\t\t */\n\t\tret = 0;\n\t\tgoto err;\n\t}\n\t/* init buddy cache */\n\tpage = e4b.bd_buddy_page;\n\tret = ext4_mb_init_cache(page, e4b.bd_bitmap);\n\tif (ret)\n\t\tgoto err;\n\tif (!PageUptodate(page)) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\nerr:\n\text4_mb_put_buddy_page_lock(&e4b);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_mb_put_buddy_page_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "1016-1026",
    "snippet": "static void ext4_mb_put_buddy_page_lock(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page) {\n\t\tunlock_page(e4b->bd_bitmap_page);\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\t}\n\tif (e4b->bd_buddy_page) {\n\t\tunlock_page(e4b->bd_buddy_page);\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "e4b->bd_buddy_page"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "e4b->bd_buddy_page"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "e4b->bd_bitmap_page"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_put_buddy_page_lock(struct ext4_buddy *e4b)\n{\n\tif (e4b->bd_bitmap_page) {\n\t\tunlock_page(e4b->bd_bitmap_page);\n\t\tpage_cache_release(e4b->bd_bitmap_page);\n\t}\n\tif (e4b->bd_buddy_page) {\n\t\tunlock_page(e4b->bd_buddy_page);\n\t\tpage_cache_release(e4b->bd_buddy_page);\n\t}\n}"
  },
  {
    "function_name": "ext4_mb_get_buddy_page_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "974-1014",
    "snippet": "static int ext4_mb_get_buddy_page_lock(struct super_block *sb,\n\t\text4_group_t group, struct ext4_buddy *e4b)\n{\n\tstruct inode *inode = EXT4_SB(sb)->s_buddy_cache;\n\tint block, pnum, poff;\n\tint blocks_per_page;\n\tstruct page *page;\n\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tif (blocks_per_page >= 2) {\n\t\t/* buddy and bitmap are on the same page */\n\t\treturn 0;\n\t}\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_buddy_page = page;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->mapping != inode->i_mapping"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "pnum",
            "GFP_NOFS"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "page->mapping != inode->i_mapping"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "pnum",
            "GFP_NOFS"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_mb_get_buddy_page_lock(struct super_block *sb,\n\t\text4_group_t group, struct ext4_buddy *e4b)\n{\n\tstruct inode *inode = EXT4_SB(sb)->s_buddy_cache;\n\tint block, pnum, poff;\n\tint blocks_per_page;\n\tstruct page *page;\n\n\te4b->bd_buddy_page = NULL;\n\te4b->bd_bitmap_page = NULL;\n\n\tblocks_per_page = PAGE_CACHE_SIZE / sb->s_blocksize;\n\t/*\n\t * the buddy cache inode stores the block bitmap\n\t * and buddy information in consecutive blocks.\n\t * So for each group we need two blocks.\n\t */\n\tblock = group * 2;\n\tpnum = block / blocks_per_page;\n\tpoff = block % blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_bitmap_page = page;\n\te4b->bd_bitmap = page_address(page) + (poff * sb->s_blocksize);\n\n\tif (blocks_per_page >= 2) {\n\t\t/* buddy and bitmap are on the same page */\n\t\treturn 0;\n\t}\n\n\tblock++;\n\tpnum = block / blocks_per_page;\n\tpage = find_or_create_page(inode->i_mapping, pnum, GFP_NOFS);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tBUG_ON(page->mapping != inode->i_mapping);\n\te4b->bd_buddy_page = page;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_mb_init_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "817-966",
    "snippet": "static int ext4_mb_init_cache(struct page *page, char *incore)\n{\n\text4_group_t ngroups;\n\tint blocksize;\n\tint blocks_per_page;\n\tint groups_per_page;\n\tint err = 0;\n\tint i;\n\text4_group_t first_group, group;\n\tint first_block;\n\tstruct super_block *sb;\n\tstruct buffer_head *bhs;\n\tstruct buffer_head **bh = NULL;\n\tstruct inode *inode;\n\tchar *data;\n\tchar *bitmap;\n\tstruct ext4_group_info *grinfo;\n\n\tmb_debug(1, \"init page %lu\\n\", page->index);\n\n\tinode = page->mapping->host;\n\tsb = inode->i_sb;\n\tngroups = ext4_get_groups_count(sb);\n\tblocksize = 1 << inode->i_blkbits;\n\tblocks_per_page = PAGE_CACHE_SIZE / blocksize;\n\n\tgroups_per_page = blocks_per_page >> 1;\n\tif (groups_per_page == 0)\n\t\tgroups_per_page = 1;\n\n\t/* allocate buffer_heads to read bitmaps */\n\tif (groups_per_page > 1) {\n\t\ti = sizeof(struct buffer_head *) * groups_per_page;\n\t\tbh = kzalloc(i, GFP_NOFS);\n\t\tif (bh == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tbh = &bhs;\n\n\tfirst_group = page->index * blocks_per_page / 2;\n\n\t/* read all groups the page covers into the cache */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t/*\n\t\t * If page is uptodate then we came here after online resize\n\t\t * which added some new uninitialized group info structs, so\n\t\t * we must skip all initialized uptodate buddies on the page,\n\t\t * which may be currently in use by an allocating task.\n\t\t */\n\t\tif (PageUptodate(page) && !EXT4_MB_GRP_NEED_INIT(grinfo)) {\n\t\t\tbh[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(bh[i] = ext4_read_block_bitmap_nowait(sb, group))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmb_debug(1, \"read bitmap for group %u\\n\", group);\n\t}\n\n\t/* wait for I/O completion */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (bh[i] && ext4_wait_block_bitmap(sb, group, bh[i])) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfirst_block = page->index * blocks_per_page;\n\tfor (i = 0; i < blocks_per_page; i++) {\n\t\tgroup = (first_block + i) >> 1;\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tif (!bh[group - first_group])\n\t\t\t/* skip initialized uptodate buddy */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * data carry information regarding this\n\t\t * particular group in the format specified\n\t\t * above\n\t\t *\n\t\t */\n\t\tdata = page_address(page) + (i * blocksize);\n\t\tbitmap = bh[group - first_group]->b_data;\n\n\t\t/*\n\t\t * We place the buddy block and bitmap block\n\t\t * close together\n\t\t */\n\t\tif ((first_block + i) & 1) {\n\t\t\t/* this is block of buddy */\n\t\t\tBUG_ON(incore == NULL);\n\t\t\tmb_debug(1, \"put buddy for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_buddy_bitmap_load(sb, group);\n\t\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t\tgrinfo->bb_fragments = 0;\n\t\t\tmemset(grinfo->bb_counters, 0,\n\t\t\t       sizeof(*grinfo->bb_counters) *\n\t\t\t\t(sb->s_blocksize_bits+2));\n\t\t\t/*\n\t\t\t * incore got set to the group block bitmap below\n\t\t\t */\n\t\t\text4_lock_group(sb, group);\n\t\t\t/* init the buddy */\n\t\t\tmemset(data, 0xff, blocksize);\n\t\t\text4_mb_generate_buddy(sb, data, incore, group);\n\t\t\text4_unlock_group(sb, group);\n\t\t\tincore = NULL;\n\t\t} else {\n\t\t\t/* this is block of bitmap */\n\t\t\tBUG_ON(incore != NULL);\n\t\t\tmb_debug(1, \"put bitmap for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_bitmap_load(sb, group);\n\n\t\t\t/* see comments in ext4_mb_put_pa() */\n\t\t\text4_lock_group(sb, group);\n\t\t\tmemcpy(data, bitmap, blocksize);\n\n\t\t\t/* mark all preallocated blks used in in-core bitmap */\n\t\t\text4_mb_generate_from_pa(sb, data, group);\n\t\t\text4_mb_generate_from_freelist(sb, data, group);\n\t\t\text4_unlock_group(sb, group);\n\n\t\t\t/* set incore so that the buddy information can be\n\t\t\t * generated using this\n\t\t\t */\n\t\t\tincore = data;\n\t\t}\n\t}\n\tSetPageUptodate(page);\n\nout:\n\tif (bh) {\n\t\tfor (i = 0; i < groups_per_page; i++)\n\t\t\tbrelse(bh[i]);\n\t\tif (bh != &bhs)\n\t\t\tkfree(bh);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bh"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh[i]"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_unlock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_unlock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2567-2571",
          "snippet": "static inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_unlock_group(struct super_block *sb,\n\t\t\t\t\text4_group_t group)\n{\n\tspin_unlock(ext4_group_lock_ptr(sb, group));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_generate_from_freelist",
          "args": [
            "sb",
            "data",
            "group"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_generate_from_freelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3425-3441",
          "snippet": "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group)\n{\n\tstruct rb_node *n;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_free_data *entry;\n\n\tgrp = ext4_get_group_info(sb, group);\n\tn = rb_first(&(grp->bb_free_root));\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_free_data, efd_node);\n\t\text4_set_bits(bitmap, entry->efd_start_cluster, entry->efd_count);\n\t\tn = rb_next(n);\n\t}\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group)\n{\n\tstruct rb_node *n;\n\tstruct ext4_group_info *grp;\n\tstruct ext4_free_data *entry;\n\n\tgrp = ext4_get_group_info(sb, group);\n\tn = rb_first(&(grp->bb_free_root));\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_free_data, efd_node);\n\t\text4_set_bits(bitmap, entry->efd_start_cluster, entry->efd_count);\n\t\tn = rb_next(n);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_generate_from_pa",
          "args": [
            "sb",
            "data",
            "group"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_generate_from_pa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "3448-3482",
          "snippet": "static noinline_for_stack\nvoid ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur;\n\text4_group_t groupnr;\n\text4_grpblk_t start;\n\tint preallocated = 0;\n\tint len;\n\n\t/* all form of preallocation discards first load group,\n\t * so the only competing code is preallocation use.\n\t * we don't need any locking here\n\t * notice we do NOT ignore preallocations with pa_deleted\n\t * otherwise we could leave used blocks available for\n\t * allocation in buddy when concurrent ext4_mb_put_pa()\n\t * is dropping preallocation\n\t */\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tspin_lock(&pa->pa_lock);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t     &groupnr, &start);\n\t\tlen = pa->pa_len;\n\t\tspin_unlock(&pa->pa_lock);\n\t\tif (unlikely(len == 0))\n\t\t\tcontinue;\n\t\tBUG_ON(groupnr != group);\n\t\text4_set_bits(bitmap, start, len);\n\t\tpreallocated += len;\n\t}\n\tmb_debug(1, \"prellocated %u for group %u\\n\", preallocated, group);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_prealloc_space *pa;\n\tstruct list_head *cur;\n\text4_group_t groupnr;\n\text4_grpblk_t start;\n\tint preallocated = 0;\n\tint len;\n\n\t/* all form of preallocation discards first load group,\n\t * so the only competing code is preallocation use.\n\t * we don't need any locking here\n\t * notice we do NOT ignore preallocations with pa_deleted\n\t * otherwise we could leave used blocks available for\n\t * allocation in buddy when concurrent ext4_mb_put_pa()\n\t * is dropping preallocation\n\t */\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\tspin_lock(&pa->pa_lock);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart,\n\t\t\t\t\t     &groupnr, &start);\n\t\tlen = pa->pa_len;\n\t\tspin_unlock(&pa->pa_lock);\n\t\tif (unlikely(len == 0))\n\t\t\tcontinue;\n\t\tBUG_ON(groupnr != group);\n\t\text4_set_bits(bitmap, start, len);\n\t\tpreallocated += len;\n\t}\n\tmb_debug(1, \"prellocated %u for group %u\\n\", preallocated, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "bitmap",
            "blocksize"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_lock_group",
          "args": [
            "sb",
            "group"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_lock_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2547-2565",
          "snippet": "static inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline void ext4_lock_group(struct super_block *sb, ext4_group_t group)\n{\n\tspinlock_t *lock = ext4_group_lock_ptr(sb, group);\n\tif (spin_trylock(lock))\n\t\t/*\n\t\t * We're able to grab the lock right away, so drop the\n\t\t * lock contention counter.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, -1, 0);\n\telse {\n\t\t/*\n\t\t * The lock is busy, so bump the contention counter,\n\t\t * and then wait on the spin lock.\n\t\t */\n\t\tatomic_add_unless(&EXT4_SB(sb)->s_lock_busy, 1,\n\t\t\t\t  EXT4_MAX_CONTENTION);\n\t\tspin_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext4_mb_bitmap_load",
          "args": [
            "sb",
            "group"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"put bitmap for group %u in page %lu/%x\\n\"",
            "group",
            "page->index",
            "i * blocksize"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "incore != NULL"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mb_generate_buddy",
          "args": [
            "sb",
            "data",
            "incore",
            "group"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_generate_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "720-777",
          "snippet": "static noinline_for_stack\nvoid ext4_mb_generate_buddy(struct super_block *sb,\n\t\t\t\tvoid *buddy, void *bitmap, ext4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_grpblk_t first;\n\text4_grpblk_t len;\n\tunsigned free = 0;\n\tunsigned fragments = 0;\n\tunsigned long long period = get_cycles();\n\n\t/* initialize buddy from bitmap which is aggregation\n\t * of on-disk bitmap and preallocations */\n\ti = mb_find_next_zero_bit(bitmap, max, 0);\n\tgrp->bb_first_free = i;\n\twhile (i < max) {\n\t\tfragments++;\n\t\tfirst = i;\n\t\ti = mb_find_next_bit(bitmap, max, i);\n\t\tlen = i - first;\n\t\tfree += len;\n\t\tif (len > 1)\n\t\t\text4_mb_mark_free_simple(sb, buddy, first, len, grp);\n\t\telse\n\t\t\tgrp->bb_counters[0]++;\n\t\tif (i < max)\n\t\t\ti = mb_find_next_zero_bit(bitmap, max, i);\n\t}\n\tgrp->bb_fragments = fragments;\n\n\tif (free != grp->bb_free) {\n\t\text4_grp_locked_error(sb, group, 0, 0,\n\t\t\t\t      \"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\",\n\t\t\t\t      free, grp->bb_free);\n\t\t/*\n\t\t * If we intend to continue, we consider group descriptor\n\t\t * corrupt and update bb_free using bitmap value\n\t\t */\n\t\tgrp->bb_free = free;\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t}\n\tmb_set_largest_free_order(sb, grp);\n\n\tclear_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(grp->bb_state));\n\n\tperiod = get_cycles() - period;\n\tspin_lock(&EXT4_SB(sb)->s_bal_lock);\n\tEXT4_SB(sb)->s_mb_buddies_generated++;\n\tEXT4_SB(sb)->s_mb_generation_time += period;\n\tspin_unlock(&EXT4_SB(sb)->s_bal_lock);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_generate_buddy(struct super_block *sb,\n\t\t\t\tvoid *buddy, void *bitmap, ext4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_grpblk_t first;\n\text4_grpblk_t len;\n\tunsigned free = 0;\n\tunsigned fragments = 0;\n\tunsigned long long period = get_cycles();\n\n\t/* initialize buddy from bitmap which is aggregation\n\t * of on-disk bitmap and preallocations */\n\ti = mb_find_next_zero_bit(bitmap, max, 0);\n\tgrp->bb_first_free = i;\n\twhile (i < max) {\n\t\tfragments++;\n\t\tfirst = i;\n\t\ti = mb_find_next_bit(bitmap, max, i);\n\t\tlen = i - first;\n\t\tfree += len;\n\t\tif (len > 1)\n\t\t\text4_mb_mark_free_simple(sb, buddy, first, len, grp);\n\t\telse\n\t\t\tgrp->bb_counters[0]++;\n\t\tif (i < max)\n\t\t\ti = mb_find_next_zero_bit(bitmap, max, i);\n\t}\n\tgrp->bb_fragments = fragments;\n\n\tif (free != grp->bb_free) {\n\t\text4_grp_locked_error(sb, group, 0, 0,\n\t\t\t\t      \"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\",\n\t\t\t\t      free, grp->bb_free);\n\t\t/*\n\t\t * If we intend to continue, we consider group descriptor\n\t\t * corrupt and update bb_free using bitmap value\n\t\t */\n\t\tgrp->bb_free = free;\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t}\n\tmb_set_largest_free_order(sb, grp);\n\n\tclear_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(grp->bb_state));\n\n\tperiod = get_cycles() - period;\n\tspin_lock(&EXT4_SB(sb)->s_bal_lock);\n\tEXT4_SB(sb)->s_mb_buddies_generated++;\n\tEXT4_SB(sb)->s_mb_generation_time += period;\n\tspin_unlock(&EXT4_SB(sb)->s_bal_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0xff",
            "blocksize"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "grinfo->bb_counters",
            "0",
            "sizeof(*grinfo->bb_counters) *\n\t\t\t\t(sb->s_blocksize_bits+2)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext4_mb_buddy_bitmap_load",
          "args": [
            "sb",
            "group"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"put buddy for group %u in page %lu/%x\\n\"",
            "group",
            "page->index",
            "i * blocksize"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "incore == NULL"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_wait_block_bitmap",
          "args": [
            "sb",
            "group",
            "bh[i]"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_wait_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "480-502",
          "snippet": "int ext4_wait_block_bitmap(struct super_block *sb, ext4_group_t block_group,\n\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_group_desc *desc;\n\n\tif (!buffer_new(bh))\n\t\treturn 0;\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn 1;\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\text4_error(sb, \"Cannot read block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, (unsigned long long) bh->b_blocknr);\n\t\treturn 1;\n\t}\n\tclear_buffer_new(bh);\n\t/* Panic or remount fs read-only if block bitmap is invalid */\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\t/* ...but check for error just in case errors=continue. */\n\treturn !buffer_verified(bh);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nint ext4_wait_block_bitmap(struct super_block *sb, ext4_group_t block_group,\n\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_group_desc *desc;\n\n\tif (!buffer_new(bh))\n\t\treturn 0;\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn 1;\n\twait_on_buffer(bh);\n\tif (!buffer_uptodate(bh)) {\n\t\text4_error(sb, \"Cannot read block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, (unsigned long long) bh->b_blocknr);\n\t\treturn 1;\n\t}\n\tclear_buffer_new(bh);\n\t/* Panic or remount fs read-only if block bitmap is invalid */\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\t/* ...but check for error just in case errors=continue. */\n\treturn !buffer_verified(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"read bitmap for group %u\\n\"",
            "group"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_block_bitmap_nowait",
          "args": [
            "sb",
            "group"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_block_bitmap_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "412-477",
          "snippet": "struct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn NULL;\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tint err;\n\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err)\n\t\t\text4_error(sb, \"Checksum bad for grp %u\", block_group);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (buffer_verified(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn NULL;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nstatic unsigned ext4_num_base_meta_clusters(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t block_group);\n\nstruct buffer_head *\next4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n{\n\tstruct ext4_group_desc *desc;\n\tstruct buffer_head *bh;\n\text4_fsblk_t bitmap_blk;\n\n\tdesc = ext4_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\tbitmap_blk = ext4_block_bitmap(sb, desc);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\n\t\t\t   \"block_group = %u, block_bitmap = %llu\",\n\t\t\t   block_group, bitmap_blk);\n\t\treturn NULL;\n\t}\n\n\tif (bitmap_uptodate(bh))\n\t\tgoto verify;\n\n\tlock_buffer(bh);\n\tif (bitmap_uptodate(bh)) {\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\text4_lock_group(sb, block_group);\n\tif (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {\n\t\tint err;\n\n\t\terr = ext4_init_block_bitmap(sb, bh, block_group, desc);\n\t\tset_bitmap_uptodate(bh);\n\t\tset_buffer_uptodate(bh);\n\t\text4_unlock_group(sb, block_group);\n\t\tunlock_buffer(bh);\n\t\tif (err)\n\t\t\text4_error(sb, \"Checksum bad for grp %u\", block_group);\n\t\treturn bh;\n\t}\n\text4_unlock_group(sb, block_group);\n\tif (buffer_uptodate(bh)) {\n\t\t/*\n\t\t * if not uninit if bh is uptodate,\n\t\t * bitmap is also uptodate\n\t\t */\n\t\tset_bitmap_uptodate(bh);\n\t\tunlock_buffer(bh);\n\t\tgoto verify;\n\t}\n\t/*\n\t * submit the buffer_head for reading\n\t */\n\tset_buffer_new(bh);\n\ttrace_ext4_read_block_bitmap_load(sb, block_group);\n\tbh->b_end_io = ext4_end_bitmap_read;\n\tget_bh(bh);\n\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\treturn bh;\nverify:\n\text4_validate_block_bitmap(sb, desc, block_group, bh);\n\tif (buffer_verified(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_NEED_INIT",
          "args": [
            "grinfo"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "i",
            "GFP_NOFS"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_groups_count",
          "args": [
            "sb"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_debug",
          "args": [
            "1",
            "\"init page %lu\\n\"",
            "page->index"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic int ext4_mb_init_cache(struct page *page, char *incore)\n{\n\text4_group_t ngroups;\n\tint blocksize;\n\tint blocks_per_page;\n\tint groups_per_page;\n\tint err = 0;\n\tint i;\n\text4_group_t first_group, group;\n\tint first_block;\n\tstruct super_block *sb;\n\tstruct buffer_head *bhs;\n\tstruct buffer_head **bh = NULL;\n\tstruct inode *inode;\n\tchar *data;\n\tchar *bitmap;\n\tstruct ext4_group_info *grinfo;\n\n\tmb_debug(1, \"init page %lu\\n\", page->index);\n\n\tinode = page->mapping->host;\n\tsb = inode->i_sb;\n\tngroups = ext4_get_groups_count(sb);\n\tblocksize = 1 << inode->i_blkbits;\n\tblocks_per_page = PAGE_CACHE_SIZE / blocksize;\n\n\tgroups_per_page = blocks_per_page >> 1;\n\tif (groups_per_page == 0)\n\t\tgroups_per_page = 1;\n\n\t/* allocate buffer_heads to read bitmaps */\n\tif (groups_per_page > 1) {\n\t\ti = sizeof(struct buffer_head *) * groups_per_page;\n\t\tbh = kzalloc(i, GFP_NOFS);\n\t\tif (bh == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tbh = &bhs;\n\n\tfirst_group = page->index * blocks_per_page / 2;\n\n\t/* read all groups the page covers into the cache */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t/*\n\t\t * If page is uptodate then we came here after online resize\n\t\t * which added some new uninitialized group info structs, so\n\t\t * we must skip all initialized uptodate buddies on the page,\n\t\t * which may be currently in use by an allocating task.\n\t\t */\n\t\tif (PageUptodate(page) && !EXT4_MB_GRP_NEED_INIT(grinfo)) {\n\t\t\tbh[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(bh[i] = ext4_read_block_bitmap_nowait(sb, group))) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmb_debug(1, \"read bitmap for group %u\\n\", group);\n\t}\n\n\t/* wait for I/O completion */\n\tfor (i = 0, group = first_group; i < groups_per_page; i++, group++) {\n\t\tif (bh[i] && ext4_wait_block_bitmap(sb, group, bh[i])) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfirst_block = page->index * blocks_per_page;\n\tfor (i = 0; i < blocks_per_page; i++) {\n\t\tgroup = (first_block + i) >> 1;\n\t\tif (group >= ngroups)\n\t\t\tbreak;\n\n\t\tif (!bh[group - first_group])\n\t\t\t/* skip initialized uptodate buddy */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * data carry information regarding this\n\t\t * particular group in the format specified\n\t\t * above\n\t\t *\n\t\t */\n\t\tdata = page_address(page) + (i * blocksize);\n\t\tbitmap = bh[group - first_group]->b_data;\n\n\t\t/*\n\t\t * We place the buddy block and bitmap block\n\t\t * close together\n\t\t */\n\t\tif ((first_block + i) & 1) {\n\t\t\t/* this is block of buddy */\n\t\t\tBUG_ON(incore == NULL);\n\t\t\tmb_debug(1, \"put buddy for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_buddy_bitmap_load(sb, group);\n\t\t\tgrinfo = ext4_get_group_info(sb, group);\n\t\t\tgrinfo->bb_fragments = 0;\n\t\t\tmemset(grinfo->bb_counters, 0,\n\t\t\t       sizeof(*grinfo->bb_counters) *\n\t\t\t\t(sb->s_blocksize_bits+2));\n\t\t\t/*\n\t\t\t * incore got set to the group block bitmap below\n\t\t\t */\n\t\t\text4_lock_group(sb, group);\n\t\t\t/* init the buddy */\n\t\t\tmemset(data, 0xff, blocksize);\n\t\t\text4_mb_generate_buddy(sb, data, incore, group);\n\t\t\text4_unlock_group(sb, group);\n\t\t\tincore = NULL;\n\t\t} else {\n\t\t\t/* this is block of bitmap */\n\t\t\tBUG_ON(incore != NULL);\n\t\t\tmb_debug(1, \"put bitmap for group %u in page %lu/%x\\n\",\n\t\t\t\tgroup, page->index, i * blocksize);\n\t\t\ttrace_ext4_mb_bitmap_load(sb, group);\n\n\t\t\t/* see comments in ext4_mb_put_pa() */\n\t\t\text4_lock_group(sb, group);\n\t\t\tmemcpy(data, bitmap, blocksize);\n\n\t\t\t/* mark all preallocated blks used in in-core bitmap */\n\t\t\text4_mb_generate_from_pa(sb, data, group);\n\t\t\text4_mb_generate_from_freelist(sb, data, group);\n\t\t\text4_unlock_group(sb, group);\n\n\t\t\t/* set incore so that the buddy information can be\n\t\t\t * generated using this\n\t\t\t */\n\t\t\tincore = data;\n\t\t}\n\t}\n\tSetPageUptodate(page);\n\nout:\n\tif (bh) {\n\t\tfor (i = 0; i < groups_per_page; i++)\n\t\t\tbrelse(bh[i]);\n\t\tif (bh != &bhs)\n\t\t\tkfree(bh);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "mb_regenerate_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "779-795",
    "snippet": "static void mb_regenerate_buddy(struct ext4_buddy *e4b)\n{\n\tint count;\n\tint order = 1;\n\tvoid *buddy;\n\n\twhile ((buddy = mb_find_buddy(e4b, order++, &count))) {\n\t\text4_set_bits(buddy, 0, count);\n\t}\n\te4b->bd_info->bb_fragments = 0;\n\tmemset(e4b->bd_info->bb_counters, 0,\n\t\tsizeof(*e4b->bd_info->bb_counters) *\n\t\t(e4b->bd_sb->s_blocksize_bits + 2));\n\n\text4_mb_generate_buddy(e4b->bd_sb, e4b->bd_buddy,\n\t\te4b->bd_bitmap, e4b->bd_group);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_mb_generate_buddy",
          "args": [
            "e4b->bd_sb",
            "e4b->bd_buddy",
            "e4b->bd_bitmap",
            "e4b->bd_group"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_generate_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "720-777",
          "snippet": "static noinline_for_stack\nvoid ext4_mb_generate_buddy(struct super_block *sb,\n\t\t\t\tvoid *buddy, void *bitmap, ext4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_grpblk_t first;\n\text4_grpblk_t len;\n\tunsigned free = 0;\n\tunsigned fragments = 0;\n\tunsigned long long period = get_cycles();\n\n\t/* initialize buddy from bitmap which is aggregation\n\t * of on-disk bitmap and preallocations */\n\ti = mb_find_next_zero_bit(bitmap, max, 0);\n\tgrp->bb_first_free = i;\n\twhile (i < max) {\n\t\tfragments++;\n\t\tfirst = i;\n\t\ti = mb_find_next_bit(bitmap, max, i);\n\t\tlen = i - first;\n\t\tfree += len;\n\t\tif (len > 1)\n\t\t\text4_mb_mark_free_simple(sb, buddy, first, len, grp);\n\t\telse\n\t\t\tgrp->bb_counters[0]++;\n\t\tif (i < max)\n\t\t\ti = mb_find_next_zero_bit(bitmap, max, i);\n\t}\n\tgrp->bb_fragments = fragments;\n\n\tif (free != grp->bb_free) {\n\t\text4_grp_locked_error(sb, group, 0, 0,\n\t\t\t\t      \"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\",\n\t\t\t\t      free, grp->bb_free);\n\t\t/*\n\t\t * If we intend to continue, we consider group descriptor\n\t\t * corrupt and update bb_free using bitmap value\n\t\t */\n\t\tgrp->bb_free = free;\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t}\n\tmb_set_largest_free_order(sb, grp);\n\n\tclear_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(grp->bb_state));\n\n\tperiod = get_cycles() - period;\n\tspin_lock(&EXT4_SB(sb)->s_bal_lock);\n\tEXT4_SB(sb)->s_mb_buddies_generated++;\n\tEXT4_SB(sb)->s_mb_generation_time += period;\n\tspin_unlock(&EXT4_SB(sb)->s_bal_lock);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_generate_buddy(struct super_block *sb,\n\t\t\t\tvoid *buddy, void *bitmap, ext4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_grpblk_t first;\n\text4_grpblk_t len;\n\tunsigned free = 0;\n\tunsigned fragments = 0;\n\tunsigned long long period = get_cycles();\n\n\t/* initialize buddy from bitmap which is aggregation\n\t * of on-disk bitmap and preallocations */\n\ti = mb_find_next_zero_bit(bitmap, max, 0);\n\tgrp->bb_first_free = i;\n\twhile (i < max) {\n\t\tfragments++;\n\t\tfirst = i;\n\t\ti = mb_find_next_bit(bitmap, max, i);\n\t\tlen = i - first;\n\t\tfree += len;\n\t\tif (len > 1)\n\t\t\text4_mb_mark_free_simple(sb, buddy, first, len, grp);\n\t\telse\n\t\t\tgrp->bb_counters[0]++;\n\t\tif (i < max)\n\t\t\ti = mb_find_next_zero_bit(bitmap, max, i);\n\t}\n\tgrp->bb_fragments = fragments;\n\n\tif (free != grp->bb_free) {\n\t\text4_grp_locked_error(sb, group, 0, 0,\n\t\t\t\t      \"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\",\n\t\t\t\t      free, grp->bb_free);\n\t\t/*\n\t\t * If we intend to continue, we consider group descriptor\n\t\t * corrupt and update bb_free using bitmap value\n\t\t */\n\t\tgrp->bb_free = free;\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t}\n\tmb_set_largest_free_order(sb, grp);\n\n\tclear_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(grp->bb_state));\n\n\tperiod = get_cycles() - period;\n\tspin_lock(&EXT4_SB(sb)->s_bal_lock);\n\tEXT4_SB(sb)->s_mb_buddies_generated++;\n\tEXT4_SB(sb)->s_mb_generation_time += period;\n\tspin_unlock(&EXT4_SB(sb)->s_bal_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "e4b->bd_info->bb_counters",
            "0",
            "sizeof(*e4b->bd_info->bb_counters) *\n\t\t(e4b->bd_sb->s_blocksize_bits + 2)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_bits",
          "args": [
            "buddy",
            "0",
            "count"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "1314-1330",
          "snippet": "void ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nvoid ext4_set_bits(void *bm, int cur, int len)\n{\n\t__u32 *addr;\n\n\tlen = cur + len;\n\twhile (cur < len) {\n\t\tif ((cur & 31) == 0 && (len - cur) >= 32) {\n\t\t\t/* fast path: set whole word at once */\n\t\t\taddr = bm + (cur >> 3);\n\t\t\t*addr = 0xffffffff;\n\t\t\tcur += 32;\n\t\t\tcontinue;\n\t\t}\n\t\tmb_set_bit(cur, bm);\n\t\tcur++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_buddy",
          "args": [
            "e4b",
            "order++",
            "&count"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "440-462",
          "snippet": "static void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void mb_regenerate_buddy(struct ext4_buddy *e4b)\n{\n\tint count;\n\tint order = 1;\n\tvoid *buddy;\n\n\twhile ((buddy = mb_find_buddy(e4b, order++, &count))) {\n\t\text4_set_bits(buddy, 0, count);\n\t}\n\te4b->bd_info->bb_fragments = 0;\n\tmemset(e4b->bd_info->bb_counters, 0,\n\t\tsizeof(*e4b->bd_info->bb_counters) *\n\t\t(e4b->bd_sb->s_blocksize_bits + 2));\n\n\text4_mb_generate_buddy(e4b->bd_sb, e4b->bd_buddy,\n\t\te4b->bd_bitmap, e4b->bd_group);\n}"
  },
  {
    "function_name": "ext4_mb_generate_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "720-777",
    "snippet": "static noinline_for_stack\nvoid ext4_mb_generate_buddy(struct super_block *sb,\n\t\t\t\tvoid *buddy, void *bitmap, ext4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_grpblk_t first;\n\text4_grpblk_t len;\n\tunsigned free = 0;\n\tunsigned fragments = 0;\n\tunsigned long long period = get_cycles();\n\n\t/* initialize buddy from bitmap which is aggregation\n\t * of on-disk bitmap and preallocations */\n\ti = mb_find_next_zero_bit(bitmap, max, 0);\n\tgrp->bb_first_free = i;\n\twhile (i < max) {\n\t\tfragments++;\n\t\tfirst = i;\n\t\ti = mb_find_next_bit(bitmap, max, i);\n\t\tlen = i - first;\n\t\tfree += len;\n\t\tif (len > 1)\n\t\t\text4_mb_mark_free_simple(sb, buddy, first, len, grp);\n\t\telse\n\t\t\tgrp->bb_counters[0]++;\n\t\tif (i < max)\n\t\t\ti = mb_find_next_zero_bit(bitmap, max, i);\n\t}\n\tgrp->bb_fragments = fragments;\n\n\tif (free != grp->bb_free) {\n\t\text4_grp_locked_error(sb, group, 0, 0,\n\t\t\t\t      \"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\",\n\t\t\t\t      free, grp->bb_free);\n\t\t/*\n\t\t * If we intend to continue, we consider group descriptor\n\t\t * corrupt and update bb_free using bitmap value\n\t\t */\n\t\tgrp->bb_free = free;\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t}\n\tmb_set_largest_free_order(sb, grp);\n\n\tclear_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(grp->bb_state));\n\n\tperiod = get_cycles() - period;\n\tspin_lock(&EXT4_SB(sb)->s_bal_lock);\n\tEXT4_SB(sb)->s_mb_buddies_generated++;\n\tEXT4_SB(sb)->s_mb_generation_time += period;\n\tspin_unlock(&EXT4_SB(sb)->s_bal_lock);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&EXT4_SB(sb)->s_bal_lock"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&EXT4_SB(sb)->s_bal_lock"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cycles",
          "args": [],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EXT4_GROUP_INFO_NEED_INIT_BIT",
            "&(grp->bb_state)"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "408-412",
          "snippet": "static inline int mb_test_and_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_and_clear_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_and_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_and_clear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_set_largest_free_order",
          "args": [
            "sb",
            "grp"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_largest_free_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "703-718",
          "snippet": "static void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT",
            "&grp->bb_state"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeclusters_counter",
            "grp->bb_free"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_BBITMAP_CORRUPT",
          "args": [
            "grp"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_grp_locked_error",
          "args": [
            "sb",
            "group",
            "0",
            "0",
            "\"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\"",
            "free",
            "grp->bb_free"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_grp_locked_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "627-677",
          "snippet": "void __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_grp_locked_error(const char *function, unsigned int line,\n\t\t\t     struct super_block *sb, ext4_group_t grp,\n\t\t\t     unsigned long ino, ext4_fsblk_t block,\n\t\t\t     const char *fmt, ...)\n__releases(bitlock)\n__acquires(bitlock)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\t__save_error_info(sb, function, line);\n\n\tif (ext4_error_ratelimit(sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: group %u, \",\n\t\t       sb->s_id, function, line, grp);\n\t\tif (ino)\n\t\t\tprintk(KERN_CONT \"inode %lu: \", ino);\n\t\tif (block)\n\t\t\tprintk(KERN_CONT \"block %llu:\",\n\t\t\t       (unsigned long long) block);\n\t\tprintk(KERN_CONT \"%pV\\n\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (test_opt(sb, ERRORS_CONT)) {\n\t\text4_commit_super(sb, 0);\n\t\treturn;\n\t}\n\n\text4_unlock_group(sb, grp);\n\text4_handle_error(sb);\n\t/*\n\t * We only get here in the ERRORS_RO case; relocking the group\n\t * may be dangerous, but nothing bad will happen since the\n\t * filesystem will have already been marked read/only and the\n\t * journal has been aborted.  We return 1 as a hint to callers\n\t * who might what to use the return value from\n\t * ext4_grp_locked_error() to distinguish between the\n\t * ERRORS_CONT and ERRORS_RO case, and perhaps return more\n\t * aggressively from the ext4 function in question, with a\n\t * more appropriate error code.\n\t */\n\text4_lock_group(sb, grp);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_next_zero_bit",
          "args": [
            "bitmap",
            "max",
            "i"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_zero_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "414-425",
          "snippet": "static inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_mb_mark_free_simple",
          "args": [
            "sb",
            "buddy",
            "first",
            "len",
            "grp"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mb_mark_free_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "663-697",
          "snippet": "static void ext4_mb_mark_free_simple(struct super_block *sb,\n\t\t\t\tvoid *buddy, ext4_grpblk_t first, ext4_grpblk_t len,\n\t\t\t\t\tstruct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t min;\n\text4_grpblk_t max;\n\text4_grpblk_t chunk;\n\tunsigned short border;\n\n\tBUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));\n\n\tborder = 2 << sb->s_blocksize_bits;\n\n\twhile (len > 0) {\n\t\t/* find how many blocks can be covered since this position */\n\t\tmax = ffs(first | border) - 1;\n\n\t\t/* find how many blocks of power 2 we need to mark */\n\t\tmin = fls(len) - 1;\n\n\t\tif (max < min)\n\t\t\tmin = max;\n\t\tchunk = 1 << min;\n\n\t\t/* mark multiblock chunks only */\n\t\tgrp->bb_counters[min]++;\n\t\tif (min > 0)\n\t\t\tmb_clear_bit(first >> min,\n\t\t\t\t     buddy + sbi->s_mb_offsets[min]);\n\n\t\tlen -= chunk;\n\t\tfirst += chunk;\n\t}\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_mark_free_simple(struct super_block *sb,\n\t\t\t\tvoid *buddy, ext4_grpblk_t first, ext4_grpblk_t len,\n\t\t\t\t\tstruct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t min;\n\text4_grpblk_t max;\n\text4_grpblk_t chunk;\n\tunsigned short border;\n\n\tBUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));\n\n\tborder = 2 << sb->s_blocksize_bits;\n\n\twhile (len > 0) {\n\t\t/* find how many blocks can be covered since this position */\n\t\tmax = ffs(first | border) - 1;\n\n\t\t/* find how many blocks of power 2 we need to mark */\n\t\tmin = fls(len) - 1;\n\n\t\tif (max < min)\n\t\t\tmin = max;\n\t\tchunk = 1 << min;\n\n\t\t/* mark multiblock chunks only */\n\t\tgrp->bb_counters[min]++;\n\t\tif (min > 0)\n\t\t\tmb_clear_bit(first >> min,\n\t\t\t\t     buddy + sbi->s_mb_offsets[min]);\n\n\t\tlen -= chunk;\n\t\tfirst += chunk;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_find_next_bit",
          "args": [
            "bitmap",
            "max",
            "i"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cycles",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "group"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic noinline_for_stack\nvoid ext4_mb_generate_buddy(struct super_block *sb,\n\t\t\t\tvoid *buddy, void *bitmap, ext4_group_t group)\n{\n\tstruct ext4_group_info *grp = ext4_get_group_info(sb, group);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t max = EXT4_CLUSTERS_PER_GROUP(sb);\n\text4_grpblk_t i = 0;\n\text4_grpblk_t first;\n\text4_grpblk_t len;\n\tunsigned free = 0;\n\tunsigned fragments = 0;\n\tunsigned long long period = get_cycles();\n\n\t/* initialize buddy from bitmap which is aggregation\n\t * of on-disk bitmap and preallocations */\n\ti = mb_find_next_zero_bit(bitmap, max, 0);\n\tgrp->bb_first_free = i;\n\twhile (i < max) {\n\t\tfragments++;\n\t\tfirst = i;\n\t\ti = mb_find_next_bit(bitmap, max, i);\n\t\tlen = i - first;\n\t\tfree += len;\n\t\tif (len > 1)\n\t\t\text4_mb_mark_free_simple(sb, buddy, first, len, grp);\n\t\telse\n\t\t\tgrp->bb_counters[0]++;\n\t\tif (i < max)\n\t\t\ti = mb_find_next_zero_bit(bitmap, max, i);\n\t}\n\tgrp->bb_fragments = fragments;\n\n\tif (free != grp->bb_free) {\n\t\text4_grp_locked_error(sb, group, 0, 0,\n\t\t\t\t      \"block bitmap and bg descriptor \"\n\t\t\t\t      \"inconsistent: %u vs %u free clusters\",\n\t\t\t\t      free, grp->bb_free);\n\t\t/*\n\t\t * If we intend to continue, we consider group descriptor\n\t\t * corrupt and update bb_free using bitmap value\n\t\t */\n\t\tgrp->bb_free = free;\n\t\tif (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))\n\t\t\tpercpu_counter_sub(&sbi->s_freeclusters_counter,\n\t\t\t\t\t   grp->bb_free);\n\t\tset_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &grp->bb_state);\n\t}\n\tmb_set_largest_free_order(sb, grp);\n\n\tclear_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(grp->bb_state));\n\n\tperiod = get_cycles() - period;\n\tspin_lock(&EXT4_SB(sb)->s_bal_lock);\n\tEXT4_SB(sb)->s_mb_buddies_generated++;\n\tEXT4_SB(sb)->s_mb_generation_time += period;\n\tspin_unlock(&EXT4_SB(sb)->s_bal_lock);\n}"
  },
  {
    "function_name": "mb_set_largest_free_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "703-718",
    "snippet": "static void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void\nmb_set_largest_free_order(struct super_block *sb, struct ext4_group_info *grp)\n{\n\tint i;\n\tint bits;\n\n\tgrp->bb_largest_free_order = -1; /* uninit */\n\n\tbits = sb->s_blocksize_bits + 1;\n\tfor (i = bits; i >= 0; i--) {\n\t\tif (grp->bb_counters[i] > 0) {\n\t\t\tgrp->bb_largest_free_order = i;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ext4_mb_mark_free_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "663-697",
    "snippet": "static void ext4_mb_mark_free_simple(struct super_block *sb,\n\t\t\t\tvoid *buddy, ext4_grpblk_t first, ext4_grpblk_t len,\n\t\t\t\t\tstruct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t min;\n\text4_grpblk_t max;\n\text4_grpblk_t chunk;\n\tunsigned short border;\n\n\tBUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));\n\n\tborder = 2 << sb->s_blocksize_bits;\n\n\twhile (len > 0) {\n\t\t/* find how many blocks can be covered since this position */\n\t\tmax = ffs(first | border) - 1;\n\n\t\t/* find how many blocks of power 2 we need to mark */\n\t\tmin = fls(len) - 1;\n\n\t\tif (max < min)\n\t\t\tmin = max;\n\t\tchunk = 1 << min;\n\n\t\t/* mark multiblock chunks only */\n\t\tgrp->bb_counters[min]++;\n\t\tif (min > 0)\n\t\t\tmb_clear_bit(first >> min,\n\t\t\t\t     buddy + sbi->s_mb_offsets[min]);\n\n\t\tlen -= chunk;\n\t\tfirst += chunk;\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_clear_bit",
          "args": [
            "first >> min",
            "buddy + sbi->s_mb_offsets[min]"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "mb_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "402-406",
          "snippet": "static inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "len"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "first | border"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "unsigned_offsets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "40-43",
          "snippet": "static inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nstatic inline int unsigned_offsets(struct file *file)\n{\n\treturn file->f_mode & FMODE_UNSIGNED_OFFSET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len > EXT4_CLUSTERS_PER_GROUP(sb)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_CLUSTERS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_mark_free_simple(struct super_block *sb,\n\t\t\t\tvoid *buddy, ext4_grpblk_t first, ext4_grpblk_t len,\n\t\t\t\t\tstruct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t min;\n\text4_grpblk_t max;\n\text4_grpblk_t chunk;\n\tunsigned short border;\n\n\tBUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));\n\n\tborder = 2 << sb->s_blocksize_bits;\n\n\twhile (len > 0) {\n\t\t/* find how many blocks can be covered since this position */\n\t\tmax = ffs(first | border) - 1;\n\n\t\t/* find how many blocks of power 2 we need to mark */\n\t\tmin = fls(len) - 1;\n\n\t\tif (max < min)\n\t\t\tmin = max;\n\t\tchunk = 1 << min;\n\n\t\t/* mark multiblock chunks only */\n\t\tgrp->bb_counters[min]++;\n\t\tif (min > 0)\n\t\t\tmb_clear_bit(first >> min,\n\t\t\t\t     buddy + sbi->s_mb_offsets[min]);\n\n\t\tlen -= chunk;\n\t\tfirst += chunk;\n\t}\n}"
  },
  {
    "function_name": "__mb_check_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "553-649",
    "snippet": "static int __mb_check_buddy(struct ext4_buddy *e4b, char *file,\n\t\t\t\tconst char *function, int line)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tint order = e4b->bd_blkbits + 1;\n\tint max;\n\tint max2;\n\tint i;\n\tint j;\n\tint k;\n\tint count;\n\tstruct ext4_group_info *grp;\n\tint fragments = 0;\n\tint fstart;\n\tstruct list_head *cur;\n\tvoid *buddy;\n\tvoid *buddy2;\n\n\t{\n\t\tstatic int mb_check_counter;\n\t\tif (mb_check_counter++ % 100 != 0)\n\t\t\treturn 0;\n\t}\n\n\twhile (order > 1) {\n\t\tbuddy = mb_find_buddy(e4b, order, &max);\n\t\tMB_CHECK_ASSERT(buddy);\n\t\tbuddy2 = mb_find_buddy(e4b, order - 1, &max2);\n\t\tMB_CHECK_ASSERT(buddy2);\n\t\tMB_CHECK_ASSERT(buddy != buddy2);\n\t\tMB_CHECK_ASSERT(max * 2 == max2);\n\n\t\tcount = 0;\n\t\tfor (i = 0; i < max; i++) {\n\n\t\t\tif (mb_test_bit(i, buddy)) {\n\t\t\t\t/* only single bit in buddy2 may be 1 */\n\t\t\t\tif (!mb_test_bit(i << 1, buddy2)) {\n\t\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t\tmb_test_bit((i<<1)+1, buddy2));\n\t\t\t\t} else if (!mb_test_bit((i << 1) + 1, buddy2)) {\n\t\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t\tmb_test_bit(i << 1, buddy2));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* both bits in buddy2 must be 1 */\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(i << 1, buddy2));\n\t\t\tMB_CHECK_ASSERT(mb_test_bit((i << 1) + 1, buddy2));\n\n\t\t\tfor (j = 0; j < (1 << order); j++) {\n\t\t\t\tk = (i * (1 << order)) + j;\n\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t!mb_test_bit(k, e4b->bd_bitmap));\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tMB_CHECK_ASSERT(e4b->bd_info->bb_counters[order] == count);\n\t\torder--;\n\t}\n\n\tfstart = -1;\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tfor (i = 0; i < max; i++) {\n\t\tif (!mb_test_bit(i, buddy)) {\n\t\t\tMB_CHECK_ASSERT(i >= e4b->bd_info->bb_first_free);\n\t\t\tif (fstart == -1) {\n\t\t\t\tfragments++;\n\t\t\t\tfstart = i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfstart = -1;\n\t\t/* check used bits only */\n\t\tfor (j = 0; j < e4b->bd_blkbits + 1; j++) {\n\t\t\tbuddy2 = mb_find_buddy(e4b, j, &max2);\n\t\t\tk = i >> j;\n\t\t\tMB_CHECK_ASSERT(k < max2);\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(k, buddy2));\n\t\t}\n\t}\n\tMB_CHECK_ASSERT(!EXT4_MB_GRP_NEED_INIT(e4b->bd_info));\n\tMB_CHECK_ASSERT(e4b->bd_info->bb_fragments == fragments);\n\n\tgrp = ext4_get_group_info(sb, e4b->bd_group);\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\text4_group_t groupnr;\n\t\tstruct ext4_prealloc_space *pa;\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart, &groupnr, &k);\n\t\tMB_CHECK_ASSERT(groupnr == e4b->bd_group);\n\t\tfor (i = 0; i < pa->pa_len; i++)\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(k + i, buddy));\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "mb_test_bit(k + i, buddy)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "k + i",
            "buddy"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "groupnr == e4b->bd_group"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_no_and_offset",
          "args": [
            "sb",
            "pa->pa_pstart",
            "&groupnr",
            "&k"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "53-67",
          "snippet": "void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nvoid ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,\n\t\text4_group_t *blockgrpp, ext4_grpblk_t *offsetp)\n{\n\tstruct ext4_super_block *es = EXT4_SB(sb)->s_es;\n\text4_grpblk_t offset;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\toffset = do_div(blocknr, EXT4_BLOCKS_PER_GROUP(sb)) >>\n\t\tEXT4_SB(sb)->s_cluster_bits;\n\tif (offsetp)\n\t\t*offsetp = offset;\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cur",
            "structext4_prealloc_space",
            "pa_group_list"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "cur",
            "&grp->bb_prealloc_list"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_group_info",
          "args": [
            "sb",
            "e4b->bd_group"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "e4b->bd_info->bb_fragments == fragments"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "!EXT4_MB_GRP_NEED_INIT(e4b->bd_info)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_MB_GRP_NEED_INIT",
          "args": [
            "e4b->bd_info"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "mb_test_bit(k, buddy2)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "k < max2"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_find_buddy",
          "args": [
            "e4b",
            "j",
            "&max2"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_buddy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "440-462",
          "snippet": "static void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "i >= e4b->bd_info->bb_first_free"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "e4b->bd_info->bb_counters[order] == count"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "!mb_test_bit(k, e4b->bd_bitmap)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "mb_test_bit((i << 1) + 1, buddy2)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "mb_test_bit(i << 1, buddy2)"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "mb_test_bit(i << 1, buddy2)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "mb_test_bit((i<<1)+1, buddy2)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "max * 2 == max2"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "buddy != buddy2"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "buddy2"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MB_CHECK_ASSERT",
          "args": [
            "buddy"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic int __mb_check_buddy(struct ext4_buddy *e4b, char *file,\n\t\t\t\tconst char *function, int line)\n{\n\tstruct super_block *sb = e4b->bd_sb;\n\tint order = e4b->bd_blkbits + 1;\n\tint max;\n\tint max2;\n\tint i;\n\tint j;\n\tint k;\n\tint count;\n\tstruct ext4_group_info *grp;\n\tint fragments = 0;\n\tint fstart;\n\tstruct list_head *cur;\n\tvoid *buddy;\n\tvoid *buddy2;\n\n\t{\n\t\tstatic int mb_check_counter;\n\t\tif (mb_check_counter++ % 100 != 0)\n\t\t\treturn 0;\n\t}\n\n\twhile (order > 1) {\n\t\tbuddy = mb_find_buddy(e4b, order, &max);\n\t\tMB_CHECK_ASSERT(buddy);\n\t\tbuddy2 = mb_find_buddy(e4b, order - 1, &max2);\n\t\tMB_CHECK_ASSERT(buddy2);\n\t\tMB_CHECK_ASSERT(buddy != buddy2);\n\t\tMB_CHECK_ASSERT(max * 2 == max2);\n\n\t\tcount = 0;\n\t\tfor (i = 0; i < max; i++) {\n\n\t\t\tif (mb_test_bit(i, buddy)) {\n\t\t\t\t/* only single bit in buddy2 may be 1 */\n\t\t\t\tif (!mb_test_bit(i << 1, buddy2)) {\n\t\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t\tmb_test_bit((i<<1)+1, buddy2));\n\t\t\t\t} else if (!mb_test_bit((i << 1) + 1, buddy2)) {\n\t\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t\tmb_test_bit(i << 1, buddy2));\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* both bits in buddy2 must be 1 */\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(i << 1, buddy2));\n\t\t\tMB_CHECK_ASSERT(mb_test_bit((i << 1) + 1, buddy2));\n\n\t\t\tfor (j = 0; j < (1 << order); j++) {\n\t\t\t\tk = (i * (1 << order)) + j;\n\t\t\t\tMB_CHECK_ASSERT(\n\t\t\t\t\t!mb_test_bit(k, e4b->bd_bitmap));\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tMB_CHECK_ASSERT(e4b->bd_info->bb_counters[order] == count);\n\t\torder--;\n\t}\n\n\tfstart = -1;\n\tbuddy = mb_find_buddy(e4b, 0, &max);\n\tfor (i = 0; i < max; i++) {\n\t\tif (!mb_test_bit(i, buddy)) {\n\t\t\tMB_CHECK_ASSERT(i >= e4b->bd_info->bb_first_free);\n\t\t\tif (fstart == -1) {\n\t\t\t\tfragments++;\n\t\t\t\tfstart = i;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfstart = -1;\n\t\t/* check used bits only */\n\t\tfor (j = 0; j < e4b->bd_blkbits + 1; j++) {\n\t\t\tbuddy2 = mb_find_buddy(e4b, j, &max2);\n\t\t\tk = i >> j;\n\t\t\tMB_CHECK_ASSERT(k < max2);\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(k, buddy2));\n\t\t}\n\t}\n\tMB_CHECK_ASSERT(!EXT4_MB_GRP_NEED_INIT(e4b->bd_info));\n\tMB_CHECK_ASSERT(e4b->bd_info->bb_fragments == fragments);\n\n\tgrp = ext4_get_group_info(sb, e4b->bd_group);\n\tlist_for_each(cur, &grp->bb_prealloc_list) {\n\t\text4_group_t groupnr;\n\t\tstruct ext4_prealloc_space *pa;\n\t\tpa = list_entry(cur, struct ext4_prealloc_space, pa_group_list);\n\t\text4_get_group_no_and_offset(sb, pa->pa_pstart, &groupnr, &k);\n\t\tMB_CHECK_ASSERT(groupnr == e4b->bd_group);\n\t\tfor (i = 0; i < pa->pa_len; i++)\n\t\t\tMB_CHECK_ASSERT(mb_test_bit(k + i, buddy));\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mb_cmp_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "535-538",
    "snippet": "static inline void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\treturn;\n}"
  },
  {
    "function_name": "mb_mark_used_double",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "530-534",
    "snippet": "static inline void mb_mark_used_double(struct ext4_buddy *e4b,\n\t\t\t\t\t\tint first, int count)\n{\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_mark_used_double(struct ext4_buddy *e4b,\n\t\t\t\t\t\tint first, int count)\n{\n\treturn;\n}"
  },
  {
    "function_name": "mb_free_blocks_double",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "525-529",
    "snippet": "static inline void mb_free_blocks_double(struct inode *inode,\n\t\t\t\tstruct ext4_buddy *e4b, int first, int count)\n{\n\treturn;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_free_blocks_double(struct inode *inode,\n\t\t\t\tstruct ext4_buddy *e4b, int first, int count)\n{\n\treturn;\n}"
  },
  {
    "function_name": "mb_cmp_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "504-522",
    "snippet": "static void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\tif (memcmp(e4b->bd_info->bb_bitmap, bitmap, e4b->bd_sb->s_blocksize)) {\n\t\tunsigned char *b1, *b2;\n\t\tint i;\n\t\tb1 = (unsigned char *) e4b->bd_info->bb_bitmap;\n\t\tb2 = (unsigned char *) bitmap;\n\t\tfor (i = 0; i < e4b->bd_sb->s_blocksize; i++) {\n\t\t\tif (b1[i] != b2[i]) {\n\t\t\t\text4_msg(e4b->bd_sb, KERN_ERR,\n\t\t\t\t\t \"corruption in group %u \"\n\t\t\t\t\t \"at byte %u(%u): %x in copy != %x \"\n\t\t\t\t\t \"on disk/prealloc\",\n\t\t\t\t\t e4b->bd_group, i, i * 8, b1[i], b2[i]);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
      "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "e4b->bd_sb",
            "KERN_ERR",
            "\"corruption in group %u \"\n\t\t\t\t\t \"at byte %u(%u): %x in copy != %x \"\n\t\t\t\t\t \"on disk/prealloc\"",
            "e4b->bd_group",
            "i",
            "i * 8",
            "b1[i]",
            "b2[i]"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "e4b->bd_info->bb_bitmap",
            "bitmap",
            "e4b->bd_sb->s_blocksize"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nstatic void mb_cmp_bitmaps(struct ext4_buddy *e4b, void *bitmap)\n{\n\tif (memcmp(e4b->bd_info->bb_bitmap, bitmap, e4b->bd_sb->s_blocksize)) {\n\t\tunsigned char *b1, *b2;\n\t\tint i;\n\t\tb1 = (unsigned char *) e4b->bd_info->bb_bitmap;\n\t\tb2 = (unsigned char *) bitmap;\n\t\tfor (i = 0; i < e4b->bd_sb->s_blocksize; i++) {\n\t\t\tif (b1[i] != b2[i]) {\n\t\t\t\text4_msg(e4b->bd_sb, KERN_ERR,\n\t\t\t\t\t \"corruption in group %u \"\n\t\t\t\t\t \"at byte %u(%u): %x in copy != %x \"\n\t\t\t\t\t \"on disk/prealloc\",\n\t\t\t\t\t e4b->bd_group, i, i * 8, b1[i], b2[i]);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "mb_mark_used_double",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "491-502",
    "snippet": "static void mb_mark_used_double(struct ext4_buddy *e4b, int first, int count)\n{\n\tint i;\n\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tfor (i = 0; i < count; i++) {\n\t\tBUG_ON(mb_test_bit(first + i, e4b->bd_info->bb_bitmap));\n\t\tmb_set_bit(first + i, e4b->bd_info->bb_bitmap);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_set_bit",
          "args": [
            "first + i",
            "e4b->bd_info->bb_bitmap"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "mb_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "396-400",
          "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mb_test_bit(first + i, e4b->bd_info->bb_bitmap)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "first + i",
            "e4b->bd_info->bb_bitmap"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_lock_ptr",
          "args": [
            "e4b->bd_sb",
            "e4b->bd_group"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2211-2536",
          "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
            "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "e4b->bd_info->bb_bitmap == NULL"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void mb_mark_used_double(struct ext4_buddy *e4b, int first, int count)\n{\n\tint i;\n\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tassert_spin_locked(ext4_group_lock_ptr(e4b->bd_sb, e4b->bd_group));\n\tfor (i = 0; i < count; i++) {\n\t\tBUG_ON(mb_test_bit(first + i, e4b->bd_info->bb_bitmap));\n\t\tmb_set_bit(first + i, e4b->bd_info->bb_bitmap);\n\t}\n}"
  },
  {
    "function_name": "mb_free_blocks_double",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "465-489",
    "snippet": "static void mb_free_blocks_double(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint i;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\tfor (i = 0; i < count; i++) {\n\t\tif (!mb_test_bit(first + i, e4b->bd_info->bb_bitmap)) {\n\t\t\text4_fsblk_t blocknr;\n\n\t\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\t\tblocknr += EXT4_C2B(EXT4_SB(sb), first + i);\n\t\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t\t      blocknr,\n\t\t\t\t\t      \"freeing block already freed \"\n\t\t\t\t\t      \"(bit %u)\",\n\t\t\t\t\t      first + i);\n\t\t}\n\t\tmb_clear_bit(first + i, e4b->bd_info->bb_bitmap);\n\t}\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_clear_bit",
          "args": [
            "first + i",
            "e4b->bd_info->bb_bitmap"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "mb_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "402-406",
          "snippet": "static inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_grp_locked_error",
          "args": [
            "sb",
            "e4b->bd_group",
            "inode ? inode->i_ino : 0",
            "blocknr",
            "\"freeing block already freed \"\n\t\t\t\t\t      \"(bit %u)\"",
            "first + i"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "first + i"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "e4b->bd_group"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_test_bit",
          "args": [
            "first + i",
            "e4b->bd_info->bb_bitmap"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "mb_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "386-394",
          "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "ext4_group_lock_ptr(sb, e4b->bd_group)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_lock_ptr",
          "args": [
            "sb",
            "e4b->bd_group"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_lock_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2211-2536",
          "snippet": "extern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400",
            "#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_FEATURE_RO_COMPAT_METADATA_CSUM\t0x0400\n#define EXT4_FEATURE_RO_COMPAT_GDT_CSUM\t\t0x0010\n\nextern __printf(4, 5)\nvoid __ext4_error(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_inode(struct inode *, const char *, unsigned int, ext4_fsblk_t,\n\t\t      const char *, ...);\nextern __printf(5, 6)\nvoid __ext4_error_file(struct file *, const char *, unsigned int, ext4_fsblk_t,\n\t\t     const char *, ...);\nextern void __ext4_std_error(struct super_block *, const char *,\n\t\t\t     unsigned int, int);\nextern __printf(4, 5)\nvoid __ext4_abort(struct super_block *, const char *, unsigned int,\n\t\t  const char *, ...);\nextern __printf(4, 5)\nvoid __ext4_warning(struct super_block *, const char *, unsigned int,\n\t\t    const char *, ...);\nextern __printf(3, 4)\nvoid __ext4_msg(struct super_block *, const char *, const char *, ...);\nextern void __dump_mmp_msg(struct super_block *, struct mmp_struct *mmp,\n\t\t\t   const char *, unsigned int, const char *);\nextern __printf(7, 8)\nvoid __ext4_grp_locked_error(const char *, unsigned int,\n\t\t\t     struct super_block *, ext4_group_t,\n\t\t\t     unsigned long, ext4_fsblk_t,\n\t\t\t     const char *, ...);\n\n#ifdef CONFIG_PRINTK\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_inode(inode, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\n\t__ext4_error_file(file, func, line, block, fmt, ##__VA_ARGS__)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_error(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_abort(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\n\t__ext4_warning(sb, __func__, __LINE__, fmt, ##__VA_ARGS__)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\\\n\t__ext4_msg(sb, level, fmt, ##__VA_ARGS__)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, __func__, __LINE__, msg)\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\n\t__ext4_grp_locked_error(__func__, __LINE__, sb, grp, ino, block, \\\n\t\t\t\tfmt, ##__VA_ARGS__)\n\n#else\n\n#define ext4_error_inode(inode, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_inode(inode, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error_file(file, func, line, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error_file(file, \"\", 0, block, \" \");\t\t\t\\\n} while (0)\n#define ext4_error(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_error(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_abort(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_abort(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_warning(sb, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_warning(sb, \"\", 0, \" \");\t\t\t\t\t\\\n} while (0)\n#define ext4_msg(sb, level, fmt, ...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\t\\\n\t__ext4_msg(sb, \"\", \" \");\t\t\t\t\t\\\n} while (0)\n#define dump_mmp_msg(sb, mmp, msg)\t\t\t\t\t\\\n\t__dump_mmp_msg(sb, mmp, \"\", 0, \"\")\n#define ext4_grp_locked_error(sb, grp, ino, block, fmt, ...)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tno_printk(fmt, ##__VA_ARGS__);\t\t\t\t\\\n\t__ext4_grp_locked_error(\"\", 0, sb, grp, ino, block, \" \");\t\\\n} while (0)\n\n#endif\n\nextern void ext4_update_dynamic_rev(struct super_block *sb);\nextern int ext4_update_compat_feature(handle_t *handle, struct super_block *sb,\n\t\t\t\t\t__u32 compat);\nextern int ext4_update_rocompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 rocompat);\nextern int ext4_update_incompat_feature(handle_t *handle,\n\t\t\t\t\tstruct super_block *sb,\t__u32 incompat);\nextern ext4_fsblk_t ext4_block_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_bitmap(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern ext4_fsblk_t ext4_inode_table(struct super_block *sb,\n\t\t\t\t     struct ext4_group_desc *bg);\nextern __u32 ext4_free_group_clusters(struct super_block *sb,\n\t\t\t\t      struct ext4_group_desc *bg);\nextern __u32 ext4_free_inodes_count(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg);\nextern __u32 ext4_used_dirs_count(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg);\nextern __u32 ext4_itable_unused_count(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg);\nextern void ext4_block_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_bitmap_set(struct super_block *sb,\n\t\t\t\t  struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_inode_table_set(struct super_block *sb,\n\t\t\t\t struct ext4_group_desc *bg, ext4_fsblk_t blk);\nextern void ext4_free_group_clusters_set(struct super_block *sb,\n\t\t\t\t\t struct ext4_group_desc *bg,\n\t\t\t\t\t __u32 count);\nextern void ext4_free_inodes_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_used_dirs_set(struct super_block *sb,\n\t\t\t\tstruct ext4_group_desc *bg, __u32 count);\nextern void ext4_itable_unused_set(struct super_block *sb,\n\t\t\t\t   struct ext4_group_desc *bg, __u32 count);\nextern int ext4_group_desc_csum_verify(struct super_block *sb, __u32 group,\n\t\t\t\t       struct ext4_group_desc *gdp);\nextern void ext4_group_desc_csum_set(struct super_block *sb, __u32 group,\n\t\t\t\t     struct ext4_group_desc *gdp);\nextern int ext4_register_li_request(struct super_block *sb,\n\t\t\t\t    ext4_group_t first_not_zeroed);\n\nstatic inline int ext4_has_group_desc_csum(struct super_block *sb)\n{\n\treturn EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t  EXT4_FEATURE_RO_COMPAT_GDT_CSUM) ||\n\t       (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\n\nstatic inline int ext4_has_metadata_csum(struct super_block *sb)\n{\n\tWARN_ON_ONCE(EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_METADATA_CSUM) &&\n\t\t     !EXT4_SB(sb)->s_chksum_driver);\n\n\treturn (EXT4_SB(sb)->s_chksum_driver != NULL);\n}\nstatic inline ext4_fsblk_t ext4_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_r_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_r_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_r_blocks_count_lo);\n}\n\nstatic inline ext4_fsblk_t ext4_free_blocks_count(struct ext4_super_block *es)\n{\n\treturn ((ext4_fsblk_t)le32_to_cpu(es->s_free_blocks_count_hi) << 32) |\n\t\tle32_to_cpu(es->s_free_blocks_count_lo);\n}\n\nstatic inline void ext4_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t ext4_fsblk_t blk)\n{\n\tes->s_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_free_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t      ext4_fsblk_t blk)\n{\n\tes->s_free_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_free_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n\t\t\t\t\t   ext4_fsblk_t blk)\n{\n\tes->s_r_blocks_count_lo = cpu_to_le32((u32)blk);\n\tes->s_r_blocks_count_hi = cpu_to_le32(blk >> 32);\n}\n\nstatic inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n{\n\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n\telse\n\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n}\n\nstatic inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\n{\n\traw_inode->i_size_lo = cpu_to_le32(i_size);\n\traw_inode->i_size_high = cpu_to_le32(i_size >> 32);\n}\n\nstatic inline\nstruct ext4_group_info *ext4_get_group_info(struct super_block *sb,\n\t\t\t\t\t    ext4_group_t group)\n{\n\t struct ext4_group_info ***grp_info;\n\t long indexv, indexh;\n\t BUG_ON(group >= EXT4_SB(sb)->s_groups_count);\n\t grp_info = EXT4_SB(sb)->s_group_info;\n\t indexv = group >> (EXT4_DESC_PER_BLOCK_BITS(sb));\n\t indexh = group & ((EXT4_DESC_PER_BLOCK(sb)) - 1);\n\t return grp_info[indexv][indexh];\n}\n\n/*\n * Reading s_groups_count requires using smp_rmb() afterwards.  See\n * the locking protocol documented in the comments of ext4_group_add()\n * in resize.c\n */\nstatic inline ext4_group_t ext4_get_groups_count(struct super_block *sb)\n{\n\text4_group_t\tngroups = EXT4_SB(sb)->s_groups_count;\n\n\tsmp_rmb();\n\treturn ngroups;\n}\n\nstatic inline ext4_group_t ext4_flex_group(struct ext4_sb_info *sbi,\n\t\t\t\t\t     ext4_group_t block_group)\n{\n\treturn block_group >> sbi->s_log_groups_per_flex;\n}\n\nstatic inline unsigned int ext4_flex_bg_size(struct ext4_sb_info *sbi)\n{\n\treturn 1 << sbi->s_log_groups_per_flex;\n}\n\n#define ext4_std_error(sb, errno)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif ((errno))\t\t\t\t\t\t\\\n\t\t__ext4_std_error((sb), __func__, __LINE__, (errno));\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\n/* Each CPU can accumulate percpu_counter_batch clusters in their local\n * counters. So we need to make sure we have free clusters more\n * than percpu_counter_batch  * nr_cpu_ids. Also add a window of 4 times.\n */\n#define EXT4_FREECLUSTERS_WATERMARK (4 * (percpu_counter_batch * nr_cpu_ids))\n#else\n#define EXT4_FREECLUSTERS_WATERMARK 0\n#endif\n\n/* Update i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)\n{\n\tWARN_ON_ONCE(S_ISREG(inode->i_mode) &&\n\t\t     !mutex_is_locked(&inode->i_mutex));\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\tif (newsize > EXT4_I(inode)->i_disksize)\n\t\tEXT4_I(inode)->i_disksize = newsize;\n\tup_write(&EXT4_I(inode)->i_data_sem);\n}\n\n/* Update i_size, i_disksize. Requires i_mutex to avoid races with truncate */\nstatic inline int ext4_update_inode_size(struct inode *inode, loff_t newsize)\n{\n\tint changed = 0;\n\n\tif (newsize > inode->i_size) {\n\t\ti_size_write(inode, newsize);\n\t\tchanged = 1;\n\t}\n\tif (newsize > EXT4_I(inode)->i_disksize) {\n\t\text4_update_i_disksize(inode, newsize);\n\t\tchanged |= 2;\n\t}\n\treturn changed;\n}\n\nstruct ext4_group_info {\n\tunsigned long   bb_state;\n\tstruct rb_root  bb_free_root;\n\text4_grpblk_t\tbb_first_free;\t/* first free block */\n\text4_grpblk_t\tbb_free;\t/* total free blocks */\n\text4_grpblk_t\tbb_fragments;\t/* nr of freespace fragments */\n\text4_grpblk_t\tbb_largest_free_order;/* order of largest frag in BG */\n\tstruct          list_head bb_prealloc_list;\n#ifdef DOUBLE_CHECK\n\tvoid            *bb_bitmap;\n#endif\n\tstruct rw_semaphore alloc_sem;\n\text4_grpblk_t\tbb_counters[];\t/* Nr of free power-of-two-block\n\t\t\t\t\t * regions, index is order.\n\t\t\t\t\t * bb_counters[3] = 5 means\n\t\t\t\t\t * 5 free 8-block regions. */\n};\n\n#define EXT4_GROUP_INFO_NEED_INIT_BIT\t\t0\n#define EXT4_GROUP_INFO_WAS_TRIMMED_BIT\t\t1\n#define EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT\t2\n#define EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT\t3\n\n#define EXT4_MB_GRP_NEED_INIT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_BBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_BBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_IBITMAP_CORRUPT(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_IBITMAP_CORRUPT_BIT, &((grp)->bb_state)))\n\n#define EXT4_MB_GRP_WAS_TRIMMED(grp)\t\\\n\t(test_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_SET_TRIMMED(grp)\t\\\n\t(set_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n#define EXT4_MB_GRP_CLEAR_TRIMMED(grp)\t\\\n\t(clear_bit(EXT4_GROUP_INFO_WAS_TRIMMED_BIT, &((grp)->bb_state)))\n\n#define EXT4_MAX_CONTENTION\t\t8\n#define EXT4_CONTENTION_THRESHOLD\t2\n\nstatic inline spinlock_t *ext4_group_lock_ptr(struct super_block *sb,\n\t\t\t\t\t      ext4_group_t group)\n{\n\treturn bgl_lock_ptr(EXT4_SB(sb)->s_blockgroup_lock, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "e4b->bd_info->bb_bitmap == NULL"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void mb_free_blocks_double(struct inode *inode, struct ext4_buddy *e4b,\n\t\t\t   int first, int count)\n{\n\tint i;\n\tstruct super_block *sb = e4b->bd_sb;\n\n\tif (unlikely(e4b->bd_info->bb_bitmap == NULL))\n\t\treturn;\n\tassert_spin_locked(ext4_group_lock_ptr(sb, e4b->bd_group));\n\tfor (i = 0; i < count; i++) {\n\t\tif (!mb_test_bit(first + i, e4b->bd_info->bb_bitmap)) {\n\t\t\text4_fsblk_t blocknr;\n\n\t\t\tblocknr = ext4_group_first_block_no(sb, e4b->bd_group);\n\t\t\tblocknr += EXT4_C2B(EXT4_SB(sb), first + i);\n\t\t\text4_grp_locked_error(sb, e4b->bd_group,\n\t\t\t\t\t      inode ? inode->i_ino : 0,\n\t\t\t\t\t      blocknr,\n\t\t\t\t\t      \"freeing block already freed \"\n\t\t\t\t\t      \"(bit %u)\",\n\t\t\t\t\t      first + i);\n\t\t}\n\t\tmb_clear_bit(first + i, e4b->bd_info->bb_bitmap);\n\t}\n}"
  },
  {
    "function_name": "mb_find_buddy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "440-462",
    "snippet": "static void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "e4b->bd_sb"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "max == NULL"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "e4b->bd_bitmap == e4b->bd_buddy"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic void *mb_find_buddy(struct ext4_buddy *e4b, int order, int *max)\n{\n\tchar *bb;\n\n\tBUG_ON(e4b->bd_bitmap == e4b->bd_buddy);\n\tBUG_ON(max == NULL);\n\n\tif (order > e4b->bd_blkbits + 1) {\n\t\t*max = 0;\n\t\treturn NULL;\n\t}\n\n\t/* at order 0 we see each particular block */\n\tif (order == 0) {\n\t\t*max = 1 << (e4b->bd_blkbits + 3);\n\t\treturn e4b->bd_bitmap;\n\t}\n\n\tbb = e4b->bd_buddy + EXT4_SB(e4b->bd_sb)->s_mb_offsets[order];\n\t*max = EXT4_SB(e4b->bd_sb)->s_mb_maxs[order];\n\n\treturn bb;\n}"
  },
  {
    "function_name": "mb_find_next_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "427-438",
    "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_find_next_bit",
          "args": [
            "addr",
            "tmpmax",
            "start"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_correct_addr_and_bit",
          "args": [
            "&fix",
            "addr"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "mb_correct_addr_and_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "372-384",
          "snippet": "static inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
  },
  {
    "function_name": "mb_find_next_zero_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "414-425",
    "snippet": "static inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_find_next_zero_bit",
          "args": [
            "addr",
            "tmpmax",
            "start"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_correct_addr_and_bit",
          "args": [
            "&fix",
            "addr"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "mb_correct_addr_and_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "372-384",
          "snippet": "static inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_zero_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_zero_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
  },
  {
    "function_name": "mb_test_and_clear_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "408-412",
    "snippet": "static inline int mb_test_and_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_and_clear_bit(bit, addr);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_test_and_clear_bit",
          "args": [
            "bit",
            "addr"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_correct_addr_and_bit",
          "args": [
            "&bit",
            "addr"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "mb_correct_addr_and_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "372-384",
          "snippet": "static inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_and_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_and_clear_bit(bit, addr);\n}"
  },
  {
    "function_name": "mb_clear_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "402-406",
    "snippet": "static inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_clear_bit",
          "args": [
            "bit",
            "addr"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_correct_addr_and_bit",
          "args": [
            "&bit",
            "addr"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "mb_correct_addr_and_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "372-384",
          "snippet": "static inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_clear_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_clear_bit(bit, addr);\n}"
  },
  {
    "function_name": "mb_set_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "396-400",
    "snippet": "static inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_set_bit",
          "args": [
            "bit",
            "addr"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_correct_addr_and_bit",
          "args": [
            "&bit",
            "addr"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "mb_correct_addr_and_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "372-384",
          "snippet": "static inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void mb_set_bit(int bit, void *addr)\n{\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\text4_set_bit(bit, addr);\n}"
  },
  {
    "function_name": "mb_test_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "386-394",
    "snippet": "static inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_test_bit",
          "args": [
            "bit",
            "addr"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_correct_addr_and_bit",
          "args": [
            "&bit",
            "addr"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "mb_correct_addr_and_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "372-384",
          "snippet": "static inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_test_bit(int bit, void *addr)\n{\n\t/*\n\t * ext4_test_bit on architecture like powerpc\n\t * needs unsigned long aligned address\n\t */\n\taddr = mb_correct_addr_and_bit(&bit, addr);\n\treturn ext4_test_bit(bit, addr);\n}"
  },
  {
    "function_name": "mb_correct_addr_and_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
    "lines": "372-384",
    "snippet": "static inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}",
    "includes": [
      "#include <trace/events/ext4.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/log2.h>",
      "#include \"mballoc.h\"",
      "#include \"ext4_jbd2.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline void *mb_correct_addr_and_bit(int *bit, void *addr)\n{\n#if BITS_PER_LONG == 64\n\t*bit += ((unsigned long) addr & 7UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~7UL);\n#elif BITS_PER_LONG == 32\n\t*bit += ((unsigned long) addr & 3UL) << 3;\n\taddr = (void *) ((unsigned long) addr & ~3UL);\n#else\n#error \"how many bits you are?!\"\n#endif\n\treturn addr;\n}"
  }
]