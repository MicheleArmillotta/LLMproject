[
  {
    "function_name": "fat_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "383-459",
    "snippet": "int fat_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\t/* Check for setting the inode time. */\n\tia_valid = attr->ia_valid;\n\tif (ia_valid & TIMES_SET_FLAGS) {\n\t\tif (fat_allow_set_time(sbi, inode))\n\t\t\tattr->ia_valid &= ~TIMES_SET_FLAGS;\n\t}\n\n\terror = inode_change_ok(inode, attr);\n\tattr->ia_valid = ia_valid;\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Expand the file. Since inode_setattr() updates ->i_size\n\t * before calling the ->truncate(), but FAT needs to fill the\n\t * hole before it. XXX: this is no longer true with new truncate\n\t * sequence.\n\t */\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tinode_dio_wait(inode);\n\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = fat_cont_expand(inode, attr->ia_size);\n\t\t\tif (error || attr->ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t\t}\n\t}\n\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     (!uid_eq(attr->ia_uid, sbi->options.fs_uid))) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     (!gid_eq(attr->ia_gid, sbi->options.fs_gid))) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (attr->ia_mode & ~FAT_VALID_MODE)))\n\t\terror = -EPERM;\n\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We don't return -EPERM here. Yes, strange, but this is too\n\t * old behavior.\n\t */\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tif (fat_sanitize_mode(sbi, inode, &attr->ia_mode) < 0)\n\t\t\tattr->ia_valid &= ~ATTR_MODE;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\terror = fat_block_truncate_page(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdown_write(&MSDOS_I(inode)->truncate_lock);\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tfat_truncate_blocks(inode, attr->ia_size);\n\t\tup_write(&MSDOS_I(inode)->truncate_lock);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)",
      "#define TIMES_SET_FLAGS\t(ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "__setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "572-597",
          "snippet": "static void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define __setattr_copy setattr_copy"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define __setattr_copy setattr_copy\n\nstatic void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&MSDOS_I(inode)->truncate_lock"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_truncate_blocks",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "fat_truncate_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "293-310",
          "snippet": "void fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t/*\n\t * This protects against truncating a file bigger than it was then\n\t * trying to write into the hole.\n\t */\n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nvoid fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t/*\n\t * This protects against truncating a file bigger than it was then\n\t * trying to write into the hole.\n\t */\n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&MSDOS_I(inode)->truncate_lock"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_block_truncate_page",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "fat_block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "304-307",
          "snippet": "int fat_block_truncate_page(struct inode *inode, loff_t from)\n{\n\treturn block_truncate_page(inode->i_mapping, from, fat_get_block);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_block_truncate_page(struct inode *inode, loff_t from)\n{\n\treturn block_truncate_page(inode->i_mapping, from, fat_get_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sanitize_mode",
          "args": [
            "sbi",
            "inode",
            "&attr->ia_mode"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sanitize_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "326-362",
          "snippet": "static int fat_sanitize_mode(const struct msdos_sb_info *sbi,\n\t\t\t     struct inode *inode, umode_t *mode_ptr)\n{\n\tumode_t mask, perm;\n\n\t/*\n\t * Note, the basic check is already done by a caller of\n\t * (attr->ia_mode & ~FAT_VALID_MODE)\n\t */\n\n\tif (S_ISREG(inode->i_mode))\n\t\tmask = sbi->options.fs_fmask;\n\telse\n\t\tmask = sbi->options.fs_dmask;\n\n\tperm = *mode_ptr & ~(S_IFMT | mask);\n\n\t/*\n\t * Of the r and x bits, all (subject to umask) must be present. Of the\n\t * w bits, either all (subject to umask) or none must be present.\n\t *\n\t * If fat_mode_can_hold_ro(inode) is false, can't change w bits.\n\t */\n\tif ((perm & (S_IRUGO | S_IXUGO)) != (inode->i_mode & (S_IRUGO|S_IXUGO)))\n\t\treturn -EPERM;\n\tif (fat_mode_can_hold_ro(inode)) {\n\t\tif ((perm & S_IWUGO) && ((perm & S_IWUGO) != (S_IWUGO & ~mask)))\n\t\t\treturn -EPERM;\n\t} else {\n\t\tif ((perm & S_IWUGO) != (S_IWUGO & ~mask))\n\t\t\treturn -EPERM;\n\t}\n\n\t*mode_ptr &= S_IFMT | perm;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\n#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)\n\nstatic int fat_sanitize_mode(const struct msdos_sb_info *sbi,\n\t\t\t     struct inode *inode, umode_t *mode_ptr)\n{\n\tumode_t mask, perm;\n\n\t/*\n\t * Note, the basic check is already done by a caller of\n\t * (attr->ia_mode & ~FAT_VALID_MODE)\n\t */\n\n\tif (S_ISREG(inode->i_mode))\n\t\tmask = sbi->options.fs_fmask;\n\telse\n\t\tmask = sbi->options.fs_dmask;\n\n\tperm = *mode_ptr & ~(S_IFMT | mask);\n\n\t/*\n\t * Of the r and x bits, all (subject to umask) must be present. Of the\n\t * w bits, either all (subject to umask) or none must be present.\n\t *\n\t * If fat_mode_can_hold_ro(inode) is false, can't change w bits.\n\t */\n\tif ((perm & (S_IRUGO | S_IXUGO)) != (inode->i_mode & (S_IRUGO|S_IXUGO)))\n\t\treturn -EPERM;\n\tif (fat_mode_can_hold_ro(inode)) {\n\t\tif ((perm & S_IWUGO) && ((perm & S_IWUGO) != (S_IWUGO & ~mask)))\n\t\t\treturn -EPERM;\n\t} else {\n\t\tif ((perm & S_IWUGO) != (S_IWUGO & ~mask))\n\t\t\treturn -EPERM;\n\t}\n\n\t*mode_ptr &= S_IFMT | perm;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "sbi->options.fs_gid"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "sbi->options.fs_uid"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_cont_expand",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cont_expand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "187-221",
          "snippet": "static int fat_cont_expand(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t start = inode->i_size, count = size - inode->i_size;\n\tint err;\n\n\terr = generic_cont_expand_simple(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tif (IS_SYNC(inode)) {\n\t\tint err2;\n\n\t\t/*\n\t\t * Opencode syncing since we don't have a file open to use\n\t\t * standard fsync path.\n\t\t */\n\t\terr = filemap_fdatawrite_range(mapping, start,\n\t\t\t\t\t       start + count - 1);\n\t\terr2 = sync_mapping_buffers(mapping);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\terr2 = write_inode_now(inode, 1);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\tif (!err) {\n\t\t\terr =  filemap_fdatawait_range(mapping, start,\n\t\t\t\t\t\t       start + count - 1);\n\t\t}\n\t}\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_cont_expand(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t start = inode->i_size, count = size - inode->i_size;\n\tint err;\n\n\terr = generic_cont_expand_simple(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tif (IS_SYNC(inode)) {\n\t\tint err2;\n\n\t\t/*\n\t\t * Opencode syncing since we don't have a file open to use\n\t\t * standard fsync path.\n\t\t */\n\t\terr = filemap_fdatawrite_range(mapping, start,\n\t\t\t\t\t       start + count - 1);\n\t\terr2 = sync_mapping_buffers(mapping);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\terr2 = write_inode_now(inode, 1);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\tif (!err) {\n\t\t\terr =  filemap_fdatawait_range(mapping, start,\n\t\t\t\t\t\t       start + count - 1);\n\t\t}\n\t}\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_allow_set_time",
          "args": [
            "sbi",
            "inode"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "fat_allow_set_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "364-377",
          "snippet": "static int fat_allow_set_time(struct msdos_sb_info *sbi, struct inode *inode)\n{\n\tumode_t allow_utime = sbi->options.allow_utime;\n\n\tif (!uid_eq(current_fsuid(), inode->i_uid)) {\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tallow_utime >>= 3;\n\t\tif (allow_utime & MAY_WRITE)\n\t\t\treturn 1;\n\t}\n\n\t/* use a default check */\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_allow_set_time(struct msdos_sb_info *sbi, struct inode *inode)\n{\n\tumode_t allow_utime = sbi->options.allow_utime;\n\n\tif (!uid_eq(current_fsuid(), inode->i_uid)) {\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tallow_utime >>= 3;\n\t\tif (allow_utime & MAY_WRITE)\n\t\t\treturn 1;\n\t}\n\n\t/* use a default check */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\n#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)\n#define TIMES_SET_FLAGS\t(ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)\n\nint fat_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\t/* Check for setting the inode time. */\n\tia_valid = attr->ia_valid;\n\tif (ia_valid & TIMES_SET_FLAGS) {\n\t\tif (fat_allow_set_time(sbi, inode))\n\t\t\tattr->ia_valid &= ~TIMES_SET_FLAGS;\n\t}\n\n\terror = inode_change_ok(inode, attr);\n\tattr->ia_valid = ia_valid;\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Expand the file. Since inode_setattr() updates ->i_size\n\t * before calling the ->truncate(), but FAT needs to fill the\n\t * hole before it. XXX: this is no longer true with new truncate\n\t * sequence.\n\t */\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tinode_dio_wait(inode);\n\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = fat_cont_expand(inode, attr->ia_size);\n\t\t\tif (error || attr->ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t\t}\n\t}\n\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     (!uid_eq(attr->ia_uid, sbi->options.fs_uid))) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     (!gid_eq(attr->ia_gid, sbi->options.fs_gid))) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (attr->ia_mode & ~FAT_VALID_MODE)))\n\t\terror = -EPERM;\n\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We don't return -EPERM here. Yes, strange, but this is too\n\t * old behavior.\n\t */\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tif (fat_sanitize_mode(sbi, inode, &attr->ia_mode) < 0)\n\t\t\tattr->ia_valid &= ~ATTR_MODE;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\terror = fat_block_truncate_page(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdown_write(&MSDOS_I(inode)->truncate_lock);\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tfat_truncate_blocks(inode, attr->ia_size);\n\t\tup_write(&MSDOS_I(inode)->truncate_lock);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "fat_allow_set_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "364-377",
    "snippet": "static int fat_allow_set_time(struct msdos_sb_info *sbi, struct inode *inode)\n{\n\tumode_t allow_utime = sbi->options.allow_utime;\n\n\tif (!uid_eq(current_fsuid(), inode->i_uid)) {\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tallow_utime >>= 3;\n\t\tif (allow_utime & MAY_WRITE)\n\t\t\treturn 1;\n\t}\n\n\t/* use a default check */\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "inode->i_gid"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "inode->i_uid"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_allow_set_time(struct msdos_sb_info *sbi, struct inode *inode)\n{\n\tumode_t allow_utime = sbi->options.allow_utime;\n\n\tif (!uid_eq(current_fsuid(), inode->i_uid)) {\n\t\tif (in_group_p(inode->i_gid))\n\t\t\tallow_utime >>= 3;\n\t\tif (allow_utime & MAY_WRITE)\n\t\t\treturn 1;\n\t}\n\n\t/* use a default check */\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_sanitize_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "326-362",
    "snippet": "static int fat_sanitize_mode(const struct msdos_sb_info *sbi,\n\t\t\t     struct inode *inode, umode_t *mode_ptr)\n{\n\tumode_t mask, perm;\n\n\t/*\n\t * Note, the basic check is already done by a caller of\n\t * (attr->ia_mode & ~FAT_VALID_MODE)\n\t */\n\n\tif (S_ISREG(inode->i_mode))\n\t\tmask = sbi->options.fs_fmask;\n\telse\n\t\tmask = sbi->options.fs_dmask;\n\n\tperm = *mode_ptr & ~(S_IFMT | mask);\n\n\t/*\n\t * Of the r and x bits, all (subject to umask) must be present. Of the\n\t * w bits, either all (subject to umask) or none must be present.\n\t *\n\t * If fat_mode_can_hold_ro(inode) is false, can't change w bits.\n\t */\n\tif ((perm & (S_IRUGO | S_IXUGO)) != (inode->i_mode & (S_IRUGO|S_IXUGO)))\n\t\treturn -EPERM;\n\tif (fat_mode_can_hold_ro(inode)) {\n\t\tif ((perm & S_IWUGO) && ((perm & S_IWUGO) != (S_IWUGO & ~mask)))\n\t\t\treturn -EPERM;\n\t} else {\n\t\tif ((perm & S_IWUGO) != (S_IWUGO & ~mask))\n\t\t\treturn -EPERM;\n\t}\n\n\t*mode_ptr &= S_IFMT | perm;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_mode_can_hold_ro",
          "args": [
            "inode"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "fat_mode_can_hold_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "159-174",
          "snippet": "static inline int fat_mode_can_hold_ro(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tumode_t mask;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (!sbi->options.rodir)\n\t\t\treturn 0;\n\t\tmask = ~sbi->options.fs_dmask;\n\t} else\n\t\tmask = ~sbi->options.fs_fmask;\n\n\tif (!(mask & S_IWUGO))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int fat_mode_can_hold_ro(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tumode_t mask;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (!sbi->options.rodir)\n\t\t\treturn 0;\n\t\tmask = ~sbi->options.fs_dmask;\n\t} else\n\t\tmask = ~sbi->options.fs_fmask;\n\n\tif (!(mask & S_IWUGO))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\n#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)\n\nstatic int fat_sanitize_mode(const struct msdos_sb_info *sbi,\n\t\t\t     struct inode *inode, umode_t *mode_ptr)\n{\n\tumode_t mask, perm;\n\n\t/*\n\t * Note, the basic check is already done by a caller of\n\t * (attr->ia_mode & ~FAT_VALID_MODE)\n\t */\n\n\tif (S_ISREG(inode->i_mode))\n\t\tmask = sbi->options.fs_fmask;\n\telse\n\t\tmask = sbi->options.fs_dmask;\n\n\tperm = *mode_ptr & ~(S_IFMT | mask);\n\n\t/*\n\t * Of the r and x bits, all (subject to umask) must be present. Of the\n\t * w bits, either all (subject to umask) or none must be present.\n\t *\n\t * If fat_mode_can_hold_ro(inode) is false, can't change w bits.\n\t */\n\tif ((perm & (S_IRUGO | S_IXUGO)) != (inode->i_mode & (S_IRUGO|S_IXUGO)))\n\t\treturn -EPERM;\n\tif (fat_mode_can_hold_ro(inode)) {\n\t\tif ((perm & S_IWUGO) && ((perm & S_IWUGO) != (S_IWUGO & ~mask)))\n\t\t\treturn -EPERM;\n\t} else {\n\t\tif ((perm & S_IWUGO) != (S_IWUGO & ~mask))\n\t\t\treturn -EPERM;\n\t}\n\n\t*mode_ptr &= S_IFMT | perm;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "312-323",
    "snippet": "int fat_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tgeneric_fillattr(inode, stat);\n\tstat->blksize = MSDOS_SB(inode->i_sb)->cluster_size;\n\n\tif (MSDOS_SB(inode->i_sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\t/* Use i_pos for ino. This is used as fileid of nfs. */\n\t\tstat->ino = fat_i_pos_read(MSDOS_SB(inode->i_sb), inode);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_i_pos_read",
          "args": [
            "MSDOS_SB(inode->i_sb)",
            "inode"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "fat_i_pos_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "232-244",
          "snippet": "static inline loff_t fat_i_pos_read(struct msdos_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode)\n{\n\tloff_t i_pos;\n#if BITS_PER_LONG == 32\n\tspin_lock(&sbi->inode_hash_lock);\n#endif\n\ti_pos = MSDOS_I(inode)->i_pos;\n#if BITS_PER_LONG == 32\n\tspin_unlock(&sbi->inode_hash_lock);\n#endif\n\treturn i_pos;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline loff_t fat_i_pos_read(struct msdos_sb_info *sbi,\n\t\t\t\t\tstruct inode *inode)\n{\n\tloff_t i_pos;\n#if BITS_PER_LONG == 32\n\tspin_lock(&sbi->inode_hash_lock);\n#endif\n\ti_pos = MSDOS_I(inode)->i_pos;\n#if BITS_PER_LONG == 32\n\tspin_unlock(&sbi->inode_hash_lock);\n#endif\n\treturn i_pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nint fat_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tgeneric_fillattr(inode, stat);\n\tstat->blksize = MSDOS_SB(inode->i_sb)->cluster_size;\n\n\tif (MSDOS_SB(inode->i_sb)->options.nfs == FAT_NFS_NOSTALE_RO) {\n\t\t/* Use i_pos for ino. This is used as fileid of nfs. */\n\t\tstat->ino = fat_i_pos_read(MSDOS_SB(inode->i_sb), inode);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_truncate_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "293-310",
    "snippet": "void fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t/*\n\t * This protects against truncating a file bigger than it was then\n\t * trying to write into the hole.\n\t */\n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_flush_inodes",
          "args": [
            "inode->i_sb",
            "inode",
            "NULL"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "fat_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1816-1830",
          "snippet": "int fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_free",
          "args": [
            "inode",
            "nr_clusters"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "224-291",
          "snippet": "static int fat_free(struct inode *inode, int skip)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint err, wait, free_start, i_start, i_logstart;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tfat_cache_inval_inode(inode);\n\n\twait = IS_DIRSYNC(inode);\n\ti_start = free_start = MSDOS_I(inode)->i_start;\n\ti_logstart = MSDOS_I(inode)->i_logstart;\n\n\t/* First, we write the new file size. */\n\tif (!skip) {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tMSDOS_I(inode)->i_logstart = 0;\n\t}\n\tMSDOS_I(inode)->i_attrs |= ATTR_ARCH;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tif (wait) {\n\t\terr = fat_sync_inode(inode);\n\t\tif (err) {\n\t\t\tMSDOS_I(inode)->i_start = i_start;\n\t\t\tMSDOS_I(inode)->i_logstart = i_logstart;\n\t\t\treturn err;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\t/* Write a new EOF, and get the remaining cluster chain for freeing. */\n\tif (skip) {\n\t\tstruct fat_entry fatent;\n\t\tint ret, fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, skip - 1, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == FAT_ENT_EOF)\n\t\t\treturn 0;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, dclus);\n\t\tif (ret == FAT_ENT_EOF) {\n\t\t\tfatent_brelse(&fatent);\n\t\t\treturn 0;\n\t\t} else if (ret == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb,\n\t\t\t\t     \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\t\tret = -EIO;\n\t\t} else if (ret > 0) {\n\t\t\terr = fat_ent_write(inode, &fatent, FAT_ENT_EOF, wait);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t\tfatent_brelse(&fatent);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfree_start = ret;\n\t}\n\tinode->i_blocks = skip << (MSDOS_SB(sb)->cluster_bits - 9);\n\n\t/* Freeing the remained cluster chain */\n\treturn fat_free_clusters(inode, free_start);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_free(struct inode *inode, int skip)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint err, wait, free_start, i_start, i_logstart;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tfat_cache_inval_inode(inode);\n\n\twait = IS_DIRSYNC(inode);\n\ti_start = free_start = MSDOS_I(inode)->i_start;\n\ti_logstart = MSDOS_I(inode)->i_logstart;\n\n\t/* First, we write the new file size. */\n\tif (!skip) {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tMSDOS_I(inode)->i_logstart = 0;\n\t}\n\tMSDOS_I(inode)->i_attrs |= ATTR_ARCH;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tif (wait) {\n\t\terr = fat_sync_inode(inode);\n\t\tif (err) {\n\t\t\tMSDOS_I(inode)->i_start = i_start;\n\t\t\tMSDOS_I(inode)->i_logstart = i_logstart;\n\t\t\treturn err;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\t/* Write a new EOF, and get the remaining cluster chain for freeing. */\n\tif (skip) {\n\t\tstruct fat_entry fatent;\n\t\tint ret, fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, skip - 1, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == FAT_ENT_EOF)\n\t\t\treturn 0;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, dclus);\n\t\tif (ret == FAT_ENT_EOF) {\n\t\t\tfatent_brelse(&fatent);\n\t\t\treturn 0;\n\t\t} else if (ret == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb,\n\t\t\t\t     \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\t\tret = -EIO;\n\t\t} else if (ret > 0) {\n\t\t\terr = fat_ent_write(inode, &fatent, FAT_ENT_EOF, wait);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t\tfatent_brelse(&fatent);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfree_start = ret;\n\t}\n\tinode->i_blocks = skip << (MSDOS_SB(sb)->cluster_bits - 9);\n\n\t/* Freeing the remained cluster chain */\n\treturn fat_free_clusters(inode, free_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nvoid fat_truncate_blocks(struct inode *inode, loff_t offset)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tconst unsigned int cluster_size = sbi->cluster_size;\n\tint nr_clusters;\n\n\t/*\n\t * This protects against truncating a file bigger than it was then\n\t * trying to write into the hole.\n\t */\n\tif (MSDOS_I(inode)->mmu_private > offset)\n\t\tMSDOS_I(inode)->mmu_private = offset;\n\n\tnr_clusters = (offset + (cluster_size - 1)) >> sbi->cluster_bits;\n\n\tfat_free(inode, nr_clusters);\n\tfat_flush_inodes(inode->i_sb, inode, NULL);\n}"
  },
  {
    "function_name": "fat_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "224-291",
    "snippet": "static int fat_free(struct inode *inode, int skip)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint err, wait, free_start, i_start, i_logstart;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tfat_cache_inval_inode(inode);\n\n\twait = IS_DIRSYNC(inode);\n\ti_start = free_start = MSDOS_I(inode)->i_start;\n\ti_logstart = MSDOS_I(inode)->i_logstart;\n\n\t/* First, we write the new file size. */\n\tif (!skip) {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tMSDOS_I(inode)->i_logstart = 0;\n\t}\n\tMSDOS_I(inode)->i_attrs |= ATTR_ARCH;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tif (wait) {\n\t\terr = fat_sync_inode(inode);\n\t\tif (err) {\n\t\t\tMSDOS_I(inode)->i_start = i_start;\n\t\t\tMSDOS_I(inode)->i_logstart = i_logstart;\n\t\t\treturn err;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\t/* Write a new EOF, and get the remaining cluster chain for freeing. */\n\tif (skip) {\n\t\tstruct fat_entry fatent;\n\t\tint ret, fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, skip - 1, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == FAT_ENT_EOF)\n\t\t\treturn 0;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, dclus);\n\t\tif (ret == FAT_ENT_EOF) {\n\t\t\tfatent_brelse(&fatent);\n\t\t\treturn 0;\n\t\t} else if (ret == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb,\n\t\t\t\t     \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\t\tret = -EIO;\n\t\t} else if (ret > 0) {\n\t\t\terr = fat_ent_write(inode, &fatent, FAT_ENT_EOF, wait);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t\tfatent_brelse(&fatent);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfree_start = ret;\n\t}\n\tinode->i_blocks = skip << (MSDOS_SB(sb)->cluster_bits - 9);\n\n\t/* Freeing the remained cluster chain */\n\treturn fat_free_clusters(inode, free_start);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_free_clusters",
          "args": [
            "inode",
            "free_start"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "553-633",
          "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_brelse",
          "args": [
            "&fatent"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_write",
          "args": [
            "inode",
            "&fatent",
            "FAT_ENT_EOF",
            "wait"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "409-423",
          "snippet": "int fat_ent_write(struct inode *inode, struct fat_entry *fatent,\n\t\t  int new, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tint err;\n\n\tops->ent_put(fatent, new);\n\tif (wait) {\n\t\terr = fat_sync_bhs(fatent->bhs, fatent->nr_bhs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn fat_mirror_bhs(sb, fatent->bhs, fatent->nr_bhs);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_ent_write(struct inode *inode, struct fat_entry *fatent,\n\t\t  int new, int wait)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tint err;\n\n\tops->ent_put(fatent, new);\n\tif (wait) {\n\t\terr = fat_sync_bhs(fatent->bhs, fatent->nr_bhs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn fat_mirror_bhs(sb, fatent->bhs, fatent->nr_bhs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "sb",
            "\"%s: invalid cluster chain (i_pos %lld)\"",
            "__func__",
            "MSDOS_I(inode)->i_pos"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_fs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "23-43",
          "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ent_read",
          "args": [
            "inode",
            "&fatent",
            "dclus"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ent_reada",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "639-650",
          "snippet": "static void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fat_ent_reada(struct super_block *sb, struct fat_entry *fatent,\n\t\t\t  unsigned long reada_blocks)\n{\n\tstruct fatent_operations *ops = MSDOS_SB(sb)->fatent_ops;\n\tsector_t blocknr;\n\tint i, offset;\n\n\tops->ent_blocknr(sb, fatent->entry, &offset, &blocknr);\n\n\tfor (i = 0; i < reada_blocks; i++)\n\t\tsb_breadahead(sb, blocknr + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatent_init",
          "args": [
            "&fatent"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "324-331",
          "snippet": "static inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_init(struct fat_entry *fatent)\n{\n\tfatent->nr_bhs = 0;\n\tfatent->entry = 0;\n\tfatent->u.ent32_p = NULL;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_cluster",
          "args": [
            "inode",
            "skip - 1",
            "&fclus",
            "&dclus"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "226-285",
          "snippet": "int fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint fat_get_cluster(struct inode *inode, int cluster, int *fclus, int *dclus)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst int limit = sb->s_maxbytes >> MSDOS_SB(sb)->cluster_bits;\n\tstruct fat_entry fatent;\n\tstruct fat_cache_id cid;\n\tint nr;\n\n\tBUG_ON(MSDOS_I(inode)->i_start == 0);\n\n\t*fclus = 0;\n\t*dclus = MSDOS_I(inode)->i_start;\n\tif (cluster == 0)\n\t\treturn 0;\n\n\tif (fat_cache_lookup(inode, cluster, &cid, fclus, dclus) < 0) {\n\t\t/*\n\t\t * dummy, always not contiguous\n\t\t * This is reinitialized by cache_init(), later.\n\t\t */\n\t\tcache_init(&cid, -1, -1);\n\t}\n\n\tfatent_init(&fatent);\n\twhile (*fclus < cluster) {\n\t\t/* prevent the infinite loop of cluster chain */\n\t\tif (*fclus > limit) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t\t\"%s: detected the cluster chain loop\"\n\t\t\t\t\t\" (i_pos %lld)\", __func__,\n\t\t\t\t\tMSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnr = fat_ent_read(inode, &fatent, *dclus);\n\t\tif (nr < 0)\n\t\t\tgoto out;\n\t\telse if (nr == FAT_ENT_FREE) {\n\t\t\tfat_fs_error_ratelimit(sb,\n\t\t\t\t       \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t       __func__,\n\t\t\t\t       MSDOS_I(inode)->i_pos);\n\t\t\tnr = -EIO;\n\t\t\tgoto out;\n\t\t} else if (nr == FAT_ENT_EOF) {\n\t\t\tfat_cache_add(inode, &cid);\n\t\t\tgoto out;\n\t\t}\n\t\t(*fclus)++;\n\t\t*dclus = nr;\n\t\tif (!cache_contiguous(&cid, *dclus))\n\t\t\tcache_init(&cid, *fclus, *dclus);\n\t}\n\tnr = 0;\n\tfat_cache_add(inode, &cid);\nout:\n\tfatent_brelse(&fatent);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_inode",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "824-827",
          "snippet": "int fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_cache_inval_inode",
          "args": [
            "inode"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fat_cache_inval_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/cache.c",
          "lines": "205-210",
          "snippet": "void fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid fat_cache_inval_inode(struct inode *inode)\n{\n\tspin_lock(&MSDOS_I(inode)->cache_lru_lock);\n\t__fat_cache_inval_inode(inode);\n\tspin_unlock(&MSDOS_I(inode)->cache_lru_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_free(struct inode *inode, int skip)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint err, wait, free_start, i_start, i_logstart;\n\n\tif (MSDOS_I(inode)->i_start == 0)\n\t\treturn 0;\n\n\tfat_cache_inval_inode(inode);\n\n\twait = IS_DIRSYNC(inode);\n\ti_start = free_start = MSDOS_I(inode)->i_start;\n\ti_logstart = MSDOS_I(inode)->i_logstart;\n\n\t/* First, we write the new file size. */\n\tif (!skip) {\n\t\tMSDOS_I(inode)->i_start = 0;\n\t\tMSDOS_I(inode)->i_logstart = 0;\n\t}\n\tMSDOS_I(inode)->i_attrs |= ATTR_ARCH;\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tif (wait) {\n\t\terr = fat_sync_inode(inode);\n\t\tif (err) {\n\t\t\tMSDOS_I(inode)->i_start = i_start;\n\t\t\tMSDOS_I(inode)->i_logstart = i_logstart;\n\t\t\treturn err;\n\t\t}\n\t} else\n\t\tmark_inode_dirty(inode);\n\n\t/* Write a new EOF, and get the remaining cluster chain for freeing. */\n\tif (skip) {\n\t\tstruct fat_entry fatent;\n\t\tint ret, fclus, dclus;\n\n\t\tret = fat_get_cluster(inode, skip - 1, &fclus, &dclus);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == FAT_ENT_EOF)\n\t\t\treturn 0;\n\n\t\tfatent_init(&fatent);\n\t\tret = fat_ent_read(inode, &fatent, dclus);\n\t\tif (ret == FAT_ENT_EOF) {\n\t\t\tfatent_brelse(&fatent);\n\t\t\treturn 0;\n\t\t} else if (ret == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb,\n\t\t\t\t     \"%s: invalid cluster chain (i_pos %lld)\",\n\t\t\t\t     __func__, MSDOS_I(inode)->i_pos);\n\t\t\tret = -EIO;\n\t\t} else if (ret > 0) {\n\t\t\terr = fat_ent_write(inode, &fatent, FAT_ENT_EOF, wait);\n\t\t\tif (err)\n\t\t\t\tret = err;\n\t\t}\n\t\tfatent_brelse(&fatent);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfree_start = ret;\n\t}\n\tinode->i_blocks = skip << (MSDOS_SB(sb)->cluster_bits - 9);\n\n\t/* Freeing the remained cluster chain */\n\treturn fat_free_clusters(inode, free_start);\n}"
  },
  {
    "function_name": "fat_cont_expand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "187-221",
    "snippet": "static int fat_cont_expand(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t start = inode->i_size, count = size - inode->i_size;\n\tint err;\n\n\terr = generic_cont_expand_simple(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tif (IS_SYNC(inode)) {\n\t\tint err2;\n\n\t\t/*\n\t\t * Opencode syncing since we don't have a file open to use\n\t\t * standard fsync path.\n\t\t */\n\t\terr = filemap_fdatawrite_range(mapping, start,\n\t\t\t\t\t       start + count - 1);\n\t\terr2 = sync_mapping_buffers(mapping);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\terr2 = write_inode_now(inode, 1);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\tif (!err) {\n\t\t\terr =  filemap_fdatawait_range(mapping, start,\n\t\t\t\t\t\t       start + count - 1);\n\t\t}\n\t}\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "mapping",
            "start",
            "start + count - 1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "1"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_mapping_buffers",
          "args": [
            "mapping"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mapping_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "570-579",
          "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "mapping",
            "start",
            "start + count - 1"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_cont_expand_simple",
          "args": [
            "inode",
            "size"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "generic_cont_expand_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2249-2271",
          "snippet": "int generic_cont_expand_simple(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\n\terr = inode_newsize_ok(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE|AOP_FLAG_CONT_EXPAND,\n\t\t\t\t&page, &fsdata);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);\n\tBUG_ON(err > 0);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint generic_cont_expand_simple(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tvoid *fsdata;\n\tint err;\n\n\terr = inode_newsize_ok(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE|AOP_FLAG_CONT_EXPAND,\n\t\t\t\t&page, &fsdata);\n\tif (err)\n\t\tgoto out;\n\n\terr = pagecache_write_end(NULL, mapping, size, 0, 0, page, fsdata);\n\tBUG_ON(err > 0);\n\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_cont_expand(struct inode *inode, loff_t size)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t start = inode->i_size, count = size - inode->i_size;\n\tint err;\n\n\terr = generic_cont_expand_simple(inode, size);\n\tif (err)\n\t\tgoto out;\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\tif (IS_SYNC(inode)) {\n\t\tint err2;\n\n\t\t/*\n\t\t * Opencode syncing since we don't have a file open to use\n\t\t * standard fsync path.\n\t\t */\n\t\terr = filemap_fdatawrite_range(mapping, start,\n\t\t\t\t\t       start + count - 1);\n\t\terr2 = sync_mapping_buffers(mapping);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\terr2 = write_inode_now(inode, 1);\n\t\tif (!err)\n\t\t\terr = err2;\n\t\tif (!err) {\n\t\t\terr =  filemap_fdatawait_range(mapping, start,\n\t\t\t\t\t\t       start + count - 1);\n\t\t}\n\t}\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "fat_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "159-168",
    "snippet": "int fat_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint res, err;\n\n\tres = generic_file_fsync(filp, start, end, datasync);\n\terr = sync_mapping_buffers(MSDOS_SB(inode->i_sb)->fat_inode->i_mapping);\n\n\treturn res ? res : err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_mapping_buffers",
          "args": [
            "MSDOS_SB(inode->i_sb)->fat_inode->i_mapping"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mapping_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "570-579",
          "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_fsync",
          "args": [
            "filp",
            "start",
            "end",
            "datasync"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "976-986",
          "snippet": "int generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\n\terr = __generic_file_fsync(file, start, end, datasync);\n\tif (err)\n\t\treturn err;\n\treturn blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nint generic_file_fsync(struct file *file, loff_t start, loff_t end,\n\t\t       int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint err;\n\n\terr = __generic_file_fsync(file, start, end, datasync);\n\tif (err)\n\t\treturn err;\n\treturn blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nint fat_file_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = filp->f_mapping->host;\n\tint res, err;\n\n\tres = generic_file_fsync(filp, start, end, datasync);\n\terr = sync_mapping_buffers(MSDOS_SB(inode->i_sb)->fat_inode->i_mapping);\n\n\treturn res ? res : err;\n}"
  },
  {
    "function_name": "fat_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "149-157",
    "snippet": "static int fat_file_release(struct inode *inode, struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_WRITE) &&\n\t     MSDOS_SB(inode->i_sb)->options.flush) {\n\t\tfat_flush_inodes(inode->i_sb, inode, NULL);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/10"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_flush_inodes",
          "args": [
            "inode->i_sb",
            "inode",
            "NULL"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "fat_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1816-1830",
          "snippet": "int fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_file_release(struct inode *inode, struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_WRITE) &&\n\t     MSDOS_SB(inode->i_sb)->options.flush) {\n\t\tfat_flush_inodes(inode->i_sb, inode, NULL);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/10);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "fat_generic_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "141-146",
    "snippet": "static long fat_generic_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n\n{\n\treturn fat_generic_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_generic_ioctl",
          "args": [
            "filp",
            "cmd",
            "(unsigned long)compat_ptr(arg)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "fat_generic_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "123-138",
          "snippet": "long fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tdefault:\n\t\treturn -ENOTTY;\t/* Inappropriate ioctl for device */\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nlong fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tdefault:\n\t\treturn -ENOTTY;\t/* Inappropriate ioctl for device */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic long fat_generic_compat_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t      unsigned long arg)\n\n{\n\treturn fat_generic_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));\n}"
  },
  {
    "function_name": "fat_generic_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "123-138",
    "snippet": "long fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tdefault:\n\t\treturn -ENOTTY;\t/* Inappropriate ioctl for device */\n\t}\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_ioctl_get_volume_id",
          "args": [
            "inode",
            "user_attr"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ioctl_get_volume_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "117-121",
          "snippet": "static int fat_ioctl_get_volume_id(struct inode *inode, u32 __user *user_attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\treturn put_user(sbi->vol_id, user_attr);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_ioctl_get_volume_id(struct inode *inode, u32 __user *user_attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\treturn put_user(sbi->vol_id, user_attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ioctl_set_attributes",
          "args": [
            "filp",
            "user_attr"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ioctl_set_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "33-115",
          "snippet": "static int fat_ioctl_set_attributes(struct file *file, u32 __user *user_attr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint is_dir = S_ISDIR(inode->i_mode);\n\tu32 attr, oldattr;\n\tstruct iattr ia;\n\tint err;\n\n\terr = get_user(attr, user_attr);\n\tif (err)\n\t\tgoto out;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * ATTR_VOLUME and ATTR_DIR cannot be changed; this also\n\t * prevents the user from turning us into a VFAT\n\t * longname entry.  Also, we obviously can't set\n\t * any of the NTFS attributes in the high 24 bits.\n\t */\n\tattr &= 0xff & ~(ATTR_VOLUME | ATTR_DIR);\n\t/* Merge in ATTR_VOLUME and ATTR_DIR */\n\tattr |= (MSDOS_I(inode)->i_attrs & ATTR_VOLUME) |\n\t\t(is_dir ? ATTR_DIR : 0);\n\toldattr = fat_make_attrs(inode);\n\n\t/* Equivalent to a chmod() */\n\tia.ia_valid = ATTR_MODE | ATTR_CTIME;\n\tia.ia_ctime = current_fs_time(inode->i_sb);\n\tif (is_dir)\n\t\tia.ia_mode = fat_make_mode(sbi, attr, S_IRWXUGO);\n\telse {\n\t\tia.ia_mode = fat_make_mode(sbi, attr,\n\t\t\tS_IRUGO | S_IWUGO | (inode->i_mode & S_IXUGO));\n\t}\n\n\t/* The root directory has no attributes */\n\tif (inode->i_ino == MSDOS_ROOT_INO && attr != ATTR_DIR) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (sbi->options.sys_immutable &&\n\t    ((attr | oldattr) & ATTR_SYS) &&\n\t    !capable(CAP_LINUX_IMMUTABLE)) {\n\t\terr = -EPERM;\n\t\tgoto out_unlock_inode;\n\t}\n\n\t/*\n\t * The security check is questionable...  We single\n\t * out the RO attribute for checking by the security\n\t * module, just because it maps to a file mode.\n\t */\n\terr = security_inode_setattr(file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\t/* This MUST be done before doing anything irreversible... */\n\terr = fat_setattr(file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\tfsnotify_change(file->f_path.dentry, ia.ia_valid);\n\tif (sbi->options.sys_immutable) {\n\t\tif (attr & ATTR_SYS)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tfat_save_attrs(inode, attr);\n\tmark_inode_dirty(inode);\nout_unlock_inode:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_ioctl_set_attributes(struct file *file, u32 __user *user_attr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint is_dir = S_ISDIR(inode->i_mode);\n\tu32 attr, oldattr;\n\tstruct iattr ia;\n\tint err;\n\n\terr = get_user(attr, user_attr);\n\tif (err)\n\t\tgoto out;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * ATTR_VOLUME and ATTR_DIR cannot be changed; this also\n\t * prevents the user from turning us into a VFAT\n\t * longname entry.  Also, we obviously can't set\n\t * any of the NTFS attributes in the high 24 bits.\n\t */\n\tattr &= 0xff & ~(ATTR_VOLUME | ATTR_DIR);\n\t/* Merge in ATTR_VOLUME and ATTR_DIR */\n\tattr |= (MSDOS_I(inode)->i_attrs & ATTR_VOLUME) |\n\t\t(is_dir ? ATTR_DIR : 0);\n\toldattr = fat_make_attrs(inode);\n\n\t/* Equivalent to a chmod() */\n\tia.ia_valid = ATTR_MODE | ATTR_CTIME;\n\tia.ia_ctime = current_fs_time(inode->i_sb);\n\tif (is_dir)\n\t\tia.ia_mode = fat_make_mode(sbi, attr, S_IRWXUGO);\n\telse {\n\t\tia.ia_mode = fat_make_mode(sbi, attr,\n\t\t\tS_IRUGO | S_IWUGO | (inode->i_mode & S_IXUGO));\n\t}\n\n\t/* The root directory has no attributes */\n\tif (inode->i_ino == MSDOS_ROOT_INO && attr != ATTR_DIR) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (sbi->options.sys_immutable &&\n\t    ((attr | oldattr) & ATTR_SYS) &&\n\t    !capable(CAP_LINUX_IMMUTABLE)) {\n\t\terr = -EPERM;\n\t\tgoto out_unlock_inode;\n\t}\n\n\t/*\n\t * The security check is questionable...  We single\n\t * out the RO attribute for checking by the security\n\t * module, just because it maps to a file mode.\n\t */\n\terr = security_inode_setattr(file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\t/* This MUST be done before doing anything irreversible... */\n\terr = fat_setattr(file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\tfsnotify_change(file->f_path.dentry, ia.ia_valid);\n\tif (sbi->options.sys_immutable) {\n\t\tif (attr & ATTR_SYS)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tfat_save_attrs(inode, attr);\n\tmark_inode_dirty(inode);\nout_unlock_inode:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_ioctl_get_attributes",
          "args": [
            "inode",
            "user_attr"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fat_ioctl_get_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "22-31",
          "snippet": "static int fat_ioctl_get_attributes(struct inode *inode, u32 __user *user_attr)\n{\n\tu32 attr;\n\n\tmutex_lock(&inode->i_mutex);\n\tattr = fat_make_attrs(inode);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn put_user(attr, user_attr);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_ioctl_get_attributes(struct inode *inode, u32 __user *user_attr)\n{\n\tu32 attr;\n\n\tmutex_lock(&inode->i_mutex);\n\tattr = fat_make_attrs(inode);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn put_user(attr, user_attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nlong fat_generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tu32 __user *user_attr = (u32 __user *)arg;\n\n\tswitch (cmd) {\n\tcase FAT_IOCTL_GET_ATTRIBUTES:\n\t\treturn fat_ioctl_get_attributes(inode, user_attr);\n\tcase FAT_IOCTL_SET_ATTRIBUTES:\n\t\treturn fat_ioctl_set_attributes(filp, user_attr);\n\tcase FAT_IOCTL_GET_VOLUME_ID:\n\t\treturn fat_ioctl_get_volume_id(inode, user_attr);\n\tdefault:\n\t\treturn -ENOTTY;\t/* Inappropriate ioctl for device */\n\t}\n}"
  },
  {
    "function_name": "fat_ioctl_get_volume_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "117-121",
    "snippet": "static int fat_ioctl_get_volume_id(struct inode *inode, u32 __user *user_attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\treturn put_user(sbi->vol_id, user_attr);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "sbi->vol_id",
            "user_attr"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_ioctl_get_volume_id(struct inode *inode, u32 __user *user_attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\treturn put_user(sbi->vol_id, user_attr);\n}"
  },
  {
    "function_name": "fat_ioctl_set_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "33-115",
    "snippet": "static int fat_ioctl_set_attributes(struct file *file, u32 __user *user_attr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint is_dir = S_ISDIR(inode->i_mode);\n\tu32 attr, oldattr;\n\tstruct iattr ia;\n\tint err;\n\n\terr = get_user(attr, user_attr);\n\tif (err)\n\t\tgoto out;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * ATTR_VOLUME and ATTR_DIR cannot be changed; this also\n\t * prevents the user from turning us into a VFAT\n\t * longname entry.  Also, we obviously can't set\n\t * any of the NTFS attributes in the high 24 bits.\n\t */\n\tattr &= 0xff & ~(ATTR_VOLUME | ATTR_DIR);\n\t/* Merge in ATTR_VOLUME and ATTR_DIR */\n\tattr |= (MSDOS_I(inode)->i_attrs & ATTR_VOLUME) |\n\t\t(is_dir ? ATTR_DIR : 0);\n\toldattr = fat_make_attrs(inode);\n\n\t/* Equivalent to a chmod() */\n\tia.ia_valid = ATTR_MODE | ATTR_CTIME;\n\tia.ia_ctime = current_fs_time(inode->i_sb);\n\tif (is_dir)\n\t\tia.ia_mode = fat_make_mode(sbi, attr, S_IRWXUGO);\n\telse {\n\t\tia.ia_mode = fat_make_mode(sbi, attr,\n\t\t\tS_IRUGO | S_IWUGO | (inode->i_mode & S_IXUGO));\n\t}\n\n\t/* The root directory has no attributes */\n\tif (inode->i_ino == MSDOS_ROOT_INO && attr != ATTR_DIR) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (sbi->options.sys_immutable &&\n\t    ((attr | oldattr) & ATTR_SYS) &&\n\t    !capable(CAP_LINUX_IMMUTABLE)) {\n\t\terr = -EPERM;\n\t\tgoto out_unlock_inode;\n\t}\n\n\t/*\n\t * The security check is questionable...  We single\n\t * out the RO attribute for checking by the security\n\t * module, just because it maps to a file mode.\n\t */\n\terr = security_inode_setattr(file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\t/* This MUST be done before doing anything irreversible... */\n\terr = fat_setattr(file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\tfsnotify_change(file->f_path.dentry, ia.ia_valid);\n\tif (sbi->options.sys_immutable) {\n\t\tif (attr & ATTR_SYS)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tfat_save_attrs(inode, attr);\n\tmark_inode_dirty(inode);\nout_unlock_inode:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_save_attrs",
          "args": [
            "inode",
            "attr"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fat_save_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "200-206",
          "snippet": "static inline void fat_save_attrs(struct inode *inode, u8 attrs)\n{\n\tif (fat_mode_can_hold_ro(inode))\n\t\tMSDOS_I(inode)->i_attrs = attrs & ATTR_UNUSED;\n\telse\n\t\tMSDOS_I(inode)->i_attrs = attrs & (ATTR_UNUSED | ATTR_RO);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_save_attrs(struct inode *inode, u8 attrs)\n{\n\tif (fat_mode_can_hold_ro(inode))\n\t\tMSDOS_I(inode)->i_attrs = attrs & ATTR_UNUSED;\n\telse\n\t\tMSDOS_I(inode)->i_attrs = attrs & (ATTR_UNUSED | ATTR_RO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_change",
          "args": [
            "file->f_path.dentry",
            "ia.ia_valid"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_setattr",
          "args": [
            "file->f_path.dentry",
            "&ia"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "fat_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
          "lines": "383-459",
          "snippet": "int fat_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\t/* Check for setting the inode time. */\n\tia_valid = attr->ia_valid;\n\tif (ia_valid & TIMES_SET_FLAGS) {\n\t\tif (fat_allow_set_time(sbi, inode))\n\t\t\tattr->ia_valid &= ~TIMES_SET_FLAGS;\n\t}\n\n\terror = inode_change_ok(inode, attr);\n\tattr->ia_valid = ia_valid;\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Expand the file. Since inode_setattr() updates ->i_size\n\t * before calling the ->truncate(), but FAT needs to fill the\n\t * hole before it. XXX: this is no longer true with new truncate\n\t * sequence.\n\t */\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tinode_dio_wait(inode);\n\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = fat_cont_expand(inode, attr->ia_size);\n\t\t\tif (error || attr->ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t\t}\n\t}\n\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     (!uid_eq(attr->ia_uid, sbi->options.fs_uid))) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     (!gid_eq(attr->ia_gid, sbi->options.fs_gid))) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (attr->ia_mode & ~FAT_VALID_MODE)))\n\t\terror = -EPERM;\n\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We don't return -EPERM here. Yes, strange, but this is too\n\t * old behavior.\n\t */\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tif (fat_sanitize_mode(sbi, inode, &attr->ia_mode) < 0)\n\t\t\tattr->ia_valid &= ~ATTR_MODE;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\terror = fat_block_truncate_page(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdown_write(&MSDOS_I(inode)->truncate_lock);\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tfat_truncate_blocks(inode, attr->ia_size);\n\t\tup_write(&MSDOS_I(inode)->truncate_lock);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)",
            "#define TIMES_SET_FLAGS\t(ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\n#define FAT_VALID_MODE\t(S_IFREG | S_IFDIR | S_IRWXUGO)\n#define TIMES_SET_FLAGS\t(ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)\n\nint fat_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dentry->d_sb);\n\tstruct inode *inode = dentry->d_inode;\n\tunsigned int ia_valid;\n\tint error;\n\n\t/* Check for setting the inode time. */\n\tia_valid = attr->ia_valid;\n\tif (ia_valid & TIMES_SET_FLAGS) {\n\t\tif (fat_allow_set_time(sbi, inode))\n\t\t\tattr->ia_valid &= ~TIMES_SET_FLAGS;\n\t}\n\n\terror = inode_change_ok(inode, attr);\n\tattr->ia_valid = ia_valid;\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Expand the file. Since inode_setattr() updates ->i_size\n\t * before calling the ->truncate(), but FAT needs to fill the\n\t * hole before it. XXX: this is no longer true with new truncate\n\t * sequence.\n\t */\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tinode_dio_wait(inode);\n\n\t\tif (attr->ia_size > inode->i_size) {\n\t\t\terror = fat_cont_expand(inode, attr->ia_size);\n\t\t\tif (error || attr->ia_valid == ATTR_SIZE)\n\t\t\t\tgoto out;\n\t\t\tattr->ia_valid &= ~ATTR_SIZE;\n\t\t}\n\t}\n\n\tif (((attr->ia_valid & ATTR_UID) &&\n\t     (!uid_eq(attr->ia_uid, sbi->options.fs_uid))) ||\n\t    ((attr->ia_valid & ATTR_GID) &&\n\t     (!gid_eq(attr->ia_gid, sbi->options.fs_gid))) ||\n\t    ((attr->ia_valid & ATTR_MODE) &&\n\t     (attr->ia_mode & ~FAT_VALID_MODE)))\n\t\terror = -EPERM;\n\n\tif (error) {\n\t\tif (sbi->options.quiet)\n\t\t\terror = 0;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We don't return -EPERM here. Yes, strange, but this is too\n\t * old behavior.\n\t */\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tif (fat_sanitize_mode(sbi, inode, &attr->ia_mode) < 0)\n\t\t\tattr->ia_valid &= ~ATTR_MODE;\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\terror = fat_block_truncate_page(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdown_write(&MSDOS_I(inode)->truncate_lock);\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\tfat_truncate_blocks(inode, attr->ia_size);\n\t\tup_write(&MSDOS_I(inode)->truncate_lock);\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_setattr",
          "args": [
            "file->f_path.dentry",
            "&ia"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_LINUX_IMMUTABLE"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_make_mode",
          "args": [
            "sbi",
            "attr",
            "S_IRUGO | S_IWUGO | (inode->i_mode & S_IXUGO)"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "177-187",
          "snippet": "static inline umode_t fat_make_mode(struct msdos_sb_info *sbi,\n\t\t\t\t   u8 attrs, umode_t mode)\n{\n\tif (attrs & ATTR_RO && !((attrs & ATTR_DIR) && !sbi->options.rodir))\n\t\tmode &= ~S_IWUGO;\n\n\tif (attrs & ATTR_DIR)\n\t\treturn (mode & ~sbi->options.fs_dmask) | S_IFDIR;\n\telse\n\t\treturn (mode & ~sbi->options.fs_fmask) | S_IFREG;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline umode_t fat_make_mode(struct msdos_sb_info *sbi,\n\t\t\t\t   u8 attrs, umode_t mode)\n{\n\tif (attrs & ATTR_RO && !((attrs & ATTR_DIR) && !sbi->options.rodir))\n\t\tmode &= ~S_IWUGO;\n\n\tif (attrs & ATTR_DIR)\n\t\treturn (mode & ~sbi->options.fs_dmask) | S_IFDIR;\n\telse\n\t\treturn (mode & ~sbi->options.fs_fmask) | S_IFREG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_make_attrs",
          "args": [
            "inode"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "190-198",
          "snippet": "static inline u8 fat_make_attrs(struct inode *inode)\n{\n\tu8 attrs = MSDOS_I(inode)->i_attrs;\n\tif (S_ISDIR(inode->i_mode))\n\t\tattrs |= ATTR_DIR;\n\tif (fat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))\n\t\tattrs |= ATTR_RO;\n\treturn attrs;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline u8 fat_make_attrs(struct inode *inode)\n{\n\tu8 attrs = MSDOS_I(inode)->i_attrs;\n\tif (S_ISDIR(inode->i_mode))\n\t\tattrs |= ATTR_DIR;\n\tif (fat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))\n\t\tattrs |= ATTR_RO;\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "inode"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "attr",
            "user_attr"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_ioctl_set_attributes(struct file *file, u32 __user *user_attr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tint is_dir = S_ISDIR(inode->i_mode);\n\tu32 attr, oldattr;\n\tstruct iattr ia;\n\tint err;\n\n\terr = get_user(attr, user_attr);\n\tif (err)\n\t\tgoto out;\n\n\terr = mnt_want_write_file(file);\n\tif (err)\n\t\tgoto out;\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * ATTR_VOLUME and ATTR_DIR cannot be changed; this also\n\t * prevents the user from turning us into a VFAT\n\t * longname entry.  Also, we obviously can't set\n\t * any of the NTFS attributes in the high 24 bits.\n\t */\n\tattr &= 0xff & ~(ATTR_VOLUME | ATTR_DIR);\n\t/* Merge in ATTR_VOLUME and ATTR_DIR */\n\tattr |= (MSDOS_I(inode)->i_attrs & ATTR_VOLUME) |\n\t\t(is_dir ? ATTR_DIR : 0);\n\toldattr = fat_make_attrs(inode);\n\n\t/* Equivalent to a chmod() */\n\tia.ia_valid = ATTR_MODE | ATTR_CTIME;\n\tia.ia_ctime = current_fs_time(inode->i_sb);\n\tif (is_dir)\n\t\tia.ia_mode = fat_make_mode(sbi, attr, S_IRWXUGO);\n\telse {\n\t\tia.ia_mode = fat_make_mode(sbi, attr,\n\t\t\tS_IRUGO | S_IWUGO | (inode->i_mode & S_IXUGO));\n\t}\n\n\t/* The root directory has no attributes */\n\tif (inode->i_ino == MSDOS_ROOT_INO && attr != ATTR_DIR) {\n\t\terr = -EINVAL;\n\t\tgoto out_unlock_inode;\n\t}\n\n\tif (sbi->options.sys_immutable &&\n\t    ((attr | oldattr) & ATTR_SYS) &&\n\t    !capable(CAP_LINUX_IMMUTABLE)) {\n\t\terr = -EPERM;\n\t\tgoto out_unlock_inode;\n\t}\n\n\t/*\n\t * The security check is questionable...  We single\n\t * out the RO attribute for checking by the security\n\t * module, just because it maps to a file mode.\n\t */\n\terr = security_inode_setattr(file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\t/* This MUST be done before doing anything irreversible... */\n\terr = fat_setattr(file->f_path.dentry, &ia);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\n\tfsnotify_change(file->f_path.dentry, ia.ia_valid);\n\tif (sbi->options.sys_immutable) {\n\t\tif (attr & ATTR_SYS)\n\t\t\tinode->i_flags |= S_IMMUTABLE;\n\t\telse\n\t\t\tinode->i_flags &= ~S_IMMUTABLE;\n\t}\n\n\tfat_save_attrs(inode, attr);\n\tmark_inode_dirty(inode);\nout_unlock_inode:\n\tmutex_unlock(&inode->i_mutex);\n\tmnt_drop_write_file(file);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "fat_ioctl_get_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/file.c",
    "lines": "22-31",
    "snippet": "static int fat_ioctl_get_attributes(struct inode *inode, u32 __user *user_attr)\n{\n\tu32 attr;\n\n\tmutex_lock(&inode->i_mutex);\n\tattr = fat_make_attrs(inode);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn put_user(attr, user_attr);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/security.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/mount.h>",
      "#include <linux/compat.h>",
      "#include <linux/module.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "attr",
            "user_attr"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_make_attrs",
          "args": [
            "inode"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "fat_make_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "190-198",
          "snippet": "static inline u8 fat_make_attrs(struct inode *inode)\n{\n\tu8 attrs = MSDOS_I(inode)->i_attrs;\n\tif (S_ISDIR(inode->i_mode))\n\t\tattrs |= ATTR_DIR;\n\tif (fat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))\n\t\tattrs |= ATTR_RO;\n\treturn attrs;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline u8 fat_make_attrs(struct inode *inode)\n{\n\tu8 attrs = MSDOS_I(inode)->i_attrs;\n\tif (S_ISDIR(inode->i_mode))\n\t\tattrs |= ATTR_DIR;\n\tif (fat_mode_can_hold_ro(inode) && !(inode->i_mode & S_IWUGO))\n\t\tattrs |= ATTR_RO;\n\treturn attrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n\nstatic int fat_ioctl_get_attributes(struct inode *inode, u32 __user *user_attr)\n{\n\tu32 attr;\n\n\tmutex_lock(&inode->i_mutex);\n\tattr = fat_make_attrs(inode);\n\tmutex_unlock(&inode->i_mutex);\n\n\treturn put_user(attr, user_attr);\n}"
  }
]