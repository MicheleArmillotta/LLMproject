[
  {
    "function_name": "hfs_btree_inc_height",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
    "lines": "455-527",
    "snippet": "static int hfs_btree_inc_height(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *new_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint key_size, rec;\n\t__be32 cnid;\n\n\tnode = NULL;\n\tif (tree->root) {\n\t\tnode = hfs_bnode_find(tree, tree->root);\n\t\tif (IS_ERR(node))\n\t\t\treturn PTR_ERR(node);\n\t}\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node)) {\n\t\thfs_bnode_put(node);\n\t\treturn PTR_ERR(new_node);\n\t}\n\n\ttree->root = new_node->this;\n\tif (!tree->depth) {\n\t\ttree->leaf_head = tree->leaf_tail = new_node->this;\n\t\tnew_node->type = HFS_NODE_LEAF;\n\t\tnew_node->num_recs = 0;\n\t} else {\n\t\tnew_node->type = HFS_NODE_INDEX;\n\t\tnew_node->num_recs = 1;\n\t}\n\tnew_node->parent = 0;\n\tnew_node->next = 0;\n\tnew_node->prev = 0;\n\tnew_node->height = ++tree->depth;\n\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\trec = tree->node_size - 2;\n\thfs_bnode_write_u16(new_node, rec, 14);\n\n\tif (node) {\n\t\t/* insert old root idx into new root */\n\t\tnode->parent = tree->root;\n\t\tif (node->type == HFS_NODE_LEAF ||\n\t\t\t\ttree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\ttree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\tkey_size = hfs_bnode_read_u16(node, 14) + 2;\n\t\telse\n\t\t\tkey_size = tree->max_key_len + 2;\n\t\thfs_bnode_copy(new_node, 14, node, 14, key_size);\n\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t\t\t\t(tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\t\tkey_size = tree->max_key_len + 2;\n\t\t\thfs_bnode_write_u16(new_node, 14, tree->max_key_len);\n\t\t}\n\t\tcnid = cpu_to_be32(node->this);\n\t\thfs_bnode_write(new_node, &cnid, 14 + key_size, 4);\n\n\t\trec -= 2;\n\t\thfs_bnode_write_u16(new_node, rec, 14 + key_size + 4);\n\n\t\thfs_bnode_put(node);\n\t}\n\thfs_bnode_put(new_node);\n\tmark_inode_dirty(tree->inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int hfs_btree_inc_height(struct hfs_btree *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "tree->inode"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "new_node"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write_u16",
          "args": [
            "new_node",
            "rec",
            "14 + key_size + 4"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "97-102",
          "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "new_node",
            "&cnid",
            "14 + key_size",
            "4"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "node->this"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_copy",
          "args": [
            "new_node",
            "14",
            "node",
            "14",
            "key_size"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "126-184",
          "snippet": "void hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct hfs_btree *tree;\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\ttree = src_node->tree;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_CACHE_SHIFT);\n\tsrc &= ~PAGE_CACHE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);\n\tdst &= ~PAGE_CACHE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\tmemcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);\n\t\tkunmap(*src_page);\n\t\tset_page_dirty(*dst_page);\n\t\tkunmap(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\tmemcpy(kmap(*++dst_page), kmap(*++src_page), l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\tif (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {\n\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct hfs_btree *tree;\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\ttree = src_node->tree;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_CACHE_SHIFT);\n\tsrc &= ~PAGE_CACHE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);\n\tdst &= ~PAGE_CACHE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\tmemcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);\n\t\tkunmap(*src_page);\n\t\tset_page_dirty(*dst_page);\n\t\tkunmap(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\tmemcpy(kmap(*++dst_page), kmap(*++src_page), l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\tif (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {\n\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "node",
            "14"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "new_node->num_recs"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_node->prev"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_node->next"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_node"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_node"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bmap_alloc",
          "args": [
            "tree"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bmap_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "344-433",
          "snippet": "struct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *next_node;\n\tstruct page **pagep;\n\tu32 nidx, idx;\n\tunsigned off;\n\tu16 off16;\n\tu16 len;\n\tu8 *data, byte, m;\n\tint i;\n\n\twhile (!tree->free_nodes) {\n\t\tstruct inode *inode = tree->inode;\n\t\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\t\tu32 count;\n\t\tint res;\n\n\t\tres = hfsplus_file_extend(inode, hfs_bnode_need_zeroout(tree));\n\t\tif (res)\n\t\t\treturn ERR_PTR(res);\n\t\thip->phys_size = inode->i_size =\n\t\t\t(loff_t)hip->alloc_blocks <<\n\t\t\t\tHFSPLUS_SB(tree->sb)->alloc_blksz_shift;\n\t\thip->fs_blocks =\n\t\t\thip->alloc_blocks << HFSPLUS_SB(tree->sb)->fs_shift;\n\t\tinode_set_bytes(inode, inode->i_size);\n\t\tcount = inode->i_size >> tree->node_size_shift;\n\t\ttree->free_nodes = count - tree->node_count;\n\t\ttree->node_count = count;\n\t}\n\n\tnidx = 0;\n\tnode = hfs_bnode_find(tree, nidx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\tlen = hfs_brec_lenoff(node, 2, &off16);\n\toff = off16;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\tdata = kmap(*pagep);\n\toff &= ~PAGE_CACHE_MASK;\n\tidx = 0;\n\n\tfor (;;) {\n\t\twhile (len) {\n\t\t\tbyte = data[off];\n\t\t\tif (byte != 0xff) {\n\t\t\t\tfor (m = 0x80, i = 0; i < 8; m >>= 1, i++) {\n\t\t\t\t\tif (!(byte & m)) {\n\t\t\t\t\t\tidx += i;\n\t\t\t\t\t\tdata[off] |= m;\n\t\t\t\t\t\tset_page_dirty(*pagep);\n\t\t\t\t\t\tkunmap(*pagep);\n\t\t\t\t\t\ttree->free_nodes--;\n\t\t\t\t\t\tmark_inode_dirty(tree->inode);\n\t\t\t\t\t\thfs_bnode_put(node);\n\t\t\t\t\t\treturn hfs_bnode_create(tree,\n\t\t\t\t\t\t\tidx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++off >= PAGE_CACHE_SIZE) {\n\t\t\t\tkunmap(*pagep);\n\t\t\t\tdata = kmap(*++pagep);\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t\tidx += 8;\n\t\t\tlen--;\n\t\t}\n\t\tkunmap(*pagep);\n\t\tnidx = node->next;\n\t\tif (!nidx) {\n\t\t\thfs_dbg(BNODE_MOD, \"create new bmap node\\n\");\n\t\t\tnext_node = hfs_bmap_new_bmap(node, idx);\n\t\t} else\n\t\t\tnext_node = hfs_bnode_find(tree, nidx);\n\t\thfs_bnode_put(node);\n\t\tif (IS_ERR(next_node))\n\t\t\treturn next_node;\n\t\tnode = next_node;\n\n\t\tlen = hfs_brec_lenoff(node, 0, &off16);\n\t\toff = off16;\n\t\toff += node->page_offset;\n\t\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\t\tdata = kmap(*pagep);\n\t\toff &= ~PAGE_CACHE_MASK;\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstruct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *next_node;\n\tstruct page **pagep;\n\tu32 nidx, idx;\n\tunsigned off;\n\tu16 off16;\n\tu16 len;\n\tu8 *data, byte, m;\n\tint i;\n\n\twhile (!tree->free_nodes) {\n\t\tstruct inode *inode = tree->inode;\n\t\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\t\tu32 count;\n\t\tint res;\n\n\t\tres = hfsplus_file_extend(inode, hfs_bnode_need_zeroout(tree));\n\t\tif (res)\n\t\t\treturn ERR_PTR(res);\n\t\thip->phys_size = inode->i_size =\n\t\t\t(loff_t)hip->alloc_blocks <<\n\t\t\t\tHFSPLUS_SB(tree->sb)->alloc_blksz_shift;\n\t\thip->fs_blocks =\n\t\t\thip->alloc_blocks << HFSPLUS_SB(tree->sb)->fs_shift;\n\t\tinode_set_bytes(inode, inode->i_size);\n\t\tcount = inode->i_size >> tree->node_size_shift;\n\t\ttree->free_nodes = count - tree->node_count;\n\t\ttree->node_count = count;\n\t}\n\n\tnidx = 0;\n\tnode = hfs_bnode_find(tree, nidx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\tlen = hfs_brec_lenoff(node, 2, &off16);\n\toff = off16;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\tdata = kmap(*pagep);\n\toff &= ~PAGE_CACHE_MASK;\n\tidx = 0;\n\n\tfor (;;) {\n\t\twhile (len) {\n\t\t\tbyte = data[off];\n\t\t\tif (byte != 0xff) {\n\t\t\t\tfor (m = 0x80, i = 0; i < 8; m >>= 1, i++) {\n\t\t\t\t\tif (!(byte & m)) {\n\t\t\t\t\t\tidx += i;\n\t\t\t\t\t\tdata[off] |= m;\n\t\t\t\t\t\tset_page_dirty(*pagep);\n\t\t\t\t\t\tkunmap(*pagep);\n\t\t\t\t\t\ttree->free_nodes--;\n\t\t\t\t\t\tmark_inode_dirty(tree->inode);\n\t\t\t\t\t\thfs_bnode_put(node);\n\t\t\t\t\t\treturn hfs_bnode_create(tree,\n\t\t\t\t\t\t\tidx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++off >= PAGE_CACHE_SIZE) {\n\t\t\t\tkunmap(*pagep);\n\t\t\t\tdata = kmap(*++pagep);\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t\tidx += 8;\n\t\t\tlen--;\n\t\t}\n\t\tkunmap(*pagep);\n\t\tnidx = node->next;\n\t\tif (!nidx) {\n\t\t\thfs_dbg(BNODE_MOD, \"create new bmap node\\n\");\n\t\t\tnext_node = hfs_bmap_new_bmap(node, idx);\n\t\t} else\n\t\t\tnext_node = hfs_bnode_find(tree, nidx);\n\t\thfs_bnode_put(node);\n\t\tif (IS_ERR(next_node))\n\t\t\treturn next_node;\n\t\tnode = next_node;\n\n\t\tlen = hfs_brec_lenoff(node, 0, &off16);\n\t\toff = off16;\n\t\toff += node->page_offset;\n\t\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\t\tdata = kmap(*pagep);\n\t\toff &= ~PAGE_CACHE_MASK;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "node"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "tree->root"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nstatic int hfs_btree_inc_height(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *new_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint key_size, rec;\n\t__be32 cnid;\n\n\tnode = NULL;\n\tif (tree->root) {\n\t\tnode = hfs_bnode_find(tree, tree->root);\n\t\tif (IS_ERR(node))\n\t\t\treturn PTR_ERR(node);\n\t}\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node)) {\n\t\thfs_bnode_put(node);\n\t\treturn PTR_ERR(new_node);\n\t}\n\n\ttree->root = new_node->this;\n\tif (!tree->depth) {\n\t\ttree->leaf_head = tree->leaf_tail = new_node->this;\n\t\tnew_node->type = HFS_NODE_LEAF;\n\t\tnew_node->num_recs = 0;\n\t} else {\n\t\tnew_node->type = HFS_NODE_INDEX;\n\t\tnew_node->num_recs = 1;\n\t}\n\tnew_node->parent = 0;\n\tnew_node->next = 0;\n\tnew_node->prev = 0;\n\tnew_node->height = ++tree->depth;\n\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\trec = tree->node_size - 2;\n\thfs_bnode_write_u16(new_node, rec, 14);\n\n\tif (node) {\n\t\t/* insert old root idx into new root */\n\t\tnode->parent = tree->root;\n\t\tif (node->type == HFS_NODE_LEAF ||\n\t\t\t\ttree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\ttree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\tkey_size = hfs_bnode_read_u16(node, 14) + 2;\n\t\telse\n\t\t\tkey_size = tree->max_key_len + 2;\n\t\thfs_bnode_copy(new_node, 14, node, 14, key_size);\n\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t\t\t\t(tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\t\tkey_size = tree->max_key_len + 2;\n\t\t\thfs_bnode_write_u16(new_node, 14, tree->max_key_len);\n\t\t}\n\t\tcnid = cpu_to_be32(node->this);\n\t\thfs_bnode_write(new_node, &cnid, 14 + key_size, 4);\n\n\t\trec -= 2;\n\t\thfs_bnode_write_u16(new_node, rec, 14 + key_size + 4);\n\n\t\thfs_bnode_put(node);\n\t}\n\thfs_bnode_put(new_node);\n\tmark_inode_dirty(tree->inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_brec_update_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
    "lines": "354-453",
    "snippet": "static int hfs_brec_update_parent(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *parent;\n\tint newkeylen, diff;\n\tint rec, rec_off, end_rec_off;\n\tint start_off, end_off;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = NULL;\n\tif (!node->parent)\n\t\treturn 0;\n\nagain:\n\tparent = hfs_bnode_find(tree, node->parent);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\t__hfs_brec_find(parent, fd, hfs_find_rec_by_key);\n\tif (fd->record < 0)\n\t\treturn -ENOENT;\n\thfs_bnode_dump(parent);\n\trec = fd->record;\n\n\t/* size difference between old and new key */\n\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\tnewkeylen = hfs_bnode_read_u16(node, 14) + 2;\n\telse\n\t\tfd->keylength = newkeylen = tree->max_key_len + 2;\n\thfs_dbg(BNODE_MOD, \"update_rec: %d, %d, %d\\n\",\n\t\trec, fd->keylength, newkeylen);\n\n\trec_off = tree->node_size - (rec + 2) * 2;\n\tend_rec_off = tree->node_size - (parent->num_recs + 1) * 2;\n\tdiff = newkeylen - fd->keylength;\n\tif (!diff)\n\t\tgoto skip;\n\tif (diff > 0) {\n\t\tend_off = hfs_bnode_read_u16(parent, end_rec_off);\n\t\tif (end_rec_off - end_off < diff) {\n\n\t\t\thfs_dbg(BNODE_MOD, \"splitting index node\\n\");\n\t\t\tfd->bnode = parent;\n\t\t\tnew_node = hfs_bnode_split(fd);\n\t\t\tif (IS_ERR(new_node))\n\t\t\t\treturn PTR_ERR(new_node);\n\t\t\tparent = fd->bnode;\n\t\t\trec = fd->record;\n\t\t\trec_off = tree->node_size - (rec + 2) * 2;\n\t\t\tend_rec_off = tree->node_size -\n\t\t\t\t(parent->num_recs + 1) * 2;\n\t\t}\n\t}\n\n\tend_off = start_off = hfs_bnode_read_u16(parent, rec_off);\n\thfs_bnode_write_u16(parent, rec_off, start_off + diff);\n\tstart_off -= 4;\t/* move previous cnid too */\n\n\twhile (rec_off > end_rec_off) {\n\t\trec_off -= 2;\n\t\tend_off = hfs_bnode_read_u16(parent, rec_off);\n\t\thfs_bnode_write_u16(parent, rec_off, end_off + diff);\n\t}\n\thfs_bnode_move(parent, start_off + diff, start_off,\n\t\t       end_off - start_off);\nskip:\n\thfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);\n\thfs_bnode_dump(parent);\n\n\thfs_bnode_put(node);\n\tnode = parent;\n\n\tif (new_node) {\n\t\t__be32 cnid;\n\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\t\t/* create index key and entry */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\tcnid = cpu_to_be32(new_node->this);\n\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\t\thfs_brec_insert(fd, &cnid, sizeof(cnid));\n\t\thfs_bnode_put(fd->bnode);\n\t\thfs_bnode_put(new_node);\n\n\t\tif (!rec) {\n\t\t\tif (new_node == node)\n\t\t\t\tgoto out;\n\t\t\t/* restore search_key */\n\t\t\thfs_bnode_read_key(node, fd->search_key, 14);\n\t\t}\n\t}\n\n\tif (!rec && node->parent)\n\t\tgoto again;\nout:\n\tfd->bnode = node;\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
      "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
      "static int hfs_btree_inc_height(struct hfs_btree *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_read_key",
          "args": [
            "node",
            "fd->search_key",
            "14"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "58-72",
          "snippet": "void hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)\n{\n\tstruct hfs_btree *tree;\n\tint key_len;\n\n\ttree = node->tree;\n\tif (node->type == HFS_NODE_LEAF ||\n\t    tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t    node->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\tkey_len = hfs_bnode_read_u16(node, off) + 2;\n\telse\n\t\tkey_len = tree->max_key_len + 2;\n\n\thfs_bnode_read(node, key, off, key_len);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)\n{\n\tstruct hfs_btree *tree;\n\tint key_len;\n\n\ttree = node->tree;\n\tif (node->type == HFS_NODE_LEAF ||\n\t    tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t    node->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\tkey_len = hfs_bnode_read_u16(node, off) + 2;\n\telse\n\t\tkey_len = tree->max_key_len + 2;\n\n\thfs_bnode_read(node, key, off, key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "new_node"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_insert",
          "args": [
            "fd",
            "&cnid",
            "sizeof(cnid)"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "62-175",
          "snippet": "int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfs_brec_find",
          "args": [
            "fd->bnode",
            "fd",
            "hfs_find_rec_by_key"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "__hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "113-161",
          "snippet": "int __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_node->this"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "new_node->parent"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_dump",
          "args": [
            "parent"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "299-334",
          "snippet": "void hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_copy",
          "args": [
            "parent",
            "fd->keyoffset",
            "node",
            "14",
            "newkeylen"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "126-184",
          "snippet": "void hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct hfs_btree *tree;\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\ttree = src_node->tree;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_CACHE_SHIFT);\n\tsrc &= ~PAGE_CACHE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);\n\tdst &= ~PAGE_CACHE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\tmemcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);\n\t\tkunmap(*src_page);\n\t\tset_page_dirty(*dst_page);\n\t\tkunmap(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\tmemcpy(kmap(*++dst_page), kmap(*++src_page), l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\tif (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {\n\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct hfs_btree *tree;\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\ttree = src_node->tree;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_CACHE_SHIFT);\n\tsrc &= ~PAGE_CACHE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);\n\tdst &= ~PAGE_CACHE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\tmemcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);\n\t\tkunmap(*src_page);\n\t\tset_page_dirty(*dst_page);\n\t\tkunmap(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\tmemcpy(kmap(*++dst_page), kmap(*++src_page), l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\tif (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {\n\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_move",
          "args": [
            "parent",
            "start_off + diff",
            "start_off",
            "end_off - start_off"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "186-297",
          "snippet": "void hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc = (src & ~PAGE_CACHE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst = (dst & ~PAGE_CACHE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tmemmove(kmap(*dst_page), kmap(*src_page), src);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, len);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_CACHE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (dst == PAGE_CACHE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc &= ~PAGE_CACHE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst &= ~PAGE_CACHE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\t\tmemmove(kmap(*++dst_page),\n\t\t\t\t\tkmap(*++src_page), l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (PAGE_CACHE_SIZE - src <\n\t\t\t\t\t\tPAGE_CACHE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc = (src & ~PAGE_CACHE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst = (dst & ~PAGE_CACHE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tmemmove(kmap(*dst_page), kmap(*src_page), src);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, len);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_CACHE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (dst == PAGE_CACHE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc &= ~PAGE_CACHE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst &= ~PAGE_CACHE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\t\tmemmove(kmap(*++dst_page),\n\t\t\t\t\tkmap(*++src_page), l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (PAGE_CACHE_SIZE - src <\n\t\t\t\t\t\tPAGE_CACHE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write_u16",
          "args": [
            "parent",
            "rec_off",
            "end_off + diff"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "97-102",
          "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "parent",
            "rec_off"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_node"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_node"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_split",
          "args": [
            "fd"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "233-352",
          "snippet": "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *next_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint num_recs, new_rec_off, new_off, old_rec_off;\n\tint data_start, data_end, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node))\n\t\treturn new_node;\n\thfs_bnode_get(node);\n\thfs_dbg(BNODE_MOD, \"split_nodes: %d - %d - %d\\n\",\n\t\tnode->this, new_node->this, node->next);\n\tnew_node->next = node->next;\n\tnew_node->prev = node->this;\n\tnew_node->parent = node->parent;\n\tnew_node->type = node->type;\n\tnew_node->height = node->height;\n\n\tif (node->next)\n\t\tnext_node = hfs_bnode_find(tree, node->next);\n\telse\n\t\tnext_node = NULL;\n\n\tif (IS_ERR(next_node)) {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\treturn next_node;\n\t}\n\n\tsize = tree->node_size / 2 - node->num_recs * 2 - 14;\n\told_rec_off = tree->node_size - 4;\n\tnum_recs = 1;\n\tfor (;;) {\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t\tif (data_start > size)\n\t\t\tbreak;\n\t\told_rec_off -= 2;\n\t\tif (++num_recs < node->num_recs)\n\t\t\tcontinue;\n\t\t/* panic? */\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\tif (next_node)\n\t\t\thfs_bnode_put(next_node);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tif (fd->record + 1 < num_recs) {\n\t\t/* new record is in the lower half,\n\t\t * so leave some more space there\n\t\t */\n\t\told_rec_off += 2;\n\t\tnum_recs--;\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t} else {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_get(new_node);\n\t\tfd->bnode = new_node;\n\t\tfd->record -= num_recs;\n\t\tfd->keyoffset -= data_start - 14;\n\t\tfd->entryoffset -= data_start - 14;\n\t}\n\tnew_node->num_recs = node->num_recs - num_recs;\n\tnode->num_recs = num_recs;\n\n\tnew_rec_off = tree->node_size - 2;\n\tnew_off = 14;\n\tsize = data_start - new_off;\n\tnum_recs = new_node->num_recs;\n\tdata_end = data_start;\n\twhile (num_recs) {\n\t\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\t\told_rec_off -= 2;\n\t\tnew_rec_off -= 2;\n\t\tdata_end = hfs_bnode_read_u16(node, old_rec_off);\n\t\tnew_off = data_end - size;\n\t\tnum_recs--;\n\t}\n\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\thfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);\n\n\t/* update new bnode header */\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update previous bnode header */\n\tnode->next = new_node->this;\n\thfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));\n\tnode_desc.next = cpu_to_be32(node->next);\n\tnode_desc.num_recs = cpu_to_be16(node->num_recs);\n\thfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update next bnode header */\n\tif (next_node) {\n\t\tnext_node->prev = new_node->this;\n\t\thfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));\n\t\tnode_desc.prev = cpu_to_be32(next_node->prev);\n\t\thfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));\n\t\thfs_bnode_put(next_node);\n\t} else if (node->this == tree->leaf_tail) {\n\t\t/* if there is no next node, this might be the new tail */\n\t\ttree->leaf_tail = new_node->this;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\n\thfs_bnode_dump(node);\n\thfs_bnode_dump(new_node);\n\thfs_bnode_put(node);\n\n\treturn new_node;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *next_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint num_recs, new_rec_off, new_off, old_rec_off;\n\tint data_start, data_end, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node))\n\t\treturn new_node;\n\thfs_bnode_get(node);\n\thfs_dbg(BNODE_MOD, \"split_nodes: %d - %d - %d\\n\",\n\t\tnode->this, new_node->this, node->next);\n\tnew_node->next = node->next;\n\tnew_node->prev = node->this;\n\tnew_node->parent = node->parent;\n\tnew_node->type = node->type;\n\tnew_node->height = node->height;\n\n\tif (node->next)\n\t\tnext_node = hfs_bnode_find(tree, node->next);\n\telse\n\t\tnext_node = NULL;\n\n\tif (IS_ERR(next_node)) {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\treturn next_node;\n\t}\n\n\tsize = tree->node_size / 2 - node->num_recs * 2 - 14;\n\told_rec_off = tree->node_size - 4;\n\tnum_recs = 1;\n\tfor (;;) {\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t\tif (data_start > size)\n\t\t\tbreak;\n\t\told_rec_off -= 2;\n\t\tif (++num_recs < node->num_recs)\n\t\t\tcontinue;\n\t\t/* panic? */\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\tif (next_node)\n\t\t\thfs_bnode_put(next_node);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tif (fd->record + 1 < num_recs) {\n\t\t/* new record is in the lower half,\n\t\t * so leave some more space there\n\t\t */\n\t\told_rec_off += 2;\n\t\tnum_recs--;\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t} else {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_get(new_node);\n\t\tfd->bnode = new_node;\n\t\tfd->record -= num_recs;\n\t\tfd->keyoffset -= data_start - 14;\n\t\tfd->entryoffset -= data_start - 14;\n\t}\n\tnew_node->num_recs = node->num_recs - num_recs;\n\tnode->num_recs = num_recs;\n\n\tnew_rec_off = tree->node_size - 2;\n\tnew_off = 14;\n\tsize = data_start - new_off;\n\tnum_recs = new_node->num_recs;\n\tdata_end = data_start;\n\twhile (num_recs) {\n\t\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\t\told_rec_off -= 2;\n\t\tnew_rec_off -= 2;\n\t\tdata_end = hfs_bnode_read_u16(node, old_rec_off);\n\t\tnew_off = data_end - size;\n\t\tnum_recs--;\n\t}\n\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\thfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);\n\n\t/* update new bnode header */\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update previous bnode header */\n\tnode->next = new_node->this;\n\thfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));\n\tnode_desc.next = cpu_to_be32(node->next);\n\tnode_desc.num_recs = cpu_to_be16(node->num_recs);\n\thfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update next bnode header */\n\tif (next_node) {\n\t\tnext_node->prev = new_node->this;\n\t\thfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));\n\t\tnode_desc.prev = cpu_to_be32(next_node->prev);\n\t\thfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));\n\t\thfs_bnode_put(next_node);\n\t} else if (node->this == tree->leaf_tail) {\n\t\t/* if there is no next node, this might be the new tail */\n\t\ttree->leaf_tail = new_node->this;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\n\thfs_bnode_dump(node);\n\thfs_bnode_dump(new_node);\n\thfs_bnode_put(node);\n\n\treturn new_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"splitting index node\\n\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"update_rec: %d, %d, %d\\n\"",
            "rec",
            "fd->keylength",
            "newkeylen"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "parent"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *parent;\n\tint newkeylen, diff;\n\tint rec, rec_off, end_rec_off;\n\tint start_off, end_off;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = NULL;\n\tif (!node->parent)\n\t\treturn 0;\n\nagain:\n\tparent = hfs_bnode_find(tree, node->parent);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\t__hfs_brec_find(parent, fd, hfs_find_rec_by_key);\n\tif (fd->record < 0)\n\t\treturn -ENOENT;\n\thfs_bnode_dump(parent);\n\trec = fd->record;\n\n\t/* size difference between old and new key */\n\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\tnewkeylen = hfs_bnode_read_u16(node, 14) + 2;\n\telse\n\t\tfd->keylength = newkeylen = tree->max_key_len + 2;\n\thfs_dbg(BNODE_MOD, \"update_rec: %d, %d, %d\\n\",\n\t\trec, fd->keylength, newkeylen);\n\n\trec_off = tree->node_size - (rec + 2) * 2;\n\tend_rec_off = tree->node_size - (parent->num_recs + 1) * 2;\n\tdiff = newkeylen - fd->keylength;\n\tif (!diff)\n\t\tgoto skip;\n\tif (diff > 0) {\n\t\tend_off = hfs_bnode_read_u16(parent, end_rec_off);\n\t\tif (end_rec_off - end_off < diff) {\n\n\t\t\thfs_dbg(BNODE_MOD, \"splitting index node\\n\");\n\t\t\tfd->bnode = parent;\n\t\t\tnew_node = hfs_bnode_split(fd);\n\t\t\tif (IS_ERR(new_node))\n\t\t\t\treturn PTR_ERR(new_node);\n\t\t\tparent = fd->bnode;\n\t\t\trec = fd->record;\n\t\t\trec_off = tree->node_size - (rec + 2) * 2;\n\t\t\tend_rec_off = tree->node_size -\n\t\t\t\t(parent->num_recs + 1) * 2;\n\t\t}\n\t}\n\n\tend_off = start_off = hfs_bnode_read_u16(parent, rec_off);\n\thfs_bnode_write_u16(parent, rec_off, start_off + diff);\n\tstart_off -= 4;\t/* move previous cnid too */\n\n\twhile (rec_off > end_rec_off) {\n\t\trec_off -= 2;\n\t\tend_off = hfs_bnode_read_u16(parent, rec_off);\n\t\thfs_bnode_write_u16(parent, rec_off, end_off + diff);\n\t}\n\thfs_bnode_move(parent, start_off + diff, start_off,\n\t\t       end_off - start_off);\nskip:\n\thfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);\n\thfs_bnode_dump(parent);\n\n\thfs_bnode_put(node);\n\tnode = parent;\n\n\tif (new_node) {\n\t\t__be32 cnid;\n\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\t\t/* create index key and entry */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\tcnid = cpu_to_be32(new_node->this);\n\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\t\thfs_brec_insert(fd, &cnid, sizeof(cnid));\n\t\thfs_bnode_put(fd->bnode);\n\t\thfs_bnode_put(new_node);\n\n\t\tif (!rec) {\n\t\t\tif (new_node == node)\n\t\t\t\tgoto out;\n\t\t\t/* restore search_key */\n\t\t\thfs_bnode_read_key(node, fd->search_key, 14);\n\t\t}\n\t}\n\n\tif (!rec && node->parent)\n\t\tgoto again;\nout:\n\tfd->bnode = node;\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_bnode_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
    "lines": "233-352",
    "snippet": "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *next_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint num_recs, new_rec_off, new_off, old_rec_off;\n\tint data_start, data_end, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node))\n\t\treturn new_node;\n\thfs_bnode_get(node);\n\thfs_dbg(BNODE_MOD, \"split_nodes: %d - %d - %d\\n\",\n\t\tnode->this, new_node->this, node->next);\n\tnew_node->next = node->next;\n\tnew_node->prev = node->this;\n\tnew_node->parent = node->parent;\n\tnew_node->type = node->type;\n\tnew_node->height = node->height;\n\n\tif (node->next)\n\t\tnext_node = hfs_bnode_find(tree, node->next);\n\telse\n\t\tnext_node = NULL;\n\n\tif (IS_ERR(next_node)) {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\treturn next_node;\n\t}\n\n\tsize = tree->node_size / 2 - node->num_recs * 2 - 14;\n\told_rec_off = tree->node_size - 4;\n\tnum_recs = 1;\n\tfor (;;) {\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t\tif (data_start > size)\n\t\t\tbreak;\n\t\told_rec_off -= 2;\n\t\tif (++num_recs < node->num_recs)\n\t\t\tcontinue;\n\t\t/* panic? */\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\tif (next_node)\n\t\t\thfs_bnode_put(next_node);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tif (fd->record + 1 < num_recs) {\n\t\t/* new record is in the lower half,\n\t\t * so leave some more space there\n\t\t */\n\t\told_rec_off += 2;\n\t\tnum_recs--;\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t} else {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_get(new_node);\n\t\tfd->bnode = new_node;\n\t\tfd->record -= num_recs;\n\t\tfd->keyoffset -= data_start - 14;\n\t\tfd->entryoffset -= data_start - 14;\n\t}\n\tnew_node->num_recs = node->num_recs - num_recs;\n\tnode->num_recs = num_recs;\n\n\tnew_rec_off = tree->node_size - 2;\n\tnew_off = 14;\n\tsize = data_start - new_off;\n\tnum_recs = new_node->num_recs;\n\tdata_end = data_start;\n\twhile (num_recs) {\n\t\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\t\told_rec_off -= 2;\n\t\tnew_rec_off -= 2;\n\t\tdata_end = hfs_bnode_read_u16(node, old_rec_off);\n\t\tnew_off = data_end - size;\n\t\tnum_recs--;\n\t}\n\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\thfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);\n\n\t/* update new bnode header */\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update previous bnode header */\n\tnode->next = new_node->this;\n\thfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));\n\tnode_desc.next = cpu_to_be32(node->next);\n\tnode_desc.num_recs = cpu_to_be16(node->num_recs);\n\thfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update next bnode header */\n\tif (next_node) {\n\t\tnext_node->prev = new_node->this;\n\t\thfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));\n\t\tnode_desc.prev = cpu_to_be32(next_node->prev);\n\t\thfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));\n\t\thfs_bnode_put(next_node);\n\t} else if (node->this == tree->leaf_tail) {\n\t\t/* if there is no next node, this might be the new tail */\n\t\ttree->leaf_tail = new_node->this;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\n\thfs_bnode_dump(node);\n\thfs_bnode_dump(new_node);\n\thfs_bnode_put(node);\n\n\treturn new_node;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
      "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
      "static int hfs_btree_inc_height(struct hfs_btree *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "node"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_dump",
          "args": [
            "new_node"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "299-334",
          "snippet": "void hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "tree->inode"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "next_node",
            "&node_desc",
            "0",
            "sizeof(node_desc)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "next_node->prev"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "next_node",
            "&node_desc",
            "0",
            "sizeof(node_desc)"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "node->num_recs"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "node->next"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "new_node->num_recs"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_node->prev"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_node->next"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_copy",
          "args": [
            "new_node",
            "14",
            "node",
            "data_start",
            "data_end - data_start"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "126-184",
          "snippet": "void hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct hfs_btree *tree;\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\ttree = src_node->tree;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_CACHE_SHIFT);\n\tsrc &= ~PAGE_CACHE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);\n\tdst &= ~PAGE_CACHE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\tmemcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);\n\t\tkunmap(*src_page);\n\t\tset_page_dirty(*dst_page);\n\t\tkunmap(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\tmemcpy(kmap(*++dst_page), kmap(*++src_page), l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\tif (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {\n\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct hfs_btree *tree;\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\ttree = src_node->tree;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_CACHE_SHIFT);\n\tsrc &= ~PAGE_CACHE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);\n\tdst &= ~PAGE_CACHE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\tmemcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);\n\t\tkunmap(*src_page);\n\t\tset_page_dirty(*dst_page);\n\t\tkunmap(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\tmemcpy(kmap(*++dst_page), kmap(*++src_page), l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\tif (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {\n\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write_u16",
          "args": [
            "new_node",
            "new_rec_off",
            "new_off"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "97-102",
          "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "node",
            "old_rec_off"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_get",
          "args": [
            "new_node"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "617-625",
          "snippet": "void hfs_bnode_get(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tatomic_inc(&node->refcnt);\n\t\thfs_dbg(BNODE_REFS, \"get_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_get(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tatomic_inc(&node->refcnt);\n\t\thfs_dbg(BNODE_REFS, \"get_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "next_node"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "node->next"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"split_nodes: %d - %d - %d\\n\"",
            "node->this",
            "new_node->this",
            "node->next"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_node"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bmap_alloc",
          "args": [
            "tree"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bmap_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "344-433",
          "snippet": "struct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *next_node;\n\tstruct page **pagep;\n\tu32 nidx, idx;\n\tunsigned off;\n\tu16 off16;\n\tu16 len;\n\tu8 *data, byte, m;\n\tint i;\n\n\twhile (!tree->free_nodes) {\n\t\tstruct inode *inode = tree->inode;\n\t\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\t\tu32 count;\n\t\tint res;\n\n\t\tres = hfsplus_file_extend(inode, hfs_bnode_need_zeroout(tree));\n\t\tif (res)\n\t\t\treturn ERR_PTR(res);\n\t\thip->phys_size = inode->i_size =\n\t\t\t(loff_t)hip->alloc_blocks <<\n\t\t\t\tHFSPLUS_SB(tree->sb)->alloc_blksz_shift;\n\t\thip->fs_blocks =\n\t\t\thip->alloc_blocks << HFSPLUS_SB(tree->sb)->fs_shift;\n\t\tinode_set_bytes(inode, inode->i_size);\n\t\tcount = inode->i_size >> tree->node_size_shift;\n\t\ttree->free_nodes = count - tree->node_count;\n\t\ttree->node_count = count;\n\t}\n\n\tnidx = 0;\n\tnode = hfs_bnode_find(tree, nidx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\tlen = hfs_brec_lenoff(node, 2, &off16);\n\toff = off16;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\tdata = kmap(*pagep);\n\toff &= ~PAGE_CACHE_MASK;\n\tidx = 0;\n\n\tfor (;;) {\n\t\twhile (len) {\n\t\t\tbyte = data[off];\n\t\t\tif (byte != 0xff) {\n\t\t\t\tfor (m = 0x80, i = 0; i < 8; m >>= 1, i++) {\n\t\t\t\t\tif (!(byte & m)) {\n\t\t\t\t\t\tidx += i;\n\t\t\t\t\t\tdata[off] |= m;\n\t\t\t\t\t\tset_page_dirty(*pagep);\n\t\t\t\t\t\tkunmap(*pagep);\n\t\t\t\t\t\ttree->free_nodes--;\n\t\t\t\t\t\tmark_inode_dirty(tree->inode);\n\t\t\t\t\t\thfs_bnode_put(node);\n\t\t\t\t\t\treturn hfs_bnode_create(tree,\n\t\t\t\t\t\t\tidx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++off >= PAGE_CACHE_SIZE) {\n\t\t\t\tkunmap(*pagep);\n\t\t\t\tdata = kmap(*++pagep);\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t\tidx += 8;\n\t\t\tlen--;\n\t\t}\n\t\tkunmap(*pagep);\n\t\tnidx = node->next;\n\t\tif (!nidx) {\n\t\t\thfs_dbg(BNODE_MOD, \"create new bmap node\\n\");\n\t\t\tnext_node = hfs_bmap_new_bmap(node, idx);\n\t\t} else\n\t\t\tnext_node = hfs_bnode_find(tree, nidx);\n\t\thfs_bnode_put(node);\n\t\tif (IS_ERR(next_node))\n\t\t\treturn next_node;\n\t\tnode = next_node;\n\n\t\tlen = hfs_brec_lenoff(node, 0, &off16);\n\t\toff = off16;\n\t\toff += node->page_offset;\n\t\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\t\tdata = kmap(*pagep);\n\t\toff &= ~PAGE_CACHE_MASK;\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstruct hfs_bnode *hfs_bmap_alloc(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *next_node;\n\tstruct page **pagep;\n\tu32 nidx, idx;\n\tunsigned off;\n\tu16 off16;\n\tu16 len;\n\tu8 *data, byte, m;\n\tint i;\n\n\twhile (!tree->free_nodes) {\n\t\tstruct inode *inode = tree->inode;\n\t\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\t\tu32 count;\n\t\tint res;\n\n\t\tres = hfsplus_file_extend(inode, hfs_bnode_need_zeroout(tree));\n\t\tif (res)\n\t\t\treturn ERR_PTR(res);\n\t\thip->phys_size = inode->i_size =\n\t\t\t(loff_t)hip->alloc_blocks <<\n\t\t\t\tHFSPLUS_SB(tree->sb)->alloc_blksz_shift;\n\t\thip->fs_blocks =\n\t\t\thip->alloc_blocks << HFSPLUS_SB(tree->sb)->fs_shift;\n\t\tinode_set_bytes(inode, inode->i_size);\n\t\tcount = inode->i_size >> tree->node_size_shift;\n\t\ttree->free_nodes = count - tree->node_count;\n\t\ttree->node_count = count;\n\t}\n\n\tnidx = 0;\n\tnode = hfs_bnode_find(tree, nidx);\n\tif (IS_ERR(node))\n\t\treturn node;\n\tlen = hfs_brec_lenoff(node, 2, &off16);\n\toff = off16;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\tdata = kmap(*pagep);\n\toff &= ~PAGE_CACHE_MASK;\n\tidx = 0;\n\n\tfor (;;) {\n\t\twhile (len) {\n\t\t\tbyte = data[off];\n\t\t\tif (byte != 0xff) {\n\t\t\t\tfor (m = 0x80, i = 0; i < 8; m >>= 1, i++) {\n\t\t\t\t\tif (!(byte & m)) {\n\t\t\t\t\t\tidx += i;\n\t\t\t\t\t\tdata[off] |= m;\n\t\t\t\t\t\tset_page_dirty(*pagep);\n\t\t\t\t\t\tkunmap(*pagep);\n\t\t\t\t\t\ttree->free_nodes--;\n\t\t\t\t\t\tmark_inode_dirty(tree->inode);\n\t\t\t\t\t\thfs_bnode_put(node);\n\t\t\t\t\t\treturn hfs_bnode_create(tree,\n\t\t\t\t\t\t\tidx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (++off >= PAGE_CACHE_SIZE) {\n\t\t\t\tkunmap(*pagep);\n\t\t\t\tdata = kmap(*++pagep);\n\t\t\t\toff = 0;\n\t\t\t}\n\t\t\tidx += 8;\n\t\t\tlen--;\n\t\t}\n\t\tkunmap(*pagep);\n\t\tnidx = node->next;\n\t\tif (!nidx) {\n\t\t\thfs_dbg(BNODE_MOD, \"create new bmap node\\n\");\n\t\t\tnext_node = hfs_bmap_new_bmap(node, idx);\n\t\t} else\n\t\t\tnext_node = hfs_bnode_find(tree, nidx);\n\t\thfs_bnode_put(node);\n\t\tif (IS_ERR(next_node))\n\t\t\treturn next_node;\n\t\tnode = next_node;\n\n\t\tlen = hfs_brec_lenoff(node, 0, &off16);\n\t\toff = off16;\n\t\toff += node->page_offset;\n\t\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\t\tdata = kmap(*pagep);\n\t\toff &= ~PAGE_CACHE_MASK;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *next_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint num_recs, new_rec_off, new_off, old_rec_off;\n\tint data_start, data_end, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node))\n\t\treturn new_node;\n\thfs_bnode_get(node);\n\thfs_dbg(BNODE_MOD, \"split_nodes: %d - %d - %d\\n\",\n\t\tnode->this, new_node->this, node->next);\n\tnew_node->next = node->next;\n\tnew_node->prev = node->this;\n\tnew_node->parent = node->parent;\n\tnew_node->type = node->type;\n\tnew_node->height = node->height;\n\n\tif (node->next)\n\t\tnext_node = hfs_bnode_find(tree, node->next);\n\telse\n\t\tnext_node = NULL;\n\n\tif (IS_ERR(next_node)) {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\treturn next_node;\n\t}\n\n\tsize = tree->node_size / 2 - node->num_recs * 2 - 14;\n\told_rec_off = tree->node_size - 4;\n\tnum_recs = 1;\n\tfor (;;) {\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t\tif (data_start > size)\n\t\t\tbreak;\n\t\told_rec_off -= 2;\n\t\tif (++num_recs < node->num_recs)\n\t\t\tcontinue;\n\t\t/* panic? */\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\tif (next_node)\n\t\t\thfs_bnode_put(next_node);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tif (fd->record + 1 < num_recs) {\n\t\t/* new record is in the lower half,\n\t\t * so leave some more space there\n\t\t */\n\t\told_rec_off += 2;\n\t\tnum_recs--;\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t} else {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_get(new_node);\n\t\tfd->bnode = new_node;\n\t\tfd->record -= num_recs;\n\t\tfd->keyoffset -= data_start - 14;\n\t\tfd->entryoffset -= data_start - 14;\n\t}\n\tnew_node->num_recs = node->num_recs - num_recs;\n\tnode->num_recs = num_recs;\n\n\tnew_rec_off = tree->node_size - 2;\n\tnew_off = 14;\n\tsize = data_start - new_off;\n\tnum_recs = new_node->num_recs;\n\tdata_end = data_start;\n\twhile (num_recs) {\n\t\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\t\told_rec_off -= 2;\n\t\tnew_rec_off -= 2;\n\t\tdata_end = hfs_bnode_read_u16(node, old_rec_off);\n\t\tnew_off = data_end - size;\n\t\tnum_recs--;\n\t}\n\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\thfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);\n\n\t/* update new bnode header */\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update previous bnode header */\n\tnode->next = new_node->this;\n\thfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));\n\tnode_desc.next = cpu_to_be32(node->next);\n\tnode_desc.num_recs = cpu_to_be16(node->num_recs);\n\thfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update next bnode header */\n\tif (next_node) {\n\t\tnext_node->prev = new_node->this;\n\t\thfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));\n\t\tnode_desc.prev = cpu_to_be32(next_node->prev);\n\t\thfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));\n\t\thfs_bnode_put(next_node);\n\t} else if (node->this == tree->leaf_tail) {\n\t\t/* if there is no next node, this might be the new tail */\n\t\ttree->leaf_tail = new_node->this;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\n\thfs_bnode_dump(node);\n\thfs_bnode_dump(new_node);\n\thfs_bnode_put(node);\n\n\treturn new_node;\n}"
  },
  {
    "function_name": "hfs_brec_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
    "lines": "177-231",
    "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
      "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
      "static int hfs_btree_inc_height(struct hfs_btree *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_brec_update_parent",
          "args": [
            "fd"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_update_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "354-453",
          "snippet": "static int hfs_brec_update_parent(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *parent;\n\tint newkeylen, diff;\n\tint rec, rec_off, end_rec_off;\n\tint start_off, end_off;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = NULL;\n\tif (!node->parent)\n\t\treturn 0;\n\nagain:\n\tparent = hfs_bnode_find(tree, node->parent);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\t__hfs_brec_find(parent, fd, hfs_find_rec_by_key);\n\tif (fd->record < 0)\n\t\treturn -ENOENT;\n\thfs_bnode_dump(parent);\n\trec = fd->record;\n\n\t/* size difference between old and new key */\n\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\tnewkeylen = hfs_bnode_read_u16(node, 14) + 2;\n\telse\n\t\tfd->keylength = newkeylen = tree->max_key_len + 2;\n\thfs_dbg(BNODE_MOD, \"update_rec: %d, %d, %d\\n\",\n\t\trec, fd->keylength, newkeylen);\n\n\trec_off = tree->node_size - (rec + 2) * 2;\n\tend_rec_off = tree->node_size - (parent->num_recs + 1) * 2;\n\tdiff = newkeylen - fd->keylength;\n\tif (!diff)\n\t\tgoto skip;\n\tif (diff > 0) {\n\t\tend_off = hfs_bnode_read_u16(parent, end_rec_off);\n\t\tif (end_rec_off - end_off < diff) {\n\n\t\t\thfs_dbg(BNODE_MOD, \"splitting index node\\n\");\n\t\t\tfd->bnode = parent;\n\t\t\tnew_node = hfs_bnode_split(fd);\n\t\t\tif (IS_ERR(new_node))\n\t\t\t\treturn PTR_ERR(new_node);\n\t\t\tparent = fd->bnode;\n\t\t\trec = fd->record;\n\t\t\trec_off = tree->node_size - (rec + 2) * 2;\n\t\t\tend_rec_off = tree->node_size -\n\t\t\t\t(parent->num_recs + 1) * 2;\n\t\t}\n\t}\n\n\tend_off = start_off = hfs_bnode_read_u16(parent, rec_off);\n\thfs_bnode_write_u16(parent, rec_off, start_off + diff);\n\tstart_off -= 4;\t/* move previous cnid too */\n\n\twhile (rec_off > end_rec_off) {\n\t\trec_off -= 2;\n\t\tend_off = hfs_bnode_read_u16(parent, rec_off);\n\t\thfs_bnode_write_u16(parent, rec_off, end_off + diff);\n\t}\n\thfs_bnode_move(parent, start_off + diff, start_off,\n\t\t       end_off - start_off);\nskip:\n\thfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);\n\thfs_bnode_dump(parent);\n\n\thfs_bnode_put(node);\n\tnode = parent;\n\n\tif (new_node) {\n\t\t__be32 cnid;\n\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\t\t/* create index key and entry */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\tcnid = cpu_to_be32(new_node->this);\n\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\t\thfs_brec_insert(fd, &cnid, sizeof(cnid));\n\t\thfs_bnode_put(fd->bnode);\n\t\thfs_bnode_put(new_node);\n\n\t\tif (!rec) {\n\t\t\tif (new_node == node)\n\t\t\t\tgoto out;\n\t\t\t/* restore search_key */\n\t\t\thfs_bnode_read_key(node, fd->search_key, 14);\n\t\t}\n\t}\n\n\tif (!rec && node->parent)\n\t\tgoto again;\nout:\n\tfd->bnode = node;\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *parent;\n\tint newkeylen, diff;\n\tint rec, rec_off, end_rec_off;\n\tint start_off, end_off;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = NULL;\n\tif (!node->parent)\n\t\treturn 0;\n\nagain:\n\tparent = hfs_bnode_find(tree, node->parent);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\t__hfs_brec_find(parent, fd, hfs_find_rec_by_key);\n\tif (fd->record < 0)\n\t\treturn -ENOENT;\n\thfs_bnode_dump(parent);\n\trec = fd->record;\n\n\t/* size difference between old and new key */\n\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\tnewkeylen = hfs_bnode_read_u16(node, 14) + 2;\n\telse\n\t\tfd->keylength = newkeylen = tree->max_key_len + 2;\n\thfs_dbg(BNODE_MOD, \"update_rec: %d, %d, %d\\n\",\n\t\trec, fd->keylength, newkeylen);\n\n\trec_off = tree->node_size - (rec + 2) * 2;\n\tend_rec_off = tree->node_size - (parent->num_recs + 1) * 2;\n\tdiff = newkeylen - fd->keylength;\n\tif (!diff)\n\t\tgoto skip;\n\tif (diff > 0) {\n\t\tend_off = hfs_bnode_read_u16(parent, end_rec_off);\n\t\tif (end_rec_off - end_off < diff) {\n\n\t\t\thfs_dbg(BNODE_MOD, \"splitting index node\\n\");\n\t\t\tfd->bnode = parent;\n\t\t\tnew_node = hfs_bnode_split(fd);\n\t\t\tif (IS_ERR(new_node))\n\t\t\t\treturn PTR_ERR(new_node);\n\t\t\tparent = fd->bnode;\n\t\t\trec = fd->record;\n\t\t\trec_off = tree->node_size - (rec + 2) * 2;\n\t\t\tend_rec_off = tree->node_size -\n\t\t\t\t(parent->num_recs + 1) * 2;\n\t\t}\n\t}\n\n\tend_off = start_off = hfs_bnode_read_u16(parent, rec_off);\n\thfs_bnode_write_u16(parent, rec_off, start_off + diff);\n\tstart_off -= 4;\t/* move previous cnid too */\n\n\twhile (rec_off > end_rec_off) {\n\t\trec_off -= 2;\n\t\tend_off = hfs_bnode_read_u16(parent, rec_off);\n\t\thfs_bnode_write_u16(parent, rec_off, end_off + diff);\n\t}\n\thfs_bnode_move(parent, start_off + diff, start_off,\n\t\t       end_off - start_off);\nskip:\n\thfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);\n\thfs_bnode_dump(parent);\n\n\thfs_bnode_put(node);\n\tnode = parent;\n\n\tif (new_node) {\n\t\t__be32 cnid;\n\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\t\t/* create index key and entry */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\tcnid = cpu_to_be32(new_node->this);\n\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\t\thfs_brec_insert(fd, &cnid, sizeof(cnid));\n\t\thfs_bnode_put(fd->bnode);\n\t\thfs_bnode_put(new_node);\n\n\t\tif (!rec) {\n\t\t\tif (new_node == node)\n\t\t\t\tgoto out;\n\t\t\t/* restore search_key */\n\t\t\thfs_bnode_read_key(node, fd->search_key, 14);\n\t\t}\n\t}\n\n\tif (!rec && node->parent)\n\t\tgoto again;\nout:\n\tfd->bnode = node;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_dump",
          "args": [
            "node"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "299-334",
          "snippet": "void hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_move",
          "args": [
            "node",
            "fd->keyoffset",
            "fd->keyoffset + size",
            "data_off - fd->keyoffset - size"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "186-297",
          "snippet": "void hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc = (src & ~PAGE_CACHE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst = (dst & ~PAGE_CACHE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tmemmove(kmap(*dst_page), kmap(*src_page), src);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, len);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_CACHE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (dst == PAGE_CACHE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc &= ~PAGE_CACHE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst &= ~PAGE_CACHE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\t\tmemmove(kmap(*++dst_page),\n\t\t\t\t\tkmap(*++src_page), l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (PAGE_CACHE_SIZE - src <\n\t\t\t\t\t\tPAGE_CACHE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc = (src & ~PAGE_CACHE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst = (dst & ~PAGE_CACHE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tmemmove(kmap(*dst_page), kmap(*src_page), src);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, len);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_CACHE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (dst == PAGE_CACHE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc &= ~PAGE_CACHE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst &= ~PAGE_CACHE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\t\tmemmove(kmap(*++dst_page),\n\t\t\t\t\tkmap(*++src_page), l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (PAGE_CACHE_SIZE - src <\n\t\t\t\t\t\tPAGE_CACHE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write_u16",
          "args": [
            "node",
            "rec_off + 2",
            "data_off - size"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "97-102",
          "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "node",
            "rec_off"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfs_brec_find",
          "args": [
            "node",
            "fd",
            "hfs_find_rec_by_key"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "113-161",
          "snippet": "int __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "node"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "parent"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "node->parent"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_unlink",
          "args": [
            "node"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "336-375",
          "snippet": "void hfs_bnode_unlink(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *tmp;\n\t__be32 cnid;\n\n\ttree = node->tree;\n\tif (node->prev) {\n\t\ttmp = hfs_bnode_find(tree, node->prev);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->next = node->next;\n\t\tcnid = cpu_to_be32(tmp->next);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, next), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_head = node->next;\n\n\tif (node->next) {\n\t\ttmp = hfs_bnode_find(tree, node->next);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->prev = node->prev;\n\t\tcnid = cpu_to_be32(tmp->prev);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, prev), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_tail = node->prev;\n\n\t/* move down? */\n\tif (!node->prev && !node->next)\n\t\thfs_dbg(BNODE_MOD, \"hfs_btree_del_level\\n\");\n\tif (!node->parent) {\n\t\ttree->root = 0;\n\t\ttree->depth = 0;\n\t}\n\tset_bit(HFS_BNODE_DELETED, &node->flags);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_unlink(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *tmp;\n\t__be32 cnid;\n\n\ttree = node->tree;\n\tif (node->prev) {\n\t\ttmp = hfs_bnode_find(tree, node->prev);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->next = node->next;\n\t\tcnid = cpu_to_be32(tmp->next);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, next), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_head = node->next;\n\n\tif (node->next) {\n\t\ttmp = hfs_bnode_find(tree, node->next);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->prev = node->prev;\n\t\tcnid = cpu_to_be32(tmp->prev);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, prev), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_tail = node->prev;\n\n\t/* move down? */\n\tif (!node->prev && !node->next)\n\t\thfs_dbg(BNODE_MOD, \"hfs_btree_del_level\\n\");\n\tif (!node->parent) {\n\t\ttree->root = 0;\n\t\ttree->depth = 0;\n\t}\n\tset_bit(HFS_BNODE_DELETED, &node->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"remove_rec: %d, %d\\n\"",
            "fd->record",
            "fd->keylength + fd->entrylength"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "tree->inode"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_brec_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
    "lines": "62-175",
    "snippet": "int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
      "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
      "static int hfs_btree_inc_height(struct hfs_btree *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "tree->max_key_len"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "fd->search_key->key_len"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "new_node"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfs_brec_find",
          "args": [
            "fd->bnode",
            "fd",
            "hfs_find_rec_by_key"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "113-161",
          "snippet": "int __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint __hfs_brec_find(struct hfs_bnode *bnode, struct hfs_find_data *fd,\n\t\t\t\t\tsearch_strategy_t rec_found)\n{\n\tu16 off, len, keylen;\n\tint rec;\n\tint b, e;\n\tint res;\n\n\tif (!rec_found)\n\t\tBUG();\n\n\tb = 0;\n\te = bnode->num_recs - 1;\n\tres = -ENOENT;\n\tdo {\n\t\trec = (e + b) / 2;\n\t\tlen = hfs_brec_lenoff(bnode, rec, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, rec);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t\tif (rec_found(bnode, fd, &b, &e, &rec)) {\n\t\t\tres = 0;\n\t\t\tgoto done;\n\t\t}\n\t} while (b <= e);\n\n\tif (rec != e && e >= 0) {\n\t\tlen = hfs_brec_lenoff(bnode, e, &off);\n\t\tkeylen = hfs_brec_keylen(bnode, e);\n\t\tif (keylen == 0) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\thfs_bnode_read(bnode, fd->key, off, keylen);\n\t}\n\ndone:\n\tfd->record = e;\n\tfd->keyoffset = off;\n\tfd->keylength = keylen;\n\tfd->entryoffset = off + keylen;\n\tfd->entrylength = len - keylen;\n\nfail:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_key",
          "args": [
            "new_node",
            "fd->search_key",
            "14"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "58-72",
          "snippet": "void hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)\n{\n\tstruct hfs_btree *tree;\n\tint key_len;\n\n\ttree = node->tree;\n\tif (node->type == HFS_NODE_LEAF ||\n\t    tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t    node->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\tkey_len = hfs_bnode_read_u16(node, off) + 2;\n\telse\n\t\tkey_len = tree->max_key_len + 2;\n\n\thfs_bnode_read(node, key, off, key_len);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)\n{\n\tstruct hfs_btree *tree;\n\tint key_len;\n\n\ttree = node->tree;\n\tif (node->type == HFS_NODE_LEAF ||\n\t    tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t    node->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\tkey_len = hfs_bnode_read_u16(node, off) + 2;\n\telse\n\t\tkey_len = tree->max_key_len + 2;\n\n\thfs_bnode_read(node, key, off, key_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "new_node->this"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "new_node->parent"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_btree_inc_height",
          "args": [
            "tree"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_btree_inc_height",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "455-527",
          "snippet": "static int hfs_btree_inc_height(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *new_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint key_size, rec;\n\t__be32 cnid;\n\n\tnode = NULL;\n\tif (tree->root) {\n\t\tnode = hfs_bnode_find(tree, tree->root);\n\t\tif (IS_ERR(node))\n\t\t\treturn PTR_ERR(node);\n\t}\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node)) {\n\t\thfs_bnode_put(node);\n\t\treturn PTR_ERR(new_node);\n\t}\n\n\ttree->root = new_node->this;\n\tif (!tree->depth) {\n\t\ttree->leaf_head = tree->leaf_tail = new_node->this;\n\t\tnew_node->type = HFS_NODE_LEAF;\n\t\tnew_node->num_recs = 0;\n\t} else {\n\t\tnew_node->type = HFS_NODE_INDEX;\n\t\tnew_node->num_recs = 1;\n\t}\n\tnew_node->parent = 0;\n\tnew_node->next = 0;\n\tnew_node->prev = 0;\n\tnew_node->height = ++tree->depth;\n\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\trec = tree->node_size - 2;\n\thfs_bnode_write_u16(new_node, rec, 14);\n\n\tif (node) {\n\t\t/* insert old root idx into new root */\n\t\tnode->parent = tree->root;\n\t\tif (node->type == HFS_NODE_LEAF ||\n\t\t\t\ttree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\ttree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\tkey_size = hfs_bnode_read_u16(node, 14) + 2;\n\t\telse\n\t\t\tkey_size = tree->max_key_len + 2;\n\t\thfs_bnode_copy(new_node, 14, node, 14, key_size);\n\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t\t\t\t(tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\t\tkey_size = tree->max_key_len + 2;\n\t\t\thfs_bnode_write_u16(new_node, 14, tree->max_key_len);\n\t\t}\n\t\tcnid = cpu_to_be32(node->this);\n\t\thfs_bnode_write(new_node, &cnid, 14 + key_size, 4);\n\n\t\trec -= 2;\n\t\thfs_bnode_write_u16(new_node, rec, 14 + key_size + 4);\n\n\t\thfs_bnode_put(node);\n\t}\n\thfs_bnode_put(new_node);\n\tmark_inode_dirty(tree->inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nstatic int hfs_btree_inc_height(struct hfs_btree *tree)\n{\n\tstruct hfs_bnode *node, *new_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint key_size, rec;\n\t__be32 cnid;\n\n\tnode = NULL;\n\tif (tree->root) {\n\t\tnode = hfs_bnode_find(tree, tree->root);\n\t\tif (IS_ERR(node))\n\t\t\treturn PTR_ERR(node);\n\t}\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node)) {\n\t\thfs_bnode_put(node);\n\t\treturn PTR_ERR(new_node);\n\t}\n\n\ttree->root = new_node->this;\n\tif (!tree->depth) {\n\t\ttree->leaf_head = tree->leaf_tail = new_node->this;\n\t\tnew_node->type = HFS_NODE_LEAF;\n\t\tnew_node->num_recs = 0;\n\t} else {\n\t\tnew_node->type = HFS_NODE_INDEX;\n\t\tnew_node->num_recs = 1;\n\t}\n\tnew_node->parent = 0;\n\tnew_node->next = 0;\n\tnew_node->prev = 0;\n\tnew_node->height = ++tree->depth;\n\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\trec = tree->node_size - 2;\n\thfs_bnode_write_u16(new_node, rec, 14);\n\n\tif (node) {\n\t\t/* insert old root idx into new root */\n\t\tnode->parent = tree->root;\n\t\tif (node->type == HFS_NODE_LEAF ||\n\t\t\t\ttree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\ttree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\tkey_size = hfs_bnode_read_u16(node, 14) + 2;\n\t\telse\n\t\t\tkey_size = tree->max_key_len + 2;\n\t\thfs_bnode_copy(new_node, 14, node, 14, key_size);\n\n\t\tif (!(tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t\t\t\t(tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\t\tkey_size = tree->max_key_len + 2;\n\t\t\thfs_bnode_write_u16(new_node, 14, tree->max_key_len);\n\t\t}\n\t\tcnid = cpu_to_be32(node->this);\n\t\thfs_bnode_write(new_node, &cnid, 14 + key_size, 4);\n\n\t\trec -= 2;\n\t\thfs_bnode_write_u16(new_node, rec, 14 + key_size + 4);\n\n\t\thfs_bnode_put(node);\n\t}\n\thfs_bnode_put(new_node);\n\tmark_inode_dirty(tree->inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_update_parent",
          "args": [
            "fd"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_update_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "354-453",
          "snippet": "static int hfs_brec_update_parent(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *parent;\n\tint newkeylen, diff;\n\tint rec, rec_off, end_rec_off;\n\tint start_off, end_off;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = NULL;\n\tif (!node->parent)\n\t\treturn 0;\n\nagain:\n\tparent = hfs_bnode_find(tree, node->parent);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\t__hfs_brec_find(parent, fd, hfs_find_rec_by_key);\n\tif (fd->record < 0)\n\t\treturn -ENOENT;\n\thfs_bnode_dump(parent);\n\trec = fd->record;\n\n\t/* size difference between old and new key */\n\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\tnewkeylen = hfs_bnode_read_u16(node, 14) + 2;\n\telse\n\t\tfd->keylength = newkeylen = tree->max_key_len + 2;\n\thfs_dbg(BNODE_MOD, \"update_rec: %d, %d, %d\\n\",\n\t\trec, fd->keylength, newkeylen);\n\n\trec_off = tree->node_size - (rec + 2) * 2;\n\tend_rec_off = tree->node_size - (parent->num_recs + 1) * 2;\n\tdiff = newkeylen - fd->keylength;\n\tif (!diff)\n\t\tgoto skip;\n\tif (diff > 0) {\n\t\tend_off = hfs_bnode_read_u16(parent, end_rec_off);\n\t\tif (end_rec_off - end_off < diff) {\n\n\t\t\thfs_dbg(BNODE_MOD, \"splitting index node\\n\");\n\t\t\tfd->bnode = parent;\n\t\t\tnew_node = hfs_bnode_split(fd);\n\t\t\tif (IS_ERR(new_node))\n\t\t\t\treturn PTR_ERR(new_node);\n\t\t\tparent = fd->bnode;\n\t\t\trec = fd->record;\n\t\t\trec_off = tree->node_size - (rec + 2) * 2;\n\t\t\tend_rec_off = tree->node_size -\n\t\t\t\t(parent->num_recs + 1) * 2;\n\t\t}\n\t}\n\n\tend_off = start_off = hfs_bnode_read_u16(parent, rec_off);\n\thfs_bnode_write_u16(parent, rec_off, start_off + diff);\n\tstart_off -= 4;\t/* move previous cnid too */\n\n\twhile (rec_off > end_rec_off) {\n\t\trec_off -= 2;\n\t\tend_off = hfs_bnode_read_u16(parent, rec_off);\n\t\thfs_bnode_write_u16(parent, rec_off, end_off + diff);\n\t}\n\thfs_bnode_move(parent, start_off + diff, start_off,\n\t\t       end_off - start_off);\nskip:\n\thfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);\n\thfs_bnode_dump(parent);\n\n\thfs_bnode_put(node);\n\tnode = parent;\n\n\tif (new_node) {\n\t\t__be32 cnid;\n\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\t\t/* create index key and entry */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\tcnid = cpu_to_be32(new_node->this);\n\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\t\thfs_brec_insert(fd, &cnid, sizeof(cnid));\n\t\thfs_bnode_put(fd->bnode);\n\t\thfs_bnode_put(new_node);\n\n\t\tif (!rec) {\n\t\t\tif (new_node == node)\n\t\t\t\tgoto out;\n\t\t\t/* restore search_key */\n\t\t\thfs_bnode_read_key(node, fd->search_key, 14);\n\t\t}\n\t}\n\n\tif (!rec && node->parent)\n\t\tgoto again;\nout:\n\tfd->bnode = node;\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *parent;\n\tint newkeylen, diff;\n\tint rec, rec_off, end_rec_off;\n\tint start_off, end_off;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = NULL;\n\tif (!node->parent)\n\t\treturn 0;\n\nagain:\n\tparent = hfs_bnode_find(tree, node->parent);\n\tif (IS_ERR(parent))\n\t\treturn PTR_ERR(parent);\n\t__hfs_brec_find(parent, fd, hfs_find_rec_by_key);\n\tif (fd->record < 0)\n\t\treturn -ENOENT;\n\thfs_bnode_dump(parent);\n\trec = fd->record;\n\n\t/* size difference between old and new key */\n\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\tnewkeylen = hfs_bnode_read_u16(node, 14) + 2;\n\telse\n\t\tfd->keylength = newkeylen = tree->max_key_len + 2;\n\thfs_dbg(BNODE_MOD, \"update_rec: %d, %d, %d\\n\",\n\t\trec, fd->keylength, newkeylen);\n\n\trec_off = tree->node_size - (rec + 2) * 2;\n\tend_rec_off = tree->node_size - (parent->num_recs + 1) * 2;\n\tdiff = newkeylen - fd->keylength;\n\tif (!diff)\n\t\tgoto skip;\n\tif (diff > 0) {\n\t\tend_off = hfs_bnode_read_u16(parent, end_rec_off);\n\t\tif (end_rec_off - end_off < diff) {\n\n\t\t\thfs_dbg(BNODE_MOD, \"splitting index node\\n\");\n\t\t\tfd->bnode = parent;\n\t\t\tnew_node = hfs_bnode_split(fd);\n\t\t\tif (IS_ERR(new_node))\n\t\t\t\treturn PTR_ERR(new_node);\n\t\t\tparent = fd->bnode;\n\t\t\trec = fd->record;\n\t\t\trec_off = tree->node_size - (rec + 2) * 2;\n\t\t\tend_rec_off = tree->node_size -\n\t\t\t\t(parent->num_recs + 1) * 2;\n\t\t}\n\t}\n\n\tend_off = start_off = hfs_bnode_read_u16(parent, rec_off);\n\thfs_bnode_write_u16(parent, rec_off, start_off + diff);\n\tstart_off -= 4;\t/* move previous cnid too */\n\n\twhile (rec_off > end_rec_off) {\n\t\trec_off -= 2;\n\t\tend_off = hfs_bnode_read_u16(parent, rec_off);\n\t\thfs_bnode_write_u16(parent, rec_off, end_off + diff);\n\t}\n\thfs_bnode_move(parent, start_off + diff, start_off,\n\t\t       end_off - start_off);\nskip:\n\thfs_bnode_copy(parent, fd->keyoffset, node, 14, newkeylen);\n\thfs_bnode_dump(parent);\n\n\thfs_bnode_put(node);\n\tnode = parent;\n\n\tif (new_node) {\n\t\t__be32 cnid;\n\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\t\t/* create index key and entry */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\tcnid = cpu_to_be32(new_node->this);\n\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\t\thfs_brec_insert(fd, &cnid, sizeof(cnid));\n\t\thfs_bnode_put(fd->bnode);\n\t\thfs_bnode_put(new_node);\n\n\t\tif (!rec) {\n\t\t\tif (new_node == node)\n\t\t\t\tgoto out;\n\t\t\t/* restore search_key */\n\t\t\thfs_bnode_read_key(node, fd->search_key, 14);\n\t\t}\n\t}\n\n\tif (!rec && node->parent)\n\t\tgoto again;\nout:\n\tfd->bnode = node;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_dump",
          "args": [
            "node"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "299-334",
          "snippet": "void hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "node",
            "entry",
            "data_off + key_len",
            "entry_len"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_move",
          "args": [
            "node",
            "data_off + size",
            "data_off",
            "end_off - data_off"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "186-297",
          "snippet": "void hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc = (src & ~PAGE_CACHE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst = (dst & ~PAGE_CACHE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tmemmove(kmap(*dst_page), kmap(*src_page), src);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, len);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_CACHE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (dst == PAGE_CACHE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc &= ~PAGE_CACHE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst &= ~PAGE_CACHE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\t\tmemmove(kmap(*++dst_page),\n\t\t\t\t\tkmap(*++src_page), l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (PAGE_CACHE_SIZE - src <\n\t\t\t\t\t\tPAGE_CACHE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc = (src & ~PAGE_CACHE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst = (dst & ~PAGE_CACHE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tmemmove(kmap(*dst_page), kmap(*src_page), src);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, len);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_CACHE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (dst == PAGE_CACHE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc &= ~PAGE_CACHE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst &= ~PAGE_CACHE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\t\tmemmove(kmap(*++dst_page),\n\t\t\t\t\tkmap(*++src_page), l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (PAGE_CACHE_SIZE - src <\n\t\t\t\t\t\tPAGE_CACHE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write_u16",
          "args": [
            "node",
            "data_rec_off",
            "data_off + size"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "97-102",
          "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "node",
            "data_rec_off + 2"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "tree->inode"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_node"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_node"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_split",
          "args": [
            "fd"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "233-352",
          "snippet": "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *next_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint num_recs, new_rec_off, new_off, old_rec_off;\n\tint data_start, data_end, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node))\n\t\treturn new_node;\n\thfs_bnode_get(node);\n\thfs_dbg(BNODE_MOD, \"split_nodes: %d - %d - %d\\n\",\n\t\tnode->this, new_node->this, node->next);\n\tnew_node->next = node->next;\n\tnew_node->prev = node->this;\n\tnew_node->parent = node->parent;\n\tnew_node->type = node->type;\n\tnew_node->height = node->height;\n\n\tif (node->next)\n\t\tnext_node = hfs_bnode_find(tree, node->next);\n\telse\n\t\tnext_node = NULL;\n\n\tif (IS_ERR(next_node)) {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\treturn next_node;\n\t}\n\n\tsize = tree->node_size / 2 - node->num_recs * 2 - 14;\n\told_rec_off = tree->node_size - 4;\n\tnum_recs = 1;\n\tfor (;;) {\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t\tif (data_start > size)\n\t\t\tbreak;\n\t\told_rec_off -= 2;\n\t\tif (++num_recs < node->num_recs)\n\t\t\tcontinue;\n\t\t/* panic? */\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\tif (next_node)\n\t\t\thfs_bnode_put(next_node);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tif (fd->record + 1 < num_recs) {\n\t\t/* new record is in the lower half,\n\t\t * so leave some more space there\n\t\t */\n\t\told_rec_off += 2;\n\t\tnum_recs--;\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t} else {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_get(new_node);\n\t\tfd->bnode = new_node;\n\t\tfd->record -= num_recs;\n\t\tfd->keyoffset -= data_start - 14;\n\t\tfd->entryoffset -= data_start - 14;\n\t}\n\tnew_node->num_recs = node->num_recs - num_recs;\n\tnode->num_recs = num_recs;\n\n\tnew_rec_off = tree->node_size - 2;\n\tnew_off = 14;\n\tsize = data_start - new_off;\n\tnum_recs = new_node->num_recs;\n\tdata_end = data_start;\n\twhile (num_recs) {\n\t\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\t\told_rec_off -= 2;\n\t\tnew_rec_off -= 2;\n\t\tdata_end = hfs_bnode_read_u16(node, old_rec_off);\n\t\tnew_off = data_end - size;\n\t\tnum_recs--;\n\t}\n\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\thfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);\n\n\t/* update new bnode header */\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update previous bnode header */\n\tnode->next = new_node->this;\n\thfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));\n\tnode_desc.next = cpu_to_be32(node->next);\n\tnode_desc.num_recs = cpu_to_be16(node->num_recs);\n\thfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update next bnode header */\n\tif (next_node) {\n\t\tnext_node->prev = new_node->this;\n\t\thfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));\n\t\tnode_desc.prev = cpu_to_be32(next_node->prev);\n\t\thfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));\n\t\thfs_bnode_put(next_node);\n\t} else if (node->this == tree->leaf_tail) {\n\t\t/* if there is no next node, this might be the new tail */\n\t\ttree->leaf_tail = new_node->this;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\n\thfs_bnode_dump(node);\n\thfs_bnode_dump(new_node);\n\thfs_bnode_put(node);\n\n\treturn new_node;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node, *next_node;\n\tstruct hfs_bnode_desc node_desc;\n\tint num_recs, new_rec_off, new_off, old_rec_off;\n\tint data_start, data_end, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\n\tnew_node = hfs_bmap_alloc(tree);\n\tif (IS_ERR(new_node))\n\t\treturn new_node;\n\thfs_bnode_get(node);\n\thfs_dbg(BNODE_MOD, \"split_nodes: %d - %d - %d\\n\",\n\t\tnode->this, new_node->this, node->next);\n\tnew_node->next = node->next;\n\tnew_node->prev = node->this;\n\tnew_node->parent = node->parent;\n\tnew_node->type = node->type;\n\tnew_node->height = node->height;\n\n\tif (node->next)\n\t\tnext_node = hfs_bnode_find(tree, node->next);\n\telse\n\t\tnext_node = NULL;\n\n\tif (IS_ERR(next_node)) {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\treturn next_node;\n\t}\n\n\tsize = tree->node_size / 2 - node->num_recs * 2 - 14;\n\told_rec_off = tree->node_size - 4;\n\tnum_recs = 1;\n\tfor (;;) {\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t\tif (data_start > size)\n\t\t\tbreak;\n\t\told_rec_off -= 2;\n\t\tif (++num_recs < node->num_recs)\n\t\t\tcontinue;\n\t\t/* panic? */\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_put(new_node);\n\t\tif (next_node)\n\t\t\thfs_bnode_put(next_node);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tif (fd->record + 1 < num_recs) {\n\t\t/* new record is in the lower half,\n\t\t * so leave some more space there\n\t\t */\n\t\told_rec_off += 2;\n\t\tnum_recs--;\n\t\tdata_start = hfs_bnode_read_u16(node, old_rec_off);\n\t} else {\n\t\thfs_bnode_put(node);\n\t\thfs_bnode_get(new_node);\n\t\tfd->bnode = new_node;\n\t\tfd->record -= num_recs;\n\t\tfd->keyoffset -= data_start - 14;\n\t\tfd->entryoffset -= data_start - 14;\n\t}\n\tnew_node->num_recs = node->num_recs - num_recs;\n\tnode->num_recs = num_recs;\n\n\tnew_rec_off = tree->node_size - 2;\n\tnew_off = 14;\n\tsize = data_start - new_off;\n\tnum_recs = new_node->num_recs;\n\tdata_end = data_start;\n\twhile (num_recs) {\n\t\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\t\told_rec_off -= 2;\n\t\tnew_rec_off -= 2;\n\t\tdata_end = hfs_bnode_read_u16(node, old_rec_off);\n\t\tnew_off = data_end - size;\n\t\tnum_recs--;\n\t}\n\thfs_bnode_write_u16(new_node, new_rec_off, new_off);\n\thfs_bnode_copy(new_node, 14, node, data_start, data_end - data_start);\n\n\t/* update new bnode header */\n\tnode_desc.next = cpu_to_be32(new_node->next);\n\tnode_desc.prev = cpu_to_be32(new_node->prev);\n\tnode_desc.type = new_node->type;\n\tnode_desc.height = new_node->height;\n\tnode_desc.num_recs = cpu_to_be16(new_node->num_recs);\n\tnode_desc.reserved = 0;\n\thfs_bnode_write(new_node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update previous bnode header */\n\tnode->next = new_node->this;\n\thfs_bnode_read(node, &node_desc, 0, sizeof(node_desc));\n\tnode_desc.next = cpu_to_be32(node->next);\n\tnode_desc.num_recs = cpu_to_be16(node->num_recs);\n\thfs_bnode_write(node, &node_desc, 0, sizeof(node_desc));\n\n\t/* update next bnode header */\n\tif (next_node) {\n\t\tnext_node->prev = new_node->this;\n\t\thfs_bnode_read(next_node, &node_desc, 0, sizeof(node_desc));\n\t\tnode_desc.prev = cpu_to_be32(next_node->prev);\n\t\thfs_bnode_write(next_node, &node_desc, 0, sizeof(node_desc));\n\t\thfs_bnode_put(next_node);\n\t} else if (node->this == tree->leaf_tail) {\n\t\t/* if there is no next node, this might be the new tail */\n\t\ttree->leaf_tail = new_node->this;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\n\thfs_bnode_dump(node);\n\thfs_bnode_dump(new_node);\n\thfs_bnode_put(node);\n\n\treturn new_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"not enough room!\\n\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"insert_rec: %d, %d, %d, %d\\n\"",
            "rec",
            "size",
            "end_off",
            "end_rec_off"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "fd->search_key->key_len"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fd->bnode"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fd->bnode"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfs_brec_keylen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
    "lines": "31-60",
    "snippet": "u16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)\n{\n\tu16 retval, recoff;\n\n\tif (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)\n\t\treturn 0;\n\n\tif ((node->type == HFS_NODE_INDEX) &&\n\t   !(node->tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t   (node->tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\tretval = node->tree->max_key_len + 2;\n\t} else {\n\t\trecoff = hfs_bnode_read_u16(node,\n\t\t\tnode->tree->node_size - (rec + 1) * 2);\n\t\tif (!recoff)\n\t\t\treturn 0;\n\t\tif (recoff > node->tree->node_size - 2) {\n\t\t\tpr_err(\"recoff %d too large\\n\", recoff);\n\t\t\treturn 0;\n\t\t}\n\n\t\tretval = hfs_bnode_read_u16(node, recoff) + 2;\n\t\tif (retval > node->tree->max_key_len + 2) {\n\t\t\tpr_err(\"keylen %d too large\\n\",\n\t\t\t\tretval);\n\t\t\tretval = 0;\n\t\t}\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"keylen %d too large\\n\"",
            "retval"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "node",
            "recoff"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"recoff %d too large\\n\"",
            "recoff"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nu16 hfs_brec_keylen(struct hfs_bnode *node, u16 rec)\n{\n\tu16 retval, recoff;\n\n\tif (node->type != HFS_NODE_INDEX && node->type != HFS_NODE_LEAF)\n\t\treturn 0;\n\n\tif ((node->type == HFS_NODE_INDEX) &&\n\t   !(node->tree->attributes & HFS_TREE_VARIDXKEYS) &&\n\t   (node->tree->cnid != HFSPLUS_ATTR_CNID)) {\n\t\tretval = node->tree->max_key_len + 2;\n\t} else {\n\t\trecoff = hfs_bnode_read_u16(node,\n\t\t\tnode->tree->node_size - (rec + 1) * 2);\n\t\tif (!recoff)\n\t\t\treturn 0;\n\t\tif (recoff > node->tree->node_size - 2) {\n\t\t\tpr_err(\"recoff %d too large\\n\", recoff);\n\t\t\treturn 0;\n\t\t}\n\n\t\tretval = hfs_bnode_read_u16(node, recoff) + 2;\n\t\tif (retval > node->tree->max_key_len + 2) {\n\t\t\tpr_err(\"keylen %d too large\\n\",\n\t\t\t\tretval);\n\t\t\tretval = 0;\n\t\t}\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "hfs_brec_lenoff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
    "lines": "19-28",
    "snippet": "u16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "retval[0]"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "retval[1]"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "node",
            "retval",
            "dataoff",
            "4"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nu16 hfs_brec_lenoff(struct hfs_bnode *node, u16 rec, u16 *off)\n{\n\t__be16 retval[2];\n\tu16 dataoff;\n\n\tdataoff = node->tree->node_size - (rec + 2) * 2;\n\thfs_bnode_read(node, retval, dataoff, 4);\n\t*off = be16_to_cpu(retval[1]);\n\treturn be16_to_cpu(retval[0]) - *off;\n}"
  }
]