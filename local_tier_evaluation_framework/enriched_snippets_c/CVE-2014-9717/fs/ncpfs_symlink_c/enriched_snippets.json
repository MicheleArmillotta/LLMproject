[
  {
    "function_name": "ncp_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/symlink.c",
    "lines": "106-179",
    "snippet": "int ncp_symlink(struct inode *dir, struct dentry *dentry, const char *symname) {\n\tstruct inode *inode;\n\tchar *rawlink;\n\tint length, err, i, outlen;\n\tint kludge;\n\tumode_t mode;\n\t__le32 attr;\n\tunsigned int hdr;\n\n\tncp_dbg(1, \"dir=%p, dentry=%p, symname=%s\\n\", dir, dentry, symname);\n\n\tif (ncp_is_nfs_extras(NCP_SERVER(dir), NCP_FINFO(dir)->volNumber))\n\t\tkludge = 0;\n\telse\n#ifdef CONFIG_NCPFS_EXTRAS\n\tif (NCP_SERVER(dir)->m.flags & NCP_MOUNT_SYMLINKS)\n\t\tkludge = 1;\n\telse\n#endif\n\t/* EPERM is returned by VFS if symlink procedure does not exist */\n\t\treturn -EPERM;\n  \n\trawlink = kmalloc(NCP_MAX_SYMLINK_SIZE, GFP_KERNEL);\n\tif (!rawlink)\n\t\treturn -ENOMEM;\n\n\tif (kludge) {\n\t\tmode = 0;\n\t\tattr = aSHARED | aHIDDEN;\n\t\t((__le32 *)rawlink)[0]=NCP_SYMLINK_MAGIC0;\n\t\t((__le32 *)rawlink)[1]=NCP_SYMLINK_MAGIC1;\n\t\thdr = 8;\n\t} else {\n\t\tmode = S_IFLNK | S_IRWXUGO;\n\t\tattr = 0;\n\t\thdr = 0;\n\t}\t\t\t\n\n\tlength = strlen(symname);\n\t/* map to/from server charset, do not touch upper/lower case as\n\t   symlink can point out of ncp filesystem */\n\toutlen = NCP_MAX_SYMLINK_SIZE - hdr;\n\terr = ncp_io2vol(NCP_SERVER(dir), rawlink + hdr, &outlen, symname, length, 0);\n\tif (err)\n\t\tgoto failfree;\n\n\toutlen += hdr;\n\n\terr = -EIO;\n\tif (ncp_create_new(dir,dentry,mode,0,attr)) {\n\t\tgoto failfree;\n\t}\n\n\tinode=dentry->d_inode;\n\n\tif (ncp_make_open(inode, O_WRONLY))\n\t\tgoto failfree;\n\n\tif (ncp_write_kernel(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle, \n\t\t\t     0, outlen, rawlink, &i) || i!=outlen) {\n\t\tgoto fail;\n\t}\n\n\tncp_inode_close(inode);\n\tncp_make_closed(inode);\n\tkfree(rawlink);\n\treturn 0;\nfail:;\n\tncp_inode_close(inode);\n\tncp_make_closed(inode);\nfailfree:;\n\tkfree(rawlink);\n\treturn err;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [
      "#define NCP_SYMLINK_MAGIC1\tcpu_to_le32(0x3e2d6b6e)",
      "#define NCP_SYMLINK_MAGIC0\tcpu_to_le32(0x6c6d7973)     /* \"symlnk->\" */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rawlink"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_closed",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_closed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "286-304",
          "snippet": "int\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_inode_close",
          "args": [
            "inode"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_inode_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "62-64",
          "snippet": "static inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rawlink"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_write_kernel",
          "args": [
            "NCP_SERVER(inode)",
            "NCP_FINFO(inode)->file_handle",
            "0",
            "outlen",
            "rawlink",
            "&i"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_write_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "1035-1053",
          "snippet": "int\nncp_write_kernel(struct ncp_server *server, const char *file_id,\n\t\t __u32 offset, __u16 to_write,\n\t\t const char *source, int *bytes_written)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_write);\n\tncp_add_mem(server, source, to_write);\n\t\n\tif ((result = ncp_request(server, 73)) == 0)\n\t\t*bytes_written = to_write;\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_write_kernel(struct ncp_server *server, const char *file_id,\n\t\t __u32 offset, __u16 to_write,\n\t\t const char *source, int *bytes_written)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_write);\n\tncp_add_mem(server, source, to_write);\n\t\n\tif ((result = ncp_request(server, 73)) == 0)\n\t\t*bytes_written = to_write;\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_open",
          "args": [
            "inode",
            "O_WRONLY"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
          "lines": "32-98",
          "snippet": "int ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nint ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_create_new",
          "args": [
            "dir",
            "dentry",
            "mode",
            "0",
            "attr"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_create_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "910-966",
          "snippet": "int ncp_create_new(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t   dev_t rdev, __le32 attributes)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct ncp_entry_info finfo;\n\tint error, result, len;\n\tint opmode;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\t\n\tncp_vdbg(\"creating %pd2, mode=%hx\\n\", dentry, mode);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = -EACCES;\n\t\n\tif (S_ISREG(mode) && \n\t    (server->m.flags & NCP_MOUNT_EXTRAS) && \n\t    (mode & S_IXUGO))\n\t\tattributes |= aSYSTEM | aSHARED;\n\t\n\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_READ | AR_WRITE, &finfo);\n\topmode = O_RDWR;\n\tif (result) {\n\t\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_WRITE, &finfo);\n\t\tif (result) {\n\t\t\tif (result == 0x87)\n\t\t\t\terror = -ENAMETOOLONG;\n\t\t\telse if (result < 0)\n\t\t\t\terror = result;\n\t\t\tncp_dbg(1, \"%pd2 failed\\n\", dentry);\n\t\t\tgoto out;\n\t\t}\n\t\topmode = O_WRONLY;\n\t}\n\tfinfo.access = opmode;\n\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\tfinfo.i.nfs.mode = mode;\n\t\tfinfo.i.nfs.rdev = new_encode_dev(rdev);\n\t\tif (ncp_modify_nfs_info(server, finfo.volume,\n\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\tmode, new_encode_dev(rdev)) != 0)\n\t\t\tgoto out;\n\t}\n\n\terror = ncp_instantiate(dir, dentry, &finfo);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ncp_create(struct inode *, struct dentry *, umode_t, bool);",
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_mkdir(struct inode *, struct dentry *, umode_t);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_create(struct inode *, struct dentry *, umode_t, bool);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_mkdir(struct inode *, struct dentry *, umode_t);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nint ncp_create_new(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t   dev_t rdev, __le32 attributes)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct ncp_entry_info finfo;\n\tint error, result, len;\n\tint opmode;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\t\n\tncp_vdbg(\"creating %pd2, mode=%hx\\n\", dentry, mode);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = -EACCES;\n\t\n\tif (S_ISREG(mode) && \n\t    (server->m.flags & NCP_MOUNT_EXTRAS) && \n\t    (mode & S_IXUGO))\n\t\tattributes |= aSYSTEM | aSHARED;\n\t\n\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_READ | AR_WRITE, &finfo);\n\topmode = O_RDWR;\n\tif (result) {\n\t\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_WRITE, &finfo);\n\t\tif (result) {\n\t\t\tif (result == 0x87)\n\t\t\t\terror = -ENAMETOOLONG;\n\t\t\telse if (result < 0)\n\t\t\t\terror = result;\n\t\t\tncp_dbg(1, \"%pd2 failed\\n\", dentry);\n\t\t\tgoto out;\n\t\t}\n\t\topmode = O_WRONLY;\n\t}\n\tfinfo.access = opmode;\n\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\tfinfo.i.nfs.mode = mode;\n\t\tfinfo.i.nfs.rdev = new_encode_dev(rdev);\n\t\tif (ncp_modify_nfs_info(server, finfo.volume,\n\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\tmode, new_encode_dev(rdev)) != 0)\n\t\t\tgoto out;\n\t}\n\n\terror = ncp_instantiate(dir, dentry, &finfo);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "NCP_SERVER(dir)",
            "rawlink + hdr",
            "&outlen",
            "symname",
            "length",
            "0"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NCP_MAX_SYMLINK_SIZE",
            "GFP_KERNEL"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_is_nfs_extras",
          "args": [
            "NCP_SERVER(dir)",
            "NCP_FINFO(dir)->volNumber"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_nfs_extras",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "119-126",
          "snippet": "static inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"dir=%p, dentry=%p, symname=%s\\n\"",
            "dir",
            "dentry",
            "symname"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\n#define NCP_SYMLINK_MAGIC1\tcpu_to_le32(0x3e2d6b6e)\n#define NCP_SYMLINK_MAGIC0\tcpu_to_le32(0x6c6d7973)     /* \"symlnk->\" */\n\nint ncp_symlink(struct inode *dir, struct dentry *dentry, const char *symname) {\n\tstruct inode *inode;\n\tchar *rawlink;\n\tint length, err, i, outlen;\n\tint kludge;\n\tumode_t mode;\n\t__le32 attr;\n\tunsigned int hdr;\n\n\tncp_dbg(1, \"dir=%p, dentry=%p, symname=%s\\n\", dir, dentry, symname);\n\n\tif (ncp_is_nfs_extras(NCP_SERVER(dir), NCP_FINFO(dir)->volNumber))\n\t\tkludge = 0;\n\telse\n#ifdef CONFIG_NCPFS_EXTRAS\n\tif (NCP_SERVER(dir)->m.flags & NCP_MOUNT_SYMLINKS)\n\t\tkludge = 1;\n\telse\n#endif\n\t/* EPERM is returned by VFS if symlink procedure does not exist */\n\t\treturn -EPERM;\n  \n\trawlink = kmalloc(NCP_MAX_SYMLINK_SIZE, GFP_KERNEL);\n\tif (!rawlink)\n\t\treturn -ENOMEM;\n\n\tif (kludge) {\n\t\tmode = 0;\n\t\tattr = aSHARED | aHIDDEN;\n\t\t((__le32 *)rawlink)[0]=NCP_SYMLINK_MAGIC0;\n\t\t((__le32 *)rawlink)[1]=NCP_SYMLINK_MAGIC1;\n\t\thdr = 8;\n\t} else {\n\t\tmode = S_IFLNK | S_IRWXUGO;\n\t\tattr = 0;\n\t\thdr = 0;\n\t}\t\t\t\n\n\tlength = strlen(symname);\n\t/* map to/from server charset, do not touch upper/lower case as\n\t   symlink can point out of ncp filesystem */\n\toutlen = NCP_MAX_SYMLINK_SIZE - hdr;\n\terr = ncp_io2vol(NCP_SERVER(dir), rawlink + hdr, &outlen, symname, length, 0);\n\tif (err)\n\t\tgoto failfree;\n\n\toutlen += hdr;\n\n\terr = -EIO;\n\tif (ncp_create_new(dir,dentry,mode,0,attr)) {\n\t\tgoto failfree;\n\t}\n\n\tinode=dentry->d_inode;\n\n\tif (ncp_make_open(inode, O_WRONLY))\n\t\tgoto failfree;\n\n\tif (ncp_write_kernel(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle, \n\t\t\t     0, outlen, rawlink, &i) || i!=outlen) {\n\t\tgoto fail;\n\t}\n\n\tncp_inode_close(inode);\n\tncp_make_closed(inode);\n\tkfree(rawlink);\n\treturn 0;\nfail:;\n\tncp_inode_close(inode);\n\tncp_make_closed(inode);\nfailfree:;\n\tkfree(rawlink);\n\treturn err;\n}"
  },
  {
    "function_name": "ncp_symlink_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/symlink.c",
    "lines": "42-95",
    "snippet": "static int ncp_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint error, length, len;\n\tchar *link, *rawlink;\n\tchar *buf = kmap(page);\n\n\terror = -ENOMEM;\n\trawlink = kmalloc(NCP_MAX_SYMLINK_SIZE, GFP_KERNEL);\n\tif (!rawlink)\n\t\tgoto fail;\n\n\tif (ncp_make_open(inode,O_RDONLY))\n\t\tgoto failEIO;\n\n\terror=ncp_read_kernel(NCP_SERVER(inode),NCP_FINFO(inode)->file_handle,\n                         0,NCP_MAX_SYMLINK_SIZE,rawlink,&length);\n\n\tncp_inode_close(inode);\n\t/* Close file handle if no other users... */\n\tncp_make_closed(inode);\n\tif (error)\n\t\tgoto failEIO;\n\n\tif (NCP_FINFO(inode)->flags & NCPI_KLUDGE_SYMLINK) {\n\t\tif (length<NCP_MIN_SYMLINK_SIZE || \n\t\t    ((__le32 *)rawlink)[0]!=NCP_SYMLINK_MAGIC0 ||\n\t\t    ((__le32 *)rawlink)[1]!=NCP_SYMLINK_MAGIC1)\n\t\t    \tgoto failEIO;\n\t\tlink = rawlink + 8;\n\t\tlength -= 8;\n\t} else {\n\t\tlink = rawlink;\n\t}\n\n\tlen = NCP_MAX_SYMLINK_SIZE;\n\terror = ncp_vol2io(NCP_SERVER(inode), buf, &len, link, length, 0);\n\tkfree(rawlink);\n\tif (error)\n\t\tgoto fail;\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nfailEIO:\n\terror = -EIO;\n\tkfree(rawlink);\nfail:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn error;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [
      "#define NCP_SYMLINK_MAGIC1\tcpu_to_le32(0x3e2d6b6e)",
      "#define NCP_SYMLINK_MAGIC0\tcpu_to_le32(0x6c6d7973)     /* \"symlnk->\" */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rawlink"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rawlink"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_vol2io",
          "args": [
            "NCP_SERVER(inode)",
            "buf",
            "&len",
            "link",
            "length",
            "0"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_make_closed",
          "args": [
            "inode"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_closed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "286-304",
          "snippet": "int\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_inode_close",
          "args": [
            "inode"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_inode_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "62-64",
          "snippet": "static inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ncp_inode_close(struct inode *inode) {\n\tatomic_dec(&NCP_FINFO(inode)->opened);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_read_kernel",
          "args": [
            "NCP_SERVER(inode)",
            "NCP_FINFO(inode)->file_handle",
            "0",
            "NCP_MAX_SYMLINK_SIZE",
            "rawlink",
            "&length"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_read_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "966-989",
          "snippet": "int\nncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_read_kernel(struct ncp_server *server, const char *file_id,\n\t     __u32 offset, __u16 to_read, char *target, int *bytes_read)\n{\n\tconst char *source;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\tncp_add_be32(server, offset);\n\tncp_add_be16(server, to_read);\n\n\tif ((result = ncp_request(server, 72)) != 0) {\n\t\tgoto out;\n\t}\n\t*bytes_read = ncp_reply_be16(server, 0);\n\tsource = ncp_reply_data(server, 2 + (offset & 1));\n\n\tmemcpy(target, source, *bytes_read);\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_make_open",
          "args": [
            "inode",
            "O_RDONLY"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/file.c",
          "lines": "32-98",
          "snippet": "int ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/uaccess.h>\n\nint ncp_make_open(struct inode *inode, int right)\n{\n\tint error;\n\tint access;\n\n\terror = -EINVAL;\n\tif (!inode) {\n\t\tpr_err(\"%s: got NULL inode\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tncp_dbg(1, \"opened=%d, volume # %u, dir entry # %u\\n\",\n\t\tatomic_read(&NCP_FINFO(inode)->opened), \n\t\tNCP_FINFO(inode)->volNumber, \n\t\tNCP_FINFO(inode)->dirEntNum);\n\terror = -EACCES;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tstruct ncp_entry_info finfo;\n\t\tint result;\n\n\t\t/* tries max. rights */\n\t\tfinfo.access = O_RDWR;\n\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ | AR_WRITE, &finfo);\n\t\tif (!result)\n\t\t\tgoto update;\n\t\t/* RDWR did not succeeded, try readonly or writeonly as requested */\n\t\tswitch (right) {\n\t\t\tcase O_RDONLY:\n\t\t\t\tfinfo.access = O_RDONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_READ, &finfo);\n\t\t\t\tbreak;\n\t\t\tcase O_WRONLY:\n\t\t\t\tfinfo.access = O_WRONLY;\n\t\t\t\tresult = ncp_open_create_file_or_subdir(NCP_SERVER(inode),\n\t\t\t\t\tinode, NULL, OC_MODE_OPEN,\n\t\t\t\t\t0, AR_WRITE, &finfo);\n\t\t\t\tbreak;\n\t\t}\n\t\tif (result) {\n\t\t\tncp_vdbg(\"failed, result=%d\\n\", result);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\t/*\n\t\t * Update the inode information.\n\t\t */\n\tupdate:\n\t\tncp_update_inode(inode, &finfo);\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 1);\n\t}\n\n\taccess = NCP_FINFO(inode)->access;\n\tncp_vdbg(\"file open, access=%x\\n\", access);\n\tif (access == right || access == O_RDWR) {\n\t\tatomic_inc(&NCP_FINFO(inode)->opened);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NCP_MAX_SYMLINK_SIZE",
            "GFP_KERNEL"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\n#define NCP_SYMLINK_MAGIC1\tcpu_to_le32(0x3e2d6b6e)\n#define NCP_SYMLINK_MAGIC0\tcpu_to_le32(0x6c6d7973)     /* \"symlnk->\" */\n\nstatic int ncp_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint error, length, len;\n\tchar *link, *rawlink;\n\tchar *buf = kmap(page);\n\n\terror = -ENOMEM;\n\trawlink = kmalloc(NCP_MAX_SYMLINK_SIZE, GFP_KERNEL);\n\tif (!rawlink)\n\t\tgoto fail;\n\n\tif (ncp_make_open(inode,O_RDONLY))\n\t\tgoto failEIO;\n\n\terror=ncp_read_kernel(NCP_SERVER(inode),NCP_FINFO(inode)->file_handle,\n                         0,NCP_MAX_SYMLINK_SIZE,rawlink,&length);\n\n\tncp_inode_close(inode);\n\t/* Close file handle if no other users... */\n\tncp_make_closed(inode);\n\tif (error)\n\t\tgoto failEIO;\n\n\tif (NCP_FINFO(inode)->flags & NCPI_KLUDGE_SYMLINK) {\n\t\tif (length<NCP_MIN_SYMLINK_SIZE || \n\t\t    ((__le32 *)rawlink)[0]!=NCP_SYMLINK_MAGIC0 ||\n\t\t    ((__le32 *)rawlink)[1]!=NCP_SYMLINK_MAGIC1)\n\t\t    \tgoto failEIO;\n\t\tlink = rawlink + 8;\n\t\tlength -= 8;\n\t} else {\n\t\tlink = rawlink;\n\t}\n\n\tlen = NCP_MAX_SYMLINK_SIZE;\n\terror = ncp_vol2io(NCP_SERVER(inode), buf, &len, link, length, 0);\n\tkfree(rawlink);\n\tif (error)\n\t\tgoto fail;\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nfailEIO:\n\terror = -EIO;\n\tkfree(rawlink);\nfail:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn error;\n}"
  }
]