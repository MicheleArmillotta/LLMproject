[
  {
    "function_name": "cachefiles_dissociate_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "532-535",
    "snippet": "static void cachefiles_dissociate_pages(struct fscache_cache *cache)\n{\n\t_enter(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic void cachefiles_dissociate_pages(struct fscache_cache *cache)\n{\n\t_enter(\"\");\n}"
  },
  {
    "function_name": "cachefiles_invalidate_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "484-527",
    "snippet": "static void cachefiles_invalidate_object(struct fscache_operation *op)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tstruct path path;\n\tuint64_t ni_size;\n\tint ret;\n\n\tobject = container_of(op->object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\top->object->cookie->def->get_attr(op->object->cookie->netfs_data,\n\t\t\t\t\t  &ni_size);\n\n\t_enter(\"{OBJ%x},[%llu]\",\n\t       op->object->debug_id, (unsigned long long)ni_size);\n\n\tif (object->backer) {\n\t\tASSERT(d_is_reg(object->backer));\n\n\t\tfscache_set_store_limit(&object->fscache, ni_size);\n\n\t\tpath.dentry = object->backer;\n\t\tpath.mnt = cache->mnt;\n\n\t\tcachefiles_begin_secure(cache, &saved_cred);\n\t\tret = vfs_truncate(&path, 0);\n\t\tif (ret == 0)\n\t\t\tret = vfs_truncate(&path, ni_size);\n\t\tcachefiles_end_secure(cache, saved_cred);\n\n\t\tif (ret != 0) {\n\t\t\tfscache_set_store_limit(&object->fscache, 0);\n\t\t\tif (ret == -EIO)\n\t\t\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\t\t\"Invalidate failed\");\n\t\t}\n\t}\n\n\tfscache_op_complete(op, true);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_op_complete",
          "args": [
            "op",
            "true"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_op_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "365-391",
          "snippet": "void fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nvoid fscache_op_complete(struct fscache_operation *op, bool cancelled)\n{\n\tstruct fscache_object *object = op->object;\n\n\t_enter(\"OBJ%x\", object->debug_id);\n\n\tASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\n\tASSERTCMP(object->n_in_progress, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_exclusive, >, 0);\n\tASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\n\t\t    object->n_in_progress, ==, 1);\n\n\tspin_lock(&object->lock);\n\n\top->state = cancelled ?\n\t\tFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\n\n\tif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\n\t\tobject->n_exclusive--;\n\tobject->n_in_progress--;\n\tif (object->n_in_progress == 0)\n\t\tfscache_start_operations(object);\n\n\tspin_unlock(&object->lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Invalidate failed\""
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_set_store_limit",
          "args": [
            "&object->fscache",
            "0"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_truncate",
          "args": [
            "&path",
            "ni_size"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "66-115",
          "snippet": "long vfs_truncate(struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nlong vfs_truncate(struct path *path, loff_t length)\n{\n\tstruct inode *inode;\n\tlong error;\n\n\tinode = path->dentry->d_inode;\n\n\t/* For directories it's -EISDIR, for other non-regulars - -EINVAL */\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\terror = mnt_want_write(path->mnt);\n\tif (error)\n\t\tgoto out;\n\n\terror = inode_permission(inode, MAY_WRITE);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = -EPERM;\n\tif (IS_APPEND(inode))\n\t\tgoto mnt_drop_write_and_out;\n\n\terror = get_write_access(inode);\n\tif (error)\n\t\tgoto mnt_drop_write_and_out;\n\n\t/*\n\t * Make sure that there are no leases.  get_write_access() protects\n\t * against the truncate racing with a lease-granting setlease().\n\t */\n\terror = break_lease(inode, O_WRONLY);\n\tif (error)\n\t\tgoto put_write_and_out;\n\n\terror = locks_verify_truncate(inode, NULL, length);\n\tif (!error)\n\t\terror = security_path_truncate(path);\n\tif (!error)\n\t\terror = do_truncate(path->dentry, length, 0, NULL);\n\nput_write_and_out:\n\tput_write_access(inode);\nmnt_drop_write_and_out:\n\tmnt_drop_write(path->mnt);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_set_store_limit",
          "args": [
            "&object->fscache",
            "ni_size"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "d_is_reg(object->backer)"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "object->backer"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},[%llu]\"",
            "op->object->debug_id",
            "(unsigned long long)ni_size"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->object->cookie->def->get_attr",
          "args": [
            "op->object->cookie->netfs_data",
            "&ni_size"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op->object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic void cachefiles_invalidate_object(struct fscache_operation *op)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tstruct path path;\n\tuint64_t ni_size;\n\tint ret;\n\n\tobject = container_of(op->object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\top->object->cookie->def->get_attr(op->object->cookie->netfs_data,\n\t\t\t\t\t  &ni_size);\n\n\t_enter(\"{OBJ%x},[%llu]\",\n\t       op->object->debug_id, (unsigned long long)ni_size);\n\n\tif (object->backer) {\n\t\tASSERT(d_is_reg(object->backer));\n\n\t\tfscache_set_store_limit(&object->fscache, ni_size);\n\n\t\tpath.dentry = object->backer;\n\t\tpath.mnt = cache->mnt;\n\n\t\tcachefiles_begin_secure(cache, &saved_cred);\n\t\tret = vfs_truncate(&path, 0);\n\t\tif (ret == 0)\n\t\t\tret = vfs_truncate(&path, ni_size);\n\t\tcachefiles_end_secure(cache, saved_cred);\n\n\t\tif (ret != 0) {\n\t\t\tfscache_set_store_limit(&object->fscache, 0);\n\t\t\tif (ret == -EIO)\n\t\t\t\tcachefiles_io_error_obj(object,\n\t\t\t\t\t\t\t\"Invalidate failed\");\n\t\t}\n\t}\n\n\tfscache_op_complete(op, true);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "cachefiles_attr_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "415-479",
    "snippet": "static int cachefiles_attr_changed(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tstruct iattr newattrs;\n\tuint64_t ni_size;\n\tloff_t oi_size;\n\tint ret;\n\n\t_object->cookie->def->get_attr(_object->cookie->netfs_data, &ni_size);\n\n\t_enter(\"{OBJ%x},[%llu]\",\n\t       _object->debug_id, (unsigned long long) ni_size);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\tif (ni_size == object->i_size)\n\t\treturn 0;\n\n\tif (!object->backer)\n\t\treturn -ENOBUFS;\n\n\tASSERT(d_is_reg(object->backer));\n\n\tfscache_set_store_limit(&object->fscache, ni_size);\n\n\toi_size = i_size_read(object->backer->d_inode);\n\tif (oi_size == ni_size)\n\t\treturn 0;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tmutex_lock(&object->backer->d_inode->i_mutex);\n\n\t/* if there's an extension to a partial page at the end of the backing\n\t * file, we need to discard the partial page so that we pick up new\n\t * data after it */\n\tif (oi_size & ~PAGE_MASK && ni_size > oi_size) {\n\t\t_debug(\"discard tail %llx\", oi_size);\n\t\tnewattrs.ia_valid = ATTR_SIZE;\n\t\tnewattrs.ia_size = oi_size & PAGE_MASK;\n\t\tret = notify_change(object->backer, &newattrs, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto truncate_failed;\n\t}\n\n\tnewattrs.ia_valid = ATTR_SIZE;\n\tnewattrs.ia_size = ni_size;\n\tret = notify_change(object->backer, &newattrs, NULL);\n\ntruncate_failed:\n\tmutex_unlock(&object->backer->d_inode->i_mutex);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tif (ret == -EIO) {\n\t\tfscache_set_store_limit(&object->fscache, 0);\n\t\tcachefiles_io_error_obj(object, \"Size set failed\");\n\t\tret = -ENOBUFS;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_attr_changed(struct fscache_object *_object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_io_error_obj",
          "args": [
            "object",
            "\"Size set failed\""
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_set_store_limit",
          "args": [
            "&object->fscache",
            "0"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&object->backer->d_inode->i_mutex"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "object->backer",
            "&newattrs",
            "NULL"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"discard tail %llx\"",
            "oi_size"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&object->backer->d_inode->i_mutex"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "object->backer->d_inode"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_set_store_limit",
          "args": [
            "&object->fscache",
            "ni_size"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "d_is_reg(object->backer)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "object->backer"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x},[%llu]\"",
            "_object->debug_id",
            "(unsigned long long) ni_size"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_object->cookie->def->get_attr",
          "args": [
            "_object->cookie->netfs_data",
            "&ni_size"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object);\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tstruct iattr newattrs;\n\tuint64_t ni_size;\n\tloff_t oi_size;\n\tint ret;\n\n\t_object->cookie->def->get_attr(_object->cookie->netfs_data, &ni_size);\n\n\t_enter(\"{OBJ%x},[%llu]\",\n\t       _object->debug_id, (unsigned long long) ni_size);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\tif (ni_size == object->i_size)\n\t\treturn 0;\n\n\tif (!object->backer)\n\t\treturn -ENOBUFS;\n\n\tASSERT(d_is_reg(object->backer));\n\n\tfscache_set_store_limit(&object->fscache, ni_size);\n\n\toi_size = i_size_read(object->backer->d_inode);\n\tif (oi_size == ni_size)\n\t\treturn 0;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tmutex_lock(&object->backer->d_inode->i_mutex);\n\n\t/* if there's an extension to a partial page at the end of the backing\n\t * file, we need to discard the partial page so that we pick up new\n\t * data after it */\n\tif (oi_size & ~PAGE_MASK && ni_size > oi_size) {\n\t\t_debug(\"discard tail %llx\", oi_size);\n\t\tnewattrs.ia_valid = ATTR_SIZE;\n\t\tnewattrs.ia_size = oi_size & PAGE_MASK;\n\t\tret = notify_change(object->backer, &newattrs, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto truncate_failed;\n\t}\n\n\tnewattrs.ia_valid = ATTR_SIZE;\n\tnewattrs.ia_size = ni_size;\n\tret = notify_change(object->backer, &newattrs, NULL);\n\ntruncate_failed:\n\tmutex_unlock(&object->backer->d_inode->i_mutex);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tif (ret == -EIO) {\n\t\tfscache_set_store_limit(&object->fscache, 0);\n\t\tcachefiles_io_error_obj(object, \"Size set failed\");\n\t\tret = -ENOBUFS;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_check_consistency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "390-409",
    "snippet": "static bool cachefiles_check_consistency(struct fscache_operation *op)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"{OBJ%x}\", op->object->debug_id);\n\n\tobject = container_of(op->object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_check_auxdata(object);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_check_auxdata",
          "args": [
            "object"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_check_auxdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
          "lines": "159-191",
          "snippet": "int cachefiles_check_auxdata(struct cachefiles_object *object)\n{\n\tstruct cachefiles_xattr *auxbuf;\n\tenum fscache_checkaux validity;\n\tstruct dentry *dentry = object->dentry;\n\tssize_t xlen;\n\tint ret;\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\tASSERT(object->fscache.cookie->def->check_aux);\n\n\tauxbuf = kmalloc(sizeof(struct cachefiles_xattr) + 512, GFP_KERNEL);\n\tif (!auxbuf)\n\t\treturn -ENOMEM;\n\n\txlen = vfs_getxattr(dentry, cachefiles_xattr_cache,\n\t\t\t    &auxbuf->type, 512 + 1);\n\tret = -ESTALE;\n\tif (xlen < 1 ||\n\t    auxbuf->type != object->fscache.cookie->def->type)\n\t\tgoto error;\n\n\txlen--;\n\tvalidity = fscache_check_aux(&object->fscache, &auxbuf->data, xlen);\n\tif (validity != FSCACHE_CHECKAUX_OKAY)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tkfree(auxbuf);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_check_auxdata(struct cachefiles_object *object)\n{\n\tstruct cachefiles_xattr *auxbuf;\n\tenum fscache_checkaux validity;\n\tstruct dentry *dentry = object->dentry;\n\tssize_t xlen;\n\tint ret;\n\n\tASSERT(dentry);\n\tASSERT(dentry->d_inode);\n\tASSERT(object->fscache.cookie->def->check_aux);\n\n\tauxbuf = kmalloc(sizeof(struct cachefiles_xattr) + 512, GFP_KERNEL);\n\tif (!auxbuf)\n\t\treturn -ENOMEM;\n\n\txlen = vfs_getxattr(dentry, cachefiles_xattr_cache,\n\t\t\t    &auxbuf->type, 512 + 1);\n\tret = -ESTALE;\n\tif (xlen < 1 ||\n\t    auxbuf->type != object->fscache.cookie->def->type)\n\t\tgoto error;\n\n\txlen--;\n\tvalidity = fscache_check_aux(&object->fscache, &auxbuf->data, xlen);\n\tif (validity != FSCACHE_CHECKAUX_OKAY)\n\t\tgoto error;\n\n\tret = 0;\nerror:\n\tkfree(auxbuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "op->object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x}\"",
            "op->object->debug_id"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic bool cachefiles_check_consistency(struct fscache_operation *op)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"{OBJ%x}\", op->object->debug_id);\n\n\tobject = container_of(op->object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_check_auxdata(object);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_sync_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "361-384",
    "snippet": "static void cachefiles_sync_cache(struct fscache_cache *_cache)\n{\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"%p\", _cache);\n\n\tcache = container_of(_cache, struct cachefiles_cache, cache);\n\n\t/* make sure all pages pinned by operations on behalf of the netfs are\n\t * written to disc */\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tdown_read(&cache->mnt->mnt_sb->s_umount);\n\tret = sync_filesystem(cache->mnt->mnt_sb);\n\tup_read(&cache->mnt->mnt_sb->s_umount);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache,\n\t\t\t\t    \"Attempt to sync backing fs superblock\"\n\t\t\t\t    \" returned error %d\",\n\t\t\t\t    ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cachefiles_io_error",
          "args": [
            "cache",
            "\"Attempt to sync backing fs superblock\"\n\t\t\t\t    \" returned error %d\"",
            "ret"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cache->mnt->mnt_sb->s_umount"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "cache->mnt->mnt_sb"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cache->mnt->mnt_sb->s_umount"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p\"",
            "_cache"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic void cachefiles_sync_cache(struct fscache_cache *_cache)\n{\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"%p\", _cache);\n\n\tcache = container_of(_cache, struct cachefiles_cache, cache);\n\n\t/* make sure all pages pinned by operations on behalf of the netfs are\n\t * written to disc */\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tdown_read(&cache->mnt->mnt_sb->s_umount);\n\tret = sync_filesystem(cache->mnt->mnt_sb);\n\tup_read(&cache->mnt->mnt_sb->s_umount);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache,\n\t\t\t\t    \"Attempt to sync backing fs superblock\"\n\t\t\t\t    \" returned error %d\",\n\t\t\t\t    ret);\n}"
  },
  {
    "function_name": "cachefiles_put_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "313-356",
    "snippet": "static void cachefiles_put_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct fscache_cache *cache;\n\n\tASSERT(_object);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\n\t_enter(\"{OBJ%x,%d}\",\n\t       object->fscache.debug_id, atomic_read(&object->usage));\n\n#ifdef CACHEFILES_DEBUG_SLAB\n\tASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\n#endif\n\n\tASSERTIFCMP(object->fscache.parent,\n\t\t    object->fscache.parent->n_children, >, 0);\n\n\tif (atomic_dec_and_test(&object->usage)) {\n\t\t_debug(\"- kill object OBJ%x\", object->fscache.debug_id);\n\n\t\tASSERT(!test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\n\t\tASSERTCMP(object->fscache.parent, ==, NULL);\n\t\tASSERTCMP(object->backer, ==, NULL);\n\t\tASSERTCMP(object->dentry, ==, NULL);\n\t\tASSERTCMP(object->fscache.n_ops, ==, 0);\n\t\tASSERTCMP(object->fscache.n_children, ==, 0);\n\n\t\tif (object->lookup_data) {\n\t\t\tkfree(object->lookup_data->key);\n\t\t\tkfree(object->lookup_data->auxdata);\n\t\t\tkfree(object->lookup_data);\n\t\t\tobject->lookup_data = NULL;\n\t\t}\n\n\t\tcache = object->fscache.cache;\n\t\tfscache_object_destroy(&object->fscache);\n\t\tkmem_cache_free(cachefiles_object_jar, object);\n\t\tfscache_object_destroyed(cache);\n\t}\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_attr_changed(struct fscache_object *_object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_destroyed",
          "args": [
            "cache"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cachefiles_object_jar",
            "object"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_destroy",
          "args": [
            "&object->fscache"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_object_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "760-767",
          "snippet": "void fscache_object_destroy(struct fscache_object *object)\n{\n\tfscache_objlist_remove(object);\n\n\t/* We can get rid of the cookie now */\n\tfscache_cookie_put(object->cookie);\n\tobject->cookie = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_object_destroy(struct fscache_object *object)\n{\n\tfscache_objlist_remove(object);\n\n\t/* We can get rid of the cookie now */\n\tfscache_cookie_put(object->cookie);\n\tobject->cookie = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "object->lookup_data"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "object->lookup_data->auxdata"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "object->lookup_data->key"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->fscache.n_children",
            "==,0"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->fscache.n_ops",
            "==,0"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->dentry",
            "==,NULL"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->backer",
            "==,NULL"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->fscache.parent",
            "==,NULL"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_OBJECT_ACTIVE",
            "&object->flags"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"- kill object OBJ%x\"",
            "object->fscache.debug_id"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&object->usage"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTIFCMP",
          "args": [
            "object->fscache.parent",
            "object->fscache.parent->n_children",
            ">,0"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->usage"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%d}\"",
            "object->fscache.debug_id",
            "atomic_read(&object->usage)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->usage"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "_object"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object);\n\nstatic void cachefiles_put_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct fscache_cache *cache;\n\n\tASSERT(_object);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\n\t_enter(\"{OBJ%x,%d}\",\n\t       object->fscache.debug_id, atomic_read(&object->usage));\n\n#ifdef CACHEFILES_DEBUG_SLAB\n\tASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\n#endif\n\n\tASSERTIFCMP(object->fscache.parent,\n\t\t    object->fscache.parent->n_children, >, 0);\n\n\tif (atomic_dec_and_test(&object->usage)) {\n\t\t_debug(\"- kill object OBJ%x\", object->fscache.debug_id);\n\n\t\tASSERT(!test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\n\t\tASSERTCMP(object->fscache.parent, ==, NULL);\n\t\tASSERTCMP(object->backer, ==, NULL);\n\t\tASSERTCMP(object->dentry, ==, NULL);\n\t\tASSERTCMP(object->fscache.n_ops, ==, 0);\n\t\tASSERTCMP(object->fscache.n_children, ==, 0);\n\n\t\tif (object->lookup_data) {\n\t\t\tkfree(object->lookup_data->key);\n\t\t\tkfree(object->lookup_data->auxdata);\n\t\t\tkfree(object->lookup_data);\n\t\t\tobject->lookup_data = NULL;\n\t\t}\n\n\t\tcache = object->fscache.cache;\n\t\tfscache_object_destroy(&object->fscache);\n\t\tkmem_cache_free(cachefiles_object_jar, object);\n\t\tfscache_object_destroyed(cache);\n\t}\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "cachefiles_drop_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "251-308",
    "snippet": "static void cachefiles_drop_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\n\tASSERT(_object);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\n\t_enter(\"{OBJ%x,%d}\",\n\t       object->fscache.debug_id, atomic_read(&object->usage));\n\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n#ifdef CACHEFILES_DEBUG_SLAB\n\tASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\n#endif\n\n\t/* We need to tidy the object up if we did in fact manage to open it.\n\t * It's possible for us to get here before the object is fully\n\t * initialised if the parent goes away or the object gets retired\n\t * before we set it up.\n\t */\n\tif (object->dentry) {\n\t\t/* delete retired objects */\n\t\tif (test_bit(FSCACHE_OBJECT_RETIRED, &object->fscache.flags) &&\n\t\t    _object != cache->cache.fsdef\n\t\t    ) {\n\t\t\t_debug(\"- retire object OBJ%x\", object->fscache.debug_id);\n\t\t\tcachefiles_begin_secure(cache, &saved_cred);\n\t\t\tcachefiles_delete_object(cache, object);\n\t\t\tcachefiles_end_secure(cache, saved_cred);\n\t\t}\n\n\t\t/* close the filesystem stuff attached to the object */\n\t\tif (object->backer != object->dentry)\n\t\t\tdput(object->backer);\n\t\tobject->backer = NULL;\n\t}\n\n\t/* note that the object is now inactive */\n\tif (test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)) {\n\t\twrite_lock(&cache->active_lock);\n\t\tif (!test_and_clear_bit(CACHEFILES_OBJECT_ACTIVE,\n\t\t\t\t\t&object->flags))\n\t\t\tBUG();\n\t\trb_erase(&object->active_node, &cache->active_nodes);\n\t\twake_up_bit(&object->flags, CACHEFILES_OBJECT_ACTIVE);\n\t\twrite_unlock(&cache->active_lock);\n\t}\n\n\tdput(object->dentry);\n\tobject->dentry = NULL;\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_attr_changed(struct fscache_object *_object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "object->dentry"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&object->flags",
            "CACHEFILES_OBJECT_ACTIVE"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&object->active_node",
            "&cache->active_nodes"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "CACHEFILES_OBJECT_ACTIVE",
            "&object->flags"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&cache->active_lock"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_OBJECT_ACTIVE",
            "&object->flags"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_delete_object",
          "args": [
            "cache",
            "object"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_delete_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "409-449",
          "snippet": "int cachefiles_delete_object(struct cachefiles_cache *cache,\n\t\t\t     struct cachefiles_object *object)\n{\n\tstruct dentry *dir;\n\tint ret;\n\n\t_enter(\",OBJ%x{%p}\", object->fscache.debug_id, object->dentry);\n\n\tASSERT(object->dentry);\n\tASSERT(object->dentry->d_inode);\n\tASSERT(object->dentry->d_parent);\n\n\tdir = dget_parent(object->dentry);\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tif (test_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {\n\t\t/* object allocation for the same key preemptively deleted this\n\t\t * object's file so that it could create its own file */\n\t\t_debug(\"object preemptively buried\");\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tret = 0;\n\t} else {\n\t\t/* we need to check that our parent is _still_ our parent - it\n\t\t * may have been renamed */\n\t\tif (dir == object->dentry->d_parent) {\n\t\t\tret = cachefiles_bury_object(cache, dir,\n\t\t\t\t\t\t     object->dentry, false);\n\t\t} else {\n\t\t\t/* it got moved, presumably by cachefilesd culling it,\n\t\t\t * so it's no longer in the key path and we can ignore\n\t\t\t * it */\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tdput(dir);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint cachefiles_delete_object(struct cachefiles_cache *cache,\n\t\t\t     struct cachefiles_object *object)\n{\n\tstruct dentry *dir;\n\tint ret;\n\n\t_enter(\",OBJ%x{%p}\", object->fscache.debug_id, object->dentry);\n\n\tASSERT(object->dentry);\n\tASSERT(object->dentry->d_inode);\n\tASSERT(object->dentry->d_parent);\n\n\tdir = dget_parent(object->dentry);\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tif (test_bit(CACHEFILES_OBJECT_BURIED, &object->flags)) {\n\t\t/* object allocation for the same key preemptively deleted this\n\t\t * object's file so that it could create its own file */\n\t\t_debug(\"object preemptively buried\");\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tret = 0;\n\t} else {\n\t\t/* we need to check that our parent is _still_ our parent - it\n\t\t * may have been renamed */\n\t\tif (dir == object->dentry->d_parent) {\n\t\t\tret = cachefiles_bury_object(cache, dir,\n\t\t\t\t\t\t     object->dentry, false);\n\t\t} else {\n\t\t\t/* it got moved, presumably by cachefilesd culling it,\n\t\t\t * so it's no longer in the key path and we can ignore\n\t\t\t * it */\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tdput(dir);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"- retire object OBJ%x\"",
            "object->fscache.debug_id"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_daemon_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/daemon.c",
          "lines": "602-619",
          "snippet": "static int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/statfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/completion.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_daemon_frun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_brun(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_cull(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_debug(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_dir(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);",
            "static int cachefiles_daemon_tag(struct cachefiles_cache *, char *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/statfs.h>\n#include <linux/mount.h>\n#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int cachefiles_daemon_frun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_fstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_brun(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bcull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_bstop(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_cull(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_dir(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_inuse(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_secctx(struct cachefiles_cache *, char *);\nstatic int cachefiles_daemon_tag(struct cachefiles_cache *, char *);\n\nstatic int cachefiles_daemon_debug(struct cachefiles_cache *cache, char *args)\n{\n\tunsigned long mask;\n\n\t_enter(\",%s\", args);\n\n\tmask = simple_strtoul(args, &args, 0);\n\tif (args[0] != '\\0')\n\t\tgoto inval;\n\n\tcachefiles_debug = mask;\n\t_leave(\" = 0\");\n\treturn 0;\n\ninval:\n\tpr_err(\"debug command requires mask\\n\");\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->usage"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%d}\"",
            "object->fscache.debug_id",
            "atomic_read(&object->usage)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->usage"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "_object"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object);\n\nstatic void cachefiles_drop_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\n\tASSERT(_object);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\n\t_enter(\"{OBJ%x,%d}\",\n\t       object->fscache.debug_id, atomic_read(&object->usage));\n\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n#ifdef CACHEFILES_DEBUG_SLAB\n\tASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\n#endif\n\n\t/* We need to tidy the object up if we did in fact manage to open it.\n\t * It's possible for us to get here before the object is fully\n\t * initialised if the parent goes away or the object gets retired\n\t * before we set it up.\n\t */\n\tif (object->dentry) {\n\t\t/* delete retired objects */\n\t\tif (test_bit(FSCACHE_OBJECT_RETIRED, &object->fscache.flags) &&\n\t\t    _object != cache->cache.fsdef\n\t\t    ) {\n\t\t\t_debug(\"- retire object OBJ%x\", object->fscache.debug_id);\n\t\t\tcachefiles_begin_secure(cache, &saved_cred);\n\t\t\tcachefiles_delete_object(cache, object);\n\t\t\tcachefiles_end_secure(cache, saved_cred);\n\t\t}\n\n\t\t/* close the filesystem stuff attached to the object */\n\t\tif (object->backer != object->dentry)\n\t\t\tdput(object->backer);\n\t\tobject->backer = NULL;\n\t}\n\n\t/* note that the object is now inactive */\n\tif (test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)) {\n\t\twrite_lock(&cache->active_lock);\n\t\tif (!test_and_clear_bit(CACHEFILES_OBJECT_ACTIVE,\n\t\t\t\t\t&object->flags))\n\t\t\tBUG();\n\t\trb_erase(&object->active_node, &cache->active_nodes);\n\t\twake_up_bit(&object->flags, CACHEFILES_OBJECT_ACTIVE);\n\t\twrite_unlock(&cache->active_lock);\n\t}\n\n\tdput(object->dentry);\n\tobject->dentry = NULL;\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "cachefiles_update_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "198-245",
    "snippet": "static void cachefiles_update_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_xattr *auxdata;\n\tstruct cachefiles_cache *cache;\n\tstruct fscache_cookie *cookie;\n\tconst struct cred *saved_cred;\n\tunsigned auxlen;\n\n\t_enter(\"{OBJ%x}\", _object->debug_id);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache, struct cachefiles_cache,\n\t\t\t     cache);\n\n\tif (!fscache_use_cookie(_object)) {\n\t\t_leave(\" [relinq]\");\n\t\treturn;\n\t}\n\n\tcookie = object->fscache.cookie;\n\n\tif (!cookie->def->get_aux) {\n\t\tfscache_unuse_cookie(_object);\n\t\t_leave(\" [no aux]\");\n\t\treturn;\n\t}\n\n\tauxdata = kmalloc(2 + 512 + 3, cachefiles_gfp);\n\tif (!auxdata) {\n\t\tfscache_unuse_cookie(_object);\n\t\t_leave(\" [nomem]\");\n\t\treturn;\n\t}\n\n\tauxlen = cookie->def->get_aux(cookie->netfs_data, auxdata->data, 511);\n\tfscache_unuse_cookie(_object);\n\tASSERTCMP(auxlen, <, 511);\n\n\tauxdata->len = auxlen + 1;\n\tauxdata->type = cookie->def->type;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tcachefiles_update_object_xattr(object, auxdata);\n\tcachefiles_end_secure(cache, saved_cred);\n\tkfree(auxdata);\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_attr_changed(struct fscache_object *_object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "auxdata"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_update_object_xattr",
          "args": [
            "object",
            "auxdata"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_update_object_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/xattr.c",
          "lines": "131-154",
          "snippet": "int cachefiles_update_object_xattr(struct cachefiles_object *object,\n\t\t\t\t   struct cachefiles_xattr *auxdata)\n{\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\tASSERT(dentry);\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\t/* attempt to install the cache metadata directly */\n\t_debug(\"SET #%u\", auxdata->len);\n\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t   XATTR_REPLACE);\n\tif (ret < 0 && ret != -ENOMEM)\n\t\tcachefiles_io_error_obj(\n\t\t\tobject,\n\t\t\t\"Failed to update xattr with error %d\", ret);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const char cachefiles_xattr_cache[] =\n\tXATTR_USER_PREFIX \"CacheFiles.cache\";\n\nint cachefiles_update_object_xattr(struct cachefiles_object *object,\n\t\t\t\t   struct cachefiles_xattr *auxdata)\n{\n\tstruct dentry *dentry = object->dentry;\n\tint ret;\n\n\tASSERT(dentry);\n\n\t_enter(\"%p,#%d\", object, auxdata->len);\n\n\t/* attempt to install the cache metadata directly */\n\t_debug(\"SET #%u\", auxdata->len);\n\n\tret = vfs_setxattr(dentry, cachefiles_xattr_cache,\n\t\t\t   &auxdata->type, auxdata->len,\n\t\t\t   XATTR_REPLACE);\n\tif (ret < 0 && ret != -ENOMEM)\n\t\tcachefiles_io_error_obj(\n\t\t\tobject,\n\t\t\t\"Failed to update xattr with error %d\", ret);\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "auxlen",
            "<,511"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_unuse_cookie",
          "args": [
            "_object"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie->def->get_aux",
          "args": [
            "cookie->netfs_data",
            "auxdata->data",
            "511"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_unuse_cookie",
          "args": [
            "_object"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "2 + 512 + 3",
            "cachefiles_gfp"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_unuse_cookie",
          "args": [
            "_object"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_use_cookie",
          "args": [
            "_object"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "object->fscache.cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x}\"",
            "_object->debug_id"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object);\n\nstatic void cachefiles_update_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_xattr *auxdata;\n\tstruct cachefiles_cache *cache;\n\tstruct fscache_cookie *cookie;\n\tconst struct cred *saved_cred;\n\tunsigned auxlen;\n\n\t_enter(\"{OBJ%x}\", _object->debug_id);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache, struct cachefiles_cache,\n\t\t\t     cache);\n\n\tif (!fscache_use_cookie(_object)) {\n\t\t_leave(\" [relinq]\");\n\t\treturn;\n\t}\n\n\tcookie = object->fscache.cookie;\n\n\tif (!cookie->def->get_aux) {\n\t\tfscache_unuse_cookie(_object);\n\t\t_leave(\" [no aux]\");\n\t\treturn;\n\t}\n\n\tauxdata = kmalloc(2 + 512 + 3, cachefiles_gfp);\n\tif (!auxdata) {\n\t\tfscache_unuse_cookie(_object);\n\t\t_leave(\" [nomem]\");\n\t\treturn;\n\t}\n\n\tauxlen = cookie->def->get_aux(cookie->netfs_data, auxdata->data, 511);\n\tfscache_unuse_cookie(_object);\n\tASSERTCMP(auxlen, <, 511);\n\n\tauxdata->len = auxlen + 1;\n\tauxdata->type = cookie->def->type;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tcachefiles_update_object_xattr(object, auxdata);\n\tcachefiles_end_secure(cache, saved_cred);\n\tkfree(auxdata);\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "cachefiles_grab_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "179-193",
    "snippet": "static\nstruct fscache_object *cachefiles_grab_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object =\n\t\tcontainer_of(_object, struct cachefiles_object, fscache);\n\n\t_enter(\"{OBJ%x,%d}\", _object->debug_id, atomic_read(&object->usage));\n\n#ifdef CACHEFILES_DEBUG_SLAB\n\tASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\n#endif\n\n\tatomic_inc(&object->usage);\n\treturn &object->fscache;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_attr_changed(struct fscache_object *_object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&object->usage"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->usage"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%d}\"",
            "_object->debug_id",
            "atomic_read(&object->usage)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&object->usage"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object);\n\nstatic\nstruct fscache_object *cachefiles_grab_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object =\n\t\tcontainer_of(_object, struct cachefiles_object, fscache);\n\n\t_enter(\"{OBJ%x,%d}\", _object->debug_id, atomic_read(&object->usage));\n\n#ifdef CACHEFILES_DEBUG_SLAB\n\tASSERT((atomic_read(&object->usage) & 0xffff0000) != 0x6b6b0000);\n#endif\n\n\tatomic_inc(&object->usage);\n\treturn &object->fscache;\n}"
  },
  {
    "function_name": "cachefiles_lookup_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "160-174",
    "snippet": "static void cachefiles_lookup_complete(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\n\t_enter(\"{OBJ%x,%p}\", object->fscache.debug_id, object->lookup_data);\n\n\tif (object->lookup_data) {\n\t\tkfree(object->lookup_data->key);\n\t\tkfree(object->lookup_data->auxdata);\n\t\tkfree(object->lookup_data);\n\t\tobject->lookup_data = NULL;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_attr_changed(struct fscache_object *_object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "object->lookup_data"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "object->lookup_data->auxdata"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "object->lookup_data->key"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x,%p}\"",
            "object->fscache.debug_id",
            "object->lookup_data"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object);\n\nstatic void cachefiles_lookup_complete(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\n\t_enter(\"{OBJ%x,%p}\", object->fscache.debug_id, object->lookup_data);\n\n\tif (object->lookup_data) {\n\t\tkfree(object->lookup_data->key);\n\t\tkfree(object->lookup_data->auxdata);\n\t\tkfree(object->lookup_data);\n\t\tobject->lookup_data = NULL;\n\t}\n}"
  },
  {
    "function_name": "cachefiles_lookup_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "117-155",
    "snippet": "static int cachefiles_lookup_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_lookup_data *lookup_data;\n\tstruct cachefiles_object *parent, *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"{OBJ%x}\", _object->debug_id);\n\n\tcache = container_of(_object->cache, struct cachefiles_cache, cache);\n\tparent = container_of(_object->parent,\n\t\t\t      struct cachefiles_object, fscache);\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tlookup_data = object->lookup_data;\n\n\tASSERTCMP(lookup_data, !=, NULL);\n\n\t/* look up the key, creating any missing bits */\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_walk_to_object(parent, object,\n\t\t\t\t\tlookup_data->key,\n\t\t\t\t\tlookup_data->auxdata);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\t/* polish off by setting the attributes of non-index files */\n\tif (ret == 0 &&\n\t    object->fscache.cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX)\n\t\tcachefiles_attr_changed(&object->fscache);\n\n\tif (ret < 0 && ret != -ETIMEDOUT) {\n\t\tif (ret != -ENOBUFS)\n\t\t\tpr_warn(\"Lookup failed error %d\\n\", ret);\n\t\tfscache_object_lookup_error(&object->fscache);\n\t}\n\n\t_leave(\" [%d]\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int cachefiles_attr_changed(struct fscache_object *_object);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" [%d]\"",
            "ret"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_lookup_error",
          "args": [
            "&object->fscache"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Lookup failed error %d\\n\"",
            "ret"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_attr_changed",
          "args": [
            "&object->fscache"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_attr_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
          "lines": "415-479",
          "snippet": "static int cachefiles_attr_changed(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tstruct iattr newattrs;\n\tuint64_t ni_size;\n\tloff_t oi_size;\n\tint ret;\n\n\t_object->cookie->def->get_attr(_object->cookie->netfs_data, &ni_size);\n\n\t_enter(\"{OBJ%x},[%llu]\",\n\t       _object->debug_id, (unsigned long long) ni_size);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\tif (ni_size == object->i_size)\n\t\treturn 0;\n\n\tif (!object->backer)\n\t\treturn -ENOBUFS;\n\n\tASSERT(d_is_reg(object->backer));\n\n\tfscache_set_store_limit(&object->fscache, ni_size);\n\n\toi_size = i_size_read(object->backer->d_inode);\n\tif (oi_size == ni_size)\n\t\treturn 0;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tmutex_lock(&object->backer->d_inode->i_mutex);\n\n\t/* if there's an extension to a partial page at the end of the backing\n\t * file, we need to discard the partial page so that we pick up new\n\t * data after it */\n\tif (oi_size & ~PAGE_MASK && ni_size > oi_size) {\n\t\t_debug(\"discard tail %llx\", oi_size);\n\t\tnewattrs.ia_valid = ATTR_SIZE;\n\t\tnewattrs.ia_size = oi_size & PAGE_MASK;\n\t\tret = notify_change(object->backer, &newattrs, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto truncate_failed;\n\t}\n\n\tnewattrs.ia_valid = ATTR_SIZE;\n\tnewattrs.ia_size = ni_size;\n\tret = notify_change(object->backer, &newattrs, NULL);\n\ntruncate_failed:\n\tmutex_unlock(&object->backer->d_inode->i_mutex);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tif (ret == -EIO) {\n\t\tfscache_set_store_limit(&object->fscache, 0);\n\t\tcachefiles_io_error_obj(object, \"Size set failed\");\n\t\tret = -ENOBUFS;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cachefiles_attr_changed(struct fscache_object *_object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object);\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object)\n{\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tstruct iattr newattrs;\n\tuint64_t ni_size;\n\tloff_t oi_size;\n\tint ret;\n\n\t_object->cookie->def->get_attr(_object->cookie->netfs_data, &ni_size);\n\n\t_enter(\"{OBJ%x},[%llu]\",\n\t       _object->debug_id, (unsigned long long) ni_size);\n\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tcache = container_of(object->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\n\tif (ni_size == object->i_size)\n\t\treturn 0;\n\n\tif (!object->backer)\n\t\treturn -ENOBUFS;\n\n\tASSERT(d_is_reg(object->backer));\n\n\tfscache_set_store_limit(&object->fscache, ni_size);\n\n\toi_size = i_size_read(object->backer->d_inode);\n\tif (oi_size == ni_size)\n\t\treturn 0;\n\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tmutex_lock(&object->backer->d_inode->i_mutex);\n\n\t/* if there's an extension to a partial page at the end of the backing\n\t * file, we need to discard the partial page so that we pick up new\n\t * data after it */\n\tif (oi_size & ~PAGE_MASK && ni_size > oi_size) {\n\t\t_debug(\"discard tail %llx\", oi_size);\n\t\tnewattrs.ia_valid = ATTR_SIZE;\n\t\tnewattrs.ia_size = oi_size & PAGE_MASK;\n\t\tret = notify_change(object->backer, &newattrs, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto truncate_failed;\n\t}\n\n\tnewattrs.ia_valid = ATTR_SIZE;\n\tnewattrs.ia_size = ni_size;\n\tret = notify_change(object->backer, &newattrs, NULL);\n\ntruncate_failed:\n\tmutex_unlock(&object->backer->d_inode->i_mutex);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\tif (ret == -EIO) {\n\t\tfscache_set_store_limit(&object->fscache, 0);\n\t\tcachefiles_io_error_obj(object, \"Size set failed\");\n\t\tret = -ENOBUFS;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_end_secure",
          "args": [
            "cache",
            "saved_cred"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_end_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "231-235",
          "snippet": "static inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\n\nstatic inline void cachefiles_end_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t const struct cred *saved_cred)\n{\n\trevert_creds(saved_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_walk_to_object",
          "args": [
            "parent",
            "object",
            "lookup_data->key",
            "lookup_data->auxdata"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_walk_to_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "455-705",
          "snippet": "int cachefiles_walk_to_object(struct cachefiles_object *parent,\n\t\t\t      struct cachefiles_object *object,\n\t\t\t      const char *key,\n\t\t\t      struct cachefiles_xattr *auxdata)\n{\n\tstruct cachefiles_cache *cache;\n\tstruct dentry *dir, *next = NULL;\n\tstruct path path;\n\tunsigned long start;\n\tconst char *name;\n\tint ret, nlen;\n\n\t_enter(\"OBJ%x{%p},OBJ%x,%s,\",\n\t       parent->fscache.debug_id, parent->dentry,\n\t       object->fscache.debug_id, key);\n\n\tcache = container_of(parent->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\tpath.mnt = cache->mnt;\n\n\tASSERT(parent->dentry);\n\tASSERT(parent->dentry->d_inode);\n\n\tif (!(d_is_dir(parent->dentry))) {\n\t\t// TODO: convert file to dir\n\t\t_leave(\"looking up in none directory\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tdir = dget(parent->dentry);\n\nadvance:\n\t/* attempt to transit the first directory component */\n\tname = key;\n\tnlen = strlen(key);\n\n\t/* key ends in a double NUL */\n\tkey = key + nlen + 1;\n\tif (!*key)\n\t\tkey = NULL;\n\nlookup_again:\n\t/* search the current directory for the element name */\n\t_debug(\"lookup '%s'\", name);\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tnext = lookup_one_len(name, dir, nlen);\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(next))\n\t\tgoto lookup_error;\n\n\t_debug(\"next -> %p %s\", next, next->d_inode ? \"positive\" : \"negative\");\n\n\tif (!key)\n\t\tobject->new = !next->d_inode;\n\n\t/* if this element of the path doesn't exist, then the lookup phase\n\t * failed, and we can release any readers in the certain knowledge that\n\t * there's nothing for them to actually read */\n\tif (!next->d_inode)\n\t\tfscache_object_lookup_negative(&object->fscache);\n\n\t/* we need to create the object if it's negative */\n\tif (key || object->type == FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* index objects and intervening tree levels must be subdirs */\n\t\tif (!next->d_inode) {\n\t\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tpath.dentry = dir;\n\t\t\tret = security_path_mkdir(&path, next, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\t\t\tstart = jiffies;\n\t\t\tret = vfs_mkdir(dir->d_inode, next, 0);\n\t\t\tcachefiles_hist(cachefiles_mkdir_histogram, start);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tASSERT(next->d_inode);\n\n\t\t\t_debug(\"mkdir -> %p{%p{ino=%lu}}\",\n\t\t\t       next, next->d_inode, next->d_inode->i_ino);\n\n\t\t} else if (!d_can_lookup(next)) {\n\t\t\tpr_err(\"inode %lu is not a directory\\n\",\n\t\t\t       next->d_inode->i_ino);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto error;\n\t\t}\n\n\t} else {\n\t\t/* non-index objects start out life as files */\n\t\tif (!next->d_inode) {\n\t\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tpath.dentry = dir;\n\t\t\tret = security_path_mknod(&path, next, S_IFREG, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\t\t\tstart = jiffies;\n\t\t\tret = vfs_create(dir->d_inode, next, S_IFREG, true);\n\t\t\tcachefiles_hist(cachefiles_create_histogram, start);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tASSERT(next->d_inode);\n\n\t\t\t_debug(\"create -> %p{%p{ino=%lu}}\",\n\t\t\t       next, next->d_inode, next->d_inode->i_ino);\n\n\t\t} else if (!d_can_lookup(next) &&\n\t\t\t   !d_is_reg(next)\n\t\t\t   ) {\n\t\t\tpr_err(\"inode %lu is not a file or directory\\n\",\n\t\t\t       next->d_inode->i_ino);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* process the next component */\n\tif (key) {\n\t\t_debug(\"advance\");\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(dir);\n\t\tdir = next;\n\t\tnext = NULL;\n\t\tgoto advance;\n\t}\n\n\t/* we've found the object we were looking for */\n\tobject->dentry = next;\n\n\t/* if we've found that the terminal object exists, then we need to\n\t * check its attributes and delete it if it's out of date */\n\tif (!object->new) {\n\t\t_debug(\"validate '%pd'\", next);\n\n\t\tret = cachefiles_check_object_xattr(object, auxdata);\n\t\tif (ret == -ESTALE) {\n\t\t\t/* delete the object (the deleter drops the directory\n\t\t\t * mutex) */\n\t\t\tobject->dentry = NULL;\n\n\t\t\tret = cachefiles_bury_object(cache, dir, next, true);\n\t\t\tdput(next);\n\t\t\tnext = NULL;\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto delete_error;\n\n\t\t\t_debug(\"redo lookup\");\n\t\t\tgoto lookup_again;\n\t\t}\n\t}\n\n\t/* note that we're now using this object */\n\tret = cachefiles_mark_object_active(cache, object);\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n\tdir = NULL;\n\n\tif (ret == -ETIMEDOUT)\n\t\tgoto mark_active_timed_out;\n\n\t_debug(\"=== OBTAINED_OBJECT ===\");\n\n\tif (object->new) {\n\t\t/* attach data to a newly constructed terminal object */\n\t\tret = cachefiles_set_object_xattr(object, auxdata);\n\t\tif (ret < 0)\n\t\t\tgoto check_error;\n\t} else {\n\t\t/* always update the atime on an object we've just looked up\n\t\t * (this is used to keep track of culling, and atimes are only\n\t\t * updated by read, write and readdir but not lookup or\n\t\t * open) */\n\t\tpath.dentry = next;\n\t\ttouch_atime(&path);\n\t}\n\n\t/* open a file interface onto a data file */\n\tif (object->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\tif (d_is_reg(object->dentry)) {\n\t\t\tconst struct address_space_operations *aops;\n\n\t\t\tret = -EPERM;\n\t\t\taops = object->dentry->d_inode->i_mapping->a_ops;\n\t\t\tif (!aops->bmap)\n\t\t\t\tgoto check_error;\n\n\t\t\tobject->backer = object->dentry;\n\t\t} else {\n\t\t\tBUG(); // TODO: open file in data-class subdir\n\t\t}\n\t}\n\n\tobject->new = 0;\n\tfscache_obtained_object(&object->fscache);\n\n\t_leave(\" = 0 [%lu]\", object->dentry->d_inode->i_ino);\n\treturn 0;\n\ncreate_error:\n\t_debug(\"create error %d\", ret);\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache, \"Create/mkdir failed\");\n\tgoto error;\n\nmark_active_timed_out:\n\t_debug(\"mark active timed out\");\n\tgoto release_dentry;\n\ncheck_error:\n\t_debug(\"check error %d\", ret);\n\twrite_lock(&cache->active_lock);\n\trb_erase(&object->active_node, &cache->active_nodes);\n\tclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\n\twake_up_bit(&object->flags, CACHEFILES_OBJECT_ACTIVE);\n\twrite_unlock(&cache->active_lock);\nrelease_dentry:\n\tdput(object->dentry);\n\tobject->dentry = NULL;\n\tgoto error_out;\n\ndelete_error:\n\t_debug(\"delete error %d\", ret);\n\tgoto error_out2;\n\nlookup_error:\n\t_debug(\"lookup error %ld\", PTR_ERR(next));\n\tret = PTR_ERR(next);\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\tnext = NULL;\nerror:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(next);\nerror_out2:\n\tdput(dir);\nerror_out:\n\t_leave(\" = error %d\", -ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint cachefiles_walk_to_object(struct cachefiles_object *parent,\n\t\t\t      struct cachefiles_object *object,\n\t\t\t      const char *key,\n\t\t\t      struct cachefiles_xattr *auxdata)\n{\n\tstruct cachefiles_cache *cache;\n\tstruct dentry *dir, *next = NULL;\n\tstruct path path;\n\tunsigned long start;\n\tconst char *name;\n\tint ret, nlen;\n\n\t_enter(\"OBJ%x{%p},OBJ%x,%s,\",\n\t       parent->fscache.debug_id, parent->dentry,\n\t       object->fscache.debug_id, key);\n\n\tcache = container_of(parent->fscache.cache,\n\t\t\t     struct cachefiles_cache, cache);\n\tpath.mnt = cache->mnt;\n\n\tASSERT(parent->dentry);\n\tASSERT(parent->dentry->d_inode);\n\n\tif (!(d_is_dir(parent->dentry))) {\n\t\t// TODO: convert file to dir\n\t\t_leave(\"looking up in none directory\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tdir = dget(parent->dentry);\n\nadvance:\n\t/* attempt to transit the first directory component */\n\tname = key;\n\tnlen = strlen(key);\n\n\t/* key ends in a double NUL */\n\tkey = key + nlen + 1;\n\tif (!*key)\n\t\tkey = NULL;\n\nlookup_again:\n\t/* search the current directory for the element name */\n\t_debug(\"lookup '%s'\", name);\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\tstart = jiffies;\n\tnext = lookup_one_len(name, dir, nlen);\n\tcachefiles_hist(cachefiles_lookup_histogram, start);\n\tif (IS_ERR(next))\n\t\tgoto lookup_error;\n\n\t_debug(\"next -> %p %s\", next, next->d_inode ? \"positive\" : \"negative\");\n\n\tif (!key)\n\t\tobject->new = !next->d_inode;\n\n\t/* if this element of the path doesn't exist, then the lookup phase\n\t * failed, and we can release any readers in the certain knowledge that\n\t * there's nothing for them to actually read */\n\tif (!next->d_inode)\n\t\tfscache_object_lookup_negative(&object->fscache);\n\n\t/* we need to create the object if it's negative */\n\tif (key || object->type == FSCACHE_COOKIE_TYPE_INDEX) {\n\t\t/* index objects and intervening tree levels must be subdirs */\n\t\tif (!next->d_inode) {\n\t\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tpath.dentry = dir;\n\t\t\tret = security_path_mkdir(&path, next, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\t\t\tstart = jiffies;\n\t\t\tret = vfs_mkdir(dir->d_inode, next, 0);\n\t\t\tcachefiles_hist(cachefiles_mkdir_histogram, start);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tASSERT(next->d_inode);\n\n\t\t\t_debug(\"mkdir -> %p{%p{ino=%lu}}\",\n\t\t\t       next, next->d_inode, next->d_inode->i_ino);\n\n\t\t} else if (!d_can_lookup(next)) {\n\t\t\tpr_err(\"inode %lu is not a directory\\n\",\n\t\t\t       next->d_inode->i_ino);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto error;\n\t\t}\n\n\t} else {\n\t\t/* non-index objects start out life as files */\n\t\tif (!next->d_inode) {\n\t\t\tret = cachefiles_has_space(cache, 1, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tpath.dentry = dir;\n\t\t\tret = security_path_mknod(&path, next, S_IFREG, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\t\t\tstart = jiffies;\n\t\t\tret = vfs_create(dir->d_inode, next, S_IFREG, true);\n\t\t\tcachefiles_hist(cachefiles_create_histogram, start);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto create_error;\n\n\t\t\tASSERT(next->d_inode);\n\n\t\t\t_debug(\"create -> %p{%p{ino=%lu}}\",\n\t\t\t       next, next->d_inode, next->d_inode->i_ino);\n\n\t\t} else if (!d_can_lookup(next) &&\n\t\t\t   !d_is_reg(next)\n\t\t\t   ) {\n\t\t\tpr_err(\"inode %lu is not a file or directory\\n\",\n\t\t\t       next->d_inode->i_ino);\n\t\t\tret = -ENOBUFS;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* process the next component */\n\tif (key) {\n\t\t_debug(\"advance\");\n\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\tdput(dir);\n\t\tdir = next;\n\t\tnext = NULL;\n\t\tgoto advance;\n\t}\n\n\t/* we've found the object we were looking for */\n\tobject->dentry = next;\n\n\t/* if we've found that the terminal object exists, then we need to\n\t * check its attributes and delete it if it's out of date */\n\tif (!object->new) {\n\t\t_debug(\"validate '%pd'\", next);\n\n\t\tret = cachefiles_check_object_xattr(object, auxdata);\n\t\tif (ret == -ESTALE) {\n\t\t\t/* delete the object (the deleter drops the directory\n\t\t\t * mutex) */\n\t\t\tobject->dentry = NULL;\n\n\t\t\tret = cachefiles_bury_object(cache, dir, next, true);\n\t\t\tdput(next);\n\t\t\tnext = NULL;\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto delete_error;\n\n\t\t\t_debug(\"redo lookup\");\n\t\t\tgoto lookup_again;\n\t\t}\n\t}\n\n\t/* note that we're now using this object */\n\tret = cachefiles_mark_object_active(cache, object);\n\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(dir);\n\tdir = NULL;\n\n\tif (ret == -ETIMEDOUT)\n\t\tgoto mark_active_timed_out;\n\n\t_debug(\"=== OBTAINED_OBJECT ===\");\n\n\tif (object->new) {\n\t\t/* attach data to a newly constructed terminal object */\n\t\tret = cachefiles_set_object_xattr(object, auxdata);\n\t\tif (ret < 0)\n\t\t\tgoto check_error;\n\t} else {\n\t\t/* always update the atime on an object we've just looked up\n\t\t * (this is used to keep track of culling, and atimes are only\n\t\t * updated by read, write and readdir but not lookup or\n\t\t * open) */\n\t\tpath.dentry = next;\n\t\ttouch_atime(&path);\n\t}\n\n\t/* open a file interface onto a data file */\n\tif (object->type != FSCACHE_COOKIE_TYPE_INDEX) {\n\t\tif (d_is_reg(object->dentry)) {\n\t\t\tconst struct address_space_operations *aops;\n\n\t\t\tret = -EPERM;\n\t\t\taops = object->dentry->d_inode->i_mapping->a_ops;\n\t\t\tif (!aops->bmap)\n\t\t\t\tgoto check_error;\n\n\t\t\tobject->backer = object->dentry;\n\t\t} else {\n\t\t\tBUG(); // TODO: open file in data-class subdir\n\t\t}\n\t}\n\n\tobject->new = 0;\n\tfscache_obtained_object(&object->fscache);\n\n\t_leave(\" = 0 [%lu]\", object->dentry->d_inode->i_ino);\n\treturn 0;\n\ncreate_error:\n\t_debug(\"create error %d\", ret);\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache, \"Create/mkdir failed\");\n\tgoto error;\n\nmark_active_timed_out:\n\t_debug(\"mark active timed out\");\n\tgoto release_dentry;\n\ncheck_error:\n\t_debug(\"check error %d\", ret);\n\twrite_lock(&cache->active_lock);\n\trb_erase(&object->active_node, &cache->active_nodes);\n\tclear_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags);\n\twake_up_bit(&object->flags, CACHEFILES_OBJECT_ACTIVE);\n\twrite_unlock(&cache->active_lock);\nrelease_dentry:\n\tdput(object->dentry);\n\tobject->dentry = NULL;\n\tgoto error_out;\n\ndelete_error:\n\t_debug(\"delete error %d\", ret);\n\tgoto error_out2;\n\nlookup_error:\n\t_debug(\"lookup error %ld\", PTR_ERR(next));\n\tret = PTR_ERR(next);\n\tif (ret == -EIO)\n\t\tcachefiles_io_error(cache, \"Lookup failed\");\n\tnext = NULL;\nerror:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tdput(next);\nerror_out2:\n\tdput(dir);\nerror_out:\n\t_leave(\" = error %d\", -ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cachefiles_begin_secure",
          "args": [
            "cache",
            "&saved_cred"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_begin_secure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/internal.h",
          "lines": "225-229",
          "snippet": "static inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/fscache-cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);",
            "extern int cachefiles_get_security_ID(struct cachefiles_cache *cache);",
            "extern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/fscache-cache.h>\n\nextern void cachefiles_daemon_unbind(struct cachefiles_cache *cache);\nextern int cachefiles_get_security_ID(struct cachefiles_cache *cache);\nextern int cachefiles_determine_cache_security(struct cachefiles_cache *cache,\n\t\t\t\t\t       struct dentry *root,\n\t\t\t\t\t       const struct cred **_saved_cred);\n\nstatic inline void cachefiles_begin_secure(struct cachefiles_cache *cache,\n\t\t\t\t\t   const struct cred **_saved_cred)\n{\n\t*_saved_cred = override_creds(cache->cache_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "lookup_data",
            "!=, NULL"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object->parent",
            "structcachefiles_object",
            "fscache"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_object->cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{OBJ%x}\"",
            "_object->debug_id"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic int cachefiles_attr_changed(struct fscache_object *_object);\n\nstatic int cachefiles_lookup_object(struct fscache_object *_object)\n{\n\tstruct cachefiles_lookup_data *lookup_data;\n\tstruct cachefiles_object *parent, *object;\n\tstruct cachefiles_cache *cache;\n\tconst struct cred *saved_cred;\n\tint ret;\n\n\t_enter(\"{OBJ%x}\", _object->debug_id);\n\n\tcache = container_of(_object->cache, struct cachefiles_cache, cache);\n\tparent = container_of(_object->parent,\n\t\t\t      struct cachefiles_object, fscache);\n\tobject = container_of(_object, struct cachefiles_object, fscache);\n\tlookup_data = object->lookup_data;\n\n\tASSERTCMP(lookup_data, !=, NULL);\n\n\t/* look up the key, creating any missing bits */\n\tcachefiles_begin_secure(cache, &saved_cred);\n\tret = cachefiles_walk_to_object(parent, object,\n\t\t\t\t\tlookup_data->key,\n\t\t\t\t\tlookup_data->auxdata);\n\tcachefiles_end_secure(cache, saved_cred);\n\n\t/* polish off by setting the attributes of non-index files */\n\tif (ret == 0 &&\n\t    object->fscache.cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX)\n\t\tcachefiles_attr_changed(&object->fscache);\n\n\tif (ret < 0 && ret != -ETIMEDOUT) {\n\t\tif (ret != -ENOBUFS)\n\t\t\tpr_warn(\"Lookup failed error %d\\n\", ret);\n\t\tfscache_object_lookup_error(&object->fscache);\n\t}\n\n\t_leave(\" [%d]\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "cachefiles_alloc_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/interface.c",
    "lines": "26-111",
    "snippet": "static struct fscache_object *cachefiles_alloc_object(\n\tstruct fscache_cache *_cache,\n\tstruct fscache_cookie *cookie)\n{\n\tstruct cachefiles_lookup_data *lookup_data;\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct cachefiles_xattr *auxdata;\n\tunsigned keylen, auxlen;\n\tvoid *buffer;\n\tchar *key;\n\n\tcache = container_of(_cache, struct cachefiles_cache, cache);\n\n\t_enter(\"{%s},%p,\", cache->cache.identifier, cookie);\n\n\tlookup_data = kmalloc(sizeof(*lookup_data), cachefiles_gfp);\n\tif (!lookup_data)\n\t\tgoto nomem_lookup_data;\n\n\t/* create a new object record and a temporary leaf image */\n\tobject = kmem_cache_alloc(cachefiles_object_jar, cachefiles_gfp);\n\tif (!object)\n\t\tgoto nomem_object;\n\n\tASSERTCMP(object->backer, ==, NULL);\n\n\tBUG_ON(test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\n\tatomic_set(&object->usage, 1);\n\n\tfscache_object_init(&object->fscache, cookie, &cache->cache);\n\n\tobject->type = cookie->def->type;\n\n\t/* get hold of the raw key\n\t * - stick the length on the front and leave space on the back for the\n\t *   encoder\n\t */\n\tbuffer = kmalloc((2 + 512) + 3, cachefiles_gfp);\n\tif (!buffer)\n\t\tgoto nomem_buffer;\n\n\tkeylen = cookie->def->get_key(cookie->netfs_data, buffer + 2, 512);\n\tASSERTCMP(keylen, <, 512);\n\n\t*(uint16_t *)buffer = keylen;\n\t((char *)buffer)[keylen + 2] = 0;\n\t((char *)buffer)[keylen + 3] = 0;\n\t((char *)buffer)[keylen + 4] = 0;\n\n\t/* turn the raw key into something that can work with as a filename */\n\tkey = cachefiles_cook_key(buffer, keylen + 2, object->type);\n\tif (!key)\n\t\tgoto nomem_key;\n\n\t/* get hold of the auxiliary data and prepend the object type */\n\tauxdata = buffer;\n\tauxlen = 0;\n\tif (cookie->def->get_aux) {\n\t\tauxlen = cookie->def->get_aux(cookie->netfs_data,\n\t\t\t\t\t      auxdata->data, 511);\n\t\tASSERTCMP(auxlen, <, 511);\n\t}\n\n\tauxdata->len = auxlen + 1;\n\tauxdata->type = cookie->def->type;\n\n\tlookup_data->auxdata = auxdata;\n\tlookup_data->key = key;\n\tobject->lookup_data = lookup_data;\n\n\t_leave(\" = %p [%p]\", &object->fscache, lookup_data);\n\treturn &object->fscache;\n\nnomem_key:\n\tkfree(buffer);\nnomem_buffer:\n\tBUG_ON(test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\n\tkmem_cache_free(cachefiles_object_jar, object);\n\tfscache_object_destroyed(&cache->cache);\nnomem_object:\n\tkfree(lookup_data);\nnomem_lookup_data:\n\t_leave(\" = -ENOMEM\");\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lookup_data"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscache_object_destroyed",
          "args": [
            "&cache->cache"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cachefiles_object_jar",
            "object"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHEFILES_OBJECT_ACTIVE",
            "&object->flags"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %p [%p]\"",
            "&object->fscache",
            "lookup_data"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "auxlen",
            "<,511"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie->def->get_aux",
          "args": [
            "cookie->netfs_data",
            "auxdata->data",
            "511"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cachefiles_cook_key",
          "args": [
            "buffer",
            "keylen + 2",
            "object->type"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_cook_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/key.c",
          "lines": "37-159",
          "snippet": "char *cachefiles_cook_key(const u8 *raw, int keylen, uint8_t type)\n{\n\tunsigned char csum, ch;\n\tunsigned int acc;\n\tchar *key;\n\tint loop, len, max, seg, mark, print;\n\n\t_enter(\",%d\", keylen);\n\n\tBUG_ON(keylen < 2 || keylen > 514);\n\n\tcsum = raw[0] + raw[1];\n\tprint = 1;\n\tfor (loop = 2; loop < keylen; loop++) {\n\t\tch = raw[loop];\n\t\tcsum += ch;\n\t\tprint &= cachefiles_filecharmap[ch];\n\t}\n\n\tif (print) {\n\t\t/* if the path is usable ASCII, then we render it directly */\n\t\tmax = keylen - 2;\n\t\tmax += 2;\t/* two base64'd length chars on the front */\n\t\tmax += 5;\t/* @checksum/M */\n\t\tmax += 3 * 2;\t/* maximum number of segment dividers (\".../M\")\n\t\t\t\t * is ((514 + 251) / 252) = 3\n\t\t\t\t */\n\t\tmax += 1;\t/* NUL on end */\n\t} else {\n\t\t/* calculate the maximum length of the cooked key */\n\t\tkeylen = (keylen + 2) / 3;\n\n\t\tmax = keylen * 4;\n\t\tmax += 5;\t/* @checksum/M */\n\t\tmax += 3 * 2;\t/* maximum number of segment dividers (\".../M\")\n\t\t\t\t * is ((514 + 188) / 189) = 3\n\t\t\t\t */\n\t\tmax += 1;\t/* NUL on end */\n\t}\n\n\tmax += 1;\t/* 2nd NUL on end */\n\n\t_debug(\"max: %d\", max);\n\n\tkey = kmalloc(max, cachefiles_gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tlen = 0;\n\n\t/* build the cooked key */\n\tsprintf(key, \"@%02x%c+\", (unsigned) csum, 0);\n\tlen = 5;\n\tmark = len - 1;\n\n\tif (print) {\n\t\tacc = *(uint16_t *) raw;\n\t\traw += 2;\n\n\t\tkey[len + 1] = cachefiles_charmap[acc & 63];\n\t\tacc >>= 6;\n\t\tkey[len] = cachefiles_charmap[acc & 63];\n\t\tlen += 2;\n\n\t\tseg = 250;\n\t\tfor (loop = keylen; loop > 0; loop--) {\n\t\t\tif (seg <= 0) {\n\t\t\t\tkey[len++] = '\\0';\n\t\t\t\tmark = len;\n\t\t\t\tkey[len++] = '+';\n\t\t\t\tseg = 252;\n\t\t\t}\n\n\t\t\tkey[len++] = *raw++;\n\t\t\tASSERT(len < max);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase FSCACHE_COOKIE_TYPE_INDEX:\t\ttype = 'I';\tbreak;\n\t\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\ttype = 'D';\tbreak;\n\t\tdefault:\t\t\t\ttype = 'S';\tbreak;\n\t\t}\n\t} else {\n\t\tseg = 252;\n\t\tfor (loop = keylen; loop > 0; loop--) {\n\t\t\tif (seg <= 0) {\n\t\t\t\tkey[len++] = '\\0';\n\t\t\t\tmark = len;\n\t\t\t\tkey[len++] = '+';\n\t\t\t\tseg = 252;\n\t\t\t}\n\n\t\t\tacc = *raw++;\n\t\t\tacc |= *raw++ << 8;\n\t\t\tacc |= *raw++ << 16;\n\n\t\t\t_debug(\"acc: %06x\", acc);\n\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\n\t\t\tASSERT(len < max);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase FSCACHE_COOKIE_TYPE_INDEX:\t\ttype = 'J';\tbreak;\n\t\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\ttype = 'E';\tbreak;\n\t\tdefault:\t\t\t\ttype = 'T';\tbreak;\n\t\t}\n\t}\n\n\tkey[mark] = type;\n\tkey[len++] = 0;\n\tkey[len] = 0;\n\n\t_leave(\" = %p %d\", key, len);\n\treturn key;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char cachefiles_charmap[64] =\n\t\"0123456789\"\t\t\t/* 0 - 9 */\n\t\"abcdefghijklmnopqrstuvwxyz\"\t/* 10 - 35 */\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t/* 36 - 61 */\n\t\"_-\"\t\t\t\t/* 62 - 63 */\n\t;",
            "static const char cachefiles_filecharmap[256] = {\n\t/* we skip space and tab and control chars */\n\t[33 ... 46] = 1,\t\t/* '!' -> '.' */\n\t/* we skip '/' as it's significant to pathwalk */\n\t[48 ... 127] = 1,\t\t/* '0' -> '~' */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n\nstatic const char cachefiles_charmap[64] =\n\t\"0123456789\"\t\t\t/* 0 - 9 */\n\t\"abcdefghijklmnopqrstuvwxyz\"\t/* 10 - 35 */\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t/* 36 - 61 */\n\t\"_-\"\t\t\t\t/* 62 - 63 */\n\t;\nstatic const char cachefiles_filecharmap[256] = {\n\t/* we skip space and tab and control chars */\n\t[33 ... 46] = 1,\t\t/* '!' -> '.' */\n\t/* we skip '/' as it's significant to pathwalk */\n\t[48 ... 127] = 1,\t\t/* '0' -> '~' */\n};\n\nchar *cachefiles_cook_key(const u8 *raw, int keylen, uint8_t type)\n{\n\tunsigned char csum, ch;\n\tunsigned int acc;\n\tchar *key;\n\tint loop, len, max, seg, mark, print;\n\n\t_enter(\",%d\", keylen);\n\n\tBUG_ON(keylen < 2 || keylen > 514);\n\n\tcsum = raw[0] + raw[1];\n\tprint = 1;\n\tfor (loop = 2; loop < keylen; loop++) {\n\t\tch = raw[loop];\n\t\tcsum += ch;\n\t\tprint &= cachefiles_filecharmap[ch];\n\t}\n\n\tif (print) {\n\t\t/* if the path is usable ASCII, then we render it directly */\n\t\tmax = keylen - 2;\n\t\tmax += 2;\t/* two base64'd length chars on the front */\n\t\tmax += 5;\t/* @checksum/M */\n\t\tmax += 3 * 2;\t/* maximum number of segment dividers (\".../M\")\n\t\t\t\t * is ((514 + 251) / 252) = 3\n\t\t\t\t */\n\t\tmax += 1;\t/* NUL on end */\n\t} else {\n\t\t/* calculate the maximum length of the cooked key */\n\t\tkeylen = (keylen + 2) / 3;\n\n\t\tmax = keylen * 4;\n\t\tmax += 5;\t/* @checksum/M */\n\t\tmax += 3 * 2;\t/* maximum number of segment dividers (\".../M\")\n\t\t\t\t * is ((514 + 188) / 189) = 3\n\t\t\t\t */\n\t\tmax += 1;\t/* NUL on end */\n\t}\n\n\tmax += 1;\t/* 2nd NUL on end */\n\n\t_debug(\"max: %d\", max);\n\n\tkey = kmalloc(max, cachefiles_gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tlen = 0;\n\n\t/* build the cooked key */\n\tsprintf(key, \"@%02x%c+\", (unsigned) csum, 0);\n\tlen = 5;\n\tmark = len - 1;\n\n\tif (print) {\n\t\tacc = *(uint16_t *) raw;\n\t\traw += 2;\n\n\t\tkey[len + 1] = cachefiles_charmap[acc & 63];\n\t\tacc >>= 6;\n\t\tkey[len] = cachefiles_charmap[acc & 63];\n\t\tlen += 2;\n\n\t\tseg = 250;\n\t\tfor (loop = keylen; loop > 0; loop--) {\n\t\t\tif (seg <= 0) {\n\t\t\t\tkey[len++] = '\\0';\n\t\t\t\tmark = len;\n\t\t\t\tkey[len++] = '+';\n\t\t\t\tseg = 252;\n\t\t\t}\n\n\t\t\tkey[len++] = *raw++;\n\t\t\tASSERT(len < max);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase FSCACHE_COOKIE_TYPE_INDEX:\t\ttype = 'I';\tbreak;\n\t\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\ttype = 'D';\tbreak;\n\t\tdefault:\t\t\t\ttype = 'S';\tbreak;\n\t\t}\n\t} else {\n\t\tseg = 252;\n\t\tfor (loop = keylen; loop > 0; loop--) {\n\t\t\tif (seg <= 0) {\n\t\t\t\tkey[len++] = '\\0';\n\t\t\t\tmark = len;\n\t\t\t\tkey[len++] = '+';\n\t\t\t\tseg = 252;\n\t\t\t}\n\n\t\t\tacc = *raw++;\n\t\t\tacc |= *raw++ << 8;\n\t\t\tacc |= *raw++ << 16;\n\n\t\t\t_debug(\"acc: %06x\", acc);\n\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\t\t\tacc >>= 6;\n\t\t\tkey[len++] = cachefiles_charmap[acc & 63];\n\n\t\t\tASSERT(len < max);\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase FSCACHE_COOKIE_TYPE_INDEX:\t\ttype = 'J';\tbreak;\n\t\tcase FSCACHE_COOKIE_TYPE_DATAFILE:\ttype = 'E';\tbreak;\n\t\tdefault:\t\t\t\ttype = 'T';\tbreak;\n\t\t}\n\t}\n\n\tkey[mark] = type;\n\tkey[len++] = 0;\n\tkey[len] = 0;\n\n\t_leave(\" = %p %d\", key, len);\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "keylen",
            "<,512"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cookie->def->get_key",
          "args": [
            "cookie->netfs_data",
            "buffer + 2",
            "512"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(2 + 512) + 3",
            "cachefiles_gfp"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_object_init",
          "args": [
            "&object->fscache",
            "cookie",
            "&cache->cache"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_object_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/object.c",
          "lines": "291-327",
          "snippet": "void fscache_object_init(struct fscache_object *object,\n\t\t\t struct fscache_cookie *cookie,\n\t\t\t struct fscache_cache *cache)\n{\n\tconst struct fscache_transition *t;\n\n\tatomic_inc(&cache->object_count);\n\n\tobject->state = STATE(WAIT_FOR_INIT);\n\tobject->oob_table = fscache_osm_init_oob;\n\tobject->flags = 1 << FSCACHE_OBJECT_IS_LIVE;\n\tspin_lock_init(&object->lock);\n\tINIT_LIST_HEAD(&object->cache_link);\n\tINIT_HLIST_NODE(&object->cookie_link);\n\tINIT_WORK(&object->work, fscache_object_work_func);\n\tINIT_LIST_HEAD(&object->dependents);\n\tINIT_LIST_HEAD(&object->dep_link);\n\tINIT_LIST_HEAD(&object->pending_ops);\n\tobject->n_children = 0;\n\tobject->n_ops = object->n_in_progress = object->n_exclusive = 0;\n\tobject->events = 0;\n\tobject->store_limit = 0;\n\tobject->store_limit_l = 0;\n\tobject->cache = cache;\n\tobject->cookie = cookie;\n\tobject->parent = NULL;\n#ifdef CONFIG_FSCACHE_OBJECT_LIST\n\tRB_CLEAR_NODE(&object->objlist_link);\n#endif\n\n\tobject->oob_event_mask = 0;\n\tfor (t = object->oob_table; t->events; t++)\n\t\tobject->oob_event_mask |= t->events;\n\tobject->event_mask = object->oob_event_mask;\n\tfor (t = object->state->transitions; t->events; t++)\n\t\tobject->event_mask |= t->events;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_drop_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_kill_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_object_available(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);",
            "static const struct fscache_state *fscache_update_object(struct fscache_object *, int);",
            "static const struct fscache_transition fscache_osm_init_oob[] = {\n\t   TRANSIT_TO(ABORT_INIT,\n\t\t      (1 << FSCACHE_OBJECT_EV_ERROR) |\n\t\t      (1 << FSCACHE_OBJECT_EV_KILL)),\n\t   { 0, NULL }\n};",
            "static int  fscache_get_object(struct fscache_object *);",
            "static void fscache_put_object(struct fscache_object *);",
            "static bool fscache_enqueue_dependents(struct fscache_object *, int);",
            "static void fscache_dequeue_object(struct fscache_object *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic const struct fscache_state *fscache_abort_initialisation(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_drop_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_initialise_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_invalidate_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_jumpstart_dependents(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_kill_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_lookup_failure(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_look_up_object(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_object_available(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_parent_ready(struct fscache_object *, int);\nstatic const struct fscache_state *fscache_update_object(struct fscache_object *, int);\nstatic const struct fscache_transition fscache_osm_init_oob[] = {\n\t   TRANSIT_TO(ABORT_INIT,\n\t\t      (1 << FSCACHE_OBJECT_EV_ERROR) |\n\t\t      (1 << FSCACHE_OBJECT_EV_KILL)),\n\t   { 0, NULL }\n};\nstatic int  fscache_get_object(struct fscache_object *);\nstatic void fscache_put_object(struct fscache_object *);\nstatic bool fscache_enqueue_dependents(struct fscache_object *, int);\nstatic void fscache_dequeue_object(struct fscache_object *);\n\nvoid fscache_object_init(struct fscache_object *object,\n\t\t\t struct fscache_cookie *cookie,\n\t\t\t struct fscache_cache *cache)\n{\n\tconst struct fscache_transition *t;\n\n\tatomic_inc(&cache->object_count);\n\n\tobject->state = STATE(WAIT_FOR_INIT);\n\tobject->oob_table = fscache_osm_init_oob;\n\tobject->flags = 1 << FSCACHE_OBJECT_IS_LIVE;\n\tspin_lock_init(&object->lock);\n\tINIT_LIST_HEAD(&object->cache_link);\n\tINIT_HLIST_NODE(&object->cookie_link);\n\tINIT_WORK(&object->work, fscache_object_work_func);\n\tINIT_LIST_HEAD(&object->dependents);\n\tINIT_LIST_HEAD(&object->dep_link);\n\tINIT_LIST_HEAD(&object->pending_ops);\n\tobject->n_children = 0;\n\tobject->n_ops = object->n_in_progress = object->n_exclusive = 0;\n\tobject->events = 0;\n\tobject->store_limit = 0;\n\tobject->store_limit_l = 0;\n\tobject->cache = cache;\n\tobject->cookie = cookie;\n\tobject->parent = NULL;\n#ifdef CONFIG_FSCACHE_OBJECT_LIST\n\tRB_CLEAR_NODE(&object->objlist_link);\n#endif\n\n\tobject->oob_event_mask = 0;\n\tfor (t = object->oob_table; t->events; t++)\n\t\tobject->oob_event_mask |= t->events;\n\tobject->event_mask = object->oob_event_mask;\n\tfor (t = object->state->transitions; t->events; t++)\n\t\tobject->event_mask |= t->events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&object->usage",
            "1"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "object->backer",
            "==,NULL"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "cachefiles_object_jar",
            "cachefiles_gfp"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s},%p,\"",
            "cache->cache.identifier",
            "cookie"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "_cache",
            "structcachefiles_cache",
            "cache"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/slab.h>\n\nstatic struct fscache_object *cachefiles_alloc_object(\n\tstruct fscache_cache *_cache,\n\tstruct fscache_cookie *cookie)\n{\n\tstruct cachefiles_lookup_data *lookup_data;\n\tstruct cachefiles_object *object;\n\tstruct cachefiles_cache *cache;\n\tstruct cachefiles_xattr *auxdata;\n\tunsigned keylen, auxlen;\n\tvoid *buffer;\n\tchar *key;\n\n\tcache = container_of(_cache, struct cachefiles_cache, cache);\n\n\t_enter(\"{%s},%p,\", cache->cache.identifier, cookie);\n\n\tlookup_data = kmalloc(sizeof(*lookup_data), cachefiles_gfp);\n\tif (!lookup_data)\n\t\tgoto nomem_lookup_data;\n\n\t/* create a new object record and a temporary leaf image */\n\tobject = kmem_cache_alloc(cachefiles_object_jar, cachefiles_gfp);\n\tif (!object)\n\t\tgoto nomem_object;\n\n\tASSERTCMP(object->backer, ==, NULL);\n\n\tBUG_ON(test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\n\tatomic_set(&object->usage, 1);\n\n\tfscache_object_init(&object->fscache, cookie, &cache->cache);\n\n\tobject->type = cookie->def->type;\n\n\t/* get hold of the raw key\n\t * - stick the length on the front and leave space on the back for the\n\t *   encoder\n\t */\n\tbuffer = kmalloc((2 + 512) + 3, cachefiles_gfp);\n\tif (!buffer)\n\t\tgoto nomem_buffer;\n\n\tkeylen = cookie->def->get_key(cookie->netfs_data, buffer + 2, 512);\n\tASSERTCMP(keylen, <, 512);\n\n\t*(uint16_t *)buffer = keylen;\n\t((char *)buffer)[keylen + 2] = 0;\n\t((char *)buffer)[keylen + 3] = 0;\n\t((char *)buffer)[keylen + 4] = 0;\n\n\t/* turn the raw key into something that can work with as a filename */\n\tkey = cachefiles_cook_key(buffer, keylen + 2, object->type);\n\tif (!key)\n\t\tgoto nomem_key;\n\n\t/* get hold of the auxiliary data and prepend the object type */\n\tauxdata = buffer;\n\tauxlen = 0;\n\tif (cookie->def->get_aux) {\n\t\tauxlen = cookie->def->get_aux(cookie->netfs_data,\n\t\t\t\t\t      auxdata->data, 511);\n\t\tASSERTCMP(auxlen, <, 511);\n\t}\n\n\tauxdata->len = auxlen + 1;\n\tauxdata->type = cookie->def->type;\n\n\tlookup_data->auxdata = auxdata;\n\tlookup_data->key = key;\n\tobject->lookup_data = lookup_data;\n\n\t_leave(\" = %p [%p]\", &object->fscache, lookup_data);\n\treturn &object->fscache;\n\nnomem_key:\n\tkfree(buffer);\nnomem_buffer:\n\tBUG_ON(test_bit(CACHEFILES_OBJECT_ACTIVE, &object->flags));\n\tkmem_cache_free(cachefiles_object_jar, object);\n\tfscache_object_destroyed(&cache->cache);\nnomem_object:\n\tkfree(lookup_data);\nnomem_lookup_data:\n\t_leave(\" = -ENOMEM\");\n\treturn ERR_PTR(-ENOMEM);\n}"
  }
]