[
  {
    "function_name": "ext4_check_all_de",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "572-595",
    "snippet": "int ext4_check_all_de(struct inode *dir, struct buffer_head *bh, void *buf,\n\t\t      int buf_size)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size;\n\twhile ((char *) de < top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -EIO;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "buf_size"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "dir",
            "NULL",
            "de",
            "bh",
            "buf",
            "buf_size",
            "offset"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4_check_all_de(struct inode *dir, struct buffer_head *bh, void *buf,\n\t\t      int buf_size)\n{\n\tstruct ext4_dir_entry_2 *de;\n\tint nlen, rlen;\n\tunsigned int offset = 0;\n\tchar *top;\n\n\tde = (struct ext4_dir_entry_2 *)buf;\n\ttop = buf + buf_size;\n\twhile ((char *) de < top) {\n\t\tif (ext4_check_dir_entry(dir, NULL, de, bh,\n\t\t\t\t\t buf, buf_size, offset))\n\t\t\treturn -EIO;\n\t\tnlen = EXT4_DIR_REC_LEN(de->name_len);\n\t\trlen = ext4_rec_len_from_disk(de->rec_len, buf_size);\n\t\tde = (struct ext4_dir_entry_2 *)((char *)de + rlen);\n\t\toffset += rlen;\n\t}\n\tif ((char *) de > top)\n\t\treturn -EIO;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_release_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "564-570",
    "snippet": "static int ext4_release_dir(struct inode *inode, struct file *filp)\n{\n\tif (filp->private_data)\n\t\text4_htree_free_dir_info(filp->private_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_htree_free_dir_info",
          "args": [
            "filp->private_data"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_free_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "379-383",
          "snippet": "void ext4_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nvoid ext4_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int ext4_release_dir(struct inode *inode, struct file *filp)\n{\n\tif (filp->private_data)\n\t\text4_htree_free_dir_info(filp->private_data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_dx_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "477-562",
    "snippet": "static int ext4_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint\tret;\n\n\tif (!info) {\n\t\tinfo = ext4_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext4_get_htree_eof(file))\n\t\treturn 0;\t/* EOF */\n\n\t/* Some one has messed with f_pos; reset the world */\n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t/*\n\t * If there are any leftover names on the hash collision\n\t * chain, return them first.\n\t */\n\tif (info->extra_fname) {\n\t\tif (call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t/*\n\t\t * Fill the rbtree if we have no more entries,\n\t\t * or the inode has changed since we last read in the\n\t\t * cached entries.\n\t\t */\n\t\tif ((!info->curr_node) ||\n\t\t    (file->f_version != inode->i_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tret = ext4_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_get_htree_eof",
          "args": [
            "file"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_htree_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "298-305",
          "snippet": "static inline loff_t ext4_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT4_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT4_HTREE_EOF_64BIT;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline loff_t ext4_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT4_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT4_HTREE_EOF_64BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "info->curr_node",
            "structfname",
            "rb_hash"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "info->curr_node"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_filldir",
          "args": [
            "file",
            "ctx",
            "fname"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "call_filldir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "450-475",
          "snippet": "static int call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: comm %s: \"\n\t\t\t \"called with null fname?!?\", __func__, __LINE__,\n\t\t\t inode->i_ino, current->comm);\n\t\treturn 0;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name,\n\t\t\t\tfname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn 1;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_readdir(struct file *, struct dir_context *);\n\nstatic int call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: comm %s: \"\n\t\t\t \"called with null fname?!?\", __func__, __LINE__,\n\t\t\t inode->i_ino, current->comm);\n\t\treturn 0;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name,\n\t\t\t\tfname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn 1;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "info->curr_node",
            "structfname",
            "rb_hash"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&info->root"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_htree_fill_tree",
          "args": [
            "file",
            "info->curr_hash",
            "info->curr_minor_hash",
            "&info->next_hash"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_fill_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "927-1018",
          "snippet": "int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct dx_frame frames[2], *frame;\n\tstruct inode *dir;\n\text4_lblk_t block;\n\tint count = 0;\n\tint ret, err;\n\t__u32 hashval;\n\n\tdxtrace(printk(KERN_DEBUG \"In htree_fill_tree, start hash: %x:%x\\n\",\n\t\t       start_hash, start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {\n\t\thinfo.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT4_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\t\tif (ext4_has_inline_data(dir)) {\n\t\t\tint has_inline_data = 1;\n\t\t\tcount = htree_inlinedir_to_tree(dir_file, dir, 0,\n\t\t\t\t\t\t\t&hinfo, start_hash,\n\t\t\t\t\t\t\tstart_minor_hash,\n\t\t\t\t\t\t\t&has_inline_data);\n\t\t\tif (has_inline_data) {\n\t\t\t\t*next_hash = ~0;\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tif ((err = ext4_htree_store_dirent(dir_file, 0, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext4_next_entry(de, dir->i_sb->s_blocksize);\n\t\tif ((err = ext4_htree_store_dirent(dir_file, 2, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext4_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(KERN_DEBUG \"Fill tree: returned %d entries, \"\n\t\t       \"next hash: %x\\n\", count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline ext4_lblk_t dx_get_block(struct dx_entry *entry);",
            "static void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);",
            "static inline unsigned dx_get_hash(struct dx_entry *entry);",
            "static void dx_set_hash(struct dx_entry *entry, unsigned value);",
            "static unsigned dx_get_count(struct dx_entry *entries);",
            "static unsigned dx_get_limit(struct dx_entry *entries);",
            "static void dx_set_count(struct dx_entry *entries, unsigned value);",
            "static void dx_set_limit(struct dx_entry *entries, unsigned value);",
            "static unsigned dx_node_limit(struct inode *dir);",
            "static struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);",
            "static void dx_release(struct dx_frame *frames);",
            "static void dx_sort_map(struct dx_map_entry *map, unsigned count);",
            "static void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);",
            "static int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline ext4_lblk_t dx_get_block(struct dx_entry *entry);\nstatic void dx_set_block(struct dx_entry *entry, ext4_lblk_t value);\nstatic inline unsigned dx_get_hash(struct dx_entry *entry);\nstatic void dx_set_hash(struct dx_entry *entry, unsigned value);\nstatic unsigned dx_get_count(struct dx_entry *entries);\nstatic unsigned dx_get_limit(struct dx_entry *entries);\nstatic void dx_set_count(struct dx_entry *entries, unsigned value);\nstatic void dx_set_limit(struct dx_entry *entries, unsigned value);\nstatic unsigned dx_node_limit(struct inode *dir);\nstatic struct dx_frame *dx_probe(const struct qstr *d_name,\n\t\t\t\t struct inode *dir,\n\t\t\t\t struct dx_hash_info *hinfo,\n\t\t\t\t struct dx_frame *frame);\nstatic void dx_release(struct dx_frame *frames);\nstatic void dx_sort_map(struct dx_map_entry *map, unsigned count);\nstatic void dx_insert_block(struct dx_frame *frame,\n\t\t\t\t\tu32 hash, ext4_lblk_t block);\nstatic int ext4_htree_next_block(struct inode *dir, __u32 hash,\n\t\t\t\t struct dx_frame *frame,\n\t\t\t\t struct dx_frame *frames,\n\t\t\t\t __u32 *start_hash);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,\n\t\t\t __u32 start_minor_hash, __u32 *next_hash)\n{\n\tstruct dx_hash_info hinfo;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct dx_frame frames[2], *frame;\n\tstruct inode *dir;\n\text4_lblk_t block;\n\tint count = 0;\n\tint ret, err;\n\t__u32 hashval;\n\n\tdxtrace(printk(KERN_DEBUG \"In htree_fill_tree, start hash: %x:%x\\n\",\n\t\t       start_hash, start_minor_hash));\n\tdir = file_inode(dir_file);\n\tif (!(ext4_test_inode_flag(dir, EXT4_INODE_INDEX))) {\n\t\thinfo.hash_version = EXT4_SB(dir->i_sb)->s_def_hash_version;\n\t\tif (hinfo.hash_version <= DX_HASH_TEA)\n\t\t\thinfo.hash_version +=\n\t\t\t\tEXT4_SB(dir->i_sb)->s_hash_unsigned;\n\t\thinfo.seed = EXT4_SB(dir->i_sb)->s_hash_seed;\n\t\tif (ext4_has_inline_data(dir)) {\n\t\t\tint has_inline_data = 1;\n\t\t\tcount = htree_inlinedir_to_tree(dir_file, dir, 0,\n\t\t\t\t\t\t\t&hinfo, start_hash,\n\t\t\t\t\t\t\tstart_minor_hash,\n\t\t\t\t\t\t\t&has_inline_data);\n\t\t\tif (has_inline_data) {\n\t\t\t\t*next_hash = ~0;\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\tcount = htree_dirblock_to_tree(dir_file, dir, 0, &hinfo,\n\t\t\t\t\t       start_hash, start_minor_hash);\n\t\t*next_hash = ~0;\n\t\treturn count;\n\t}\n\thinfo.hash = start_hash;\n\thinfo.minor_hash = 0;\n\tframe = dx_probe(NULL, dir, &hinfo, frames);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\t/* Add '.' and '..' from the htree header */\n\tif (!start_hash && !start_minor_hash) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tif ((err = ext4_htree_store_dirent(dir_file, 0, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\tif (start_hash < 2 || (start_hash ==2 && start_minor_hash==0)) {\n\t\tde = (struct ext4_dir_entry_2 *) frames[0].bh->b_data;\n\t\tde = ext4_next_entry(de, dir->i_sb->s_blocksize);\n\t\tif ((err = ext4_htree_store_dirent(dir_file, 2, 0, de)) != 0)\n\t\t\tgoto errout;\n\t\tcount++;\n\t}\n\n\twhile (1) {\n\t\tblock = dx_get_block(frame->at);\n\t\tret = htree_dirblock_to_tree(dir_file, dir, block, &hinfo,\n\t\t\t\t\t     start_hash, start_minor_hash);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\tcount += ret;\n\t\thashval = ~0;\n\t\tret = ext4_htree_next_block(dir, HASH_NB_ALWAYS,\n\t\t\t\t\t    frame, frames, &hashval);\n\t\t*next_hash = hashval;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto errout;\n\t\t}\n\t\t/*\n\t\t * Stop if:  (a) there are no more entries, or\n\t\t * (b) we have inserted at least one entry and the\n\t\t * next hash value is not a continuation\n\t\t */\n\t\tif ((ret == 0) ||\n\t\t    (count && ((hashval & 1) == 0)))\n\t\t\tbreak;\n\t}\n\tdx_release(frames);\n\tdxtrace(printk(KERN_DEBUG \"Fill tree: returned %d entries, \"\n\t\t       \"next hash: %x\\n\", count, *next_hash));\n\treturn count;\nerrout:\n\tdx_release(frames);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rb_tree_fname",
          "args": [
            "&info->root"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "free_rb_tree_fname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "351-363",
          "snippet": "static void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\twhile (fname) {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t}\n\n\t*root = RB_ROOT;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\twhile (fname) {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t}\n\n\t*root = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&info->root"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos2min_hash",
          "args": [
            "file",
            "ctx->pos"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "286-293",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos2maj_hash",
          "args": [
            "file",
            "ctx->pos"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "pos2maj_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "277-284",
          "snippet": "static inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_htree_create_dir_info",
          "args": [
            "file",
            "ctx->pos"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_htree_create_dir_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "366-377",
          "snippet": "static struct dir_private_info *ext4_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(struct dir_private_info), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic struct dir_private_info *ext4_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(struct dir_private_info), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_readdir(struct file *, struct dir_context *);\n\nstatic int ext4_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint\tret;\n\n\tif (!info) {\n\t\tinfo = ext4_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext4_get_htree_eof(file))\n\t\treturn 0;\t/* EOF */\n\n\t/* Some one has messed with f_pos; reset the world */\n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t/*\n\t * If there are any leftover names on the hash collision\n\t * chain, return them first.\n\t */\n\tif (info->extra_fname) {\n\t\tif (call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t/*\n\t\t * Fill the rbtree if we have no more entries,\n\t\t * or the inode has changed since we last read in the\n\t\t * cached entries.\n\t\t */\n\t\tif ((!info->curr_node) ||\n\t\t    (file->f_version != inode->i_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tret = ext4_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn 0;\n}"
  },
  {
    "function_name": "call_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "450-475",
    "snippet": "static int call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: comm %s: \"\n\t\t\t \"called with null fname?!?\", __func__, __LINE__,\n\t\t\t inode->i_ino, current->comm);\n\t\treturn 0;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name,\n\t\t\t\tfname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn 1;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "fname->name",
            "fname->name_len",
            "fname->inode",
            "get_dtype(sb, fname->file_type)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dtype",
          "args": [
            "sb",
            "fname->file_type"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "get_dtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "33-40",
          "snippet": "static unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\n\nstatic unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash2pos",
          "args": [
            "file",
            "fname->hash",
            "fname->minor_hash"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "hash2pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "268-275",
          "snippet": "static inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"%s:%d: inode #%lu: comm %s: \"\n\t\t\t \"called with null fname?!?\"",
            "__func__",
            "__LINE__",
            "inode->i_ino",
            "current->comm"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "593-607",
          "snippet": "void __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_unfreeze(struct super_block *sb);",
            "static int ext4_freeze(struct super_block *sb);",
            "static inline int ext2_feature_set_ok(struct super_block *sb);",
            "static inline int ext3_feature_set_ok(struct super_block *sb);",
            "static void ext4_unregister_li_request(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext4_unfreeze(struct super_block *sb);\nstatic int ext4_freeze(struct super_block *sb);\nstatic inline int ext2_feature_set_ok(struct super_block *sb);\nstatic inline int ext3_feature_set_ok(struct super_block *sb);\nstatic void ext4_unregister_li_request(struct super_block *sb);\n\nvoid __ext4_msg(struct super_block *sb,\n\t\tconst char *prefix, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!___ratelimit(&(EXT4_SB(sb)->s_msg_ratelimit_state), \"EXT4-fs\"))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(\"%sEXT4-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_readdir(struct file *, struct dir_context *);\n\nstatic int call_filldir(struct file *file, struct dir_context *ctx,\n\t\t\tstruct fname *fname)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!fname) {\n\t\text4_msg(sb, KERN_ERR, \"%s:%d: inode #%lu: comm %s: \"\n\t\t\t \"called with null fname?!?\", __func__, __LINE__,\n\t\t\t inode->i_ino, current->comm);\n\t\treturn 0;\n\t}\n\tctx->pos = hash2pos(file, fname->hash, fname->minor_hash);\n\twhile (fname) {\n\t\tif (!dir_emit(ctx, fname->name,\n\t\t\t\tfname->name_len,\n\t\t\t\tfname->inode,\n\t\t\t\tget_dtype(sb, fname->file_type))) {\n\t\t\tinfo->extra_fname = fname;\n\t\t\treturn 1;\n\t\t}\n\t\tfname = fname->next;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_htree_store_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "388-441",
    "snippet": "int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext4_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new_fn->rb_hash",
            "&info->root"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new_fn->rb_hash",
            "parent",
            "p"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structfname",
            "rb_hash"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_fn->name",
            "dirent->name",
            "dirent->name_len"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dirent->inode"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint ext4_htree_store_dirent(struct file *dir_file, __u32 hash,\n\t\t\t     __u32 minor_hash,\n\t\t\t     struct ext4_dir_entry_2 *dirent)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct fname *fname, *new_fn;\n\tstruct dir_private_info *info;\n\tint len;\n\n\tinfo = dir_file->private_data;\n\tp = &info->root.rb_node;\n\n\t/* Create and allocate the fname structure */\n\tlen = sizeof(struct fname) + dirent->name_len + 1;\n\tnew_fn = kzalloc(len, GFP_KERNEL);\n\tif (!new_fn)\n\t\treturn -ENOMEM;\n\tnew_fn->hash = hash;\n\tnew_fn->minor_hash = minor_hash;\n\tnew_fn->inode = le32_to_cpu(dirent->inode);\n\tnew_fn->name_len = dirent->name_len;\n\tnew_fn->file_type = dirent->file_type;\n\tmemcpy(new_fn->name, dirent->name, dirent->name_len);\n\tnew_fn->name[dirent->name_len] = 0;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfname = rb_entry(parent, struct fname, rb_hash);\n\n\t\t/*\n\t\t * If the hash and minor hash match up, then we put\n\t\t * them on a linked list.  This rarely happens...\n\t\t */\n\t\tif ((new_fn->hash == fname->hash) &&\n\t\t    (new_fn->minor_hash == fname->minor_hash)) {\n\t\t\tnew_fn->next = fname->next;\n\t\t\tfname->next = new_fn;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (new_fn->hash < fname->hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (new_fn->hash > fname->hash)\n\t\t\tp = &(*p)->rb_right;\n\t\telse if (new_fn->minor_hash < fname->minor_hash)\n\t\t\tp = &(*p)->rb_left;\n\t\telse /* if (new_fn->minor_hash > fname->minor_hash) */\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&new_fn->rb_hash, parent, p);\n\trb_insert_color(&new_fn->rb_hash, &info->root);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_htree_free_dir_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "379-383",
    "snippet": "void ext4_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_rb_tree_fname",
          "args": [
            "&p->root"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "free_rb_tree_fname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "351-363",
          "snippet": "static void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\twhile (fname) {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t}\n\n\t*root = RB_ROOT;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\twhile (fname) {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t}\n\n\t*root = RB_ROOT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nvoid ext4_htree_free_dir_info(struct dir_private_info *p)\n{\n\tfree_rb_tree_fname(&p->root);\n\tkfree(p);\n}"
  },
  {
    "function_name": "ext4_htree_create_dir_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "366-377",
    "snippet": "static struct dir_private_info *ext4_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(struct dir_private_info), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pos2min_hash",
          "args": [
            "filp",
            "pos"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "pos2min_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "286-293",
          "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos2maj_hash",
          "args": [
            "filp",
            "pos"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "pos2maj_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "277-284",
          "snippet": "static inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dir_private_info)",
            "GFP_KERNEL"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic struct dir_private_info *ext4_htree_create_dir_info(struct file *filp,\n\t\t\t\t\t\t\t   loff_t pos)\n{\n\tstruct dir_private_info *p;\n\n\tp = kzalloc(sizeof(struct dir_private_info), GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\tp->curr_hash = pos2maj_hash(filp, pos);\n\tp->curr_minor_hash = pos2min_hash(filp, pos);\n\treturn p;\n}"
  },
  {
    "function_name": "free_rb_tree_fname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "351-363",
    "snippet": "static void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\twhile (fname) {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t}\n\n\t*root = RB_ROOT;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "old"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbtree_postorder_for_each_entry_safe",
          "args": [
            "fname",
            "next",
            "root",
            "rb_hash"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic void free_rb_tree_fname(struct rb_root *root)\n{\n\tstruct fname *fname, *next;\n\n\trbtree_postorder_for_each_entry_safe(fname, next, root, rb_hash)\n\t\twhile (fname) {\n\t\t\tstruct fname *old = fname;\n\t\t\tfname = fname->next;\n\t\t\tkfree(old);\n\t\t}\n\n\t*root = RB_ROOT;\n}"
  },
  {
    "function_name": "ext4_dir_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "319-330",
    "snippet": "static loff_t ext4_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint dx_dir = is_dx_dir(inode);\n\tloff_t htree_max = ext4_get_htree_eof(file);\n\n\tif (likely(dx_dir))\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\t    htree_max, htree_max);\n\telse\n\t\treturn ext4_llseek(file, offset, whence);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_llseek",
          "args": [
            "file",
            "offset",
            "whence"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/file.c",
          "lines": "583-606",
          "snippet": "loff_t ext4_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes;\n\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\tmaxbytes = EXT4_SB(inode->i_sb)->s_bitmap_maxbytes;\n\telse\n\t\tmaxbytes = inode->i_sb->s_maxbytes;\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\tcase SEEK_CUR:\n\tcase SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tmaxbytes, i_size_read(inode));\n\tcase SEEK_DATA:\n\t\treturn ext4_seek_data(file, offset, maxbytes);\n\tcase SEEK_HOLE:\n\t\treturn ext4_seek_hole(file, offset, maxbytes);\n\t}\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/aio.h>",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/pagevec.h>\n#include <linux/quotaops.h>\n#include <linux/aio.h>\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nloff_t ext4_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tloff_t maxbytes;\n\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\tmaxbytes = EXT4_SB(inode->i_sb)->s_bitmap_maxbytes;\n\telse\n\t\tmaxbytes = inode->i_sb->s_maxbytes;\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\tcase SEEK_CUR:\n\tcase SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tmaxbytes, i_size_read(inode));\n\tcase SEEK_DATA:\n\t\treturn ext4_seek_data(file, offset, maxbytes);\n\tcase SEEK_HOLE:\n\t\treturn ext4_seek_hole(file, offset, maxbytes);\n\t}\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_file_llseek_size",
          "args": [
            "file",
            "offset",
            "whence",
            "htree_max",
            "htree_max"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_llseek_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "88-134",
          "snippet": "loff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t\ngeneric_file_llseek_size(struct file *file, loff_t offset, int whence,\n\t\tloff_t maxsize, loff_t eof)\n{\n\tswitch (whence) {\n\tcase SEEK_END:\n\t\toffset += eof;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\t/*\n\t\t * Here we special-case the lseek(fd, 0, SEEK_CUR)\n\t\t * position-querying operation.  Avoid rewriting the \"same\"\n\t\t * f_pos value back to the file because a concurrent read(),\n\t\t * write() or lseek() might have altered it\n\t\t */\n\t\tif (offset == 0)\n\t\t\treturn file->f_pos;\n\t\t/*\n\t\t * f_lock protects against read/modify/write race with other\n\t\t * SEEK_CURs. Note that parallel writes and reads behave\n\t\t * like SEEK_SET.\n\t\t */\n\t\tspin_lock(&file->f_lock);\n\t\toffset = vfs_setpos(file, file->f_pos + offset, maxsize);\n\t\tspin_unlock(&file->f_lock);\n\t\treturn offset;\n\tcase SEEK_DATA:\n\t\t/*\n\t\t * In the generic case the entire file is data, so as long as\n\t\t * offset isn't at the end of the file then the offset is data.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\tbreak;\n\tcase SEEK_HOLE:\n\t\t/*\n\t\t * There is a virtual hole at the end of the file, so as long as\n\t\t * offset isn't i_size or larger, return i_size.\n\t\t */\n\t\tif (offset >= eof)\n\t\t\treturn -ENXIO;\n\t\toffset = eof;\n\t\tbreak;\n\t}\n\n\treturn vfs_setpos(file, offset, maxsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "dx_dir"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_get_htree_eof",
          "args": [
            "file"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_htree_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "298-305",
          "snippet": "static inline loff_t ext4_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT4_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT4_HTREE_EOF_64BIT;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline loff_t ext4_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT4_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT4_HTREE_EOF_64BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx_dir",
          "args": [
            "inode"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic loff_t ext4_dir_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint dx_dir = is_dx_dir(inode);\n\tloff_t htree_max = ext4_get_htree_eof(file);\n\n\tif (likely(dx_dir))\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\t    htree_max, htree_max);\n\telse\n\t\treturn ext4_llseek(file, offset, whence);\n}"
  },
  {
    "function_name": "ext4_get_htree_eof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "298-305",
    "snippet": "static inline loff_t ext4_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT4_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT4_HTREE_EOF_64BIT;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_32bit_api",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "250-257",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline loff_t ext4_get_htree_eof(struct file *filp)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn EXT4_HTREE_EOF_32BIT;\n\telse\n\t\treturn EXT4_HTREE_EOF_64BIT;\n}"
  },
  {
    "function_name": "pos2min_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "286-293",
    "snippet": "static inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_32bit_api",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "250-257",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2min_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn 0;\n\telse\n\t\treturn pos & 0xffffffff;\n}"
  },
  {
    "function_name": "pos2maj_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "277-284",
    "snippet": "static inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_32bit_api",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "250-257",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline __u32 pos2maj_hash(struct file *filp, loff_t pos)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn (pos << 1) & 0xffffffff;\n\telse\n\t\treturn ((pos >> 32) << 1) & 0xffffffff;\n}"
  },
  {
    "function_name": "hash2pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "268-275",
    "snippet": "static inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "major >> 1"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_api",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "is_32bit_api",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "250-257",
          "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline loff_t hash2pos(struct file *filp, __u32 major, __u32 minor)\n{\n\tif ((filp->f_mode & FMODE_32BITHASH) ||\n\t    (!(filp->f_mode & FMODE_64BITHASH) && is_32bit_api()))\n\t\treturn major >> 1;\n\telse\n\t\treturn ((__u64)(major >> 1) << 32) | (__u64)minor;\n}"
  },
  {
    "function_name": "is_32bit_api",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "250-257",
    "snippet": "static inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_compat_task",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int is_32bit_api(void)\n{\n#ifdef CONFIG_COMPAT\n\treturn is_compat_task();\n#else\n\treturn (BITS_PER_LONG == 32);\n#endif\n}"
  },
  {
    "function_name": "ext4_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "105-248",
    "snippet": "static int ext4_readdir(struct file *file, struct dir_context *ctx)\n{\n\tunsigned int offset;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tint err;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint dir_has_error = 0;\n\n\tif (is_dx_dir(inode)) {\n\t\terr = ext4_dx_readdir(file, ctx);\n\t\tif (err != ERR_BAD_DX_DIR) {\n\t\t\treturn err;\n\t\t}\n\t\t/*\n\t\t * We don't set the inode dirty flag since it's not\n\t\t * critical that it get flushed back to the disk.\n\t\t */\n\t\text4_clear_inode_flag(file_inode(file),\n\t\t\t\t      EXT4_INODE_INDEX);\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\t\tint ret = ext4_read_inline_dir(file, ctx,\n\t\t\t\t\t   &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn ret;\n\t}\n\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tstruct ext4_map_blocks map;\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tmap.m_lblk = ctx->pos >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\tmap.m_len = 1;\n\t\terr = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (err > 0) {\n\t\t\tpgoff_t index = map.m_pblk >>\n\t\t\t\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\t\tif (!ra_has_index(&file->f_ra, index))\n\t\t\t\tpage_cache_sync_readahead(\n\t\t\t\t\tsb->s_bdev->bd_inode->i_mapping,\n\t\t\t\t\t&file->f_ra, file,\n\t\t\t\t\tindex, 1);\n\t\t\tfile->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\n\t\t\tbh = ext4_bread(NULL, inode, map.m_lblk, 0);\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn PTR_ERR(bh);\n\t\t}\n\n\t\tif (!bh) {\n\t\t\tif (!dir_has_error) {\n\t\t\t\tEXT4_ERROR_FILE(file, 0,\n\t\t\t\t\t\t\"directory contains a \"\n\t\t\t\t\t\t\"hole at offset %llu\",\n\t\t\t\t\t   (unsigned long long) ctx->pos);\n\t\t\t\tdir_has_error = 1;\n\t\t\t}\n\t\t\t/* corrupt size?  Maybe no more blocks to read */\n\t\t\tif (ctx->pos > inode->i_blocks << 9)\n\t\t\t\tbreak;\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check the checksum */\n\t\tif (!buffer_verified(bh) &&\n\t\t    !ext4_dirent_csum_verify(inode,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_FILE(file, 0, \"directory fails checksum \"\n\t\t\t\t\t\"at offset %llu\",\n\t\t\t\t\t(unsigned long long)ctx->pos);\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tset_buffer_verified(bh);\n\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (file->f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t(bh->b_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\tsb->s_blocksize) < EXT4_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t    sb->s_blocksize);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\tfile->f_version = inode->i_version;\n\t\t}\n\n\t\twhile (ctx->pos < inode->i_size\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ext4_dir_entry_2 *) (bh->b_data + offset);\n\t\t\tif (ext4_check_dir_entry(inode, file, de, bh,\n\t\t\t\t\t\t bh->b_data, bh->b_size,\n\t\t\t\t\t\t offset)) {\n\t\t\t\t/*\n\t\t\t\t * On error, skip to the next block\n\t\t\t\t */\n\t\t\t\tctx->pos = (ctx->pos |\n\t\t\t\t\t\t(sb->s_blocksize - 1)) + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\tsb->s_blocksize);\n\t\t\tif (le32_to_cpu(de->inode)) {\n\t\t\t\tif (!dir_emit(ctx, de->name,\n\t\t\t\t\t\tde->name_len,\n\t\t\t\t\t\tle32_to_cpu(de->inode),\n\t\t\t\t\t\tget_dtype(sb, de->file_type))) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tsb->s_blocksize);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse(bh);\n\t\tif (ctx->pos < inode->i_size) {\n\t\t\tif (!dir_relax(inode))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_dx_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_relax",
          "args": [
            "inode"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "sb->s_blocksize"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->name",
            "de->name_len",
            "le32_to_cpu(de->inode)",
            "get_dtype(sb, de->file_type)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dtype",
          "args": [
            "sb",
            "de->file_type"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "get_dtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/dir.c",
          "lines": "33-40",
          "snippet": "static unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/compat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/compat.h>\n\nstatic unsigned char ext3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK, DT_FIFO, DT_SOCK, DT_LNK\n};\n\nstatic unsigned char get_dtype(struct super_block *sb, int filetype)\n{\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_FILETYPE) ||\n\t    (filetype >= EXT3_FT_MAX))\n\t\treturn DT_UNKNOWN;\n\n\treturn (ext3_filetype_table[filetype]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_check_dir_entry",
          "args": [
            "inode",
            "file",
            "de",
            "bh",
            "bh->b_data",
            "bh->b_size",
            "offset"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "bh"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_FILE",
          "args": [
            "file",
            "0",
            "\"directory fails checksum \"\n\t\t\t\t\t\"at offset %llu\"",
            "(unsigned long long)ctx->pos"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_dirent_csum_verify",
          "args": [
            "inode",
            "(struct ext4_dir_entry *)bh->b_data"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dirent_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/namei.c",
          "lines": "336-354",
          "snippet": "int ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t\t(void *)t - (void *)dirent))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/time.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);",
            "static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/time.h>\n#include <linux/jbd2.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_csum_verify(struct inode *inode,\n\t\t\t       struct ext4_dir_entry *dirent);\nstatic int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,\n\t\t\t     struct inode *inode);\n\nint ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)\n{\n\tstruct ext4_dir_entry_tail *t;\n\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tt = get_dirent_tail(inode, dirent);\n\tif (!t) {\n\t\twarn_no_space_for_csum(inode);\n\t\treturn 0;\n\t}\n\n\tif (t->det_checksum != ext4_dirent_csum(inode, dirent,\n\t\t\t\t\t\t(void *)t - (void *)dirent))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_verified",
          "args": [
            "bh"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_FILE",
          "args": [
            "file",
            "0",
            "\"directory contains a \"\n\t\t\t\t\t\t\"hole at offset %llu\"",
            "(unsigned long long) ctx->pos"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bh"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_bread",
          "args": [
            "NULL",
            "inode",
            "map.m_lblk",
            "0"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "791-807",
          "snippet": "struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int create)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, create);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_sync_readahead",
          "args": [
            "sb->s_bdev->bd_inode->i_mapping",
            "&file->f_ra",
            "file",
            "index",
            "1"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ra_has_index",
          "args": [
            "&file->f_ra",
            "index"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_map_blocks",
          "args": [
            "NULL",
            "inode",
            "&map",
            "0"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_map_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "460-658",
          "snippet": "int ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ext4_journalled_writepage(struct page *page, unsigned int len);",
            "static int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_get_block_write_nolock(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create);\n\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EIO;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tif (!(flags & EXT4_GET_BLOCKS_NO_LOCK))\n\t\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto has_zeroout;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\nhas_zeroout:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_read_inline_dir",
          "args": [
            "file",
            "ctx",
            "&has_inline_data"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_read_inline_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1424-1552",
          "snippet": "int ext4_read_inline_dir(struct file *file,\n\t\t\t struct dir_context *ctx,\n\t\t\t int *has_inline_data)\n{\n\tunsigned int offset, parent_ino;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n\tstruct inode *inode = file_inode(file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tint dotdot_offset, dotdot_size, extra_offset, extra_size;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tsb = inode->i_sb;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\toffset = ctx->pos;\n\n\t/*\n\t * dotdot_offset and dotdot_size is the real offset and\n\t * size for \"..\" and \".\" if the dir is block based while\n\t * the real size for them are only EXT4_INLINE_DOTDOT_SIZE.\n\t * So we will use extra_offset and extra_size to indicate them\n\t * during the inline dir iteration.\n\t */\n\tdotdot_offset = EXT4_DIR_REC_LEN(1);\n\tdotdot_size = dotdot_offset + EXT4_DIR_REC_LEN(2);\n\textra_offset = dotdot_size - EXT4_INLINE_DOTDOT_SIZE;\n\textra_size = extra_offset + inline_size;\n\n\t/*\n\t * If the version has changed since the last call to\n\t * readdir(2), then we might be pointing to an invalid\n\t * dirent right now.  Scan from the start of the inline\n\t * dir to make sure.\n\t */\n\tif (file->f_version != inode->i_version) {\n\t\tfor (i = 0; i < extra_size && i < offset;) {\n\t\t\t/*\n\t\t\t * \".\" is with offset 0 and\n\t\t\t * \"..\" is dotdot_offset.\n\t\t\t */\n\t\t\tif (!i) {\n\t\t\t\ti = dotdot_offset;\n\t\t\t\tcontinue;\n\t\t\t} else if (i == dotdot_offset) {\n\t\t\t\ti = dotdot_size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* for other entry, the real offset in\n\t\t\t * the buf has to be tuned accordingly.\n\t\t\t */\n\t\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t\t(dir_buf + i - extra_offset);\n\t\t\t/* It's too expensive to do a full\n\t\t\t * dirent test each time round this\n\t\t\t * loop, but we do have to test at\n\t\t\t * least that it is non-zero.  A\n\t\t\t * failure will be detected in the\n\t\t\t * dirent test below. */\n\t\t\tif (ext4_rec_len_from_disk(de->rec_len, extra_size)\n\t\t\t\t< EXT4_DIR_REC_LEN(1))\n\t\t\t\tbreak;\n\t\t\ti += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t    extra_size);\n\t\t}\n\t\toffset = i;\n\t\tctx->pos = offset;\n\t\tfile->f_version = inode->i_version;\n\t}\n\n\twhile (ctx->pos < extra_size) {\n\t\tif (ctx->pos == 0) {\n\t\t\tif (!dir_emit(ctx, \".\", 1, inode->i_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->pos == dotdot_offset) {\n\t\t\tif (!dir_emit(ctx, \"..\", 2, parent_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t(dir_buf + ctx->pos - extra_offset);\n\t\tif (ext4_check_dir_entry(inode, file, de, iloc.bh, dir_buf,\n\t\t\t\t\t extra_size, ctx->pos))\n\t\t\tgoto out;\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le32_to_cpu(de->inode),\n\t\t\t\t      get_dtype(sb, de->file_type)))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += ext4_rec_len_from_disk(de->rec_len, extra_size);\n\t}\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [
            "#define EXT4_INLINE_DOTDOT_SIZE\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\n#define EXT4_INLINE_DOTDOT_SIZE\t\t4\n\nint ext4_read_inline_dir(struct file *file,\n\t\t\t struct dir_context *ctx,\n\t\t\t int *has_inline_data)\n{\n\tunsigned int offset, parent_ino;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tstruct super_block *sb;\n\tstruct inode *inode = file_inode(file);\n\tint ret, inline_size = 0;\n\tstruct ext4_iloc iloc;\n\tvoid *dir_buf = NULL;\n\tint dotdot_offset, dotdot_size, extra_offset, extra_size;\n\n\tret = ext4_get_inode_loc(inode, &iloc);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\tif (!ext4_has_inline_data(inode)) {\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\t*has_inline_data = 0;\n\t\tgoto out;\n\t}\n\n\tinline_size = ext4_get_inline_size(inode);\n\tdir_buf = kmalloc(inline_size, GFP_NOFS);\n\tif (!dir_buf) {\n\t\tret = -ENOMEM;\n\t\tup_read(&EXT4_I(inode)->xattr_sem);\n\t\tgoto out;\n\t}\n\n\tret = ext4_read_inline_data(inode, dir_buf, inline_size, &iloc);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = 0;\n\tsb = inode->i_sb;\n\tparent_ino = le32_to_cpu(((struct ext4_dir_entry_2 *)dir_buf)->inode);\n\toffset = ctx->pos;\n\n\t/*\n\t * dotdot_offset and dotdot_size is the real offset and\n\t * size for \"..\" and \".\" if the dir is block based while\n\t * the real size for them are only EXT4_INLINE_DOTDOT_SIZE.\n\t * So we will use extra_offset and extra_size to indicate them\n\t * during the inline dir iteration.\n\t */\n\tdotdot_offset = EXT4_DIR_REC_LEN(1);\n\tdotdot_size = dotdot_offset + EXT4_DIR_REC_LEN(2);\n\textra_offset = dotdot_size - EXT4_INLINE_DOTDOT_SIZE;\n\textra_size = extra_offset + inline_size;\n\n\t/*\n\t * If the version has changed since the last call to\n\t * readdir(2), then we might be pointing to an invalid\n\t * dirent right now.  Scan from the start of the inline\n\t * dir to make sure.\n\t */\n\tif (file->f_version != inode->i_version) {\n\t\tfor (i = 0; i < extra_size && i < offset;) {\n\t\t\t/*\n\t\t\t * \".\" is with offset 0 and\n\t\t\t * \"..\" is dotdot_offset.\n\t\t\t */\n\t\t\tif (!i) {\n\t\t\t\ti = dotdot_offset;\n\t\t\t\tcontinue;\n\t\t\t} else if (i == dotdot_offset) {\n\t\t\t\ti = dotdot_size;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* for other entry, the real offset in\n\t\t\t * the buf has to be tuned accordingly.\n\t\t\t */\n\t\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t\t(dir_buf + i - extra_offset);\n\t\t\t/* It's too expensive to do a full\n\t\t\t * dirent test each time round this\n\t\t\t * loop, but we do have to test at\n\t\t\t * least that it is non-zero.  A\n\t\t\t * failure will be detected in the\n\t\t\t * dirent test below. */\n\t\t\tif (ext4_rec_len_from_disk(de->rec_len, extra_size)\n\t\t\t\t< EXT4_DIR_REC_LEN(1))\n\t\t\t\tbreak;\n\t\t\ti += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t    extra_size);\n\t\t}\n\t\toffset = i;\n\t\tctx->pos = offset;\n\t\tfile->f_version = inode->i_version;\n\t}\n\n\twhile (ctx->pos < extra_size) {\n\t\tif (ctx->pos == 0) {\n\t\t\tif (!dir_emit(ctx, \".\", 1, inode->i_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->pos == dotdot_offset) {\n\t\t\tif (!dir_emit(ctx, \"..\", 2, parent_ino, DT_DIR))\n\t\t\t\tgoto out;\n\t\t\tctx->pos = dotdot_size;\n\t\t\tcontinue;\n\t\t}\n\n\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t(dir_buf + ctx->pos - extra_offset);\n\t\tif (ext4_check_dir_entry(inode, file, de, iloc.bh, dir_buf,\n\t\t\t\t\t extra_size, ctx->pos))\n\t\t\tgoto out;\n\t\tif (le32_to_cpu(de->inode)) {\n\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t      le32_to_cpu(de->inode),\n\t\t\t\t      get_dtype(sb, de->file_type)))\n\t\t\t\tgoto out;\n\t\t}\n\t\tctx->pos += ext4_rec_len_from_disk(de->rec_len, extra_size);\n\t}\nout:\n\tkfree(dir_buf);\n\tbrelse(iloc.bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_flag",
          "args": [
            "file_inode(file)",
            "EXT4_INODE_INDEX"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_dx_readdir",
          "args": [
            "file",
            "ctx"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_dx_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "477-562",
          "snippet": "static int ext4_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint\tret;\n\n\tif (!info) {\n\t\tinfo = ext4_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext4_get_htree_eof(file))\n\t\treturn 0;\t/* EOF */\n\n\t/* Some one has messed with f_pos; reset the world */\n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t/*\n\t * If there are any leftover names on the hash collision\n\t * chain, return them first.\n\t */\n\tif (info->extra_fname) {\n\t\tif (call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t/*\n\t\t * Fill the rbtree if we have no more entries,\n\t\t * or the inode has changed since we last read in the\n\t\t * cached entries.\n\t\t */\n\t\tif ((!info->curr_node) ||\n\t\t    (file->f_version != inode->i_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tret = ext4_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_dx_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_readdir(struct file *, struct dir_context *);\n\nstatic int ext4_dx_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dir_private_info *info = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct fname *fname;\n\tint\tret;\n\n\tif (!info) {\n\t\tinfo = ext4_htree_create_dir_info(file, ctx->pos);\n\t\tif (!info)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = info;\n\t}\n\n\tif (ctx->pos == ext4_get_htree_eof(file))\n\t\treturn 0;\t/* EOF */\n\n\t/* Some one has messed with f_pos; reset the world */\n\tif (info->last_pos != ctx->pos) {\n\t\tfree_rb_tree_fname(&info->root);\n\t\tinfo->curr_node = NULL;\n\t\tinfo->extra_fname = NULL;\n\t\tinfo->curr_hash = pos2maj_hash(file, ctx->pos);\n\t\tinfo->curr_minor_hash = pos2min_hash(file, ctx->pos);\n\t}\n\n\t/*\n\t * If there are any leftover names on the hash collision\n\t * chain, return them first.\n\t */\n\tif (info->extra_fname) {\n\t\tif (call_filldir(file, ctx, info->extra_fname))\n\t\t\tgoto finished;\n\t\tinfo->extra_fname = NULL;\n\t\tgoto next_node;\n\t} else if (!info->curr_node)\n\t\tinfo->curr_node = rb_first(&info->root);\n\n\twhile (1) {\n\t\t/*\n\t\t * Fill the rbtree if we have no more entries,\n\t\t * or the inode has changed since we last read in the\n\t\t * cached entries.\n\t\t */\n\t\tif ((!info->curr_node) ||\n\t\t    (file->f_version != inode->i_version)) {\n\t\t\tinfo->curr_node = NULL;\n\t\t\tfree_rb_tree_fname(&info->root);\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tret = ext4_htree_fill_tree(file, info->curr_hash,\n\t\t\t\t\t\t   info->curr_minor_hash,\n\t\t\t\t\t\t   &info->next_hash);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_node = rb_first(&info->root);\n\t\t}\n\n\t\tfname = rb_entry(info->curr_node, struct fname, rb_hash);\n\t\tinfo->curr_hash = fname->hash;\n\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\tif (call_filldir(file, ctx, fname))\n\t\t\tbreak;\n\tnext_node:\n\t\tinfo->curr_node = rb_next(info->curr_node);\n\t\tif (info->curr_node) {\n\t\t\tfname = rb_entry(info->curr_node, struct fname,\n\t\t\t\t\t rb_hash);\n\t\t\tinfo->curr_hash = fname->hash;\n\t\t\tinfo->curr_minor_hash = fname->minor_hash;\n\t\t} else {\n\t\t\tif (info->next_hash == ~0) {\n\t\t\t\tctx->pos = ext4_get_htree_eof(file);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo->curr_hash = info->next_hash;\n\t\t\tinfo->curr_minor_hash = 0;\n\t\t}\n\t}\nfinished:\n\tinfo->last_pos = ctx->pos;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dx_dir",
          "args": [
            "inode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "is_dx_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
          "lines": "41-53",
          "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int ext4_dx_readdir(struct file *, struct dir_context *);\n\nstatic int ext4_readdir(struct file *file, struct dir_context *ctx)\n{\n\tunsigned int offset;\n\tint i;\n\tstruct ext4_dir_entry_2 *de;\n\tint err;\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\tint dir_has_error = 0;\n\n\tif (is_dx_dir(inode)) {\n\t\terr = ext4_dx_readdir(file, ctx);\n\t\tif (err != ERR_BAD_DX_DIR) {\n\t\t\treturn err;\n\t\t}\n\t\t/*\n\t\t * We don't set the inode dirty flag since it's not\n\t\t * critical that it get flushed back to the disk.\n\t\t */\n\t\text4_clear_inode_flag(file_inode(file),\n\t\t\t\t      EXT4_INODE_INDEX);\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline_data = 1;\n\t\tint ret = ext4_read_inline_dir(file, ctx,\n\t\t\t\t\t   &has_inline_data);\n\t\tif (has_inline_data)\n\t\t\treturn ret;\n\t}\n\n\toffset = ctx->pos & (sb->s_blocksize - 1);\n\n\twhile (ctx->pos < inode->i_size) {\n\t\tstruct ext4_map_blocks map;\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tmap.m_lblk = ctx->pos >> EXT4_BLOCK_SIZE_BITS(sb);\n\t\tmap.m_len = 1;\n\t\terr = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (err > 0) {\n\t\t\tpgoff_t index = map.m_pblk >>\n\t\t\t\t\t(PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\t\tif (!ra_has_index(&file->f_ra, index))\n\t\t\t\tpage_cache_sync_readahead(\n\t\t\t\t\tsb->s_bdev->bd_inode->i_mapping,\n\t\t\t\t\t&file->f_ra, file,\n\t\t\t\t\tindex, 1);\n\t\t\tfile->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\n\t\t\tbh = ext4_bread(NULL, inode, map.m_lblk, 0);\n\t\t\tif (IS_ERR(bh))\n\t\t\t\treturn PTR_ERR(bh);\n\t\t}\n\n\t\tif (!bh) {\n\t\t\tif (!dir_has_error) {\n\t\t\t\tEXT4_ERROR_FILE(file, 0,\n\t\t\t\t\t\t\"directory contains a \"\n\t\t\t\t\t\t\"hole at offset %llu\",\n\t\t\t\t\t   (unsigned long long) ctx->pos);\n\t\t\t\tdir_has_error = 1;\n\t\t\t}\n\t\t\t/* corrupt size?  Maybe no more blocks to read */\n\t\t\tif (ctx->pos > inode->i_blocks << 9)\n\t\t\t\tbreak;\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check the checksum */\n\t\tif (!buffer_verified(bh) &&\n\t\t    !ext4_dirent_csum_verify(inode,\n\t\t\t\t(struct ext4_dir_entry *)bh->b_data)) {\n\t\t\tEXT4_ERROR_FILE(file, 0, \"directory fails checksum \"\n\t\t\t\t\t\"at offset %llu\",\n\t\t\t\t\t(unsigned long long)ctx->pos);\n\t\t\tctx->pos += sb->s_blocksize - offset;\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tset_buffer_verified(bh);\n\n\t\t/* If the dir block has changed since the last call to\n\t\t * readdir(2), then we might be pointing to an invalid\n\t\t * dirent right now.  Scan from the start of the block\n\t\t * to make sure. */\n\t\tif (file->f_version != inode->i_version) {\n\t\t\tfor (i = 0; i < sb->s_blocksize && i < offset; ) {\n\t\t\t\tde = (struct ext4_dir_entry_2 *)\n\t\t\t\t\t(bh->b_data + i);\n\t\t\t\t/* It's too expensive to do a full\n\t\t\t\t * dirent test each time round this\n\t\t\t\t * loop, but we do have to test at\n\t\t\t\t * least that it is non-zero.  A\n\t\t\t\t * failure will be detected in the\n\t\t\t\t * dirent test below. */\n\t\t\t\tif (ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\tsb->s_blocksize) < EXT4_DIR_REC_LEN(1))\n\t\t\t\t\tbreak;\n\t\t\t\ti += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\t\t    sb->s_blocksize);\n\t\t\t}\n\t\t\toffset = i;\n\t\t\tctx->pos = (ctx->pos & ~(sb->s_blocksize - 1))\n\t\t\t\t| offset;\n\t\t\tfile->f_version = inode->i_version;\n\t\t}\n\n\t\twhile (ctx->pos < inode->i_size\n\t\t       && offset < sb->s_blocksize) {\n\t\t\tde = (struct ext4_dir_entry_2 *) (bh->b_data + offset);\n\t\t\tif (ext4_check_dir_entry(inode, file, de, bh,\n\t\t\t\t\t\t bh->b_data, bh->b_size,\n\t\t\t\t\t\t offset)) {\n\t\t\t\t/*\n\t\t\t\t * On error, skip to the next block\n\t\t\t\t */\n\t\t\t\tctx->pos = (ctx->pos |\n\t\t\t\t\t\t(sb->s_blocksize - 1)) + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\tsb->s_blocksize);\n\t\t\tif (le32_to_cpu(de->inode)) {\n\t\t\t\tif (!dir_emit(ctx, de->name,\n\t\t\t\t\t\tde->name_len,\n\t\t\t\t\t\tle32_to_cpu(de->inode),\n\t\t\t\t\t\tget_dtype(sb, de->file_type))) {\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tsb->s_blocksize);\n\t\t}\n\t\toffset = 0;\n\t\tbrelse(bh);\n\t\tif (ctx->pos < inode->i_size) {\n\t\t\tif (!dir_relax(inode))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__ext4_check_dir_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "63-103",
    "snippet": "int __ext4_check_dir_entry(const char *function, unsigned int line,\n\t\t\t   struct inode *dir, struct file *filp,\n\t\t\t   struct ext4_dir_entry_2 *de,\n\t\t\t   struct buffer_head *bh, char *buf, int size,\n\t\t\t   unsigned int offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\n\tif (unlikely(rlen < EXT4_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT4_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(((char *) de - buf) + rlen > size))\n\t\terror_msg = \"directory entry across range\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT4_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\telse\n\t\treturn 0;\n\n\tif (filp)\n\t\text4_error_file(filp, function, line, bh->b_blocknr,\n\t\t\t\t\"bad entry in directory: %s - offset=%u(%u), \"\n\t\t\t\t\"inode=%u, rec_len=%d, name_len=%d\",\n\t\t\t\terror_msg, (unsigned) (offset % size),\n\t\t\t\toffset, le32_to_cpu(de->inode),\n\t\t\t\trlen, de->name_len);\n\telse\n\t\text4_error_inode(dir, function, line, bh->b_blocknr,\n\t\t\t\t\"bad entry in directory: %s - offset=%u(%u), \"\n\t\t\t\t\"inode=%u, rec_len=%d, name_len=%d\",\n\t\t\t\terror_msg, (unsigned) (offset % size),\n\t\t\t\toffset, le32_to_cpu(de->inode),\n\t\t\t\trlen, de->name_len);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_error_inode",
          "args": [
            "dir",
            "function",
            "line",
            "bh->b_blocknr",
            "\"bad entry in directory: %s - offset=%u(%u), \"\n\t\t\t\t\"inode=%u, rec_len=%d, name_len=%d\"",
            "error_msg",
            "(unsigned) (offset % size)",
            "offset",
            "le32_to_cpu(de->inode)",
            "rlen",
            "de->name_len"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "426-454",
          "snippet": "void __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_inode(struct inode *inode, const char *function,\n\t\t\tunsigned int line, ext4_fsblk_t block,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tes->s_last_error_block = cpu_to_le64(block);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: block %llu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT \"EXT4-fs error (device %s): %s:%d: \"\n\t\t\t       \"inode #%lu: comm %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->inode"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_error_file",
          "args": [
            "filp",
            "function",
            "line",
            "bh->b_blocknr",
            "\"bad entry in directory: %s - offset=%u(%u), \"\n\t\t\t\t\"inode=%u, rec_len=%d, name_len=%d\"",
            "error_msg",
            "(unsigned) (offset % size)",
            "offset",
            "le32_to_cpu(de->inode)",
            "rlen",
            "de->name_len"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_error_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/super.c",
          "lines": "456-491",
          "snippet": "void __ext4_error_file(struct file *file, const char *function,\n\t\t       unsigned int line, ext4_fsblk_t block,\n\t\t       const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es;\n\tstruct inode *inode = file_inode(file);\n\tchar pathname[80], *path;\n\n\tes = EXT4_SB(inode->i_sb)->s_es;\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tpath = d_path(&(file->f_path), pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"block %llu: comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, path, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, path, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);",
            "static void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);",
            "static int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <asm/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/jbd2.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext4_mark_recovery_complete(struct super_block *sb,\n\t\t\t\t\tstruct ext4_super_block *es);\nstatic void ext4_clear_journal_err(struct super_block *sb,\n\t\t\t\t   struct ext4_super_block *es);\nstatic int ext4_reserve_clusters(struct ext4_sb_info *, ext4_fsblk_t);\n\nvoid __ext4_error_file(struct file *file, const char *function,\n\t\t       unsigned int line, ext4_fsblk_t block,\n\t\t       const char *fmt, ...)\n{\n\tva_list args;\n\tstruct va_format vaf;\n\tstruct ext4_super_block *es;\n\tstruct inode *inode = file_inode(file);\n\tchar pathname[80], *path;\n\n\tes = EXT4_SB(inode->i_sb)->s_es;\n\tes->s_last_error_ino = cpu_to_le32(inode->i_ino);\n\tif (ext4_error_ratelimit(inode->i_sb)) {\n\t\tpath = d_path(&(file->f_path), pathname, sizeof(pathname));\n\t\tif (IS_ERR(path))\n\t\t\tpath = \"(unknown)\";\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tif (block)\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"block %llu: comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       block, current->comm, path, &vaf);\n\t\telse\n\t\t\tprintk(KERN_CRIT\n\t\t\t       \"EXT4-fs error (device %s): %s:%d: inode #%lu: \"\n\t\t\t       \"comm %s: path %s: %pV\\n\",\n\t\t\t       inode->i_sb->s_id, function, line, inode->i_ino,\n\t\t\t       current->comm, path, &vaf);\n\t\tva_end(args);\n\t}\n\tsave_error_info(inode->i_sb, function, line);\n\text4_handle_error(inode->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT4_SB(dir->i_sb)->s_es->s_inodes_count)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "((char *) de - buf) + rlen > size"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen < EXT4_DIR_REC_LEN(de->name_len)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen % 4 != 0"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rlen < EXT4_DIR_REC_LEN(1)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_rec_len_from_disk",
          "args": [
            "de->rec_len",
            "dir->i_sb->s_blocksize"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_rec_len_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1703-1715",
          "snippet": "static inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\n#define EXT4_MAX_REC_LEN\t\t((1<<16)-1)\n\nstatic inline unsigned int\next4_rec_len_from_disk(__le16 dlen, unsigned blocksize)\n{\n\tunsigned len = le16_to_cpu(dlen);\n\n#if (PAGE_CACHE_SIZE >= 65536)\n\tif (len == EXT4_MAX_REC_LEN || len == 0)\n\t\treturn blocksize;\n\treturn (len & 65532) | ((len & 3) << 16);\n#else\n\treturn len;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nint __ext4_check_dir_entry(const char *function, unsigned int line,\n\t\t\t   struct inode *dir, struct file *filp,\n\t\t\t   struct ext4_dir_entry_2 *de,\n\t\t\t   struct buffer_head *bh, char *buf, int size,\n\t\t\t   unsigned int offset)\n{\n\tconst char *error_msg = NULL;\n\tconst int rlen = ext4_rec_len_from_disk(de->rec_len,\n\t\t\t\t\t\tdir->i_sb->s_blocksize);\n\n\tif (unlikely(rlen < EXT4_DIR_REC_LEN(1)))\n\t\terror_msg = \"rec_len is smaller than minimal\";\n\telse if (unlikely(rlen % 4 != 0))\n\t\terror_msg = \"rec_len % 4 != 0\";\n\telse if (unlikely(rlen < EXT4_DIR_REC_LEN(de->name_len)))\n\t\terror_msg = \"rec_len is too small for name_len\";\n\telse if (unlikely(((char *) de - buf) + rlen > size))\n\t\terror_msg = \"directory entry across range\";\n\telse if (unlikely(le32_to_cpu(de->inode) >\n\t\t\tle32_to_cpu(EXT4_SB(dir->i_sb)->s_es->s_inodes_count)))\n\t\terror_msg = \"inode out of bounds\";\n\telse\n\t\treturn 0;\n\n\tif (filp)\n\t\text4_error_file(filp, function, line, bh->b_blocknr,\n\t\t\t\t\"bad entry in directory: %s - offset=%u(%u), \"\n\t\t\t\t\"inode=%u, rec_len=%d, name_len=%d\",\n\t\t\t\terror_msg, (unsigned) (offset % size),\n\t\t\t\toffset, le32_to_cpu(de->inode),\n\t\t\t\trlen, de->name_len);\n\telse\n\t\text4_error_inode(dir, function, line, bh->b_blocknr,\n\t\t\t\t\"bad entry in directory: %s - offset=%u(%u), \"\n\t\t\t\t\"inode=%u, rec_len=%d, name_len=%d\",\n\t\t\t\terror_msg, (unsigned) (offset % size),\n\t\t\t\toffset, le32_to_cpu(de->inode),\n\t\t\t\trlen, de->name_len);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "is_dx_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/dir.c",
    "lines": "41-53",
    "snippet": "static int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_INDEX"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "inode->i_sb",
            "EXT4_FEATURE_COMPAT_DIR_INDEX"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic int is_dx_dir(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (EXT4_HAS_COMPAT_FEATURE(inode->i_sb,\n\t\t     EXT4_FEATURE_COMPAT_DIR_INDEX) &&\n\t    ((ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) ||\n\t     ((inode->i_size >> sb->s_blocksize_bits) == 1) ||\n\t     ext4_has_inline_data(inode)))\n\t\treturn 1;\n\n\treturn 0;\n}"
  }
]