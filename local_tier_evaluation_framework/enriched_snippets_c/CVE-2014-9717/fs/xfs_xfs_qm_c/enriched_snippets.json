[
  {
    "function_name": "xfs_qm_vop_create_dqattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1897-1933",
    "snippet": "void\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot",
          "args": [
            "tp",
            "pdqp",
            "XFS_TRANS_DQ_ICOUNT",
            "1"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "198-290",
          "snippet": "void\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqhold",
          "args": [
            "pdqp"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "180-186",
          "snippet": "static inline struct xfs_dquot *xfs_qm_dqhold(struct xfs_dquot *dqp)\n{\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs++;\n\txfs_dqunlock(dqp);\n\treturn dqp;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dquot *xfs_qm_dqhold(struct xfs_dquot *dqp)\n{\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs++;\n\txfs_dqunlock(dqp);\n\treturn dqp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id)"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pdqp->q_core.d_id"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_pdquot == NULL"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id)"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "gdqp->q_core.d_id"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_gdquot == NULL"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id)"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "udqp->q_core.d_id"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_udquot == NULL"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(mp)"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}"
  },
  {
    "function_name": "xfs_qm_vop_rename_dqattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1869-1895",
    "snippet": "int\nxfs_qm_vop_rename_dqattach(\n\tstruct xfs_inode\t**i_tab)\n{\n\tstruct xfs_mount\t*mp = i_tab[0]->i_mount;\n\tint\t\t\ti;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tfor (i = 0; (i < 4 && i_tab[i]); i++) {\n\t\tstruct xfs_inode\t*ip = i_tab[i];\n\t\tint\t\t\terror;\n\n\t\t/*\n\t\t * Watch out for duplicate entries in the table.\n\t\t */\n\t\tif (i == 0 || ip != i_tab[i-1]) {\n\t\t\tif (XFS_NOT_DQATTACHED(mp, ip)) {\n\t\t\t\terror = xfs_qm_dqattach(ip, 0);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "ip",
            "0"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_NOT_DQATTACHED",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_vop_rename_dqattach(\n\tstruct xfs_inode\t**i_tab)\n{\n\tstruct xfs_mount\t*mp = i_tab[0]->i_mount;\n\tint\t\t\ti;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tfor (i = 0; (i < 4 && i_tab[i]); i++) {\n\t\tstruct xfs_inode\t*ip = i_tab[i];\n\t\tint\t\t\terror;\n\n\t\t/*\n\t\t * Watch out for duplicate entries in the table.\n\t\t */\n\t\tif (i == 0 || ip != i_tab[i-1]) {\n\t\t\tif (XFS_NOT_DQATTACHED(mp, ip)) {\n\t\t\t\terror = xfs_qm_dqattach(ip, 0);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_vop_chown_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1777-1867",
    "snippet": "int\nxfs_qm_vop_chown_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tdelblks, blkflags, prjflags = 0;\n\tstruct xfs_dquot\t*udq_unres = NULL;\n\tstruct xfs_dquot\t*gdq_unres = NULL;\n\tstruct xfs_dquot\t*pdq_unres = NULL;\n\tstruct xfs_dquot\t*udq_delblks = NULL;\n\tstruct xfs_dquot\t*gdq_delblks = NULL;\n\tstruct xfs_dquot\t*pdq_delblks = NULL;\n\tint\t\t\terror;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tdelblks = ip->i_delayed_blks;\n\tblkflags = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS;\n\n\tif (XFS_IS_UQUOTA_ON(mp) && udqp &&\n\t    ip->i_d.di_uid != be32_to_cpu(udqp->q_core.d_id)) {\n\t\tudq_delblks = udqp;\n\t\t/*\n\t\t * If there are delayed allocation blocks, then we have to\n\t\t * unreserve those from the old dquot, and add them to the\n\t\t * new dquot.\n\t\t */\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_udquot);\n\t\t\tudq_unres = ip->i_udquot;\n\t\t}\n\t}\n\tif (XFS_IS_GQUOTA_ON(ip->i_mount) && gdqp &&\n\t    ip->i_d.di_gid != be32_to_cpu(gdqp->q_core.d_id)) {\n\t\tgdq_delblks = gdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgdq_unres = ip->i_gdquot;\n\t\t}\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(ip->i_mount) && pdqp &&\n\t    xfs_get_projid(ip) != be32_to_cpu(pdqp->q_core.d_id)) {\n\t\tprjflags = XFS_QMOPT_ENOSPC;\n\t\tpdq_delblks = pdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpdq_unres = ip->i_pdquot;\n\t\t}\n\t}\n\n\terror = xfs_trans_reserve_quota_bydquots(tp, ip->i_mount,\n\t\t\t\tudq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t\tip->i_d.di_nblocks, 1,\n\t\t\t\tflags | blkflags | prjflags);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Do the delayed blks reservations/unreservations now. Since, these\n\t * are done without the help of a transaction, if a reservation fails\n\t * its previous reservations won't be automatically undone by trans\n\t * code. So, we have to do it manually here.\n\t */\n\tif (delblks) {\n\t\t/*\n\t\t * Do the reservations first. Unreservation can't fail.\n\t\t */\n\t\tASSERT(udq_delblks || gdq_delblks || pdq_delblks);\n\t\tASSERT(udq_unres || gdq_unres || pdq_unres);\n\t\terror = xfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t    udq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t    (xfs_qcnt_t)delblks, 0,\n\t\t\t    flags | blkflags | prjflags);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t\tudq_unres, gdq_unres, pdq_unres,\n\t\t\t\t-((xfs_qcnt_t)delblks), 0, blkflags);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota_bydquots",
          "args": [
            "NULL",
            "ip->i_mount",
            "udq_unres",
            "gdq_unres",
            "pdq_unres",
            "-((xfs_qcnt_t)delblks)",
            "0",
            "blkflags"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_bydquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "740-794",
          "snippet": "int\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "udq_unres || gdq_unres || pdq_unres"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "udq_delblks || gdq_delblks || pdq_delblks"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_pdquot"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "pdqp->q_core.d_id"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "ip->i_mount"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_gdquot"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "gdqp->q_core.d_id"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "ip->i_mount"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_udquot"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "udqp->q_core.d_id"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(mp)"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL|XFS_ILOCK_SHARED"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_vop_chown_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tdelblks, blkflags, prjflags = 0;\n\tstruct xfs_dquot\t*udq_unres = NULL;\n\tstruct xfs_dquot\t*gdq_unres = NULL;\n\tstruct xfs_dquot\t*pdq_unres = NULL;\n\tstruct xfs_dquot\t*udq_delblks = NULL;\n\tstruct xfs_dquot\t*gdq_delblks = NULL;\n\tstruct xfs_dquot\t*pdq_delblks = NULL;\n\tint\t\t\terror;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tdelblks = ip->i_delayed_blks;\n\tblkflags = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS;\n\n\tif (XFS_IS_UQUOTA_ON(mp) && udqp &&\n\t    ip->i_d.di_uid != be32_to_cpu(udqp->q_core.d_id)) {\n\t\tudq_delblks = udqp;\n\t\t/*\n\t\t * If there are delayed allocation blocks, then we have to\n\t\t * unreserve those from the old dquot, and add them to the\n\t\t * new dquot.\n\t\t */\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_udquot);\n\t\t\tudq_unres = ip->i_udquot;\n\t\t}\n\t}\n\tif (XFS_IS_GQUOTA_ON(ip->i_mount) && gdqp &&\n\t    ip->i_d.di_gid != be32_to_cpu(gdqp->q_core.d_id)) {\n\t\tgdq_delblks = gdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgdq_unres = ip->i_gdquot;\n\t\t}\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(ip->i_mount) && pdqp &&\n\t    xfs_get_projid(ip) != be32_to_cpu(pdqp->q_core.d_id)) {\n\t\tprjflags = XFS_QMOPT_ENOSPC;\n\t\tpdq_delblks = pdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpdq_unres = ip->i_pdquot;\n\t\t}\n\t}\n\n\terror = xfs_trans_reserve_quota_bydquots(tp, ip->i_mount,\n\t\t\t\tudq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t\tip->i_d.di_nblocks, 1,\n\t\t\t\tflags | blkflags | prjflags);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Do the delayed blks reservations/unreservations now. Since, these\n\t * are done without the help of a transaction, if a reservation fails\n\t * its previous reservations won't be automatically undone by trans\n\t * code. So, we have to do it manually here.\n\t */\n\tif (delblks) {\n\t\t/*\n\t\t * Do the reservations first. Unreservation can't fail.\n\t\t */\n\t\tASSERT(udq_delblks || gdq_delblks || pdq_delblks);\n\t\tASSERT(udq_unres || gdq_unres || pdq_unres);\n\t\terror = xfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t    udq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t    (xfs_qcnt_t)delblks, 0,\n\t\t\t    flags | blkflags | prjflags);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t\tudq_unres, gdq_unres, pdq_unres,\n\t\t\t\t-((xfs_qcnt_t)delblks), 0, blkflags);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_vop_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1738-1772",
    "snippet": "xfs_dquot_t *\nxfs_qm_vop_chown(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_dquot_t\t**IO_olddq,\n\txfs_dquot_t\t*newdq)\n{\n\txfs_dquot_t\t*prevdq;\n\tuint\t\tbfield = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t XFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(ip->i_mount));\n\n\t/* old dquot */\n\tprevdq = *IO_olddq;\n\tASSERT(prevdq);\n\tASSERT(prevdq != newdq);\n\n\txfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));\n\txfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/* the sparkling new dquot */\n\txfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);\n\txfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\n\n\t/*\n\t * Take an extra reference, because the inode is going to keep\n\t * this dquot pointer even after the trans_commit.\n\t */\n\t*IO_olddq = xfs_qm_dqhold(newdq);\n\n\treturn prevdq;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqhold",
          "args": [
            "newdq"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "180-186",
          "snippet": "static inline struct xfs_dquot *xfs_qm_dqhold(struct xfs_dquot *dqp)\n{\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs++;\n\txfs_dqunlock(dqp);\n\treturn dqp;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dquot *xfs_qm_dqhold(struct xfs_dquot *dqp)\n{\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs++;\n\txfs_dqunlock(dqp);\n\treturn dqp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot",
          "args": [
            "tp",
            "newdq",
            "XFS_TRANS_DQ_ICOUNT",
            "1"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "198-290",
          "snippet": "void\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot(\n\txfs_trans_t\t*tp,\n\txfs_dquot_t\t*dqp,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_dqtrx_t\t*qtrx;\n\n\tASSERT(tp);\n\tASSERT(XFS_IS_QUOTA_RUNNING(tp->t_mountp));\n\tqtrx = NULL;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\t/*\n\t * Find either the first free slot or the slot that belongs\n\t * to this dquot.\n\t */\n\tqtrx = xfs_trans_get_dqtrx(tp, dqp);\n\tASSERT(qtrx);\n\tif (qtrx->qt_dquot == NULL)\n\t\tqtrx->qt_dquot = dqp;\n\n\tswitch (field) {\n\n\t\t/*\n\t\t * regular disk blk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_BLKS:\n\t\tqtrx->qt_blk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * inode reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_INOS:\n\t\tqtrx->qt_ino_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * disk blocks used.\n\t\t */\n\t      case XFS_TRANS_DQ_BCOUNT:\n\t\tif (qtrx->qt_blk_res && delta > 0) {\n\t\t\tqtrx->qt_blk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_blk_res >= qtrx->qt_blk_res_used);\n\t\t}\n\t\tqtrx->qt_bcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELBCOUNT:\n\t\tqtrx->qt_delbcnt_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * Inode Count\n\t\t */\n\t      case XFS_TRANS_DQ_ICOUNT:\n\t\tif (qtrx->qt_ino_res && delta > 0) {\n\t\t\tqtrx->qt_ino_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_ino_res >= qtrx->qt_ino_res_used);\n\t\t}\n\t\tqtrx->qt_icount_delta += delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk reservation\n\t\t */\n\t      case XFS_TRANS_DQ_RES_RTBLKS:\n\t\tqtrx->qt_rtblk_res += (ulong)delta;\n\t\tbreak;\n\n\t\t/*\n\t\t * rtblk count\n\t\t */\n\t      case XFS_TRANS_DQ_RTBCOUNT:\n\t\tif (qtrx->qt_rtblk_res && delta > 0) {\n\t\t\tqtrx->qt_rtblk_res_used += (ulong)delta;\n\t\t\tASSERT(qtrx->qt_rtblk_res >= qtrx->qt_rtblk_res_used);\n\t\t}\n\t\tqtrx->qt_rtbcount_delta += delta;\n\t\tbreak;\n\n\t      case XFS_TRANS_DQ_DELRTBCOUNT:\n\t\tqtrx->qt_delrtb_delta += delta;\n\t\tbreak;\n\n\t      default:\n\t\tASSERT(0);\n\t}\n\ttp->t_flags |= XFS_TRANS_DQ_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "prevdq != newdq"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "prevdq"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(ip->i_mount)"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "ip->i_mount"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dquot_t *\nxfs_qm_vop_chown(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_dquot_t\t**IO_olddq,\n\txfs_dquot_t\t*newdq)\n{\n\txfs_dquot_t\t*prevdq;\n\tuint\t\tbfield = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t XFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(ip->i_mount));\n\n\t/* old dquot */\n\tprevdq = *IO_olddq;\n\tASSERT(prevdq);\n\tASSERT(prevdq != newdq);\n\n\txfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));\n\txfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/* the sparkling new dquot */\n\txfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);\n\txfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\n\n\t/*\n\t * Take an extra reference, because the inode is going to keep\n\t * this dquot pointer even after the trans_commit.\n\t */\n\t*IO_olddq = xfs_qm_dqhold(newdq);\n\n\treturn prevdq;\n}"
  },
  {
    "function_name": "xfs_qm_vop_dqalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1595-1732",
    "snippet": "int\nxfs_qm_vop_dqalloc(\n\tstruct xfs_inode\t*ip,\n\txfs_dqid_t\t\tuid,\n\txfs_dqid_t\t\tgid,\n\tprid_t\t\t\tprid,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_udqpp,\n\tstruct xfs_dquot\t**O_gdqpp,\n\tstruct xfs_dquot\t**O_pdqpp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*uq = NULL;\n\tstruct xfs_dquot\t*gq = NULL;\n\tstruct xfs_dquot\t*pq = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tlockflags;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tlockflags = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lockflags);\n\n\tif ((flags & XFS_QMOPT_INHERIT) && XFS_INHERIT_GID(ip))\n\t\tgid = ip->i_d.di_gid;\n\n\t/*\n\t * Attach the dquot(s) to this inode, doing a dquot allocation\n\t * if necessary. The dquot(s) will not be locked.\n\t */\n\tif (XFS_NOT_DQATTACHED(mp, ip)) {\n\t\terror = xfs_qm_dqattach_locked(ip, XFS_QMOPT_DQALLOC);\n\t\tif (error) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((flags & XFS_QMOPT_UQUOTA) && XFS_IS_UQUOTA_ON(mp)) {\n\t\tif (ip->i_d.di_uid != uid) {\n\t\t\t/*\n\t\t\t * What we need is the dquot that has this uid, and\n\t\t\t * if we send the inode to dqget, the uid of the inode\n\t\t\t * takes priority over what's sent in the uid argument.\n\t\t\t * We must unlock inode here before calling dqget if\n\t\t\t * we're not sending the inode, because otherwise\n\t\t\t * we'll deadlock by doing trans_reserve while\n\t\t\t * holding ilock.\n\t\t\t */\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, NULL, uid,\n\t\t\t\t\t\t XFS_DQ_USER,\n\t\t\t\t\t\t XFS_QMOPT_DQALLOC |\n\t\t\t\t\t\t XFS_QMOPT_DOWARN,\n\t\t\t\t\t\t &uq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Get the ilock in the right order.\n\t\t\t */\n\t\t\txfs_dqunlock(uq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Take an extra reference, because we'll return\n\t\t\t * this to caller\n\t\t\t */\n\t\t\tASSERT(ip->i_udquot);\n\t\t\tuq = xfs_qm_dqhold(ip->i_udquot);\n\t\t}\n\t}\n\tif ((flags & XFS_QMOPT_GQUOTA) && XFS_IS_GQUOTA_ON(mp)) {\n\t\tif (ip->i_d.di_gid != gid) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, NULL, gid,\n\t\t\t\t\t\t XFS_DQ_GROUP,\n\t\t\t\t\t\t XFS_QMOPT_DQALLOC |\n\t\t\t\t\t\t XFS_QMOPT_DOWARN,\n\t\t\t\t\t\t &gq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\tgoto error_rele;\n\t\t\t}\n\t\t\txfs_dqunlock(gq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgq = xfs_qm_dqhold(ip->i_gdquot);\n\t\t}\n\t}\n\tif ((flags & XFS_QMOPT_PQUOTA) && XFS_IS_PQUOTA_ON(mp)) {\n\t\tif (xfs_get_projid(ip) != prid) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, NULL, (xfs_dqid_t)prid,\n\t\t\t\t\t\t XFS_DQ_PROJ,\n\t\t\t\t\t\t XFS_QMOPT_DQALLOC |\n\t\t\t\t\t\t XFS_QMOPT_DOWARN,\n\t\t\t\t\t\t &pq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\tgoto error_rele;\n\t\t\t}\n\t\t\txfs_dqunlock(pq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpq = xfs_qm_dqhold(ip->i_pdquot);\n\t\t}\n\t}\n\tif (uq)\n\t\ttrace_xfs_dquot_dqalloc(ip);\n\n\txfs_iunlock(ip, lockflags);\n\tif (O_udqpp)\n\t\t*O_udqpp = uq;\n\telse\n\t\txfs_qm_dqrele(uq);\n\tif (O_gdqpp)\n\t\t*O_gdqpp = gq;\n\telse\n\t\txfs_qm_dqrele(gq);\n\tif (O_pdqpp)\n\t\t*O_pdqpp = pq;\n\telse\n\t\txfs_qm_dqrele(pq);\n\treturn 0;\n\nerror_rele:\n\txfs_qm_dqrele(gq);\n\txfs_qm_dqrele(uq);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "uq"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "lockflags"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dquot_dqalloc",
          "args": [
            "ip"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqhold",
          "args": [
            "ip->i_pdquot"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqhold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "180-186",
          "snippet": "static inline struct xfs_dquot *xfs_qm_dqhold(struct xfs_dquot *dqp)\n{\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs++;\n\txfs_dqunlock(dqp);\n\treturn dqp;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dquot *xfs_qm_dqhold(struct xfs_dquot *dqp)\n{\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs++;\n\txfs_dqunlock(dqp);\n\treturn dqp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_pdquot"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "lockflags"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "pq"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOENT"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqget",
          "args": [
            "mp",
            "NULL",
            "(xfs_dqid_t)prid",
            "XFS_DQ_PROJ",
            "XFS_QMOPT_DQALLOC |\n\t\t\t\t\t\t XFS_QMOPT_DOWARN",
            "&pq"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "698-831",
          "snippet": "int\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_gdquot"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOENT"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_udquot"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOENT"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach_locked",
          "args": [
            "ip",
            "XFS_QMOPT_DQALLOC"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "330-377",
          "snippet": "int\nxfs_qm_dqattach_locked(\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror = 0;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (XFS_IS_UQUOTA_ON(mp) && !ip->i_udquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_uid, XFS_DQ_USER,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_udquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_udquot);\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp) && !ip->i_gdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_gid, XFS_DQ_GROUP,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_gdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_gdquot);\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp) && !ip->i_pdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, xfs_get_projid(ip), XFS_DQ_PROJ,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_pdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_pdquot);\n\t}\n\ndone:\n\t/*\n\t * Don't worry about the dquots that we may have attached before any\n\t * error - they'll get detached later if it has not already been done.\n\t */\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nint\nxfs_qm_dqattach_locked(\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror = 0;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (XFS_IS_UQUOTA_ON(mp) && !ip->i_udquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_uid, XFS_DQ_USER,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_udquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_udquot);\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp) && !ip->i_gdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_gid, XFS_DQ_GROUP,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_gdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_gdquot);\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp) && !ip->i_pdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, xfs_get_projid(ip), XFS_DQ_PROJ,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_pdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_pdquot);\n\t}\n\ndone:\n\t/*\n\t * Don't worry about the dquots that we may have attached before any\n\t * error - they'll get detached later if it has not already been done.\n\t */\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_NOT_DQATTACHED",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_INHERIT_GID",
          "args": [
            "ip"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_vop_dqalloc(\n\tstruct xfs_inode\t*ip,\n\txfs_dqid_t\t\tuid,\n\txfs_dqid_t\t\tgid,\n\tprid_t\t\t\tprid,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_udqpp,\n\tstruct xfs_dquot\t**O_gdqpp,\n\tstruct xfs_dquot\t**O_pdqpp)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*uq = NULL;\n\tstruct xfs_dquot\t*gq = NULL;\n\tstruct xfs_dquot\t*pq = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tlockflags;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tlockflags = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lockflags);\n\n\tif ((flags & XFS_QMOPT_INHERIT) && XFS_INHERIT_GID(ip))\n\t\tgid = ip->i_d.di_gid;\n\n\t/*\n\t * Attach the dquot(s) to this inode, doing a dquot allocation\n\t * if necessary. The dquot(s) will not be locked.\n\t */\n\tif (XFS_NOT_DQATTACHED(mp, ip)) {\n\t\terror = xfs_qm_dqattach_locked(ip, XFS_QMOPT_DQALLOC);\n\t\tif (error) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((flags & XFS_QMOPT_UQUOTA) && XFS_IS_UQUOTA_ON(mp)) {\n\t\tif (ip->i_d.di_uid != uid) {\n\t\t\t/*\n\t\t\t * What we need is the dquot that has this uid, and\n\t\t\t * if we send the inode to dqget, the uid of the inode\n\t\t\t * takes priority over what's sent in the uid argument.\n\t\t\t * We must unlock inode here before calling dqget if\n\t\t\t * we're not sending the inode, because otherwise\n\t\t\t * we'll deadlock by doing trans_reserve while\n\t\t\t * holding ilock.\n\t\t\t */\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, NULL, uid,\n\t\t\t\t\t\t XFS_DQ_USER,\n\t\t\t\t\t\t XFS_QMOPT_DQALLOC |\n\t\t\t\t\t\t XFS_QMOPT_DOWARN,\n\t\t\t\t\t\t &uq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Get the ilock in the right order.\n\t\t\t */\n\t\t\txfs_dqunlock(uq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Take an extra reference, because we'll return\n\t\t\t * this to caller\n\t\t\t */\n\t\t\tASSERT(ip->i_udquot);\n\t\t\tuq = xfs_qm_dqhold(ip->i_udquot);\n\t\t}\n\t}\n\tif ((flags & XFS_QMOPT_GQUOTA) && XFS_IS_GQUOTA_ON(mp)) {\n\t\tif (ip->i_d.di_gid != gid) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, NULL, gid,\n\t\t\t\t\t\t XFS_DQ_GROUP,\n\t\t\t\t\t\t XFS_QMOPT_DQALLOC |\n\t\t\t\t\t\t XFS_QMOPT_DOWARN,\n\t\t\t\t\t\t &gq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\tgoto error_rele;\n\t\t\t}\n\t\t\txfs_dqunlock(gq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgq = xfs_qm_dqhold(ip->i_gdquot);\n\t\t}\n\t}\n\tif ((flags & XFS_QMOPT_PQUOTA) && XFS_IS_PQUOTA_ON(mp)) {\n\t\tif (xfs_get_projid(ip) != prid) {\n\t\t\txfs_iunlock(ip, lockflags);\n\t\t\terror = xfs_qm_dqget(mp, NULL, (xfs_dqid_t)prid,\n\t\t\t\t\t\t XFS_DQ_PROJ,\n\t\t\t\t\t\t XFS_QMOPT_DQALLOC |\n\t\t\t\t\t\t XFS_QMOPT_DOWARN,\n\t\t\t\t\t\t &pq);\n\t\t\tif (error) {\n\t\t\t\tASSERT(error != -ENOENT);\n\t\t\t\tgoto error_rele;\n\t\t\t}\n\t\t\txfs_dqunlock(pq);\n\t\t\tlockflags = XFS_ILOCK_SHARED;\n\t\t\txfs_ilock(ip, lockflags);\n\t\t} else {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpq = xfs_qm_dqhold(ip->i_pdquot);\n\t\t}\n\t}\n\tif (uq)\n\t\ttrace_xfs_dquot_dqalloc(ip);\n\n\txfs_iunlock(ip, lockflags);\n\tif (O_udqpp)\n\t\t*O_udqpp = uq;\n\telse\n\t\txfs_qm_dqrele(uq);\n\tif (O_gdqpp)\n\t\t*O_gdqpp = gq;\n\telse\n\t\txfs_qm_dqrele(gq);\n\tif (O_pdqpp)\n\t\t*O_pdqpp = pq;\n\telse\n\t\txfs_qm_dqrele(pq);\n\treturn 0;\n\nerror_rele:\n\txfs_qm_dqrele(gq);\n\txfs_qm_dqrele(uq);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_dqfree_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1565-1580",
    "snippet": "STATIC void\nxfs_qm_dqfree_one(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\n\tmutex_lock(&qi->qi_tree_lock);\n\tradix_tree_delete(xfs_dquot_tree(qi, dqp->q_core.d_flags),\n\t\t\t  be32_to_cpu(dqp->q_core.d_id));\n\n\tqi->qi_dquots--;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n\txfs_qm_dqdestroy(dqp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqdestroy",
          "args": [
            "dqp"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqdestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "71-81",
          "snippet": "void\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_zone\t\t*xfs_qm_dqzone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "xfs_dquot_tree(qi, dqp->q_core.d_flags)",
            "be32_to_cpu(dqp->q_core.d_id)"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_id"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dquot_tree",
          "args": [
            "qi",
            "dqp->q_core.d_flags"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.h",
          "lines": "88-104",
          "snippet": "static inline struct radix_tree_root *\nxfs_dquot_tree(\n\tstruct xfs_quotainfo\t*qi,\n\tint\t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\treturn &qi->qi_uquota_tree;\n\tcase XFS_DQ_GROUP:\n\t\treturn &qi->qi_gquota_tree;\n\tcase XFS_DQ_PROJ:\n\t\treturn &qi->qi_pquota_tree;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n\nstatic inline struct radix_tree_root *\nxfs_dquot_tree(\n\tstruct xfs_quotainfo\t*qi,\n\tint\t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\treturn &qi->qi_uquota_tree;\n\tcase XFS_DQ_GROUP:\n\t\treturn &qi->qi_gquota_tree;\n\tcase XFS_DQ_PROJ:\n\t\treturn &qi->qi_pquota_tree;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC void\nxfs_qm_dqfree_one(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\n\tmutex_lock(&qi->qi_tree_lock);\n\tradix_tree_delete(xfs_dquot_tree(qi, dqp->q_core.d_flags),\n\t\t\t  be32_to_cpu(dqp->q_core.d_id));\n\n\tqi->qi_dquots--;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n\txfs_qm_dqdestroy(dqp);\n}"
  },
  {
    "function_name": "xfs_qm_init_quotainos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1476-1563",
    "snippet": "STATIC int\nxfs_qm_init_quotainos(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tflags = 0;\n\n\tASSERT(mp->m_quotainfo);\n\n\t/*\n\t * Get the uquota and gquota inodes\n\t */\n\tif (xfs_sb_version_hasquota(&mp->m_sb)) {\n\t\tif (XFS_IS_UQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_uquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t     0, 0, &uip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (XFS_IS_GQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_gquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t     0, 0, &gip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t\tif (XFS_IS_PQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_pquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t     0, 0, &pip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t} else {\n\t\tflags |= XFS_QMOPT_SBVERSION;\n\t}\n\n\t/*\n\t * Create the three inodes, if they don't exist already. The changes\n\t * made above will get added to a transaction and logged in one of\n\t * the qino_alloc calls below.  If the device is readonly,\n\t * temporarily switch to read-write to do this.\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp) && uip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &uip,\n\t\t\t\t\t      flags | XFS_QMOPT_UQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp) && gip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &gip,\n\t\t\t\t\t  flags | XFS_QMOPT_GQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp) && pip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &pip,\n\t\t\t\t\t  flags | XFS_QMOPT_PQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\t}\n\n\tmp->m_quotainfo->qi_uquotaip = uip;\n\tmp->m_quotainfo->qi_gquotaip = gip;\n\tmp->m_quotainfo->qi_pquotaip = pip;\n\n\treturn 0;\n\nerror_rele:\n\tif (uip)\n\t\tIRELE(uip);\n\tif (gip)\n\t\tIRELE(gip);\n\tif (pip)\n\t\tIRELE(pip);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "pip"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "gip"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "uip"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_qino_alloc",
          "args": [
            "mp",
            "&pip",
            "flags | XFS_QMOPT_PQUOTA"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_qino_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "713-802",
          "snippet": "STATIC int\nxfs_qm_qino_alloc(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t**ip,\n\tuint\t\tflags)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\tint\t\tcommitted;\n\n\t*ip = NULL;\n\t/*\n\t * With superblock that doesn't have separate pquotino, we\n\t * share an inode between gquota and pquota. If the on-disk\n\t * superblock has GQUOTA and the filesystem is now mounted\n\t * with PQUOTA, just use sb_gquotino for sb_pquotino and\n\t * vice-versa.\n\t */\n\tif (!xfs_sb_version_has_pquotino(&mp->m_sb) &&\n\t\t\t(flags & (XFS_QMOPT_PQUOTA|XFS_QMOPT_GQUOTA))) {\n\t\txfs_ino_t ino = NULLFSINO;\n\n\t\tif ((flags & XFS_QMOPT_PQUOTA) &&\n\t\t\t     (mp->m_sb.sb_gquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_gquotino;\n\t\t\tASSERT(mp->m_sb.sb_pquotino == NULLFSINO);\n\t\t} else if ((flags & XFS_QMOPT_GQUOTA) &&\n\t\t\t     (mp->m_sb.sb_pquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_pquotino;\n\t\t\tASSERT(mp->m_sb.sb_gquotino == NULLFSINO);\n\t\t}\n\t\tif (ino != NULLFSINO) {\n\t\t\terror = xfs_iget(mp, NULL, ino, 0, 0, ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\t\t}\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QINOCREATE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_create,\n\t\t\t\t  XFS_QM_QINOCREATE_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tif (!*ip) {\n\t\terror = xfs_dir_ialloc(&tp, NULL, S_IFREG, 1, 0, 0, 1, ip,\n\t\t\t\t\t\t\t\t&committed);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t XFS_TRANS_ABORT);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/*\n\t * Make the changes in the superblock, and log those too.\n\t * sbfields arg may contain fields other than *QUOTINO;\n\t * VERSIONNUM for example.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tif (flags & XFS_QMOPT_SBVERSION) {\n\t\tASSERT(!xfs_sb_version_hasquota(&mp->m_sb));\n\n\t\txfs_sb_version_addquota(&mp->m_sb);\n\t\tmp->m_sb.sb_uquotino = NULLFSINO;\n\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\n\t\t/* qflags will get updated fully _after_ quotacheck */\n\t\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_ALL_QUOTA_ACCT;\n\t}\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\tmp->m_sb.sb_uquotino = (*ip)->i_ino;\n\telse if (flags & XFS_QMOPT_GQUOTA)\n\t\tmp->m_sb.sb_gquotino = (*ip)->i_ino;\n\telse\n\t\tmp->m_sb.sb_pquotino = (*ip)->i_ino;\n\tspin_unlock(&mp->m_sb_lock);\n\txfs_log_sb(tp);\n\n\tif ((error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES))) {\n\t\txfs_alert(mp, \"%s failed (error %d)!\", __func__, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC int\nxfs_qm_qino_alloc(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t**ip,\n\tuint\t\tflags)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\tint\t\tcommitted;\n\n\t*ip = NULL;\n\t/*\n\t * With superblock that doesn't have separate pquotino, we\n\t * share an inode between gquota and pquota. If the on-disk\n\t * superblock has GQUOTA and the filesystem is now mounted\n\t * with PQUOTA, just use sb_gquotino for sb_pquotino and\n\t * vice-versa.\n\t */\n\tif (!xfs_sb_version_has_pquotino(&mp->m_sb) &&\n\t\t\t(flags & (XFS_QMOPT_PQUOTA|XFS_QMOPT_GQUOTA))) {\n\t\txfs_ino_t ino = NULLFSINO;\n\n\t\tif ((flags & XFS_QMOPT_PQUOTA) &&\n\t\t\t     (mp->m_sb.sb_gquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_gquotino;\n\t\t\tASSERT(mp->m_sb.sb_pquotino == NULLFSINO);\n\t\t} else if ((flags & XFS_QMOPT_GQUOTA) &&\n\t\t\t     (mp->m_sb.sb_pquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_pquotino;\n\t\t\tASSERT(mp->m_sb.sb_gquotino == NULLFSINO);\n\t\t}\n\t\tif (ino != NULLFSINO) {\n\t\t\terror = xfs_iget(mp, NULL, ino, 0, 0, ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\t\t}\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QINOCREATE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_create,\n\t\t\t\t  XFS_QM_QINOCREATE_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tif (!*ip) {\n\t\terror = xfs_dir_ialloc(&tp, NULL, S_IFREG, 1, 0, 0, 1, ip,\n\t\t\t\t\t\t\t\t&committed);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t XFS_TRANS_ABORT);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/*\n\t * Make the changes in the superblock, and log those too.\n\t * sbfields arg may contain fields other than *QUOTINO;\n\t * VERSIONNUM for example.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tif (flags & XFS_QMOPT_SBVERSION) {\n\t\tASSERT(!xfs_sb_version_hasquota(&mp->m_sb));\n\n\t\txfs_sb_version_addquota(&mp->m_sb);\n\t\tmp->m_sb.sb_uquotino = NULLFSINO;\n\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\n\t\t/* qflags will get updated fully _after_ quotacheck */\n\t\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_ALL_QUOTA_ACCT;\n\t}\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\tmp->m_sb.sb_uquotino = (*ip)->i_ino;\n\telse if (flags & XFS_QMOPT_GQUOTA)\n\t\tmp->m_sb.sb_gquotino = (*ip)->i_ino;\n\telse\n\t\tmp->m_sb.sb_pquotino = (*ip)->i_ino;\n\tspin_unlock(&mp->m_sb_lock);\n\txfs_log_sb(tp);\n\n\tif ((error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES))) {\n\t\txfs_alert(mp, \"%s failed (error %d)!\", __func__, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "mp->m_sb.sb_pquotino",
            "0",
            "0",
            "&pip"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_sb.sb_pquotino > 0"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_sb.sb_gquotino > 0"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_sb.sb_uquotino > 0"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasquota",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasquota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "389-392",
          "snippet": "static inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n\nstatic inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_quotainfo"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC int\nxfs_qm_init_quotainos(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tflags = 0;\n\n\tASSERT(mp->m_quotainfo);\n\n\t/*\n\t * Get the uquota and gquota inodes\n\t */\n\tif (xfs_sb_version_hasquota(&mp->m_sb)) {\n\t\tif (XFS_IS_UQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_uquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t     0, 0, &uip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (XFS_IS_GQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_gquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t     0, 0, &gip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t\tif (XFS_IS_PQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_pquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t     0, 0, &pip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t} else {\n\t\tflags |= XFS_QMOPT_SBVERSION;\n\t}\n\n\t/*\n\t * Create the three inodes, if they don't exist already. The changes\n\t * made above will get added to a transaction and logged in one of\n\t * the qino_alloc calls below.  If the device is readonly,\n\t * temporarily switch to read-write to do this.\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp) && uip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &uip,\n\t\t\t\t\t      flags | XFS_QMOPT_UQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp) && gip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &gip,\n\t\t\t\t\t  flags | XFS_QMOPT_GQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp) && pip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &pip,\n\t\t\t\t\t  flags | XFS_QMOPT_PQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\t}\n\n\tmp->m_quotainfo->qi_uquotaip = uip;\n\tmp->m_quotainfo->qi_gquotaip = gip;\n\tmp->m_quotainfo->qi_pquotaip = pip;\n\n\treturn 0;\n\nerror_rele:\n\tif (uip)\n\t\tIRELE(uip);\n\tif (gip)\n\t\tIRELE(gip);\n\tif (pip)\n\t\tIRELE(pip);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_mount_quotas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1388-1470",
    "snippet": "void\nxfs_qm_mount_quotas(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\tuint\t\t\tsbf;\n\n\t/*\n\t * If quotas on realtime volumes is not supported, we disable\n\t * quotas immediately.\n\t */\n\tif (mp->m_sb.sb_rextents) {\n\t\txfs_notice(mp, \"Cannot turn on quotas for realtime filesystem\");\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * Allocate the quotainfo structure inside the mount struct, and\n\t * create quotainode(s), and change/rev superblock if necessary.\n\t */\n\terror = xfs_qm_init_quotainfo(mp);\n\tif (error) {\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo == NULL);\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\t/*\n\t * If any of the quotas are not consistent, do a quotacheck.\n\t */\n\tif (XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\terror = xfs_qm_quotacheck(mp);\n\t\tif (error) {\n\t\t\t/* Quotacheck failed and disabled quotas. */\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tif (!XFS_IS_UQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_UQUOTA_CHKD;\n\tif (!XFS_IS_GQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_GQUOTA_CHKD;\n\tif (!XFS_IS_PQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_PQUOTA_CHKD;\n\n write_changes:\n\t/*\n\t * We actually don't have to acquire the m_sb_lock at all.\n\t * This can only be called from mount, and that's single threaded. XXX\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\n\t\tif (xfs_sync_sb(mp, false)) {\n\t\t\t/*\n\t\t\t * We could only have been turning quotas off.\n\t\t\t * We aren't in very good shape actually because\n\t\t\t * the incore structures are convinced that quotas are\n\t\t\t * off, but the on disk superblock doesn't know that !\n\t\t\t */\n\t\t\tASSERT(!(XFS_IS_QUOTA_RUNNING(mp)));\n\t\t\txfs_alert(mp, \"%s: Superblock update failed!\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp, \"Failed to initialize disk quotas.\");\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Failed to initialize disk quotas.\""
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s: Superblock update failed!\"",
            "__func__"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(XFS_IS_QUOTA_RUNNING(mp))"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sync_sb",
          "args": [
            "mp",
            "false"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sync_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "790-809",
          "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_quotacheck",
          "args": [
            "mp"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_quotacheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1243-1377",
          "snippet": "STATIC int\nxfs_qm_quotacheck(\n\txfs_mount_t\t*mp)\n{\n\tint\t\t\tdone, count, error, error2;\n\txfs_ino_t\t\tlastino;\n\tsize_t\t\t\tstructsz;\n\tuint\t\t\tflags;\n\tLIST_HEAD\t\t(buffer_list);\n\tstruct xfs_inode\t*uip = mp->m_quotainfo->qi_uquotaip;\n\tstruct xfs_inode\t*gip = mp->m_quotainfo->qi_gquotaip;\n\tstruct xfs_inode\t*pip = mp->m_quotainfo->qi_pquotaip;\n\n\tcount = INT_MAX;\n\tstructsz = 1;\n\tlastino = 0;\n\tflags = 0;\n\n\tASSERT(uip || gip || pip);\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\txfs_notice(mp, \"Quotacheck needed: Please wait.\");\n\n\t/*\n\t * First we go thru all the dquots on disk, USR and GRP/PRJ, and reset\n\t * their counters to zero. We need a clean slate.\n\t * We don't log our changes till later.\n\t */\n\tif (uip) {\n\t\terror = xfs_qm_dqiterate(mp, uip, XFS_QMOPT_UQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_UQUOTA_CHKD;\n\t}\n\n\tif (gip) {\n\t\terror = xfs_qm_dqiterate(mp, gip, XFS_QMOPT_GQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_GQUOTA_CHKD;\n\t}\n\n\tif (pip) {\n\t\terror = xfs_qm_dqiterate(mp, pip, XFS_QMOPT_PQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_PQUOTA_CHKD;\n\t}\n\n\tdo {\n\t\t/*\n\t\t * Iterate thru all the inodes in the file system,\n\t\t * adjusting the corresponding dquot counters in core.\n\t\t */\n\t\terror = xfs_bulkstat(mp, &lastino, &count,\n\t\t\t\t     xfs_qm_dqusage_adjust,\n\t\t\t\t     structsz, NULL, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t} while (!done);\n\n\t/*\n\t * We've made all the changes that we need to make incore.  Flush them\n\t * down to disk buffers if everything was updated successfully.\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp)) {\n\t\terror = xfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_flush_one,\n\t\t\t\t\t  &buffer_list);\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\tif (!error)\n\t\terror = error2;\n\n\t/*\n\t * We can get this error if we couldn't do a dquot allocation inside\n\t * xfs_qm_dqusage_adjust (via bulkstat). We don't care about the\n\t * dirty dquots that might be cached, we just want to get rid of them\n\t * and turn quotaoff. The dquots won't be attached to any of the inodes\n\t * at this point (because we intentionally didn't in dqget_noattach).\n\t */\n\tif (error) {\n\t\txfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tmp->m_qflags &= ~XFS_ALL_QUOTA_CHKD;\n\tmp->m_qflags |= flags;\n\n error_return:\n\twhile (!list_empty(&buffer_list)) {\n\t\tstruct xfs_buf *bp =\n\t\t\tlist_first_entry(&buffer_list, struct xfs_buf, b_list);\n\t\tlist_del_init(&bp->b_list);\n\t\txfs_buf_relse(bp);\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp,\n\t\"Quotacheck: Unsuccessful (Error %d): Disabling quotas.\",\n\t\t\terror);\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo != NULL);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\tif (xfs_mount_reset_sbqflags(mp)) {\n\t\t\txfs_warn(mp,\n\t\t\t\t\"Quotacheck: Failed to reset quota flags.\");\n\t\t}\n\t} else\n\t\txfs_notice(mp, \"Quotacheck: Done.\");\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC int\nxfs_qm_quotacheck(\n\txfs_mount_t\t*mp)\n{\n\tint\t\t\tdone, count, error, error2;\n\txfs_ino_t\t\tlastino;\n\tsize_t\t\t\tstructsz;\n\tuint\t\t\tflags;\n\tLIST_HEAD\t\t(buffer_list);\n\tstruct xfs_inode\t*uip = mp->m_quotainfo->qi_uquotaip;\n\tstruct xfs_inode\t*gip = mp->m_quotainfo->qi_gquotaip;\n\tstruct xfs_inode\t*pip = mp->m_quotainfo->qi_pquotaip;\n\n\tcount = INT_MAX;\n\tstructsz = 1;\n\tlastino = 0;\n\tflags = 0;\n\n\tASSERT(uip || gip || pip);\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\txfs_notice(mp, \"Quotacheck needed: Please wait.\");\n\n\t/*\n\t * First we go thru all the dquots on disk, USR and GRP/PRJ, and reset\n\t * their counters to zero. We need a clean slate.\n\t * We don't log our changes till later.\n\t */\n\tif (uip) {\n\t\terror = xfs_qm_dqiterate(mp, uip, XFS_QMOPT_UQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_UQUOTA_CHKD;\n\t}\n\n\tif (gip) {\n\t\terror = xfs_qm_dqiterate(mp, gip, XFS_QMOPT_GQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_GQUOTA_CHKD;\n\t}\n\n\tif (pip) {\n\t\terror = xfs_qm_dqiterate(mp, pip, XFS_QMOPT_PQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_PQUOTA_CHKD;\n\t}\n\n\tdo {\n\t\t/*\n\t\t * Iterate thru all the inodes in the file system,\n\t\t * adjusting the corresponding dquot counters in core.\n\t\t */\n\t\terror = xfs_bulkstat(mp, &lastino, &count,\n\t\t\t\t     xfs_qm_dqusage_adjust,\n\t\t\t\t     structsz, NULL, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t} while (!done);\n\n\t/*\n\t * We've made all the changes that we need to make incore.  Flush them\n\t * down to disk buffers if everything was updated successfully.\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp)) {\n\t\terror = xfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_flush_one,\n\t\t\t\t\t  &buffer_list);\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\tif (!error)\n\t\terror = error2;\n\n\t/*\n\t * We can get this error if we couldn't do a dquot allocation inside\n\t * xfs_qm_dqusage_adjust (via bulkstat). We don't care about the\n\t * dirty dquots that might be cached, we just want to get rid of them\n\t * and turn quotaoff. The dquots won't be attached to any of the inodes\n\t * at this point (because we intentionally didn't in dqget_noattach).\n\t */\n\tif (error) {\n\t\txfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tmp->m_qflags &= ~XFS_ALL_QUOTA_CHKD;\n\tmp->m_qflags |= flags;\n\n error_return:\n\twhile (!list_empty(&buffer_list)) {\n\t\tstruct xfs_buf *bp =\n\t\t\tlist_first_entry(&buffer_list, struct xfs_buf, b_list);\n\t\tlist_del_init(&bp->b_list);\n\t\txfs_buf_relse(bp);\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp,\n\t\"Quotacheck: Unsuccessful (Error %d): Disabling quotas.\",\n\t\t\terror);\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo != NULL);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\tif (xfs_mount_reset_sbqflags(mp)) {\n\t\t\txfs_warn(mp,\n\t\t\t\t\"Quotacheck: Failed to reset quota flags.\");\n\t\t}\n\t} else\n\t\txfs_notice(mp, \"Quotacheck: Done.\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_QM_NEED_QUOTACHECK",
          "args": [
            "mp"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_quotainfo == NULL"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_init_quotainfo",
          "args": [
            "mp"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_init_quotainfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "567-672",
          "snippet": "STATIC int\nxfs_qm_init_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qinf;\n\tint\t\terror;\n\txfs_dquot_t\t*dqp;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tqinf = mp->m_quotainfo = kmem_zalloc(sizeof(xfs_quotainfo_t), KM_SLEEP);\n\n\terror = list_lru_init(&qinf->qi_lru);\n\tif (error)\n\t\tgoto out_free_qinf;\n\n\t/*\n\t * See if quotainodes are setup, and if not, allocate them,\n\t * and change the superblock accordingly.\n\t */\n\terror = xfs_qm_init_quotainos(mp);\n\tif (error)\n\t\tgoto out_free_lru;\n\n\tINIT_RADIX_TREE(&qinf->qi_uquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_gquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_pquota_tree, GFP_NOFS);\n\tmutex_init(&qinf->qi_tree_lock);\n\n\t/* mutex used to serialize quotaoffs */\n\tmutex_init(&qinf->qi_quotaofflock);\n\n\t/* Precalc some constants */\n\tqinf->qi_dqchunklen = XFS_FSB_TO_BB(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tqinf->qi_dqperchunk = xfs_calc_dquots_per_chunk(qinf->qi_dqchunklen);\n\n\tmp->m_qflags |= (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_CHKD);\n\n\t/*\n\t * We try to get the limits from the superuser's limits fields.\n\t * This is quite hacky, but it is standard quota practice.\n\t *\n\t * We look at the USR dquot with id == 0 first, but if user quotas\n\t * are not enabled we goto the GRP dquot with id == 0.\n\t * We don't really care to keep separate default limits for user\n\t * and group quotas, at least not at this point.\n\t *\n\t * Since we may not have done a quotacheck by this point, just read\n\t * the dquot without attaching it to any hashtables or lists.\n\t */\n\terror = xfs_qm_dqread(mp, 0,\n\t\t\tXFS_IS_UQUOTA_RUNNING(mp) ? XFS_DQ_USER :\n\t\t\t (XFS_IS_GQUOTA_RUNNING(mp) ? XFS_DQ_GROUP :\n\t\t\t  XFS_DQ_PROJ),\n\t\t\tXFS_QMOPT_DOWARN, &dqp);\n\tif (!error) {\n\t\txfs_disk_dquot_t\t*ddqp = &dqp->q_core;\n\n\t\t/*\n\t\t * The warnings and timers set the grace period given to\n\t\t * a user or group before he or she can not perform any\n\t\t * more writing. If it is zero, a default is used.\n\t\t */\n\t\tqinf->qi_btimelimit = ddqp->d_btimer ?\n\t\t\tbe32_to_cpu(ddqp->d_btimer) : XFS_QM_BTIMELIMIT;\n\t\tqinf->qi_itimelimit = ddqp->d_itimer ?\n\t\t\tbe32_to_cpu(ddqp->d_itimer) : XFS_QM_ITIMELIMIT;\n\t\tqinf->qi_rtbtimelimit = ddqp->d_rtbtimer ?\n\t\t\tbe32_to_cpu(ddqp->d_rtbtimer) : XFS_QM_RTBTIMELIMIT;\n\t\tqinf->qi_bwarnlimit = ddqp->d_bwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_bwarns) : XFS_QM_BWARNLIMIT;\n\t\tqinf->qi_iwarnlimit = ddqp->d_iwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_iwarns) : XFS_QM_IWARNLIMIT;\n\t\tqinf->qi_rtbwarnlimit = ddqp->d_rtbwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_rtbwarns) : XFS_QM_RTBWARNLIMIT;\n\t\tqinf->qi_bhardlimit = be64_to_cpu(ddqp->d_blk_hardlimit);\n\t\tqinf->qi_bsoftlimit = be64_to_cpu(ddqp->d_blk_softlimit);\n\t\tqinf->qi_ihardlimit = be64_to_cpu(ddqp->d_ino_hardlimit);\n\t\tqinf->qi_isoftlimit = be64_to_cpu(ddqp->d_ino_softlimit);\n\t\tqinf->qi_rtbhardlimit = be64_to_cpu(ddqp->d_rtb_hardlimit);\n\t\tqinf->qi_rtbsoftlimit = be64_to_cpu(ddqp->d_rtb_softlimit);\n\n\t\txfs_qm_dqdestroy(dqp);\n\t} else {\n\t\tqinf->qi_btimelimit = XFS_QM_BTIMELIMIT;\n\t\tqinf->qi_itimelimit = XFS_QM_ITIMELIMIT;\n\t\tqinf->qi_rtbtimelimit = XFS_QM_RTBTIMELIMIT;\n\t\tqinf->qi_bwarnlimit = XFS_QM_BWARNLIMIT;\n\t\tqinf->qi_iwarnlimit = XFS_QM_IWARNLIMIT;\n\t\tqinf->qi_rtbwarnlimit = XFS_QM_RTBWARNLIMIT;\n\t}\n\n\tqinf->qi_shrinker.count_objects = xfs_qm_shrink_count;\n\tqinf->qi_shrinker.scan_objects = xfs_qm_shrink_scan;\n\tqinf->qi_shrinker.seeks = DEFAULT_SEEKS;\n\tqinf->qi_shrinker.flags = SHRINKER_NUMA_AWARE;\n\tregister_shrinker(&qinf->qi_shrinker);\n\treturn 0;\n\nout_free_lru:\n\tlist_lru_destroy(&qinf->qi_lru);\nout_free_qinf:\n\tkmem_free(qinf);\n\tmp->m_quotainfo = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);",
            "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_init_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qinf;\n\tint\t\terror;\n\txfs_dquot_t\t*dqp;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tqinf = mp->m_quotainfo = kmem_zalloc(sizeof(xfs_quotainfo_t), KM_SLEEP);\n\n\terror = list_lru_init(&qinf->qi_lru);\n\tif (error)\n\t\tgoto out_free_qinf;\n\n\t/*\n\t * See if quotainodes are setup, and if not, allocate them,\n\t * and change the superblock accordingly.\n\t */\n\terror = xfs_qm_init_quotainos(mp);\n\tif (error)\n\t\tgoto out_free_lru;\n\n\tINIT_RADIX_TREE(&qinf->qi_uquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_gquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_pquota_tree, GFP_NOFS);\n\tmutex_init(&qinf->qi_tree_lock);\n\n\t/* mutex used to serialize quotaoffs */\n\tmutex_init(&qinf->qi_quotaofflock);\n\n\t/* Precalc some constants */\n\tqinf->qi_dqchunklen = XFS_FSB_TO_BB(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tqinf->qi_dqperchunk = xfs_calc_dquots_per_chunk(qinf->qi_dqchunklen);\n\n\tmp->m_qflags |= (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_CHKD);\n\n\t/*\n\t * We try to get the limits from the superuser's limits fields.\n\t * This is quite hacky, but it is standard quota practice.\n\t *\n\t * We look at the USR dquot with id == 0 first, but if user quotas\n\t * are not enabled we goto the GRP dquot with id == 0.\n\t * We don't really care to keep separate default limits for user\n\t * and group quotas, at least not at this point.\n\t *\n\t * Since we may not have done a quotacheck by this point, just read\n\t * the dquot without attaching it to any hashtables or lists.\n\t */\n\terror = xfs_qm_dqread(mp, 0,\n\t\t\tXFS_IS_UQUOTA_RUNNING(mp) ? XFS_DQ_USER :\n\t\t\t (XFS_IS_GQUOTA_RUNNING(mp) ? XFS_DQ_GROUP :\n\t\t\t  XFS_DQ_PROJ),\n\t\t\tXFS_QMOPT_DOWARN, &dqp);\n\tif (!error) {\n\t\txfs_disk_dquot_t\t*ddqp = &dqp->q_core;\n\n\t\t/*\n\t\t * The warnings and timers set the grace period given to\n\t\t * a user or group before he or she can not perform any\n\t\t * more writing. If it is zero, a default is used.\n\t\t */\n\t\tqinf->qi_btimelimit = ddqp->d_btimer ?\n\t\t\tbe32_to_cpu(ddqp->d_btimer) : XFS_QM_BTIMELIMIT;\n\t\tqinf->qi_itimelimit = ddqp->d_itimer ?\n\t\t\tbe32_to_cpu(ddqp->d_itimer) : XFS_QM_ITIMELIMIT;\n\t\tqinf->qi_rtbtimelimit = ddqp->d_rtbtimer ?\n\t\t\tbe32_to_cpu(ddqp->d_rtbtimer) : XFS_QM_RTBTIMELIMIT;\n\t\tqinf->qi_bwarnlimit = ddqp->d_bwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_bwarns) : XFS_QM_BWARNLIMIT;\n\t\tqinf->qi_iwarnlimit = ddqp->d_iwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_iwarns) : XFS_QM_IWARNLIMIT;\n\t\tqinf->qi_rtbwarnlimit = ddqp->d_rtbwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_rtbwarns) : XFS_QM_RTBWARNLIMIT;\n\t\tqinf->qi_bhardlimit = be64_to_cpu(ddqp->d_blk_hardlimit);\n\t\tqinf->qi_bsoftlimit = be64_to_cpu(ddqp->d_blk_softlimit);\n\t\tqinf->qi_ihardlimit = be64_to_cpu(ddqp->d_ino_hardlimit);\n\t\tqinf->qi_isoftlimit = be64_to_cpu(ddqp->d_ino_softlimit);\n\t\tqinf->qi_rtbhardlimit = be64_to_cpu(ddqp->d_rtb_hardlimit);\n\t\tqinf->qi_rtbsoftlimit = be64_to_cpu(ddqp->d_rtb_softlimit);\n\n\t\txfs_qm_dqdestroy(dqp);\n\t} else {\n\t\tqinf->qi_btimelimit = XFS_QM_BTIMELIMIT;\n\t\tqinf->qi_itimelimit = XFS_QM_ITIMELIMIT;\n\t\tqinf->qi_rtbtimelimit = XFS_QM_RTBTIMELIMIT;\n\t\tqinf->qi_bwarnlimit = XFS_QM_BWARNLIMIT;\n\t\tqinf->qi_iwarnlimit = XFS_QM_IWARNLIMIT;\n\t\tqinf->qi_rtbwarnlimit = XFS_QM_RTBWARNLIMIT;\n\t}\n\n\tqinf->qi_shrinker.count_objects = xfs_qm_shrink_count;\n\tqinf->qi_shrinker.scan_objects = xfs_qm_shrink_scan;\n\tqinf->qi_shrinker.seeks = DEFAULT_SEEKS;\n\tqinf->qi_shrinker.flags = SHRINKER_NUMA_AWARE;\n\tregister_shrinker(&qinf->qi_shrinker);\n\treturn 0;\n\nout_free_lru:\n\tlist_lru_destroy(&qinf->qi_lru);\nout_free_qinf:\n\tkmem_free(qinf);\n\tmp->m_quotainfo = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(mp)"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"Cannot turn on quotas for realtime filesystem\""
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_mount_quotas(\n\tstruct xfs_mount\t*mp)\n{\n\tint\t\t\terror = 0;\n\tuint\t\t\tsbf;\n\n\t/*\n\t * If quotas on realtime volumes is not supported, we disable\n\t * quotas immediately.\n\t */\n\tif (mp->m_sb.sb_rextents) {\n\t\txfs_notice(mp, \"Cannot turn on quotas for realtime filesystem\");\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * Allocate the quotainfo structure inside the mount struct, and\n\t * create quotainode(s), and change/rev superblock if necessary.\n\t */\n\terror = xfs_qm_init_quotainfo(mp);\n\tif (error) {\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo == NULL);\n\t\tmp->m_qflags = 0;\n\t\tgoto write_changes;\n\t}\n\t/*\n\t * If any of the quotas are not consistent, do a quotacheck.\n\t */\n\tif (XFS_QM_NEED_QUOTACHECK(mp)) {\n\t\terror = xfs_qm_quotacheck(mp);\n\t\tif (error) {\n\t\t\t/* Quotacheck failed and disabled quotas. */\n\t\t\treturn;\n\t\t}\n\t}\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tif (!XFS_IS_UQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_UQUOTA_CHKD;\n\tif (!XFS_IS_GQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_GQUOTA_CHKD;\n\tif (!XFS_IS_PQUOTA_ON(mp))\n\t\tmp->m_qflags &= ~XFS_PQUOTA_CHKD;\n\n write_changes:\n\t/*\n\t * We actually don't have to acquire the m_sb_lock at all.\n\t * This can only be called from mount, and that's single threaded. XXX\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_MOUNT_QUOTA_ALL;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (sbf != (mp->m_qflags & XFS_MOUNT_QUOTA_ALL)) {\n\t\tif (xfs_sync_sb(mp, false)) {\n\t\t\t/*\n\t\t\t * We could only have been turning quotas off.\n\t\t\t * We aren't in very good shape actually because\n\t\t\t * the incore structures are convinced that quotas are\n\t\t\t * off, but the on disk superblock doesn't know that !\n\t\t\t */\n\t\t\tASSERT(!(XFS_IS_QUOTA_RUNNING(mp)));\n\t\t\txfs_alert(mp, \"%s: Superblock update failed!\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp, \"Failed to initialize disk quotas.\");\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "xfs_qm_quotacheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1243-1377",
    "snippet": "STATIC int\nxfs_qm_quotacheck(\n\txfs_mount_t\t*mp)\n{\n\tint\t\t\tdone, count, error, error2;\n\txfs_ino_t\t\tlastino;\n\tsize_t\t\t\tstructsz;\n\tuint\t\t\tflags;\n\tLIST_HEAD\t\t(buffer_list);\n\tstruct xfs_inode\t*uip = mp->m_quotainfo->qi_uquotaip;\n\tstruct xfs_inode\t*gip = mp->m_quotainfo->qi_gquotaip;\n\tstruct xfs_inode\t*pip = mp->m_quotainfo->qi_pquotaip;\n\n\tcount = INT_MAX;\n\tstructsz = 1;\n\tlastino = 0;\n\tflags = 0;\n\n\tASSERT(uip || gip || pip);\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\txfs_notice(mp, \"Quotacheck needed: Please wait.\");\n\n\t/*\n\t * First we go thru all the dquots on disk, USR and GRP/PRJ, and reset\n\t * their counters to zero. We need a clean slate.\n\t * We don't log our changes till later.\n\t */\n\tif (uip) {\n\t\terror = xfs_qm_dqiterate(mp, uip, XFS_QMOPT_UQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_UQUOTA_CHKD;\n\t}\n\n\tif (gip) {\n\t\terror = xfs_qm_dqiterate(mp, gip, XFS_QMOPT_GQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_GQUOTA_CHKD;\n\t}\n\n\tif (pip) {\n\t\terror = xfs_qm_dqiterate(mp, pip, XFS_QMOPT_PQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_PQUOTA_CHKD;\n\t}\n\n\tdo {\n\t\t/*\n\t\t * Iterate thru all the inodes in the file system,\n\t\t * adjusting the corresponding dquot counters in core.\n\t\t */\n\t\terror = xfs_bulkstat(mp, &lastino, &count,\n\t\t\t\t     xfs_qm_dqusage_adjust,\n\t\t\t\t     structsz, NULL, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t} while (!done);\n\n\t/*\n\t * We've made all the changes that we need to make incore.  Flush them\n\t * down to disk buffers if everything was updated successfully.\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp)) {\n\t\terror = xfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_flush_one,\n\t\t\t\t\t  &buffer_list);\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\tif (!error)\n\t\terror = error2;\n\n\t/*\n\t * We can get this error if we couldn't do a dquot allocation inside\n\t * xfs_qm_dqusage_adjust (via bulkstat). We don't care about the\n\t * dirty dquots that might be cached, we just want to get rid of them\n\t * and turn quotaoff. The dquots won't be attached to any of the inodes\n\t * at this point (because we intentionally didn't in dqget_noattach).\n\t */\n\tif (error) {\n\t\txfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tmp->m_qflags &= ~XFS_ALL_QUOTA_CHKD;\n\tmp->m_qflags |= flags;\n\n error_return:\n\twhile (!list_empty(&buffer_list)) {\n\t\tstruct xfs_buf *bp =\n\t\t\tlist_first_entry(&buffer_list, struct xfs_buf, b_list);\n\t\tlist_del_init(&bp->b_list);\n\t\txfs_buf_relse(bp);\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp,\n\t\"Quotacheck: Unsuccessful (Error %d): Disabling quotas.\",\n\t\t\terror);\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo != NULL);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\tif (xfs_mount_reset_sbqflags(mp)) {\n\t\t\txfs_warn(mp,\n\t\t\t\t\"Quotacheck: Failed to reset quota flags.\");\n\t\t}\n\t} else\n\t\txfs_notice(mp, \"Quotacheck: Done.\");\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"Quotacheck: Done.\""
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Quotacheck: Failed to reset quota flags.\""
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mount_reset_sbqflags",
          "args": [
            "mp"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mount_reset_sbqflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "582-599",
          "snippet": "int\nxfs_mount_reset_sbqflags(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_qflags = 0;\n\n\t/* It is OK to look at sb_qflags in the mount path without m_sb_lock. */\n\tif (mp->m_sb.sb_qflags == 0)\n\t\treturn 0;\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = 0;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, false);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mount_reset_sbqflags(\n\tstruct xfs_mount\t*mp)\n{\n\tmp->m_qflags = 0;\n\n\t/* It is OK to look at sb_qflags in the mount path without m_sb_lock. */\n\tif (mp->m_sb.sb_qflags == 0)\n\t\treturn 0;\n\tspin_lock(&mp->m_sb_lock);\n\tmp->m_sb.sb_qflags = 0;\n\tspin_unlock(&mp->m_sb_lock);\n\n\tif (!xfs_fs_writable(mp, SB_FREEZE_WRITE))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_destroy_quotainfo",
          "args": [
            "mp"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_destroy_quotainfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "680-707",
          "snippet": "void\nxfs_qm_destroy_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\n\tif (qi->qi_uquotaip) {\n\t\tIRELE(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL; /* paranoia */\n\t}\n\tif (qi->qi_gquotaip) {\n\t\tIRELE(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\tIRELE(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nvoid\nxfs_qm_destroy_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\n\tif (qi->qi_uquotaip) {\n\t\tIRELE(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL; /* paranoia */\n\t}\n\tif (qi->qi_gquotaip) {\n\t\tIRELE(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\tIRELE(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_quotainfo != NULL"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Quotacheck: Unsuccessful (Error %d): Disabling quotas.\"",
            "error"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bp->b_list"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&buffer_list",
            "structxfs_buf",
            "b_list"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&buffer_list"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqpurge_all",
          "args": [
            "mp",
            "XFS_QMOPT_QUOTALL"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqpurge_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "196-207",
          "snippet": "void\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags)\n{\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_GQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags)\n{\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_GQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_submit",
          "args": [
            "&buffer_list"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1856-1881",
          "snippet": "int\nxfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\tint\t\t\terror = 0, error2;\n\tstruct xfs_buf\t\t*bp;\n\n\t__xfs_buf_delwri_submit(buffer_list, &io_list, true);\n\n\t/* Wait for IO to complete. */\n\twhile (!list_empty(&io_list)) {\n\t\tbp = list_first_entry(&io_list, struct xfs_buf, b_list);\n\n\t\tlist_del_init(&bp->b_list);\n\n\t\t/* locking the buffer will wait for async IO completion. */\n\t\txfs_buf_lock(bp);\n\t\terror2 = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\tint\t\t\terror = 0, error2;\n\tstruct xfs_buf\t\t*bp;\n\n\t__xfs_buf_delwri_submit(buffer_list, &io_list, true);\n\n\t/* Wait for IO to complete. */\n\twhile (!list_empty(&io_list)) {\n\t\tbp = list_first_entry(&io_list, struct xfs_buf, b_list);\n\n\t\tlist_del_init(&bp->b_list);\n\n\t\t/* locking the buffer will wait for async IO completion. */\n\t\txfs_buf_lock(bp);\n\t\terror2 = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dquot_walk",
          "args": [
            "mp",
            "XFS_DQ_PROJ",
            "xfs_qm_flush_one",
            "&buffer_list"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dquot_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "61-122",
          "snippet": "STATIC int\nxfs_qm_dquot_walk(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\ttype,\n\tint\t\t\t(*execute)(struct xfs_dquot *dqp, void *data),\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tuint32_t\t\tnext_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tnr_found;\n\nrestart:\n\tskipped = 0;\n\tnext_index = 0;\n\tnr_found = 0;\n\n\twhile (1) {\n\t\tstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\tmutex_lock(&qi->qi_tree_lock);\n\t\tnr_found = radix_tree_gang_lookup(tree, (void **)batch,\n\t\t\t\t\tnext_index, XFS_DQ_LOOKUP_BATCH);\n\t\tif (!nr_found) {\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_dquot *dqp = batch[i];\n\n\t\t\tnext_index = be32_to_cpu(dqp->q_core.d_id) + 1;\n\n\t\t\terror = execute(batch[i], data);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (last_error == -EFSCORRUPTED) {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\n\treturn last_error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_DQ_LOOKUP_BATCH\t32"
          ],
          "globals_used": [
            "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_DQ_LOOKUP_BATCH\t32\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_dquot_walk(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\ttype,\n\tint\t\t\t(*execute)(struct xfs_dquot *dqp, void *data),\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tuint32_t\t\tnext_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tnr_found;\n\nrestart:\n\tskipped = 0;\n\tnext_index = 0;\n\tnr_found = 0;\n\n\twhile (1) {\n\t\tstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\tmutex_lock(&qi->qi_tree_lock);\n\t\tnr_found = radix_tree_gang_lookup(tree, (void **)batch,\n\t\t\t\t\tnext_index, XFS_DQ_LOOKUP_BATCH);\n\t\tif (!nr_found) {\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_dquot *dqp = batch[i];\n\n\t\t\tnext_index = be32_to_cpu(dqp->q_core.d_id) + 1;\n\n\t\t\terror = execute(batch[i], data);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (last_error == -EFSCORRUPTED) {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\n\treturn last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bulkstat",
          "args": [
            "mp",
            "&lastino",
            "&count",
            "xfs_qm_dqusage_adjust",
            "structsz",
            "NULL",
            "&done"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bulkstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_itable.c",
          "lines": "340-531",
          "snippet": "int\t\t\t\t\t/* error status */\nxfs_bulkstat(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_ino_t\t\t*lastinop, /* last inode returned */\n\tint\t\t\t*ubcountp, /* size of buffer/count returned */\n\tbulkstat_one_pf\t\tformatter, /* func that'd fill a single buf */\n\tsize_t\t\t\tstatstruct_size, /* sizeof struct filling */\n\tchar\t\t\t__user *ubuffer, /* buffer with inode stats */\n\tint\t\t\t*done)\t/* 1 if there are more stats to get */\n{\n\txfs_buf_t\t\t*agbp;\t/* agi header buffer */\n\txfs_agino_t\t\tagino;\t/* inode # in allocation group */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor for ialloc btree */\n\tsize_t\t\t\tirbsize; /* size of irec buffer in bytes */\n\txfs_inobt_rec_incore_t\t*irbuf;\t/* start of irec buffer */\n\tint\t\t\tnirbuf;\t/* size of irbuf */\n\tint\t\t\tubcount; /* size of user's buffer */\n\tstruct xfs_bulkstat_agichunk ac;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Get the last inode value, see if there's nothing to do.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, *lastinop);\n\tagino = XFS_INO_TO_AGINO(mp, *lastinop);\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t*done = 1;\n\t\t*ubcountp = 0;\n\t\treturn 0;\n\t}\n\n\tubcount = *ubcountp; /* statstruct's */\n\tac.ac_ubuffer = &ubuffer;\n\tac.ac_ubleft = ubcount * statstruct_size; /* bytes */;\n\tac.ac_ubelem = 0;\n\n\t*ubcountp = 0;\n\t*done = 0;\n\n\tirbuf = kmem_zalloc_greedy(&irbsize, PAGE_SIZE, PAGE_SIZE * 4);\n\tif (!irbuf)\n\t\treturn -ENOMEM;\n\n\tnirbuf = irbsize / sizeof(*irbuf);\n\n\t/*\n\t * Loop over the allocation groups, starting from the last\n\t * inode returned; 0 means start of the allocation group.\n\t */\n\twhile (agno < mp->m_sb.sb_agcount) {\n\t\tstruct xfs_inobt_rec_incore\t*irbp = irbuf;\n\t\tstruct xfs_inobt_rec_incore\t*irbufend = irbuf + nirbuf;\n\t\tbool\t\t\t\tend_of_ag = false;\n\t\tint\t\t\t\ticount = 0;\n\t\tint\t\t\t\tstat;\n\n\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Allocate and initialize a btree cursor for ialloc btree.\n\t\t */\n\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t    XFS_BTNUM_INO);\n\t\tif (agino > 0) {\n\t\t\t/*\n\t\t\t * In the middle of an allocation group, we need to get\n\t\t\t * the remainder of the chunk we're in.\n\t\t\t */\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_bulkstat_grab_ichunk(cur, agino, &icount, &r);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tif (icount) {\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t}\n\t\t\t/* Increment to the next record */\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t} else {\n\t\t\t/* Start of ag.  Lookup the first inode chunk */\n\t\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);\n\t\t}\n\t\tif (error || stat == 0) {\n\t\t\tend_of_ag = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * Loop through inode btree records in this ag,\n\t\t * until we run out of inodes or space in the buffer.\n\t\t */\n\t\twhile (irbp < irbufend && icount < ubcount) {\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this chunk has any allocated inodes, save it.\n\t\t\t * Also start read-ahead now for this chunk.\n\t\t\t */\n\t\t\tif (r.ir_freecount < XFS_INODES_PER_CHUNK) {\n\t\t\t\txfs_bulkstat_ichunk_ra(mp, agno, &r);\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t\ticount += XFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\t\t}\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Drop the btree buffers and the agi buffer as we can't hold any\n\t\t * of the locks these represent when calling iget. If there is a\n\t\t * pending error, then we are done.\n\t\t */\ndel_cursor:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\txfs_buf_relse(agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Now format all the good inodes into the user's buffer. The\n\t\t * call to xfs_bulkstat_ag_ichunk() sets up the agino pointer\n\t\t * for the next loop iteration.\n\t\t */\n\t\tirbufend = irbp;\n\t\tfor (irbp = irbuf;\n\t\t     irbp < irbufend && ac.ac_ubleft >= statstruct_size;\n\t\t     irbp++) {\n\t\t\terror = xfs_bulkstat_ag_ichunk(mp, agno, irbp,\n\t\t\t\t\tformatter, statstruct_size, &ac,\n\t\t\t\t\t&agino);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * If we've run out of space or had a formatting error, we\n\t\t * are now done\n\t\t */\n\t\tif (ac.ac_ubleft < statstruct_size || error)\n\t\t\tbreak;\n\n\t\tif (end_of_ag) {\n\t\t\tagno++;\n\t\t\tagino = 0;\n\t\t}\n\t}\n\t/*\n\t * Done, we're either out of filesystem or space to put the data.\n\t */\n\tkmem_free(irbuf);\n\t*ubcountp = ac.ac_ubelem;\n\n\t/*\n\t * We found some inodes, so clear the error status and return them.\n\t * The lastino pointer will point directly at the inode that triggered\n\t * any error that occurred, so on the next call the error will be\n\t * triggered again and propagated to userspace as there will be no\n\t * formatted inodes in the buffer.\n\t */\n\tif (ac.ac_ubelem)\n\t\terror = 0;\n\n\t/*\n\t * If we ran out of filesystem, lastino will point off the end of\n\t * the filesystem so the next call will return immediately.\n\t */\n\t*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);\n\tif (agno >= mp->m_sb.sb_agcount)\n\t\t*done = 1;\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error status */\nxfs_bulkstat(\n\txfs_mount_t\t\t*mp,\t/* mount point for filesystem */\n\txfs_ino_t\t\t*lastinop, /* last inode returned */\n\tint\t\t\t*ubcountp, /* size of buffer/count returned */\n\tbulkstat_one_pf\t\tformatter, /* func that'd fill a single buf */\n\tsize_t\t\t\tstatstruct_size, /* sizeof struct filling */\n\tchar\t\t\t__user *ubuffer, /* buffer with inode stats */\n\tint\t\t\t*done)\t/* 1 if there are more stats to get */\n{\n\txfs_buf_t\t\t*agbp;\t/* agi header buffer */\n\txfs_agino_t\t\tagino;\t/* inode # in allocation group */\n\txfs_agnumber_t\t\tagno;\t/* allocation group number */\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor for ialloc btree */\n\tsize_t\t\t\tirbsize; /* size of irec buffer in bytes */\n\txfs_inobt_rec_incore_t\t*irbuf;\t/* start of irec buffer */\n\tint\t\t\tnirbuf;\t/* size of irbuf */\n\tint\t\t\tubcount; /* size of user's buffer */\n\tstruct xfs_bulkstat_agichunk ac;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Get the last inode value, see if there's nothing to do.\n\t */\n\tagno = XFS_INO_TO_AGNO(mp, *lastinop);\n\tagino = XFS_INO_TO_AGINO(mp, *lastinop);\n\tif (agno >= mp->m_sb.sb_agcount ||\n\t    *lastinop != XFS_AGINO_TO_INO(mp, agno, agino)) {\n\t\t*done = 1;\n\t\t*ubcountp = 0;\n\t\treturn 0;\n\t}\n\n\tubcount = *ubcountp; /* statstruct's */\n\tac.ac_ubuffer = &ubuffer;\n\tac.ac_ubleft = ubcount * statstruct_size; /* bytes */;\n\tac.ac_ubelem = 0;\n\n\t*ubcountp = 0;\n\t*done = 0;\n\n\tirbuf = kmem_zalloc_greedy(&irbsize, PAGE_SIZE, PAGE_SIZE * 4);\n\tif (!irbuf)\n\t\treturn -ENOMEM;\n\n\tnirbuf = irbsize / sizeof(*irbuf);\n\n\t/*\n\t * Loop over the allocation groups, starting from the last\n\t * inode returned; 0 means start of the allocation group.\n\t */\n\twhile (agno < mp->m_sb.sb_agcount) {\n\t\tstruct xfs_inobt_rec_incore\t*irbp = irbuf;\n\t\tstruct xfs_inobt_rec_incore\t*irbufend = irbuf + nirbuf;\n\t\tbool\t\t\t\tend_of_ag = false;\n\t\tint\t\t\t\ticount = 0;\n\t\tint\t\t\t\tstat;\n\n\t\terror = xfs_ialloc_read_agi(mp, NULL, agno, &agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Allocate and initialize a btree cursor for ialloc btree.\n\t\t */\n\t\tcur = xfs_inobt_init_cursor(mp, NULL, agbp, agno,\n\t\t\t\t\t    XFS_BTNUM_INO);\n\t\tif (agino > 0) {\n\t\t\t/*\n\t\t\t * In the middle of an allocation group, we need to get\n\t\t\t * the remainder of the chunk we're in.\n\t\t\t */\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_bulkstat_grab_ichunk(cur, agino, &icount, &r);\n\t\t\tif (error)\n\t\t\t\tgoto del_cursor;\n\t\t\tif (icount) {\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t}\n\t\t\t/* Increment to the next record */\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t} else {\n\t\t\t/* Start of ag.  Lookup the first inode chunk */\n\t\t\terror = xfs_inobt_lookup(cur, 0, XFS_LOOKUP_GE, &stat);\n\t\t}\n\t\tif (error || stat == 0) {\n\t\t\tend_of_ag = true;\n\t\t\tgoto del_cursor;\n\t\t}\n\n\t\t/*\n\t\t * Loop through inode btree records in this ag,\n\t\t * until we run out of inodes or space in the buffer.\n\t\t */\n\t\twhile (irbp < irbufend && icount < ubcount) {\n\t\t\tstruct xfs_inobt_rec_incore\tr;\n\n\t\t\terror = xfs_inobt_get_rec(cur, &r, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If this chunk has any allocated inodes, save it.\n\t\t\t * Also start read-ahead now for this chunk.\n\t\t\t */\n\t\t\tif (r.ir_freecount < XFS_INODES_PER_CHUNK) {\n\t\t\t\txfs_bulkstat_ichunk_ra(mp, agno, &r);\n\t\t\t\tirbp->ir_startino = r.ir_startino;\n\t\t\t\tirbp->ir_freecount = r.ir_freecount;\n\t\t\t\tirbp->ir_free = r.ir_free;\n\t\t\t\tirbp++;\n\t\t\t\ticount += XFS_INODES_PER_CHUNK - r.ir_freecount;\n\t\t\t}\n\t\t\terror = xfs_btree_increment(cur, 0, &stat);\n\t\t\tif (error || stat == 0) {\n\t\t\t\tend_of_ag = true;\n\t\t\t\tgoto del_cursor;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Drop the btree buffers and the agi buffer as we can't hold any\n\t\t * of the locks these represent when calling iget. If there is a\n\t\t * pending error, then we are done.\n\t\t */\ndel_cursor:\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\txfs_buf_relse(agbp);\n\t\tif (error)\n\t\t\tbreak;\n\t\t/*\n\t\t * Now format all the good inodes into the user's buffer. The\n\t\t * call to xfs_bulkstat_ag_ichunk() sets up the agino pointer\n\t\t * for the next loop iteration.\n\t\t */\n\t\tirbufend = irbp;\n\t\tfor (irbp = irbuf;\n\t\t     irbp < irbufend && ac.ac_ubleft >= statstruct_size;\n\t\t     irbp++) {\n\t\t\terror = xfs_bulkstat_ag_ichunk(mp, agno, irbp,\n\t\t\t\t\tformatter, statstruct_size, &ac,\n\t\t\t\t\t&agino);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * If we've run out of space or had a formatting error, we\n\t\t * are now done\n\t\t */\n\t\tif (ac.ac_ubleft < statstruct_size || error)\n\t\t\tbreak;\n\n\t\tif (end_of_ag) {\n\t\t\tagno++;\n\t\t\tagino = 0;\n\t\t}\n\t}\n\t/*\n\t * Done, we're either out of filesystem or space to put the data.\n\t */\n\tkmem_free(irbuf);\n\t*ubcountp = ac.ac_ubelem;\n\n\t/*\n\t * We found some inodes, so clear the error status and return them.\n\t * The lastino pointer will point directly at the inode that triggered\n\t * any error that occurred, so on the next call the error will be\n\t * triggered again and propagated to userspace as there will be no\n\t * formatted inodes in the buffer.\n\t */\n\tif (ac.ac_ubelem)\n\t\terror = 0;\n\n\t/*\n\t * If we ran out of filesystem, lastino will point off the end of\n\t * the filesystem so the next call will return immediately.\n\t */\n\t*lastinop = XFS_AGINO_TO_INO(mp, agno, agino);\n\tif (agno >= mp->m_sb.sb_agcount)\n\t\t*done = 1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqiterate",
          "args": [
            "mp",
            "pip",
            "XFS_QMOPT_PQUOTA",
            "&buffer_list"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqiterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "934-1023",
          "snippet": "STATIC int\nxfs_qm_dqiterate(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*qip,\n\tuint\t\t\tflags,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_bmbt_irec\t*map;\n\tint\t\t\ti, nmaps;\t/* number of map entries */\n\tint\t\t\terror;\t\t/* return value */\n\txfs_fileoff_t\t\tlblkno;\n\txfs_filblks_t\t\tmaxlblkcnt;\n\txfs_dqid_t\t\tfirstid;\n\txfs_fsblock_t\t\trablkno;\n\txfs_filblks_t\t\trablkcnt;\n\n\terror = 0;\n\t/*\n\t * This looks racy, but we can't keep an inode lock across a\n\t * trans_reserve. But, this gets called during quotacheck, and that\n\t * happens only at mount time which is single threaded.\n\t */\n\tif (qip->i_d.di_nblocks == 0)\n\t\treturn 0;\n\n\tmap = kmem_alloc(XFS_DQITER_MAP_SIZE * sizeof(*map), KM_SLEEP);\n\n\tlblkno = 0;\n\tmaxlblkcnt = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tdo {\n\t\tuint\t\tlock_mode;\n\n\t\tnmaps = XFS_DQITER_MAP_SIZE;\n\t\t/*\n\t\t * We aren't changing the inode itself. Just changing\n\t\t * some of its data. No new blocks are added here, and\n\t\t * the inode is never added to the transaction.\n\t\t */\n\t\tlock_mode = xfs_ilock_data_map_shared(qip);\n\t\terror = xfs_bmapi_read(qip, lblkno, maxlblkcnt - lblkno,\n\t\t\t\t       map, &nmaps, 0);\n\t\txfs_iunlock(qip, lock_mode);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(nmaps <= XFS_DQITER_MAP_SIZE);\n\t\tfor (i = 0; i < nmaps; i++) {\n\t\t\tASSERT(map[i].br_startblock != DELAYSTARTBLOCK);\n\t\t\tASSERT(map[i].br_blockcount);\n\n\n\t\t\tlblkno += map[i].br_blockcount;\n\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tcontinue;\n\n\t\t\tfirstid = (xfs_dqid_t) map[i].br_startoff *\n\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\t/*\n\t\t\t * Do a read-ahead on the next extent.\n\t\t\t */\n\t\t\tif ((i+1 < nmaps) &&\n\t\t\t    (map[i+1].br_startblock != HOLESTARTBLOCK)) {\n\t\t\t\trablkcnt =  map[i+1].br_blockcount;\n\t\t\t\trablkno = map[i+1].br_startblock;\n\t\t\t\twhile (rablkcnt--) {\n\t\t\t\t\txfs_buf_readahead(mp->m_ddev_targp,\n\t\t\t\t\t       XFS_FSB_TO_DADDR(mp, rablkno),\n\t\t\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t       &xfs_dquot_buf_ops);\n\t\t\t\t\trablkno++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Iterate thru all the blks in the extent and\n\t\t\t * reset the counters of all the dquots inside them.\n\t\t\t */\n\t\t\terror = xfs_qm_dqiter_bufs(mp, firstid,\n\t\t\t\t\t\t   map[i].br_startblock,\n\t\t\t\t\t\t   map[i].br_blockcount,\n\t\t\t\t\t\t   flags, buffer_list);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t} while (nmaps > 0);\n\nout:\n\tkmem_free(map);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqiterate(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*qip,\n\tuint\t\t\tflags,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_bmbt_irec\t*map;\n\tint\t\t\ti, nmaps;\t/* number of map entries */\n\tint\t\t\terror;\t\t/* return value */\n\txfs_fileoff_t\t\tlblkno;\n\txfs_filblks_t\t\tmaxlblkcnt;\n\txfs_dqid_t\t\tfirstid;\n\txfs_fsblock_t\t\trablkno;\n\txfs_filblks_t\t\trablkcnt;\n\n\terror = 0;\n\t/*\n\t * This looks racy, but we can't keep an inode lock across a\n\t * trans_reserve. But, this gets called during quotacheck, and that\n\t * happens only at mount time which is single threaded.\n\t */\n\tif (qip->i_d.di_nblocks == 0)\n\t\treturn 0;\n\n\tmap = kmem_alloc(XFS_DQITER_MAP_SIZE * sizeof(*map), KM_SLEEP);\n\n\tlblkno = 0;\n\tmaxlblkcnt = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tdo {\n\t\tuint\t\tlock_mode;\n\n\t\tnmaps = XFS_DQITER_MAP_SIZE;\n\t\t/*\n\t\t * We aren't changing the inode itself. Just changing\n\t\t * some of its data. No new blocks are added here, and\n\t\t * the inode is never added to the transaction.\n\t\t */\n\t\tlock_mode = xfs_ilock_data_map_shared(qip);\n\t\terror = xfs_bmapi_read(qip, lblkno, maxlblkcnt - lblkno,\n\t\t\t\t       map, &nmaps, 0);\n\t\txfs_iunlock(qip, lock_mode);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(nmaps <= XFS_DQITER_MAP_SIZE);\n\t\tfor (i = 0; i < nmaps; i++) {\n\t\t\tASSERT(map[i].br_startblock != DELAYSTARTBLOCK);\n\t\t\tASSERT(map[i].br_blockcount);\n\n\n\t\t\tlblkno += map[i].br_blockcount;\n\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tcontinue;\n\n\t\t\tfirstid = (xfs_dqid_t) map[i].br_startoff *\n\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\t/*\n\t\t\t * Do a read-ahead on the next extent.\n\t\t\t */\n\t\t\tif ((i+1 < nmaps) &&\n\t\t\t    (map[i+1].br_startblock != HOLESTARTBLOCK)) {\n\t\t\t\trablkcnt =  map[i+1].br_blockcount;\n\t\t\t\trablkno = map[i+1].br_startblock;\n\t\t\t\twhile (rablkcnt--) {\n\t\t\t\t\txfs_buf_readahead(mp->m_ddev_targp,\n\t\t\t\t\t       XFS_FSB_TO_DADDR(mp, rablkno),\n\t\t\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t       &xfs_dquot_buf_ops);\n\t\t\t\t\trablkno++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Iterate thru all the blks in the extent and\n\t\t\t * reset the counters of all the dquots inside them.\n\t\t\t */\n\t\t\terror = xfs_qm_dqiter_bufs(mp, firstid,\n\t\t\t\t\t\t   map[i].br_startblock,\n\t\t\t\t\t\t   map[i].br_blockcount,\n\t\t\t\t\t\t   flags, buffer_list);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t} while (nmaps > 0);\n\nout:\n\tkmem_free(map);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"Quotacheck needed: Please wait.\""
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(mp)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "uip || gip || pip"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "buffer_list"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC int\nxfs_qm_quotacheck(\n\txfs_mount_t\t*mp)\n{\n\tint\t\t\tdone, count, error, error2;\n\txfs_ino_t\t\tlastino;\n\tsize_t\t\t\tstructsz;\n\tuint\t\t\tflags;\n\tLIST_HEAD\t\t(buffer_list);\n\tstruct xfs_inode\t*uip = mp->m_quotainfo->qi_uquotaip;\n\tstruct xfs_inode\t*gip = mp->m_quotainfo->qi_gquotaip;\n\tstruct xfs_inode\t*pip = mp->m_quotainfo->qi_pquotaip;\n\n\tcount = INT_MAX;\n\tstructsz = 1;\n\tlastino = 0;\n\tflags = 0;\n\n\tASSERT(uip || gip || pip);\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\txfs_notice(mp, \"Quotacheck needed: Please wait.\");\n\n\t/*\n\t * First we go thru all the dquots on disk, USR and GRP/PRJ, and reset\n\t * their counters to zero. We need a clean slate.\n\t * We don't log our changes till later.\n\t */\n\tif (uip) {\n\t\terror = xfs_qm_dqiterate(mp, uip, XFS_QMOPT_UQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_UQUOTA_CHKD;\n\t}\n\n\tif (gip) {\n\t\terror = xfs_qm_dqiterate(mp, gip, XFS_QMOPT_GQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_GQUOTA_CHKD;\n\t}\n\n\tif (pip) {\n\t\terror = xfs_qm_dqiterate(mp, pip, XFS_QMOPT_PQUOTA,\n\t\t\t\t\t &buffer_list);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t\tflags |= XFS_PQUOTA_CHKD;\n\t}\n\n\tdo {\n\t\t/*\n\t\t * Iterate thru all the inodes in the file system,\n\t\t * adjusting the corresponding dquot counters in core.\n\t\t */\n\t\terror = xfs_bulkstat(mp, &lastino, &count,\n\t\t\t\t     xfs_qm_dqusage_adjust,\n\t\t\t\t     structsz, NULL, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t} while (!done);\n\n\t/*\n\t * We've made all the changes that we need to make incore.  Flush them\n\t * down to disk buffers if everything was updated successfully.\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp)) {\n\t\terror = xfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_flush_one,\n\t\t\t\t\t  &buffer_list);\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\terror2 = xfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_flush_one,\n\t\t\t\t\t   &buffer_list);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\terror2 = xfs_buf_delwri_submit(&buffer_list);\n\tif (!error)\n\t\terror = error2;\n\n\t/*\n\t * We can get this error if we couldn't do a dquot allocation inside\n\t * xfs_qm_dqusage_adjust (via bulkstat). We don't care about the\n\t * dirty dquots that might be cached, we just want to get rid of them\n\t * and turn quotaoff. The dquots won't be attached to any of the inodes\n\t * at this point (because we intentionally didn't in dqget_noattach).\n\t */\n\tif (error) {\n\t\txfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * If one type of quotas is off, then it will lose its\n\t * quotachecked status, since we won't be doing accounting for\n\t * that type anymore.\n\t */\n\tmp->m_qflags &= ~XFS_ALL_QUOTA_CHKD;\n\tmp->m_qflags |= flags;\n\n error_return:\n\twhile (!list_empty(&buffer_list)) {\n\t\tstruct xfs_buf *bp =\n\t\t\tlist_first_entry(&buffer_list, struct xfs_buf, b_list);\n\t\tlist_del_init(&bp->b_list);\n\t\txfs_buf_relse(bp);\n\t}\n\n\tif (error) {\n\t\txfs_warn(mp,\n\t\"Quotacheck: Unsuccessful (Error %d): Disabling quotas.\",\n\t\t\terror);\n\t\t/*\n\t\t * We must turn off quotas.\n\t\t */\n\t\tASSERT(mp->m_quotainfo != NULL);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\tif (xfs_mount_reset_sbqflags(mp)) {\n\t\t\txfs_warn(mp,\n\t\t\t\t\"Quotacheck: Failed to reset quota flags.\");\n\t\t}\n\t} else\n\t\txfs_notice(mp, \"Quotacheck: Done.\");\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_flush_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1212-1237",
    "snippet": "STATIC int\nxfs_qm_flush_one(\n\tstruct xfs_dquot\t*dqp,\n\tvoid\t\t\t*data)\n{\n\tstruct list_head\t*buffer_list = data;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tint\t\t\terror = 0;\n\n\txfs_dqlock(dqp);\n\tif (dqp->dq_flags & XFS_DQ_FREEING)\n\t\tgoto out_unlock;\n\tif (!XFS_DQ_IS_DIRTY(dqp))\n\t\tgoto out_unlock;\n\n\txfs_dqflock(dqp);\n\terror = xfs_qm_dqflush(dqp, &bp);\n\tif (error)\n\t\tgoto out_unlock;\n\n\txfs_buf_delwri_queue(bp, buffer_list);\n\txfs_buf_relse(bp);\nout_unlock:\n\txfs_dqunlock(dqp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqflush",
          "args": [
            "dqp",
            "&bp"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "930-1048",
          "snippet": "int\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqflock",
          "args": [
            "dqp"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqflock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "89-92",
          "snippet": "static inline bool xfs_dqflock_nowait(xfs_dquot_t *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool xfs_dqflock_nowait(xfs_dquot_t *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_DIRTY",
          "args": [
            "dqp"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqlock",
          "args": [
            "dqp"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "104-107",
          "snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_flush_one(\n\tstruct xfs_dquot\t*dqp,\n\tvoid\t\t\t*data)\n{\n\tstruct list_head\t*buffer_list = data;\n\tstruct xfs_buf\t\t*bp = NULL;\n\tint\t\t\terror = 0;\n\n\txfs_dqlock(dqp);\n\tif (dqp->dq_flags & XFS_DQ_FREEING)\n\t\tgoto out_unlock;\n\tif (!XFS_DQ_IS_DIRTY(dqp))\n\t\tgoto out_unlock;\n\n\txfs_dqflock(dqp);\n\terror = xfs_qm_dqflush(dqp, &bp);\n\tif (error)\n\t\tgoto out_unlock;\n\n\txfs_buf_delwri_queue(bp, buffer_list);\n\txfs_buf_relse(bp);\nout_unlock:\n\txfs_dqunlock(dqp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_dqusage_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1118-1210",
    "snippet": "STATIC int\nxfs_qm_dqusage_adjust(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* not used */\n\tint\t\tubsize,\t\t/* not used */\n\tint\t\t*ubused,\t/* not used */\n\tint\t\t*res)\t\t/* result code value */\n{\n\txfs_inode_t\t*ip;\n\txfs_qcnt_t\tnblks, rtblks = 0;\n\tint\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * rootino must have its resources accounted for, not so with the quota\n\t * inodes.\n\t */\n\tif (xfs_is_quota_inode(&mp->m_sb, ino)) {\n\t\t*res = BULKSTAT_RV_NOTHING;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * We don't _need_ to take the ilock EXCL. However, the xfs_qm_dqget\n\t * interface expects the inode to be exclusively locked because that's\n\t * the case in all other instances. It's OK that we do this because\n\t * quotacheck is done only at mount time.\n\t */\n\terror = xfs_iget(mp, NULL, ino, 0, XFS_ILOCK_EXCL, &ip);\n\tif (error) {\n\t\t*res = BULKSTAT_RV_NOTHING;\n\t\treturn error;\n\t}\n\n\tASSERT(ip->i_delayed_blks == 0);\n\n\tif (XFS_IS_REALTIME_INODE(ip)) {\n\t\t/*\n\t\t * Walk thru the extent list and count the realtime blocks.\n\t\t */\n\t\terror = xfs_qm_get_rtblks(ip, &rtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tnblks = (xfs_qcnt_t)ip->i_d.di_nblocks - rtblks;\n\n\t/*\n\t * Add the (disk blocks and inode) resources occupied by this\n\t * inode to its dquots. We do this adjustment in the incore dquot,\n\t * and also copy the changes to its buffer.\n\t * We don't care about putting these changes in a transaction\n\t * envelope because if we crash in the middle of a 'quotacheck'\n\t * we have to start from the beginning anyway.\n\t * Once we're done, we'll log all the dquot bufs.\n\t *\n\t * The *QUOTA_ON checks below may look pretty racy, but quotachecks\n\t * and quotaoffs don't race. (Quotachecks happen at mount time only).\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, ip->i_d.di_uid,\n\t\t\t\t\t\t   XFS_DQ_USER, nblks, rtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, ip->i_d.di_gid,\n\t\t\t\t\t\t   XFS_DQ_GROUP, nblks, rtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, xfs_get_projid(ip),\n\t\t\t\t\t\t   XFS_DQ_PROJ, nblks, rtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tIRELE(ip);\n\t*res = BULKSTAT_RV_DIDONE;\n\treturn 0;\n\nerror0:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tIRELE(ip);\n\t*res = BULKSTAT_RV_GIVEUP;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_quotacheck_dqadjust",
          "args": [
            "ip",
            "xfs_get_projid(ip)",
            "XFS_DQ_PROJ",
            "nblks",
            "rtblks"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_quotacheck_dqadjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1033-1086",
          "snippet": "STATIC int\nxfs_qm_quotacheck_dqadjust(\n\tstruct xfs_inode\t*ip,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\txfs_qcnt_t\t\tnblks,\n\txfs_qcnt_t\t\trtblks)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget(mp, ip, id, type,\n\t\t\t     XFS_QMOPT_DQALLOC | XFS_QMOPT_DOWARN, &dqp);\n\tif (error) {\n\t\t/*\n\t\t * Shouldn't be able to turn off quotas here.\n\t\t */\n\t\tASSERT(error != -ESRCH);\n\t\tASSERT(error != -ENOENT);\n\t\treturn error;\n\t}\n\n\ttrace_xfs_dqadjust(dqp);\n\n\t/*\n\t * Adjust the inode count and the block count to reflect this inode's\n\t * resource usage.\n\t */\n\tbe64_add_cpu(&dqp->q_core.d_icount, 1);\n\tdqp->q_res_icount++;\n\tif (nblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_bcount, nblks);\n\t\tdqp->q_res_bcount += nblks;\n\t}\n\tif (rtblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_rtbcount, rtblks);\n\t\tdqp->q_res_rtbcount += rtblks;\n\t}\n\n\t/*\n\t * Set default limits, adjust timers (since we changed usages)\n\t *\n\t * There are no timers for the default values set in the root dquot.\n\t */\n\tif (dqp->q_core.d_id) {\n\t\txfs_qm_adjust_dqlimits(mp, dqp);\n\t\txfs_qm_adjust_dqtimers(mp, &dqp->q_core);\n\t}\n\n\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\txfs_qm_dqput(dqp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_quotacheck_dqadjust(\n\tstruct xfs_inode\t*ip,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\txfs_qcnt_t\t\tnblks,\n\txfs_qcnt_t\t\trtblks)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget(mp, ip, id, type,\n\t\t\t     XFS_QMOPT_DQALLOC | XFS_QMOPT_DOWARN, &dqp);\n\tif (error) {\n\t\t/*\n\t\t * Shouldn't be able to turn off quotas here.\n\t\t */\n\t\tASSERT(error != -ESRCH);\n\t\tASSERT(error != -ENOENT);\n\t\treturn error;\n\t}\n\n\ttrace_xfs_dqadjust(dqp);\n\n\t/*\n\t * Adjust the inode count and the block count to reflect this inode's\n\t * resource usage.\n\t */\n\tbe64_add_cpu(&dqp->q_core.d_icount, 1);\n\tdqp->q_res_icount++;\n\tif (nblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_bcount, nblks);\n\t\tdqp->q_res_bcount += nblks;\n\t}\n\tif (rtblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_rtbcount, rtblks);\n\t\tdqp->q_res_rtbcount += rtblks;\n\t}\n\n\t/*\n\t * Set default limits, adjust timers (since we changed usages)\n\t *\n\t * There are no timers for the default values set in the root dquot.\n\t */\n\tif (dqp->q_core.d_id) {\n\t\txfs_qm_adjust_dqlimits(mp, dqp);\n\t\txfs_qm_adjust_dqtimers(mp, &dqp->q_core);\n\t}\n\n\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\txfs_qm_dqput(dqp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_get_rtblks",
          "args": [
            "ip",
            "&rtblks"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_get_rtblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1088-1111",
          "snippet": "STATIC int\nxfs_qm_get_rtblks(\n\txfs_inode_t\t*ip,\n\txfs_qcnt_t\t*O_rtblks)\n{\n\txfs_filblks_t\trtblks;\t\t\t/* total rt blks */\n\txfs_extnum_t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\tint\t\terror;\n\n\tASSERT(XFS_IS_REALTIME_INODE(ip));\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\tif ((error = xfs_iread_extents(NULL, ip, XFS_DATA_FORK)))\n\t\t\treturn error;\n\t}\n\trtblks = 0;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0; idx < nextents; idx++)\n\t\trtblks += xfs_bmbt_get_blockcount(xfs_iext_get_ext(ifp, idx));\n\t*O_rtblks = (xfs_qcnt_t)rtblks;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_get_rtblks(\n\txfs_inode_t\t*ip,\n\txfs_qcnt_t\t*O_rtblks)\n{\n\txfs_filblks_t\trtblks;\t\t\t/* total rt blks */\n\txfs_extnum_t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\tint\t\terror;\n\n\tASSERT(XFS_IS_REALTIME_INODE(ip));\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\tif ((error = xfs_iread_extents(NULL, ip, XFS_DATA_FORK)))\n\t\t\treturn error;\n\t}\n\trtblks = 0;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0; idx < nextents; idx++)\n\t\trtblks += xfs_bmbt_get_blockcount(xfs_iext_get_ext(ifp, idx));\n\t*O_rtblks = (xfs_qcnt_t)rtblks;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_delayed_blks == 0"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "ino",
            "0",
            "XFS_ILOCK_EXCL",
            "&ip"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_is_quota_inode",
          "args": [
            "&mp->m_sb",
            "ino"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_is_quota_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "575-581",
          "snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(mp)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC int\nxfs_qm_dqusage_adjust(\n\txfs_mount_t\t*mp,\t\t/* mount point for filesystem */\n\txfs_ino_t\tino,\t\t/* inode number to get data for */\n\tvoid\t\t__user *buffer,\t/* not used */\n\tint\t\tubsize,\t\t/* not used */\n\tint\t\t*ubused,\t/* not used */\n\tint\t\t*res)\t\t/* result code value */\n{\n\txfs_inode_t\t*ip;\n\txfs_qcnt_t\tnblks, rtblks = 0;\n\tint\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\t/*\n\t * rootino must have its resources accounted for, not so with the quota\n\t * inodes.\n\t */\n\tif (xfs_is_quota_inode(&mp->m_sb, ino)) {\n\t\t*res = BULKSTAT_RV_NOTHING;\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * We don't _need_ to take the ilock EXCL. However, the xfs_qm_dqget\n\t * interface expects the inode to be exclusively locked because that's\n\t * the case in all other instances. It's OK that we do this because\n\t * quotacheck is done only at mount time.\n\t */\n\terror = xfs_iget(mp, NULL, ino, 0, XFS_ILOCK_EXCL, &ip);\n\tif (error) {\n\t\t*res = BULKSTAT_RV_NOTHING;\n\t\treturn error;\n\t}\n\n\tASSERT(ip->i_delayed_blks == 0);\n\n\tif (XFS_IS_REALTIME_INODE(ip)) {\n\t\t/*\n\t\t * Walk thru the extent list and count the realtime blocks.\n\t\t */\n\t\terror = xfs_qm_get_rtblks(ip, &rtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tnblks = (xfs_qcnt_t)ip->i_d.di_nblocks - rtblks;\n\n\t/*\n\t * Add the (disk blocks and inode) resources occupied by this\n\t * inode to its dquots. We do this adjustment in the incore dquot,\n\t * and also copy the changes to its buffer.\n\t * We don't care about putting these changes in a transaction\n\t * envelope because if we crash in the middle of a 'quotacheck'\n\t * we have to start from the beginning anyway.\n\t * Once we're done, we'll log all the dquot bufs.\n\t *\n\t * The *QUOTA_ON checks below may look pretty racy, but quotachecks\n\t * and quotaoffs don't race. (Quotachecks happen at mount time only).\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, ip->i_d.di_uid,\n\t\t\t\t\t\t   XFS_DQ_USER, nblks, rtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, ip->i_d.di_gid,\n\t\t\t\t\t\t   XFS_DQ_GROUP, nblks, rtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp)) {\n\t\terror = xfs_qm_quotacheck_dqadjust(ip, xfs_get_projid(ip),\n\t\t\t\t\t\t   XFS_DQ_PROJ, nblks, rtblks);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tIRELE(ip);\n\t*res = BULKSTAT_RV_DIDONE;\n\treturn 0;\n\nerror0:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tIRELE(ip);\n\t*res = BULKSTAT_RV_GIVEUP;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_get_rtblks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1088-1111",
    "snippet": "STATIC int\nxfs_qm_get_rtblks(\n\txfs_inode_t\t*ip,\n\txfs_qcnt_t\t*O_rtblks)\n{\n\txfs_filblks_t\trtblks;\t\t\t/* total rt blks */\n\txfs_extnum_t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\tint\t\terror;\n\n\tASSERT(XFS_IS_REALTIME_INODE(ip));\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\tif ((error = xfs_iread_extents(NULL, ip, XFS_DATA_FORK)))\n\t\t\treturn error;\n\t}\n\trtblks = 0;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0; idx < nextents; idx++)\n\t\trtblks += xfs_bmbt_get_blockcount(xfs_iext_get_ext(ifp, idx));\n\t*O_rtblks = (xfs_qcnt_t)rtblks;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_blockcount",
          "args": [
            "xfs_iext_get_ext(ifp, idx)"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "134-139",
          "snippet": "xfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "idx"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "NULL",
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_REALTIME_INODE(ip)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_get_rtblks(\n\txfs_inode_t\t*ip,\n\txfs_qcnt_t\t*O_rtblks)\n{\n\txfs_filblks_t\trtblks;\t\t\t/* total rt blks */\n\txfs_extnum_t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\tint\t\terror;\n\n\tASSERT(XFS_IS_REALTIME_INODE(ip));\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\tif ((error = xfs_iread_extents(NULL, ip, XFS_DATA_FORK)))\n\t\t\treturn error;\n\t}\n\trtblks = 0;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0; idx < nextents; idx++)\n\t\trtblks += xfs_bmbt_get_blockcount(xfs_iext_get_ext(ifp, idx));\n\t*O_rtblks = (xfs_qcnt_t)rtblks;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_quotacheck_dqadjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "1033-1086",
    "snippet": "STATIC int\nxfs_qm_quotacheck_dqadjust(\n\tstruct xfs_inode\t*ip,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\txfs_qcnt_t\t\tnblks,\n\txfs_qcnt_t\t\trtblks)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget(mp, ip, id, type,\n\t\t\t     XFS_QMOPT_DQALLOC | XFS_QMOPT_DOWARN, &dqp);\n\tif (error) {\n\t\t/*\n\t\t * Shouldn't be able to turn off quotas here.\n\t\t */\n\t\tASSERT(error != -ESRCH);\n\t\tASSERT(error != -ENOENT);\n\t\treturn error;\n\t}\n\n\ttrace_xfs_dqadjust(dqp);\n\n\t/*\n\t * Adjust the inode count and the block count to reflect this inode's\n\t * resource usage.\n\t */\n\tbe64_add_cpu(&dqp->q_core.d_icount, 1);\n\tdqp->q_res_icount++;\n\tif (nblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_bcount, nblks);\n\t\tdqp->q_res_bcount += nblks;\n\t}\n\tif (rtblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_rtbcount, rtblks);\n\t\tdqp->q_res_rtbcount += rtblks;\n\t}\n\n\t/*\n\t * Set default limits, adjust timers (since we changed usages)\n\t *\n\t * There are no timers for the default values set in the root dquot.\n\t */\n\tif (dqp->q_core.d_id) {\n\t\txfs_qm_adjust_dqlimits(mp, dqp);\n\t\txfs_qm_adjust_dqtimers(mp, &dqp->q_core);\n\t}\n\n\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\txfs_qm_dqput(dqp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqput",
          "args": [
            "dqp"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "839-856",
          "snippet": "void\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqput(\n\tstruct xfs_dquot\t*dqp)\n{\n\tASSERT(dqp->q_nrefs > 0);\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\n\ttrace_xfs_dqput(dqp);\n\n\tif (--dqp->q_nrefs == 0) {\n\t\tstruct xfs_quotainfo\t*qi = dqp->q_mount->m_quotainfo;\n\t\ttrace_xfs_dqput_free(dqp);\n\n\t\tif (list_lru_add(&qi->qi_lru, &dqp->q_lru))\n\t\t\tXFS_STATS_INC(xs_qm_dquot_unused);\n\t}\n\txfs_dqunlock(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_adjust_dqtimers",
          "args": [
            "mp",
            "&dqp->q_core"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_adjust_dqtimers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "133-220",
          "snippet": "void\nxfs_qm_adjust_dqtimers(\n\txfs_mount_t\t\t*mp,\n\txfs_disk_dquot_t\t*d)\n{\n\tASSERT(d->d_id);\n\n#ifdef DEBUG\n\tif (d->d_blk_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit));\n\tif (d->d_ino_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit));\n\tif (d->d_rtb_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit));\n#endif\n\n\tif (!d->d_btimer) {\n\t\tif ((d->d_blk_softlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_softlimit))) ||\n\t\t    (d->d_blk_hardlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit);\n\t\t} else {\n\t\t\td->d_bwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_blk_softlimit ||\n\t\t     (be64_to_cpu(d->d_bcount) <=\n\t\t      be64_to_cpu(d->d_blk_softlimit))) &&\n\t\t    (!d->d_blk_hardlimit ||\n\t\t    (be64_to_cpu(d->d_bcount) <=\n\t\t     be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_itimer) {\n\t\tif ((d->d_ino_softlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_softlimit))) ||\n\t\t    (d->d_ino_hardlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit);\n\t\t} else {\n\t\t\td->d_iwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_ino_softlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_softlimit)))  &&\n\t\t    (!d->d_ino_hardlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_rtbtimer) {\n\t\tif ((d->d_rtb_softlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) ||\n\t\t    (d->d_rtb_hardlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit);\n\t\t} else {\n\t\t\td->d_rtbwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_rtb_softlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) &&\n\t\t    (!d->d_rtb_hardlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_adjust_dqtimers(\n\txfs_mount_t\t\t*mp,\n\txfs_disk_dquot_t\t*d)\n{\n\tASSERT(d->d_id);\n\n#ifdef DEBUG\n\tif (d->d_blk_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_blk_softlimit) <=\n\t\t       be64_to_cpu(d->d_blk_hardlimit));\n\tif (d->d_ino_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_ino_softlimit) <=\n\t\t       be64_to_cpu(d->d_ino_hardlimit));\n\tif (d->d_rtb_hardlimit)\n\t\tASSERT(be64_to_cpu(d->d_rtb_softlimit) <=\n\t\t       be64_to_cpu(d->d_rtb_hardlimit));\n#endif\n\n\tif (!d->d_btimer) {\n\t\tif ((d->d_blk_softlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_softlimit))) ||\n\t\t    (d->d_blk_hardlimit &&\n\t\t     (be64_to_cpu(d->d_bcount) >\n\t\t      be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_btimelimit);\n\t\t} else {\n\t\t\td->d_bwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_blk_softlimit ||\n\t\t     (be64_to_cpu(d->d_bcount) <=\n\t\t      be64_to_cpu(d->d_blk_softlimit))) &&\n\t\t    (!d->d_blk_hardlimit ||\n\t\t    (be64_to_cpu(d->d_bcount) <=\n\t\t     be64_to_cpu(d->d_blk_hardlimit)))) {\n\t\t\td->d_btimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_itimer) {\n\t\tif ((d->d_ino_softlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_softlimit))) ||\n\t\t    (d->d_ino_hardlimit &&\n\t\t     (be64_to_cpu(d->d_icount) >\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_itimelimit);\n\t\t} else {\n\t\t\td->d_iwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_ino_softlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_softlimit)))  &&\n\t\t    (!d->d_ino_hardlimit ||\n\t\t     (be64_to_cpu(d->d_icount) <=\n\t\t      be64_to_cpu(d->d_ino_hardlimit)))) {\n\t\t\td->d_itimer = 0;\n\t\t}\n\t}\n\n\tif (!d->d_rtbtimer) {\n\t\tif ((d->d_rtb_softlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) ||\n\t\t    (d->d_rtb_hardlimit &&\n\t\t     (be64_to_cpu(d->d_rtbcount) >\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = cpu_to_be32(get_seconds() +\n\t\t\t\t\tmp->m_quotainfo->qi_rtbtimelimit);\n\t\t} else {\n\t\t\td->d_rtbwarns = 0;\n\t\t}\n\t} else {\n\t\tif ((!d->d_rtb_softlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_softlimit))) &&\n\t\t    (!d->d_rtb_hardlimit ||\n\t\t     (be64_to_cpu(d->d_rtbcount) <=\n\t\t      be64_to_cpu(d->d_rtb_hardlimit)))) {\n\t\t\td->d_rtbtimer = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_adjust_dqlimits",
          "args": [
            "mp",
            "dqp"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_adjust_dqlimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "88-118",
          "snippet": "void\nxfs_qm_adjust_dqlimits(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dq)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*d = &dq->q_core;\n\tint\t\t\tprealloc = 0;\n\n\tASSERT(d->d_id);\n\n\tif (q->qi_bsoftlimit && !d->d_blk_softlimit) {\n\t\td->d_blk_softlimit = cpu_to_be64(q->qi_bsoftlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_bhardlimit && !d->d_blk_hardlimit) {\n\t\td->d_blk_hardlimit = cpu_to_be64(q->qi_bhardlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_isoftlimit && !d->d_ino_softlimit)\n\t\td->d_ino_softlimit = cpu_to_be64(q->qi_isoftlimit);\n\tif (q->qi_ihardlimit && !d->d_ino_hardlimit)\n\t\td->d_ino_hardlimit = cpu_to_be64(q->qi_ihardlimit);\n\tif (q->qi_rtbsoftlimit && !d->d_rtb_softlimit)\n\t\td->d_rtb_softlimit = cpu_to_be64(q->qi_rtbsoftlimit);\n\tif (q->qi_rtbhardlimit && !d->d_rtb_hardlimit)\n\t\td->d_rtb_hardlimit = cpu_to_be64(q->qi_rtbhardlimit);\n\n\tif (prealloc)\n\t\txfs_dquot_set_prealloc_limits(dq);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_adjust_dqlimits(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*dq)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*d = &dq->q_core;\n\tint\t\t\tprealloc = 0;\n\n\tASSERT(d->d_id);\n\n\tif (q->qi_bsoftlimit && !d->d_blk_softlimit) {\n\t\td->d_blk_softlimit = cpu_to_be64(q->qi_bsoftlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_bhardlimit && !d->d_blk_hardlimit) {\n\t\td->d_blk_hardlimit = cpu_to_be64(q->qi_bhardlimit);\n\t\tprealloc = 1;\n\t}\n\tif (q->qi_isoftlimit && !d->d_ino_softlimit)\n\t\td->d_ino_softlimit = cpu_to_be64(q->qi_isoftlimit);\n\tif (q->qi_ihardlimit && !d->d_ino_hardlimit)\n\t\td->d_ino_hardlimit = cpu_to_be64(q->qi_ihardlimit);\n\tif (q->qi_rtbsoftlimit && !d->d_rtb_softlimit)\n\t\td->d_rtb_softlimit = cpu_to_be64(q->qi_rtbsoftlimit);\n\tif (q->qi_rtbhardlimit && !d->d_rtb_hardlimit)\n\t\td->d_rtb_hardlimit = cpu_to_be64(q->qi_rtbhardlimit);\n\n\tif (prealloc)\n\t\txfs_dquot_set_prealloc_limits(dq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&dqp->q_core.d_rtbcount",
            "rtblks"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&dqp->q_core.d_bcount",
            "nblks"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&dqp->q_core.d_icount",
            "1"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqadjust",
          "args": [
            "dqp"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOENT"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ESRCH"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqget",
          "args": [
            "mp",
            "ip",
            "id",
            "type",
            "XFS_QMOPT_DQALLOC | XFS_QMOPT_DOWARN",
            "&dqp"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "698-831",
          "snippet": "int\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_quotacheck_dqadjust(\n\tstruct xfs_inode\t*ip,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\txfs_qcnt_t\t\tnblks,\n\txfs_qcnt_t\t\trtblks)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\terror = xfs_qm_dqget(mp, ip, id, type,\n\t\t\t     XFS_QMOPT_DQALLOC | XFS_QMOPT_DOWARN, &dqp);\n\tif (error) {\n\t\t/*\n\t\t * Shouldn't be able to turn off quotas here.\n\t\t */\n\t\tASSERT(error != -ESRCH);\n\t\tASSERT(error != -ENOENT);\n\t\treturn error;\n\t}\n\n\ttrace_xfs_dqadjust(dqp);\n\n\t/*\n\t * Adjust the inode count and the block count to reflect this inode's\n\t * resource usage.\n\t */\n\tbe64_add_cpu(&dqp->q_core.d_icount, 1);\n\tdqp->q_res_icount++;\n\tif (nblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_bcount, nblks);\n\t\tdqp->q_res_bcount += nblks;\n\t}\n\tif (rtblks) {\n\t\tbe64_add_cpu(&dqp->q_core.d_rtbcount, rtblks);\n\t\tdqp->q_res_rtbcount += rtblks;\n\t}\n\n\t/*\n\t * Set default limits, adjust timers (since we changed usages)\n\t *\n\t * There are no timers for the default values set in the root dquot.\n\t */\n\tif (dqp->q_core.d_id) {\n\t\txfs_qm_adjust_dqlimits(mp, dqp);\n\t\txfs_qm_adjust_dqtimers(mp, &dqp->q_core);\n\t}\n\n\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\txfs_qm_dqput(dqp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_dqiterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "934-1023",
    "snippet": "STATIC int\nxfs_qm_dqiterate(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*qip,\n\tuint\t\t\tflags,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_bmbt_irec\t*map;\n\tint\t\t\ti, nmaps;\t/* number of map entries */\n\tint\t\t\terror;\t\t/* return value */\n\txfs_fileoff_t\t\tlblkno;\n\txfs_filblks_t\t\tmaxlblkcnt;\n\txfs_dqid_t\t\tfirstid;\n\txfs_fsblock_t\t\trablkno;\n\txfs_filblks_t\t\trablkcnt;\n\n\terror = 0;\n\t/*\n\t * This looks racy, but we can't keep an inode lock across a\n\t * trans_reserve. But, this gets called during quotacheck, and that\n\t * happens only at mount time which is single threaded.\n\t */\n\tif (qip->i_d.di_nblocks == 0)\n\t\treturn 0;\n\n\tmap = kmem_alloc(XFS_DQITER_MAP_SIZE * sizeof(*map), KM_SLEEP);\n\n\tlblkno = 0;\n\tmaxlblkcnt = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tdo {\n\t\tuint\t\tlock_mode;\n\n\t\tnmaps = XFS_DQITER_MAP_SIZE;\n\t\t/*\n\t\t * We aren't changing the inode itself. Just changing\n\t\t * some of its data. No new blocks are added here, and\n\t\t * the inode is never added to the transaction.\n\t\t */\n\t\tlock_mode = xfs_ilock_data_map_shared(qip);\n\t\terror = xfs_bmapi_read(qip, lblkno, maxlblkcnt - lblkno,\n\t\t\t\t       map, &nmaps, 0);\n\t\txfs_iunlock(qip, lock_mode);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(nmaps <= XFS_DQITER_MAP_SIZE);\n\t\tfor (i = 0; i < nmaps; i++) {\n\t\t\tASSERT(map[i].br_startblock != DELAYSTARTBLOCK);\n\t\t\tASSERT(map[i].br_blockcount);\n\n\n\t\t\tlblkno += map[i].br_blockcount;\n\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tcontinue;\n\n\t\t\tfirstid = (xfs_dqid_t) map[i].br_startoff *\n\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\t/*\n\t\t\t * Do a read-ahead on the next extent.\n\t\t\t */\n\t\t\tif ((i+1 < nmaps) &&\n\t\t\t    (map[i+1].br_startblock != HOLESTARTBLOCK)) {\n\t\t\t\trablkcnt =  map[i+1].br_blockcount;\n\t\t\t\trablkno = map[i+1].br_startblock;\n\t\t\t\twhile (rablkcnt--) {\n\t\t\t\t\txfs_buf_readahead(mp->m_ddev_targp,\n\t\t\t\t\t       XFS_FSB_TO_DADDR(mp, rablkno),\n\t\t\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t       &xfs_dquot_buf_ops);\n\t\t\t\t\trablkno++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Iterate thru all the blks in the extent and\n\t\t\t * reset the counters of all the dquots inside them.\n\t\t\t */\n\t\t\terror = xfs_qm_dqiter_bufs(mp, firstid,\n\t\t\t\t\t\t   map[i].br_startblock,\n\t\t\t\t\t\t   map[i].br_blockcount,\n\t\t\t\t\t\t   flags, buffer_list);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t} while (nmaps > 0);\n\nout:\n\tkmem_free(map);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "map"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqiter_bufs",
          "args": [
            "mp",
            "firstid",
            "map[i].br_startblock",
            "map[i].br_blockcount",
            "flags",
            "buffer_list"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqiter_bufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "862-928",
          "snippet": "STATIC int\nxfs_qm_dqiter_bufs(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tfirstid,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tblkcnt,\n\tuint\t\t\tflags,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ttype;\n\n\tASSERT(blkcnt > 0);\n\ttype = flags & XFS_QMOPT_UQUOTA ? XFS_DQ_USER :\n\t\t(flags & XFS_QMOPT_PQUOTA ? XFS_DQ_PROJ : XFS_DQ_GROUP);\n\terror = 0;\n\n\t/*\n\t * Blkcnt arg can be a very big number, and might even be\n\t * larger than the log itself. So, we have to break it up into\n\t * manageable-sized transactions.\n\t * Note that we don't start a permanent transaction here; we might\n\t * not be able to get a log reservation for the whole thing up front,\n\t * and we don't really care to either, because we just discard\n\t * everything if we were to crash in the middle of this loop.\n\t */\n\twhile (blkcnt--) {\n\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t      &xfs_dquot_buf_ops);\n\n\t\t/*\n\t\t * CRC and validation errors will return a EFSCORRUPTED here. If\n\t\t * this occurs, re-read without CRC validation so that we can\n\t\t * repair the damage via xfs_qm_reset_dqcounts(). This process\n\t\t * will leave a trace in the log indicating corruption has\n\t\t * been detected.\n\t\t */\n\t\tif (error == -EFSCORRUPTED) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t      NULL);\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * A corrupt buffer might not have a verifier attached, so\n\t\t * make sure we have the correct one attached before writeback\n\t\t * occurs.\n\t\t */\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n\t\txfs_qm_reset_dqcounts(mp, bp, firstid, type);\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\txfs_buf_relse(bp);\n\n\t\t/* goto the next block. */\n\t\tbno++;\n\t\tfirstid += mp->m_quotainfo->qi_dqperchunk;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqiter_bufs(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tfirstid,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tblkcnt,\n\tuint\t\t\tflags,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ttype;\n\n\tASSERT(blkcnt > 0);\n\ttype = flags & XFS_QMOPT_UQUOTA ? XFS_DQ_USER :\n\t\t(flags & XFS_QMOPT_PQUOTA ? XFS_DQ_PROJ : XFS_DQ_GROUP);\n\terror = 0;\n\n\t/*\n\t * Blkcnt arg can be a very big number, and might even be\n\t * larger than the log itself. So, we have to break it up into\n\t * manageable-sized transactions.\n\t * Note that we don't start a permanent transaction here; we might\n\t * not be able to get a log reservation for the whole thing up front,\n\t * and we don't really care to either, because we just discard\n\t * everything if we were to crash in the middle of this loop.\n\t */\n\twhile (blkcnt--) {\n\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t      &xfs_dquot_buf_ops);\n\n\t\t/*\n\t\t * CRC and validation errors will return a EFSCORRUPTED here. If\n\t\t * this occurs, re-read without CRC validation so that we can\n\t\t * repair the damage via xfs_qm_reset_dqcounts(). This process\n\t\t * will leave a trace in the log indicating corruption has\n\t\t * been detected.\n\t\t */\n\t\tif (error == -EFSCORRUPTED) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t      NULL);\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * A corrupt buffer might not have a verifier attached, so\n\t\t * make sure we have the correct one attached before writeback\n\t\t * occurs.\n\t\t */\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n\t\txfs_qm_reset_dqcounts(mp, bp, firstid, type);\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\txfs_buf_relse(bp);\n\n\t\t/* goto the next block. */\n\t\tbno++;\n\t\tfirstid += mp->m_quotainfo->qi_dqperchunk;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_readahead",
          "args": [
            "mp->m_ddev_targp",
            "XFS_FSB_TO_DADDR(mp, rablkno)",
            "mp->m_quotainfo->qi_dqchunklen",
            "&xfs_dquot_buf_ops"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "256-265",
          "snippet": "static inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "rablkno"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "map[i].br_blockcount"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "map[i].br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmaps <= XFS_DQITER_MAP_SIZE"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "qip",
            "lock_mode"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "qip",
            "lblkno",
            "maxlblkcnt - lblkno",
            "map",
            "&nmaps",
            "0"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "qip"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "mp->m_super->s_maxbytes"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "XFS_DQITER_MAP_SIZE * sizeof(*map)",
            "KM_SLEEP"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqiterate(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*qip,\n\tuint\t\t\tflags,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_bmbt_irec\t*map;\n\tint\t\t\ti, nmaps;\t/* number of map entries */\n\tint\t\t\terror;\t\t/* return value */\n\txfs_fileoff_t\t\tlblkno;\n\txfs_filblks_t\t\tmaxlblkcnt;\n\txfs_dqid_t\t\tfirstid;\n\txfs_fsblock_t\t\trablkno;\n\txfs_filblks_t\t\trablkcnt;\n\n\terror = 0;\n\t/*\n\t * This looks racy, but we can't keep an inode lock across a\n\t * trans_reserve. But, this gets called during quotacheck, and that\n\t * happens only at mount time which is single threaded.\n\t */\n\tif (qip->i_d.di_nblocks == 0)\n\t\treturn 0;\n\n\tmap = kmem_alloc(XFS_DQITER_MAP_SIZE * sizeof(*map), KM_SLEEP);\n\n\tlblkno = 0;\n\tmaxlblkcnt = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tdo {\n\t\tuint\t\tlock_mode;\n\n\t\tnmaps = XFS_DQITER_MAP_SIZE;\n\t\t/*\n\t\t * We aren't changing the inode itself. Just changing\n\t\t * some of its data. No new blocks are added here, and\n\t\t * the inode is never added to the transaction.\n\t\t */\n\t\tlock_mode = xfs_ilock_data_map_shared(qip);\n\t\terror = xfs_bmapi_read(qip, lblkno, maxlblkcnt - lblkno,\n\t\t\t\t       map, &nmaps, 0);\n\t\txfs_iunlock(qip, lock_mode);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(nmaps <= XFS_DQITER_MAP_SIZE);\n\t\tfor (i = 0; i < nmaps; i++) {\n\t\t\tASSERT(map[i].br_startblock != DELAYSTARTBLOCK);\n\t\t\tASSERT(map[i].br_blockcount);\n\n\n\t\t\tlblkno += map[i].br_blockcount;\n\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK)\n\t\t\t\tcontinue;\n\n\t\t\tfirstid = (xfs_dqid_t) map[i].br_startoff *\n\t\t\t\tmp->m_quotainfo->qi_dqperchunk;\n\t\t\t/*\n\t\t\t * Do a read-ahead on the next extent.\n\t\t\t */\n\t\t\tif ((i+1 < nmaps) &&\n\t\t\t    (map[i+1].br_startblock != HOLESTARTBLOCK)) {\n\t\t\t\trablkcnt =  map[i+1].br_blockcount;\n\t\t\t\trablkno = map[i+1].br_startblock;\n\t\t\t\twhile (rablkcnt--) {\n\t\t\t\t\txfs_buf_readahead(mp->m_ddev_targp,\n\t\t\t\t\t       XFS_FSB_TO_DADDR(mp, rablkno),\n\t\t\t\t\t       mp->m_quotainfo->qi_dqchunklen,\n\t\t\t\t\t       &xfs_dquot_buf_ops);\n\t\t\t\t\trablkno++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Iterate thru all the blks in the extent and\n\t\t\t * reset the counters of all the dquots inside them.\n\t\t\t */\n\t\t\terror = xfs_qm_dqiter_bufs(mp, firstid,\n\t\t\t\t\t\t   map[i].br_startblock,\n\t\t\t\t\t\t   map[i].br_blockcount,\n\t\t\t\t\t\t   flags, buffer_list);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t}\n\t} while (nmaps > 0);\n\nout:\n\tkmem_free(map);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_dqiter_bufs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "862-928",
    "snippet": "STATIC int\nxfs_qm_dqiter_bufs(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tfirstid,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tblkcnt,\n\tuint\t\t\tflags,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ttype;\n\n\tASSERT(blkcnt > 0);\n\ttype = flags & XFS_QMOPT_UQUOTA ? XFS_DQ_USER :\n\t\t(flags & XFS_QMOPT_PQUOTA ? XFS_DQ_PROJ : XFS_DQ_GROUP);\n\terror = 0;\n\n\t/*\n\t * Blkcnt arg can be a very big number, and might even be\n\t * larger than the log itself. So, we have to break it up into\n\t * manageable-sized transactions.\n\t * Note that we don't start a permanent transaction here; we might\n\t * not be able to get a log reservation for the whole thing up front,\n\t * and we don't really care to either, because we just discard\n\t * everything if we were to crash in the middle of this loop.\n\t */\n\twhile (blkcnt--) {\n\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t      &xfs_dquot_buf_ops);\n\n\t\t/*\n\t\t * CRC and validation errors will return a EFSCORRUPTED here. If\n\t\t * this occurs, re-read without CRC validation so that we can\n\t\t * repair the damage via xfs_qm_reset_dqcounts(). This process\n\t\t * will leave a trace in the log indicating corruption has\n\t\t * been detected.\n\t\t */\n\t\tif (error == -EFSCORRUPTED) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t      NULL);\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * A corrupt buffer might not have a verifier attached, so\n\t\t * make sure we have the correct one attached before writeback\n\t\t * occurs.\n\t\t */\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n\t\txfs_qm_reset_dqcounts(mp, bp, firstid, type);\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\txfs_buf_relse(bp);\n\n\t\t/* goto the next block. */\n\t\tbno++;\n\t\tfirstid += mp->m_quotainfo->qi_dqperchunk;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "buffer_list"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_reset_dqcounts",
          "args": [
            "mp",
            "bp",
            "firstid",
            "type"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_reset_dqcounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "805-860",
          "snippet": "STATIC void\nxfs_qm_reset_dqcounts(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp,\n\txfs_dqid_t\tid,\n\tuint\t\ttype)\n{\n\tstruct xfs_dqblk\t*dqb;\n\tint\t\t\tj;\n\n\ttrace_xfs_reset_dqcounts(bp, _RET_IP_);\n\n\t/*\n\t * Reset all counters and timers. They'll be\n\t * started afresh by xfs_qm_quotacheck.\n\t */\n#ifdef DEBUG\n\tj = XFS_FSB_TO_B(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tdo_div(j, sizeof(xfs_dqblk_t));\n\tASSERT(mp->m_quotainfo->qi_dqperchunk == j);\n#endif\n\tdqb = bp->b_addr;\n\tfor (j = 0; j < mp->m_quotainfo->qi_dqperchunk; j++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\n\t\tddq = (struct xfs_disk_dquot *)&dqb[j];\n\n\t\t/*\n\t\t * Do a sanity check, and if needed, repair the dqblk. Don't\n\t\t * output any warnings because it's perfectly possible to\n\t\t * find uninitialised dquot blks. See comment in xfs_dqcheck.\n\t\t */\n\t\txfs_dqcheck(mp, ddq, id+j, type, XFS_QMOPT_DQREPAIR,\n\t\t\t    \"xfs_quotacheck\");\n\t\t/*\n\t\t * Reset type in case we are reusing group quota file for\n\t\t * project quotas or vice versa\n\t\t */\n\t\tddq->d_flags = type;\n\t\tddq->d_bcount = 0;\n\t\tddq->d_icount = 0;\n\t\tddq->d_rtbcount = 0;\n\t\tddq->d_btimer = 0;\n\t\tddq->d_itimer = 0;\n\t\tddq->d_rtbtimer = 0;\n\t\tddq->d_bwarns = 0;\n\t\tddq->d_iwarns = 0;\n\t\tddq->d_rtbwarns = 0;\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\txfs_update_cksum((char *)&dqb[j],\n\t\t\t\t\t sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC void\nxfs_qm_reset_dqcounts(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp,\n\txfs_dqid_t\tid,\n\tuint\t\ttype)\n{\n\tstruct xfs_dqblk\t*dqb;\n\tint\t\t\tj;\n\n\ttrace_xfs_reset_dqcounts(bp, _RET_IP_);\n\n\t/*\n\t * Reset all counters and timers. They'll be\n\t * started afresh by xfs_qm_quotacheck.\n\t */\n#ifdef DEBUG\n\tj = XFS_FSB_TO_B(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tdo_div(j, sizeof(xfs_dqblk_t));\n\tASSERT(mp->m_quotainfo->qi_dqperchunk == j);\n#endif\n\tdqb = bp->b_addr;\n\tfor (j = 0; j < mp->m_quotainfo->qi_dqperchunk; j++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\n\t\tddq = (struct xfs_disk_dquot *)&dqb[j];\n\n\t\t/*\n\t\t * Do a sanity check, and if needed, repair the dqblk. Don't\n\t\t * output any warnings because it's perfectly possible to\n\t\t * find uninitialised dquot blks. See comment in xfs_dqcheck.\n\t\t */\n\t\txfs_dqcheck(mp, ddq, id+j, type, XFS_QMOPT_DQREPAIR,\n\t\t\t    \"xfs_quotacheck\");\n\t\t/*\n\t\t * Reset type in case we are reusing group quota file for\n\t\t * project quotas or vice versa\n\t\t */\n\t\tddq->d_flags = type;\n\t\tddq->d_bcount = 0;\n\t\tddq->d_icount = 0;\n\t\tddq->d_rtbcount = 0;\n\t\tddq->d_btimer = 0;\n\t\tddq->d_itimer = 0;\n\t\tddq->d_rtbtimer = 0;\n\t\tddq->d_bwarns = 0;\n\t\tddq->d_iwarns = 0;\n\t\tddq->d_rtbwarns = 0;\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\txfs_update_cksum((char *)&dqb[j],\n\t\t\t\t\t sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_read_buf",
          "args": [
            "mp",
            "NULL",
            "mp->m_ddev_targp",
            "XFS_FSB_TO_DADDR(mp, bno)",
            "mp->m_quotainfo->qi_dqchunklen",
            "0",
            "&bp",
            "NULL"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "186-200",
          "snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_trans_read_buf(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_read_buf_map(mp, tp, target, &map, 1,\n\t\t\t\t      flags, bpp, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "bno"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "bno"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blkcnt > 0"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_qm_dqiter_bufs(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tfirstid,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tblkcnt,\n\tuint\t\t\tflags,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ttype;\n\n\tASSERT(blkcnt > 0);\n\ttype = flags & XFS_QMOPT_UQUOTA ? XFS_DQ_USER :\n\t\t(flags & XFS_QMOPT_PQUOTA ? XFS_DQ_PROJ : XFS_DQ_GROUP);\n\terror = 0;\n\n\t/*\n\t * Blkcnt arg can be a very big number, and might even be\n\t * larger than the log itself. So, we have to break it up into\n\t * manageable-sized transactions.\n\t * Note that we don't start a permanent transaction here; we might\n\t * not be able to get a log reservation for the whole thing up front,\n\t * and we don't really care to either, because we just discard\n\t * everything if we were to crash in the middle of this loop.\n\t */\n\twhile (blkcnt--) {\n\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t      &xfs_dquot_buf_ops);\n\n\t\t/*\n\t\t * CRC and validation errors will return a EFSCORRUPTED here. If\n\t\t * this occurs, re-read without CRC validation so that we can\n\t\t * repair the damage via xfs_qm_reset_dqcounts(). This process\n\t\t * will leave a trace in the log indicating corruption has\n\t\t * been detected.\n\t\t */\n\t\tif (error == -EFSCORRUPTED) {\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t      XFS_FSB_TO_DADDR(mp, bno),\n\t\t\t\t      mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t      NULL);\n\t\t}\n\n\t\tif (error)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * A corrupt buffer might not have a verifier attached, so\n\t\t * make sure we have the correct one attached before writeback\n\t\t * occurs.\n\t\t */\n\t\tbp->b_ops = &xfs_dquot_buf_ops;\n\t\txfs_qm_reset_dqcounts(mp, bp, firstid, type);\n\t\txfs_buf_delwri_queue(bp, buffer_list);\n\t\txfs_buf_relse(bp);\n\n\t\t/* goto the next block. */\n\t\tbno++;\n\t\tfirstid += mp->m_quotainfo->qi_dqperchunk;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_reset_dqcounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "805-860",
    "snippet": "STATIC void\nxfs_qm_reset_dqcounts(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp,\n\txfs_dqid_t\tid,\n\tuint\t\ttype)\n{\n\tstruct xfs_dqblk\t*dqb;\n\tint\t\t\tj;\n\n\ttrace_xfs_reset_dqcounts(bp, _RET_IP_);\n\n\t/*\n\t * Reset all counters and timers. They'll be\n\t * started afresh by xfs_qm_quotacheck.\n\t */\n#ifdef DEBUG\n\tj = XFS_FSB_TO_B(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tdo_div(j, sizeof(xfs_dqblk_t));\n\tASSERT(mp->m_quotainfo->qi_dqperchunk == j);\n#endif\n\tdqb = bp->b_addr;\n\tfor (j = 0; j < mp->m_quotainfo->qi_dqperchunk; j++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\n\t\tddq = (struct xfs_disk_dquot *)&dqb[j];\n\n\t\t/*\n\t\t * Do a sanity check, and if needed, repair the dqblk. Don't\n\t\t * output any warnings because it's perfectly possible to\n\t\t * find uninitialised dquot blks. See comment in xfs_dqcheck.\n\t\t */\n\t\txfs_dqcheck(mp, ddq, id+j, type, XFS_QMOPT_DQREPAIR,\n\t\t\t    \"xfs_quotacheck\");\n\t\t/*\n\t\t * Reset type in case we are reusing group quota file for\n\t\t * project quotas or vice versa\n\t\t */\n\t\tddq->d_flags = type;\n\t\tddq->d_bcount = 0;\n\t\tddq->d_icount = 0;\n\t\tddq->d_rtbcount = 0;\n\t\tddq->d_btimer = 0;\n\t\tddq->d_itimer = 0;\n\t\tddq->d_rtbtimer = 0;\n\t\tddq->d_bwarns = 0;\n\t\tddq->d_iwarns = 0;\n\t\tddq->d_rtbwarns = 0;\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\txfs_update_cksum((char *)&dqb[j],\n\t\t\t\t\t sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_update_cksum",
          "args": [
            "(char *)&dqb[j]",
            "sizeof(struct xfs_dqblk)",
            "XFS_DQUOT_CRC_OFF"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "44-50",
          "snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqcheck",
          "args": [
            "mp",
            "ddq",
            "id+j",
            "type",
            "XFS_QMOPT_DQREPAIR",
            "\"xfs_quotacheck\""
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqcheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "50-172",
          "snippet": "int\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dqcheck(\n\tstruct xfs_mount *mp,\n\txfs_disk_dquot_t *ddq,\n\txfs_dqid_t\t id,\n\tuint\t\t type,\t  /* used only when IO_dorepair is true */\n\tuint\t\t flags,\n\tchar\t\t *str)\n{\n\txfs_dqblk_t\t *d = (xfs_dqblk_t *)ddq;\n\tint\t\terrs = 0;\n\n\t/*\n\t * We can encounter an uninitialized dquot buffer for 2 reasons:\n\t * 1. If we crash while deleting the quotainode(s), and those blks got\n\t *    used for user data. This is because we take the path of regular\n\t *    file deletion; however, the size field of quotainodes is never\n\t *    updated, so all the tricks that we play in itruncate_finish\n\t *    don't quite matter.\n\t *\n\t * 2. We don't play the quota buffers when there's a quotaoff logitem.\n\t *    But the allocation will be replayed so we'll end up with an\n\t *    uninitialized quota block.\n\t *\n\t * This is all fine; things are still consistent, and we haven't lost\n\t * any quota information. Just don't complain about bad dquot blks.\n\t */\n\tif (ddq->d_magic != cpu_to_be16(XFS_DQUOT_MAGIC)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, magic 0x%x != 0x%x\",\n\t\t\tstr, id, be16_to_cpu(ddq->d_magic), XFS_DQUOT_MAGIC);\n\t\terrs++;\n\t}\n\tif (ddq->d_version != XFS_DQUOT_VERSION) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, version 0x%x != 0x%x\",\n\t\t\tstr, id, ddq->d_version, XFS_DQUOT_VERSION);\n\t\terrs++;\n\t}\n\n\tif (ddq->d_flags != XFS_DQ_USER &&\n\t    ddq->d_flags != XFS_DQ_PROJ &&\n\t    ddq->d_flags != XFS_DQ_GROUP) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : XFS dquot ID 0x%x, unknown flags 0x%x\",\n\t\t\tstr, id, ddq->d_flags);\n\t\terrs++;\n\t}\n\n\tif (id != -1 && id != be32_to_cpu(ddq->d_id)) {\n\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\txfs_alert(mp,\n\t\t\t\"%s : ondisk-dquot 0x%p, ID mismatch: \"\n\t\t\t\"0x%x expected, found id 0x%x\",\n\t\t\tstr, ddq, id, be32_to_cpu(ddq->d_id));\n\t\terrs++;\n\t}\n\n\tif (!errs && ddq->d_id) {\n\t\tif (ddq->d_blk_softlimit &&\n\t\t    be64_to_cpu(ddq->d_bcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_blk_softlimit)) {\n\t\t\tif (!ddq->d_btimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) BLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_ino_softlimit &&\n\t\t    be64_to_cpu(ddq->d_icount) >\n\t\t\t\tbe64_to_cpu(ddq->d_ino_softlimit)) {\n\t\t\tif (!ddq->d_itimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) INODE TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t\tif (ddq->d_rtb_softlimit &&\n\t\t    be64_to_cpu(ddq->d_rtbcount) >\n\t\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit)) {\n\t\t\tif (!ddq->d_rtbtimer) {\n\t\t\t\tif (flags & XFS_QMOPT_DOWARN)\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\"%s : Dquot ID 0x%x (0x%p) RTBLK TIMER NOT STARTED\",\n\t\t\t\t\tstr, (int)be32_to_cpu(ddq->d_id), ddq);\n\t\t\t\terrs++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!errs || !(flags & XFS_QMOPT_DQREPAIR))\n\t\treturn errs;\n\n\tif (flags & XFS_QMOPT_DOWARN)\n\t\txfs_notice(mp, \"Re-initializing dquot ID 0x%x\", id);\n\n\t/*\n\t * Typically, a repair is only requested by quotacheck.\n\t */\n\tASSERT(id != -1);\n\tASSERT(flags & XFS_QMOPT_DQREPAIR);\n\tmemset(d, 0, sizeof(xfs_dqblk_t));\n\n\td->dd_diskdq.d_magic = cpu_to_be16(XFS_DQUOT_MAGIC);\n\td->dd_diskdq.d_version = XFS_DQUOT_VERSION;\n\td->dd_diskdq.d_flags = type;\n\td->dd_diskdq.d_id = cpu_to_be32(id);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tuuid_copy(&d->dd_uuid, &mp->m_sb.sb_uuid);\n\t\txfs_update_cksum((char *)d, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\treturn errs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_quotainfo->qi_dqperchunk == j"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "j",
            "sizeof(xfs_dqblk_t)"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "XFS_DQUOT_CLUSTER_SIZE_FSB"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_reset_dqcounts",
          "args": [
            "bp",
            "_RET_IP_"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC void\nxfs_qm_reset_dqcounts(\n\txfs_mount_t\t*mp,\n\txfs_buf_t\t*bp,\n\txfs_dqid_t\tid,\n\tuint\t\ttype)\n{\n\tstruct xfs_dqblk\t*dqb;\n\tint\t\t\tj;\n\n\ttrace_xfs_reset_dqcounts(bp, _RET_IP_);\n\n\t/*\n\t * Reset all counters and timers. They'll be\n\t * started afresh by xfs_qm_quotacheck.\n\t */\n#ifdef DEBUG\n\tj = XFS_FSB_TO_B(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tdo_div(j, sizeof(xfs_dqblk_t));\n\tASSERT(mp->m_quotainfo->qi_dqperchunk == j);\n#endif\n\tdqb = bp->b_addr;\n\tfor (j = 0; j < mp->m_quotainfo->qi_dqperchunk; j++) {\n\t\tstruct xfs_disk_dquot\t*ddq;\n\n\t\tddq = (struct xfs_disk_dquot *)&dqb[j];\n\n\t\t/*\n\t\t * Do a sanity check, and if needed, repair the dqblk. Don't\n\t\t * output any warnings because it's perfectly possible to\n\t\t * find uninitialised dquot blks. See comment in xfs_dqcheck.\n\t\t */\n\t\txfs_dqcheck(mp, ddq, id+j, type, XFS_QMOPT_DQREPAIR,\n\t\t\t    \"xfs_quotacheck\");\n\t\t/*\n\t\t * Reset type in case we are reusing group quota file for\n\t\t * project quotas or vice versa\n\t\t */\n\t\tddq->d_flags = type;\n\t\tddq->d_bcount = 0;\n\t\tddq->d_icount = 0;\n\t\tddq->d_rtbcount = 0;\n\t\tddq->d_btimer = 0;\n\t\tddq->d_itimer = 0;\n\t\tddq->d_rtbtimer = 0;\n\t\tddq->d_bwarns = 0;\n\t\tddq->d_iwarns = 0;\n\t\tddq->d_rtbwarns = 0;\n\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\txfs_update_cksum((char *)&dqb[j],\n\t\t\t\t\t sizeof(struct xfs_dqblk),\n\t\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_qm_qino_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "713-802",
    "snippet": "STATIC int\nxfs_qm_qino_alloc(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t**ip,\n\tuint\t\tflags)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\tint\t\tcommitted;\n\n\t*ip = NULL;\n\t/*\n\t * With superblock that doesn't have separate pquotino, we\n\t * share an inode between gquota and pquota. If the on-disk\n\t * superblock has GQUOTA and the filesystem is now mounted\n\t * with PQUOTA, just use sb_gquotino for sb_pquotino and\n\t * vice-versa.\n\t */\n\tif (!xfs_sb_version_has_pquotino(&mp->m_sb) &&\n\t\t\t(flags & (XFS_QMOPT_PQUOTA|XFS_QMOPT_GQUOTA))) {\n\t\txfs_ino_t ino = NULLFSINO;\n\n\t\tif ((flags & XFS_QMOPT_PQUOTA) &&\n\t\t\t     (mp->m_sb.sb_gquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_gquotino;\n\t\t\tASSERT(mp->m_sb.sb_pquotino == NULLFSINO);\n\t\t} else if ((flags & XFS_QMOPT_GQUOTA) &&\n\t\t\t     (mp->m_sb.sb_pquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_pquotino;\n\t\t\tASSERT(mp->m_sb.sb_gquotino == NULLFSINO);\n\t\t}\n\t\tif (ino != NULLFSINO) {\n\t\t\terror = xfs_iget(mp, NULL, ino, 0, 0, ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\t\t}\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QINOCREATE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_create,\n\t\t\t\t  XFS_QM_QINOCREATE_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tif (!*ip) {\n\t\terror = xfs_dir_ialloc(&tp, NULL, S_IFREG, 1, 0, 0, 1, ip,\n\t\t\t\t\t\t\t\t&committed);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t XFS_TRANS_ABORT);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/*\n\t * Make the changes in the superblock, and log those too.\n\t * sbfields arg may contain fields other than *QUOTINO;\n\t * VERSIONNUM for example.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tif (flags & XFS_QMOPT_SBVERSION) {\n\t\tASSERT(!xfs_sb_version_hasquota(&mp->m_sb));\n\n\t\txfs_sb_version_addquota(&mp->m_sb);\n\t\tmp->m_sb.sb_uquotino = NULLFSINO;\n\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\n\t\t/* qflags will get updated fully _after_ quotacheck */\n\t\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_ALL_QUOTA_ACCT;\n\t}\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\tmp->m_sb.sb_uquotino = (*ip)->i_ino;\n\telse if (flags & XFS_QMOPT_GQUOTA)\n\t\tmp->m_sb.sb_gquotino = (*ip)->i_ino;\n\telse\n\t\tmp->m_sb.sb_pquotino = (*ip)->i_ino;\n\tspin_unlock(&mp->m_sb_lock);\n\txfs_log_sb(tp);\n\n\tif ((error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES))) {\n\t\txfs_alert(mp, \"%s failed (error %d)!\", __func__, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s failed (error %d)!\"",
            "__func__",
            "error"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_sb",
          "args": [
            "tp"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_sbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1083-1100",
          "snippet": "int\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_log_sbcount(xfs_mount_t *mp)\n{\n\t/* allow this to proceed during the freeze sequence... */\n\tif (!xfs_fs_writable(mp, SB_FREEZE_COMPLETE))\n\t\treturn 0;\n\n\txfs_icsb_sync_counters(mp, 0);\n\n\t/*\n\t * we don't need to do this if we are updating the superblock\n\t * counters on every modification.\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\treturn 0;\n\n\treturn xfs_sync_sb(mp, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_addquota",
          "args": [
            "&mp->m_sb"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_addquota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "394-397",
          "snippet": "static inline void xfs_sb_version_addquota(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_QUOTABIT;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n\nstatic inline void xfs_sb_version_addquota(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_QUOTABIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_sb_version_hasquota(&mp->m_sb)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasquota",
          "args": [
            "&mp->m_sb"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasquota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "389-392",
          "snippet": "static inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_QUOTABIT\t\t0x0040\n\nstatic inline bool xfs_sb_version_hasquota(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_QUOTABIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t XFS_TRANS_ABORT"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_ialloc",
          "args": [
            "&tp",
            "NULL",
            "S_IFREG",
            "1",
            "0",
            "0",
            "1",
            "ip",
            "&committed"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "838-1009",
          "snippet": "int\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_create",
            "XFS_QM_QINOCREATE_SPACE_RES(mp)",
            "0"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_QM_QINOCREATE_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_QM_QINOCREATE"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iget",
          "args": [
            "mp",
            "NULL",
            "ino",
            "0",
            "0",
            "ip"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "388-456",
          "snippet": "int\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nint\nxfs_iget(\n\txfs_mount_t\t*mp,\n\txfs_trans_t\t*tp,\n\txfs_ino_t\tino,\n\tuint\t\tflags,\n\tuint\t\tlock_flags,\n\txfs_inode_t\t**ipp)\n{\n\txfs_inode_t\t*ip;\n\tint\t\terror;\n\txfs_perag_t\t*pag;\n\txfs_agino_t\tagino;\n\n\t/*\n\t * xfs_reclaim_inode() uses the ILOCK to ensure an inode\n\t * doesn't get freed while it's being referenced during a\n\t * radix tree traversal here.  It assumes this function\n\t * aqcuires only the ILOCK (and therefore it has no need to\n\t * involve the IOLOCK in this synchronization).\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_EXCL | XFS_IOLOCK_SHARED)) == 0);\n\n\t/* reject inode numbers outside existing AGs */\n\tif (!ino || XFS_INO_TO_AGNO(mp, ino) >= mp->m_sb.sb_agcount)\n\t\treturn -EINVAL;\n\n\t/* get the perag structure and ensure that it's inode capable */\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ino));\n\tagino = XFS_INO_TO_AGINO(mp, ino);\n\nagain:\n\terror = 0;\n\trcu_read_lock();\n\tip = radix_tree_lookup(&pag->pag_ici_root, agino);\n\n\tif (ip) {\n\t\terror = xfs_iget_cache_hit(pag, ip, ino, flags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t} else {\n\t\trcu_read_unlock();\n\t\tXFS_STATS_INC(xs_ig_missed);\n\n\t\terror = xfs_iget_cache_miss(mp, pag, tp, ino, &ip,\n\t\t\t\t\t\t\tflags, lock_flags);\n\t\tif (error)\n\t\t\tgoto out_error_or_again;\n\t}\n\txfs_perag_put(pag);\n\n\t*ipp = ip;\n\n\t/*\n\t * If we have a real type for an on-disk inode, we can set ops(&unlock)\n\t * now.\t If it's a new inode being created, xfs_ialloc will handle it.\n\t */\n\tif (xfs_iflags_test(ip, XFS_INEW) && ip->i_d.di_mode != 0)\n\t\txfs_setup_inode(ip);\n\treturn 0;\n\nout_error_or_again:\n\tif (error == -EAGAIN) {\n\t\tdelay(1);\n\t\tgoto again;\n\t}\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_sb.sb_gquotino == NULLFSINO"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_sb.sb_pquotino == NULLFSINO"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_has_pquotino",
          "args": [
            "&mp->m_sb"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_has_pquotino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "552-555",
          "snippet": "static inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC int\nxfs_qm_qino_alloc(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t**ip,\n\tuint\t\tflags)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\tint\t\tcommitted;\n\n\t*ip = NULL;\n\t/*\n\t * With superblock that doesn't have separate pquotino, we\n\t * share an inode between gquota and pquota. If the on-disk\n\t * superblock has GQUOTA and the filesystem is now mounted\n\t * with PQUOTA, just use sb_gquotino for sb_pquotino and\n\t * vice-versa.\n\t */\n\tif (!xfs_sb_version_has_pquotino(&mp->m_sb) &&\n\t\t\t(flags & (XFS_QMOPT_PQUOTA|XFS_QMOPT_GQUOTA))) {\n\t\txfs_ino_t ino = NULLFSINO;\n\n\t\tif ((flags & XFS_QMOPT_PQUOTA) &&\n\t\t\t     (mp->m_sb.sb_gquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_gquotino;\n\t\t\tASSERT(mp->m_sb.sb_pquotino == NULLFSINO);\n\t\t} else if ((flags & XFS_QMOPT_GQUOTA) &&\n\t\t\t     (mp->m_sb.sb_pquotino != NULLFSINO)) {\n\t\t\tino = mp->m_sb.sb_pquotino;\n\t\t\tASSERT(mp->m_sb.sb_gquotino == NULLFSINO);\n\t\t}\n\t\tif (ino != NULLFSINO) {\n\t\t\terror = xfs_iget(mp, NULL, ino, 0, 0, ip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\t\t}\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_QINOCREATE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_create,\n\t\t\t\t  XFS_QM_QINOCREATE_SPACE_RES(mp), 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\tif (!*ip) {\n\t\terror = xfs_dir_ialloc(&tp, NULL, S_IFREG, 1, 0, 0, 1, ip,\n\t\t\t\t\t\t\t\t&committed);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t XFS_TRANS_ABORT);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/*\n\t * Make the changes in the superblock, and log those too.\n\t * sbfields arg may contain fields other than *QUOTINO;\n\t * VERSIONNUM for example.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tif (flags & XFS_QMOPT_SBVERSION) {\n\t\tASSERT(!xfs_sb_version_hasquota(&mp->m_sb));\n\n\t\txfs_sb_version_addquota(&mp->m_sb);\n\t\tmp->m_sb.sb_uquotino = NULLFSINO;\n\t\tmp->m_sb.sb_gquotino = NULLFSINO;\n\t\tmp->m_sb.sb_pquotino = NULLFSINO;\n\n\t\t/* qflags will get updated fully _after_ quotacheck */\n\t\tmp->m_sb.sb_qflags = mp->m_qflags & XFS_ALL_QUOTA_ACCT;\n\t}\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\tmp->m_sb.sb_uquotino = (*ip)->i_ino;\n\telse if (flags & XFS_QMOPT_GQUOTA)\n\t\tmp->m_sb.sb_gquotino = (*ip)->i_ino;\n\telse\n\t\tmp->m_sb.sb_pquotino = (*ip)->i_ino;\n\tspin_unlock(&mp->m_sb_lock);\n\txfs_log_sb(tp);\n\n\tif ((error = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES))) {\n\t\txfs_alert(mp, \"%s failed (error %d)!\", __func__, error);\n\t\treturn error;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_destroy_quotainfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "680-707",
    "snippet": "void\nxfs_qm_destroy_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\n\tif (qi->qi_uquotaip) {\n\t\tIRELE(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL; /* paranoia */\n\t}\n\tif (qi->qi_gquotaip) {\n\t\tIRELE(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\tIRELE(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "qi"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&qi->qi_quotaofflock"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "qi->qi_pquotaip"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "qi->qi_gquotaip"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "qi->qi_uquotaip"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_destroy",
          "args": [
            "&qi->qi_lru"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&qi->qi_shrinker"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "qi != NULL"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nvoid\nxfs_qm_destroy_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\n\tif (qi->qi_uquotaip) {\n\t\tIRELE(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL; /* paranoia */\n\t}\n\tif (qi->qi_gquotaip) {\n\t\tIRELE(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\tIRELE(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}"
  },
  {
    "function_name": "xfs_qm_init_quotainfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "567-672",
    "snippet": "STATIC int\nxfs_qm_init_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qinf;\n\tint\t\terror;\n\txfs_dquot_t\t*dqp;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tqinf = mp->m_quotainfo = kmem_zalloc(sizeof(xfs_quotainfo_t), KM_SLEEP);\n\n\terror = list_lru_init(&qinf->qi_lru);\n\tif (error)\n\t\tgoto out_free_qinf;\n\n\t/*\n\t * See if quotainodes are setup, and if not, allocate them,\n\t * and change the superblock accordingly.\n\t */\n\terror = xfs_qm_init_quotainos(mp);\n\tif (error)\n\t\tgoto out_free_lru;\n\n\tINIT_RADIX_TREE(&qinf->qi_uquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_gquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_pquota_tree, GFP_NOFS);\n\tmutex_init(&qinf->qi_tree_lock);\n\n\t/* mutex used to serialize quotaoffs */\n\tmutex_init(&qinf->qi_quotaofflock);\n\n\t/* Precalc some constants */\n\tqinf->qi_dqchunklen = XFS_FSB_TO_BB(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tqinf->qi_dqperchunk = xfs_calc_dquots_per_chunk(qinf->qi_dqchunklen);\n\n\tmp->m_qflags |= (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_CHKD);\n\n\t/*\n\t * We try to get the limits from the superuser's limits fields.\n\t * This is quite hacky, but it is standard quota practice.\n\t *\n\t * We look at the USR dquot with id == 0 first, but if user quotas\n\t * are not enabled we goto the GRP dquot with id == 0.\n\t * We don't really care to keep separate default limits for user\n\t * and group quotas, at least not at this point.\n\t *\n\t * Since we may not have done a quotacheck by this point, just read\n\t * the dquot without attaching it to any hashtables or lists.\n\t */\n\terror = xfs_qm_dqread(mp, 0,\n\t\t\tXFS_IS_UQUOTA_RUNNING(mp) ? XFS_DQ_USER :\n\t\t\t (XFS_IS_GQUOTA_RUNNING(mp) ? XFS_DQ_GROUP :\n\t\t\t  XFS_DQ_PROJ),\n\t\t\tXFS_QMOPT_DOWARN, &dqp);\n\tif (!error) {\n\t\txfs_disk_dquot_t\t*ddqp = &dqp->q_core;\n\n\t\t/*\n\t\t * The warnings and timers set the grace period given to\n\t\t * a user or group before he or she can not perform any\n\t\t * more writing. If it is zero, a default is used.\n\t\t */\n\t\tqinf->qi_btimelimit = ddqp->d_btimer ?\n\t\t\tbe32_to_cpu(ddqp->d_btimer) : XFS_QM_BTIMELIMIT;\n\t\tqinf->qi_itimelimit = ddqp->d_itimer ?\n\t\t\tbe32_to_cpu(ddqp->d_itimer) : XFS_QM_ITIMELIMIT;\n\t\tqinf->qi_rtbtimelimit = ddqp->d_rtbtimer ?\n\t\t\tbe32_to_cpu(ddqp->d_rtbtimer) : XFS_QM_RTBTIMELIMIT;\n\t\tqinf->qi_bwarnlimit = ddqp->d_bwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_bwarns) : XFS_QM_BWARNLIMIT;\n\t\tqinf->qi_iwarnlimit = ddqp->d_iwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_iwarns) : XFS_QM_IWARNLIMIT;\n\t\tqinf->qi_rtbwarnlimit = ddqp->d_rtbwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_rtbwarns) : XFS_QM_RTBWARNLIMIT;\n\t\tqinf->qi_bhardlimit = be64_to_cpu(ddqp->d_blk_hardlimit);\n\t\tqinf->qi_bsoftlimit = be64_to_cpu(ddqp->d_blk_softlimit);\n\t\tqinf->qi_ihardlimit = be64_to_cpu(ddqp->d_ino_hardlimit);\n\t\tqinf->qi_isoftlimit = be64_to_cpu(ddqp->d_ino_softlimit);\n\t\tqinf->qi_rtbhardlimit = be64_to_cpu(ddqp->d_rtb_hardlimit);\n\t\tqinf->qi_rtbsoftlimit = be64_to_cpu(ddqp->d_rtb_softlimit);\n\n\t\txfs_qm_dqdestroy(dqp);\n\t} else {\n\t\tqinf->qi_btimelimit = XFS_QM_BTIMELIMIT;\n\t\tqinf->qi_itimelimit = XFS_QM_ITIMELIMIT;\n\t\tqinf->qi_rtbtimelimit = XFS_QM_RTBTIMELIMIT;\n\t\tqinf->qi_bwarnlimit = XFS_QM_BWARNLIMIT;\n\t\tqinf->qi_iwarnlimit = XFS_QM_IWARNLIMIT;\n\t\tqinf->qi_rtbwarnlimit = XFS_QM_RTBWARNLIMIT;\n\t}\n\n\tqinf->qi_shrinker.count_objects = xfs_qm_shrink_count;\n\tqinf->qi_shrinker.scan_objects = xfs_qm_shrink_scan;\n\tqinf->qi_shrinker.seeks = DEFAULT_SEEKS;\n\tqinf->qi_shrinker.flags = SHRINKER_NUMA_AWARE;\n\tregister_shrinker(&qinf->qi_shrinker);\n\treturn 0;\n\nout_free_lru:\n\tlist_lru_destroy(&qinf->qi_lru);\nout_free_qinf:\n\tkmem_free(qinf);\n\tmp->m_quotainfo = NULL;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);",
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "qinf"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_destroy",
          "args": [
            "&qinf->qi_lru"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_shrinker",
          "args": [
            "&qinf->qi_shrinker"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/extents_status.c",
          "lines": "1220-1227",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"extents_status.h\"",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"extents_status.h\"\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n#include <linux/rbtree.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tif (sbi->s_proc)\n\t\tremove_proc_entry(\"es_shrinker_info\", sbi->s_proc);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqdestroy",
          "args": [
            "dqp"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqdestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "71-81",
          "snippet": "void\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_zone\t\t*xfs_qm_dqzone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_rtb_softlimit"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_rtb_hardlimit"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_ino_softlimit"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_ino_hardlimit"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_blk_softlimit"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ddqp->d_blk_hardlimit"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ddqp->d_rtbwarns"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ddqp->d_iwarns"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ddqp->d_bwarns"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddqp->d_rtbtimer"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddqp->d_itimer"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ddqp->d_btimer"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqread",
          "args": [
            "mp",
            "0",
            "XFS_IS_UQUOTA_RUNNING(mp) ? XFS_DQ_USER :\n\t\t\t (XFS_IS_GQUOTA_RUNNING(mp) ? XFS_DQ_GROUP :\n\t\t\t  XFS_DQ_PROJ)",
            "XFS_QMOPT_DOWARN",
            "&dqp"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "558-688",
          "snippet": "int\nxfs_qm_dqread(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_dqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tint\t\t\tcancelflags = 0;\n\n\n\tdqp = kmem_zone_zalloc(xfs_qm_dqzone, KM_SLEEP);\n\n\tdqp->dq_flags = type;\n\tdqp->q_core.d_id = cpu_to_be32(id);\n\tdqp->q_mount = mp;\n\tINIT_LIST_HEAD(&dqp->q_lru);\n\tmutex_init(&dqp->q_qlock);\n\tinit_waitqueue_head(&dqp->q_pinwait);\n\n\t/*\n\t * Because we want to use a counting completion, complete\n\t * the flush completion once to allow a single access to\n\t * the flush completion without blocking.\n\t */\n\tinit_completion(&dqp->q_flush);\n\tcomplete(&dqp->q_flush);\n\n\t/*\n\t * Make sure group quotas have a different lock class than user\n\t * quotas.\n\t */\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\t/* uses the default lock class */\n\t\tbreak;\n\tcase XFS_DQ_GROUP:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_group_class);\n\t\tbreak;\n\tcase XFS_DQ_PROJ:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_project_class);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\tXFS_STATS_INC(xs_qm_dquot);\n\n\ttrace_xfs_dqread(dqp);\n\n\tif (flags & XFS_QMOPT_DQALLOC) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_DQALLOC);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_dqalloc,\n\t\t\t\t\t  XFS_QM_DQALLOC_SPACE_RES(mp), 0);\n\t\tif (error)\n\t\t\tgoto error1;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t}\n\n\t/*\n\t * get a pointer to the on-disk dquot and the buffer containing it\n\t * dqp already knows its own type (GROUP/USER).\n\t */\n\terror = xfs_qm_dqtobp(&tp, dqp, &ddqp, &bp, flags);\n\tif (error) {\n\t\t/*\n\t\t * This can happen if quotas got turned off (ESRCH),\n\t\t * or if the dquot didn't exist on disk and we ask to\n\t\t * allocate (ENOENT).\n\t\t */\n\t\ttrace_xfs_dqread_fail(dqp);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\tgoto error1;\n\t}\n\n\t/* copy everything from disk dquot to the incore dquot */\n\tmemcpy(&dqp->q_core, ddqp, sizeof(xfs_disk_dquot_t));\n\txfs_qm_dquot_logitem_init(dqp);\n\n\t/*\n\t * Reservation counters are defined as reservation plus current usage\n\t * to avoid having to add every time.\n\t */\n\tdqp->q_res_bcount = be64_to_cpu(ddqp->d_bcount);\n\tdqp->q_res_icount = be64_to_cpu(ddqp->d_icount);\n\tdqp->q_res_rtbcount = be64_to_cpu(ddqp->d_rtbcount);\n\n\t/* initialize the dquot speculative prealloc thresholds */\n\txfs_dquot_set_prealloc_limits(dqp);\n\n\t/* Mark the buf so that this will stay incore a little longer */\n\txfs_buf_set_ref(bp, XFS_DQUOT_REF);\n\n\t/*\n\t * We got the buffer with a xfs_trans_read_buf() (in dqtobp())\n\t * So we need to release with xfs_trans_brelse().\n\t * The strategy here is identical to that of inodes; we lock\n\t * the dquot in xfs_qm_dqget() before making it accessible to\n\t * others. This is because dquots, like inodes, need a good level of\n\t * concurrency, and we don't want to take locks on the entire buffers\n\t * for dquot accesses.\n\t * Note also that the dquot buffer may even be dirty at this point, if\n\t * this particular dquot was repaired. We still aren't afraid to\n\t * brelse it because we have the changes incore.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_trans_brelse(tp, bp);\n\n\tif (tp) {\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t*O_dqpp = dqp;\n\treturn error;\n\nerror1:\n\tif (tp)\n\t\txfs_trans_cancel(tp, cancelflags);\nerror0:\n\txfs_qm_dqdestroy(dqp);\n\t*O_dqpp = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_zone\t\t*xfs_qm_dqzone;",
            "static struct lock_class_key xfs_dquot_group_class;",
            "static struct lock_class_key xfs_dquot_project_class;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\nstatic struct lock_class_key xfs_dquot_group_class;\nstatic struct lock_class_key xfs_dquot_project_class;\n\nint\nxfs_qm_dqread(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tuint\t\t\tflags,\n\tstruct xfs_dquot\t**O_dqpp)\n{\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tint\t\t\tcancelflags = 0;\n\n\n\tdqp = kmem_zone_zalloc(xfs_qm_dqzone, KM_SLEEP);\n\n\tdqp->dq_flags = type;\n\tdqp->q_core.d_id = cpu_to_be32(id);\n\tdqp->q_mount = mp;\n\tINIT_LIST_HEAD(&dqp->q_lru);\n\tmutex_init(&dqp->q_qlock);\n\tinit_waitqueue_head(&dqp->q_pinwait);\n\n\t/*\n\t * Because we want to use a counting completion, complete\n\t * the flush completion once to allow a single access to\n\t * the flush completion without blocking.\n\t */\n\tinit_completion(&dqp->q_flush);\n\tcomplete(&dqp->q_flush);\n\n\t/*\n\t * Make sure group quotas have a different lock class than user\n\t * quotas.\n\t */\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\t/* uses the default lock class */\n\t\tbreak;\n\tcase XFS_DQ_GROUP:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_group_class);\n\t\tbreak;\n\tcase XFS_DQ_PROJ:\n\t\tlockdep_set_class(&dqp->q_qlock, &xfs_dquot_project_class);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\tbreak;\n\t}\n\n\tXFS_STATS_INC(xs_qm_dquot);\n\n\ttrace_xfs_dqread(dqp);\n\n\tif (flags & XFS_QMOPT_DQALLOC) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_DQALLOC);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_dqalloc,\n\t\t\t\t\t  XFS_QM_DQALLOC_SPACE_RES(mp), 0);\n\t\tif (error)\n\t\t\tgoto error1;\n\t\tcancelflags = XFS_TRANS_RELEASE_LOG_RES;\n\t}\n\n\t/*\n\t * get a pointer to the on-disk dquot and the buffer containing it\n\t * dqp already knows its own type (GROUP/USER).\n\t */\n\terror = xfs_qm_dqtobp(&tp, dqp, &ddqp, &bp, flags);\n\tif (error) {\n\t\t/*\n\t\t * This can happen if quotas got turned off (ESRCH),\n\t\t * or if the dquot didn't exist on disk and we ask to\n\t\t * allocate (ENOENT).\n\t\t */\n\t\ttrace_xfs_dqread_fail(dqp);\n\t\tcancelflags |= XFS_TRANS_ABORT;\n\t\tgoto error1;\n\t}\n\n\t/* copy everything from disk dquot to the incore dquot */\n\tmemcpy(&dqp->q_core, ddqp, sizeof(xfs_disk_dquot_t));\n\txfs_qm_dquot_logitem_init(dqp);\n\n\t/*\n\t * Reservation counters are defined as reservation plus current usage\n\t * to avoid having to add every time.\n\t */\n\tdqp->q_res_bcount = be64_to_cpu(ddqp->d_bcount);\n\tdqp->q_res_icount = be64_to_cpu(ddqp->d_icount);\n\tdqp->q_res_rtbcount = be64_to_cpu(ddqp->d_rtbcount);\n\n\t/* initialize the dquot speculative prealloc thresholds */\n\txfs_dquot_set_prealloc_limits(dqp);\n\n\t/* Mark the buf so that this will stay incore a little longer */\n\txfs_buf_set_ref(bp, XFS_DQUOT_REF);\n\n\t/*\n\t * We got the buffer with a xfs_trans_read_buf() (in dqtobp())\n\t * So we need to release with xfs_trans_brelse().\n\t * The strategy here is identical to that of inodes; we lock\n\t * the dquot in xfs_qm_dqget() before making it accessible to\n\t * others. This is because dquots, like inodes, need a good level of\n\t * concurrency, and we don't want to take locks on the entire buffers\n\t * for dquot accesses.\n\t * Note also that the dquot buffer may even be dirty at this point, if\n\t * this particular dquot was repaired. We still aren't afraid to\n\t * brelse it because we have the changes incore.\n\t */\n\tASSERT(xfs_buf_islocked(bp));\n\txfs_trans_brelse(tp, bp);\n\n\tif (tp) {\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\t*O_dqpp = dqp;\n\treturn error;\n\nerror1:\n\tif (tp)\n\t\txfs_trans_cancel(tp, cancelflags);\nerror0:\n\txfs_qm_dqdestroy(dqp);\n\t*O_dqpp = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_calc_dquots_per_chunk",
          "args": [
            "qinf->qi_dqchunklen"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_calc_dquots_per_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dquot_buf.c",
          "lines": "34-45",
          "snippet": "int\nxfs_calc_dquots_per_chunk(\n\tunsigned int\t\tnbblks)\t/* basic block units */\n{\n\tunsigned int\tndquots;\n\n\tASSERT(nbblks > 0);\n\tndquots = BBTOB(nbblks);\n\tdo_div(ndquots, sizeof(xfs_dqblk_t));\n\n\treturn ndquots;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_calc_dquots_per_chunk(\n\tunsigned int\t\tnbblks)\t/* basic block units */\n{\n\tunsigned int\tndquots;\n\n\tASSERT(nbblks > 0);\n\tndquots = BBTOB(nbblks);\n\tdo_div(ndquots, sizeof(xfs_dqblk_t));\n\n\treturn ndquots;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "XFS_DQUOT_CLUSTER_SIZE_FSB"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&qinf->qi_quotaofflock"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&qinf->qi_tree_lock"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&qinf->qi_pquota_tree",
            "GFP_NOFS"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&qinf->qi_gquota_tree",
            "GFP_NOFS"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&qinf->qi_uquota_tree",
            "GFP_NOFS"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_init_quotainos",
          "args": [
            "mp"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_init_quotainos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1476-1563",
          "snippet": "STATIC int\nxfs_qm_init_quotainos(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tflags = 0;\n\n\tASSERT(mp->m_quotainfo);\n\n\t/*\n\t * Get the uquota and gquota inodes\n\t */\n\tif (xfs_sb_version_hasquota(&mp->m_sb)) {\n\t\tif (XFS_IS_UQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_uquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t     0, 0, &uip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (XFS_IS_GQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_gquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t     0, 0, &gip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t\tif (XFS_IS_PQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_pquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t     0, 0, &pip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t} else {\n\t\tflags |= XFS_QMOPT_SBVERSION;\n\t}\n\n\t/*\n\t * Create the three inodes, if they don't exist already. The changes\n\t * made above will get added to a transaction and logged in one of\n\t * the qino_alloc calls below.  If the device is readonly,\n\t * temporarily switch to read-write to do this.\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp) && uip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &uip,\n\t\t\t\t\t      flags | XFS_QMOPT_UQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp) && gip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &gip,\n\t\t\t\t\t  flags | XFS_QMOPT_GQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp) && pip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &pip,\n\t\t\t\t\t  flags | XFS_QMOPT_PQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\t}\n\n\tmp->m_quotainfo->qi_uquotaip = uip;\n\tmp->m_quotainfo->qi_gquotaip = gip;\n\tmp->m_quotainfo->qi_pquotaip = pip;\n\n\treturn 0;\n\nerror_rele:\n\tif (uip)\n\t\tIRELE(uip);\n\tif (gip)\n\t\tIRELE(gip);\n\tif (pip)\n\t\tIRELE(pip);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nSTATIC int\nxfs_qm_init_quotainos(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tflags = 0;\n\n\tASSERT(mp->m_quotainfo);\n\n\t/*\n\t * Get the uquota and gquota inodes\n\t */\n\tif (xfs_sb_version_hasquota(&mp->m_sb)) {\n\t\tif (XFS_IS_UQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_uquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t     0, 0, &uip);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (XFS_IS_GQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_gquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t     0, 0, &gip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t\tif (XFS_IS_PQUOTA_ON(mp) &&\n\t\t    mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\t\tASSERT(mp->m_sb.sb_pquotino > 0);\n\t\t\terror = xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t     0, 0, &pip);\n\t\t\tif (error)\n\t\t\t\tgoto error_rele;\n\t\t}\n\t} else {\n\t\tflags |= XFS_QMOPT_SBVERSION;\n\t}\n\n\t/*\n\t * Create the three inodes, if they don't exist already. The changes\n\t * made above will get added to a transaction and logged in one of\n\t * the qino_alloc calls below.  If the device is readonly,\n\t * temporarily switch to read-write to do this.\n\t */\n\tif (XFS_IS_UQUOTA_ON(mp) && uip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &uip,\n\t\t\t\t\t      flags | XFS_QMOPT_UQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_GQUOTA_ON(mp) && gip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &gip,\n\t\t\t\t\t  flags | XFS_QMOPT_GQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\n\t\tflags &= ~XFS_QMOPT_SBVERSION;\n\t}\n\tif (XFS_IS_PQUOTA_ON(mp) && pip == NULL) {\n\t\terror = xfs_qm_qino_alloc(mp, &pip,\n\t\t\t\t\t  flags | XFS_QMOPT_PQUOTA);\n\t\tif (error)\n\t\t\tgoto error_rele;\n\t}\n\n\tmp->m_quotainfo->qi_uquotaip = uip;\n\tmp->m_quotainfo->qi_gquotaip = gip;\n\tmp->m_quotainfo->qi_pquotaip = pip;\n\n\treturn 0;\n\nerror_rele:\n\tif (uip)\n\t\tIRELE(uip);\n\tif (gip)\n\t\tIRELE(gip);\n\tif (pip)\n\t\tIRELE(pip);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_init",
          "args": [
            "&qinf->qi_lru"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(xfs_quotainfo_t)",
            "KM_SLEEP"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IS_QUOTA_RUNNING(mp)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_init_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qinf;\n\tint\t\terror;\n\txfs_dquot_t\t*dqp;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tqinf = mp->m_quotainfo = kmem_zalloc(sizeof(xfs_quotainfo_t), KM_SLEEP);\n\n\terror = list_lru_init(&qinf->qi_lru);\n\tif (error)\n\t\tgoto out_free_qinf;\n\n\t/*\n\t * See if quotainodes are setup, and if not, allocate them,\n\t * and change the superblock accordingly.\n\t */\n\terror = xfs_qm_init_quotainos(mp);\n\tif (error)\n\t\tgoto out_free_lru;\n\n\tINIT_RADIX_TREE(&qinf->qi_uquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_gquota_tree, GFP_NOFS);\n\tINIT_RADIX_TREE(&qinf->qi_pquota_tree, GFP_NOFS);\n\tmutex_init(&qinf->qi_tree_lock);\n\n\t/* mutex used to serialize quotaoffs */\n\tmutex_init(&qinf->qi_quotaofflock);\n\n\t/* Precalc some constants */\n\tqinf->qi_dqchunklen = XFS_FSB_TO_BB(mp, XFS_DQUOT_CLUSTER_SIZE_FSB);\n\tqinf->qi_dqperchunk = xfs_calc_dquots_per_chunk(qinf->qi_dqchunklen);\n\n\tmp->m_qflags |= (mp->m_sb.sb_qflags & XFS_ALL_QUOTA_CHKD);\n\n\t/*\n\t * We try to get the limits from the superuser's limits fields.\n\t * This is quite hacky, but it is standard quota practice.\n\t *\n\t * We look at the USR dquot with id == 0 first, but if user quotas\n\t * are not enabled we goto the GRP dquot with id == 0.\n\t * We don't really care to keep separate default limits for user\n\t * and group quotas, at least not at this point.\n\t *\n\t * Since we may not have done a quotacheck by this point, just read\n\t * the dquot without attaching it to any hashtables or lists.\n\t */\n\terror = xfs_qm_dqread(mp, 0,\n\t\t\tXFS_IS_UQUOTA_RUNNING(mp) ? XFS_DQ_USER :\n\t\t\t (XFS_IS_GQUOTA_RUNNING(mp) ? XFS_DQ_GROUP :\n\t\t\t  XFS_DQ_PROJ),\n\t\t\tXFS_QMOPT_DOWARN, &dqp);\n\tif (!error) {\n\t\txfs_disk_dquot_t\t*ddqp = &dqp->q_core;\n\n\t\t/*\n\t\t * The warnings and timers set the grace period given to\n\t\t * a user or group before he or she can not perform any\n\t\t * more writing. If it is zero, a default is used.\n\t\t */\n\t\tqinf->qi_btimelimit = ddqp->d_btimer ?\n\t\t\tbe32_to_cpu(ddqp->d_btimer) : XFS_QM_BTIMELIMIT;\n\t\tqinf->qi_itimelimit = ddqp->d_itimer ?\n\t\t\tbe32_to_cpu(ddqp->d_itimer) : XFS_QM_ITIMELIMIT;\n\t\tqinf->qi_rtbtimelimit = ddqp->d_rtbtimer ?\n\t\t\tbe32_to_cpu(ddqp->d_rtbtimer) : XFS_QM_RTBTIMELIMIT;\n\t\tqinf->qi_bwarnlimit = ddqp->d_bwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_bwarns) : XFS_QM_BWARNLIMIT;\n\t\tqinf->qi_iwarnlimit = ddqp->d_iwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_iwarns) : XFS_QM_IWARNLIMIT;\n\t\tqinf->qi_rtbwarnlimit = ddqp->d_rtbwarns ?\n\t\t\tbe16_to_cpu(ddqp->d_rtbwarns) : XFS_QM_RTBWARNLIMIT;\n\t\tqinf->qi_bhardlimit = be64_to_cpu(ddqp->d_blk_hardlimit);\n\t\tqinf->qi_bsoftlimit = be64_to_cpu(ddqp->d_blk_softlimit);\n\t\tqinf->qi_ihardlimit = be64_to_cpu(ddqp->d_ino_hardlimit);\n\t\tqinf->qi_isoftlimit = be64_to_cpu(ddqp->d_ino_softlimit);\n\t\tqinf->qi_rtbhardlimit = be64_to_cpu(ddqp->d_rtb_hardlimit);\n\t\tqinf->qi_rtbsoftlimit = be64_to_cpu(ddqp->d_rtb_softlimit);\n\n\t\txfs_qm_dqdestroy(dqp);\n\t} else {\n\t\tqinf->qi_btimelimit = XFS_QM_BTIMELIMIT;\n\t\tqinf->qi_itimelimit = XFS_QM_ITIMELIMIT;\n\t\tqinf->qi_rtbtimelimit = XFS_QM_RTBTIMELIMIT;\n\t\tqinf->qi_bwarnlimit = XFS_QM_BWARNLIMIT;\n\t\tqinf->qi_iwarnlimit = XFS_QM_IWARNLIMIT;\n\t\tqinf->qi_rtbwarnlimit = XFS_QM_RTBWARNLIMIT;\n\t}\n\n\tqinf->qi_shrinker.count_objects = xfs_qm_shrink_count;\n\tqinf->qi_shrinker.scan_objects = xfs_qm_shrink_scan;\n\tqinf->qi_shrinker.seeks = DEFAULT_SEEKS;\n\tqinf->qi_shrinker.flags = SHRINKER_NUMA_AWARE;\n\tregister_shrinker(&qinf->qi_shrinker);\n\treturn 0;\n\nout_free_lru:\n\tlist_lru_destroy(&qinf->qi_lru);\nout_free_qinf:\n\tkmem_free(qinf);\n\tmp->m_quotainfo = NULL;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_shrink_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "552-561",
    "snippet": "static unsigned long\nxfs_qm_shrink_count(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_quotainfo\t*qi = container_of(shrink,\n\t\t\t\t\tstruct xfs_quotainfo, qi_shrinker);\n\n\treturn list_lru_shrink_count(&qi->qi_lru, sc);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_shrink_count",
          "args": [
            "&qi->qi_lru",
            "sc"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "shrink",
            "structxfs_quotainfo",
            "qi_shrinker"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic unsigned long\nxfs_qm_shrink_count(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_quotainfo\t*qi = container_of(shrink,\n\t\t\t\t\tstruct xfs_quotainfo, qi_shrinker);\n\n\treturn list_lru_shrink_count(&qi->qi_lru, sc);\n}"
  },
  {
    "function_name": "xfs_qm_shrink_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "517-550",
    "snippet": "static unsigned long\nxfs_qm_shrink_scan(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_quotainfo\t*qi = container_of(shrink,\n\t\t\t\t\tstruct xfs_quotainfo, qi_shrinker);\n\tstruct xfs_qm_isolate\tisol;\n\tunsigned long\t\tfreed;\n\tint\t\t\terror;\n\n\tif ((sc->gfp_mask & (__GFP_FS|__GFP_WAIT)) != (__GFP_FS|__GFP_WAIT))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&isol.buffers);\n\tINIT_LIST_HEAD(&isol.dispose);\n\n\tfreed = list_lru_shrink_walk(&qi->qi_lru, sc,\n\t\t\t\t     xfs_qm_dquot_isolate, &isol);\n\n\terror = xfs_buf_delwri_submit(&isol.buffers);\n\tif (error)\n\t\txfs_warn(NULL, \"%s: dquot reclaim failed\", __func__);\n\n\twhile (!list_empty(&isol.dispose)) {\n\t\tstruct xfs_dquot\t*dqp;\n\n\t\tdqp = list_first_entry(&isol.dispose, struct xfs_dquot, q_lru);\n\t\tlist_del_init(&dqp->q_lru);\n\t\txfs_qm_dqfree_one(dqp);\n\t}\n\n\treturn freed;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqfree_one",
          "args": [
            "dqp"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqfree_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1565-1580",
          "snippet": "STATIC void\nxfs_qm_dqfree_one(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\n\tmutex_lock(&qi->qi_tree_lock);\n\tradix_tree_delete(xfs_dquot_tree(qi, dqp->q_core.d_flags),\n\t\t\t  be32_to_cpu(dqp->q_core.d_id));\n\n\tqi->qi_dquots--;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n\txfs_qm_dqdestroy(dqp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC void\nxfs_qm_dqfree_one(\n\tstruct xfs_dquot\t*dqp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\n\tmutex_lock(&qi->qi_tree_lock);\n\tradix_tree_delete(xfs_dquot_tree(qi, dqp->q_core.d_flags),\n\t\t\t  be32_to_cpu(dqp->q_core.d_id));\n\n\tqi->qi_dquots--;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n\txfs_qm_dqdestroy(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dqp->q_lru"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&isol.dispose",
            "structxfs_dquot",
            "q_lru"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&isol.dispose"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "NULL",
            "\"%s: dquot reclaim failed\"",
            "__func__"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_submit",
          "args": [
            "&isol.buffers"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_submit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1856-1881",
          "snippet": "int\nxfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\tint\t\t\terror = 0, error2;\n\tstruct xfs_buf\t\t*bp;\n\n\t__xfs_buf_delwri_submit(buffer_list, &io_list, true);\n\n\t/* Wait for IO to complete. */\n\twhile (!list_empty(&io_list)) {\n\t\tbp = list_first_entry(&io_list, struct xfs_buf, b_list);\n\n\t\tlist_del_init(&bp->b_list);\n\n\t\t/* locking the buffer will wait for async IO completion. */\n\t\txfs_buf_lock(bp);\n\t\terror2 = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_delwri_submit(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\tint\t\t\terror = 0, error2;\n\tstruct xfs_buf\t\t*bp;\n\n\t__xfs_buf_delwri_submit(buffer_list, &io_list, true);\n\n\t/* Wait for IO to complete. */\n\twhile (!list_empty(&io_list)) {\n\t\tbp = list_first_entry(&io_list, struct xfs_buf, b_list);\n\n\t\tlist_del_init(&bp->b_list);\n\n\t\t/* locking the buffer will wait for async IO completion. */\n\t\txfs_buf_lock(bp);\n\t\terror2 = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\tif (!error)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_walk",
          "args": [
            "&qi->qi_lru",
            "sc",
            "xfs_qm_dquot_isolate",
            "&isol"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&isol.dispose"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&isol.buffers"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "shrink",
            "structxfs_quotainfo",
            "qi_shrinker"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nstatic unsigned long\nxfs_qm_shrink_scan(\n\tstruct shrinker\t\t*shrink,\n\tstruct shrink_control\t*sc)\n{\n\tstruct xfs_quotainfo\t*qi = container_of(shrink,\n\t\t\t\t\tstruct xfs_quotainfo, qi_shrinker);\n\tstruct xfs_qm_isolate\tisol;\n\tunsigned long\t\tfreed;\n\tint\t\t\terror;\n\n\tif ((sc->gfp_mask & (__GFP_FS|__GFP_WAIT)) != (__GFP_FS|__GFP_WAIT))\n\t\treturn 0;\n\n\tINIT_LIST_HEAD(&isol.buffers);\n\tINIT_LIST_HEAD(&isol.dispose);\n\n\tfreed = list_lru_shrink_walk(&qi->qi_lru, sc,\n\t\t\t\t     xfs_qm_dquot_isolate, &isol);\n\n\terror = xfs_buf_delwri_submit(&isol.buffers);\n\tif (error)\n\t\txfs_warn(NULL, \"%s: dquot reclaim failed\", __func__);\n\n\twhile (!list_empty(&isol.dispose)) {\n\t\tstruct xfs_dquot\t*dqp;\n\n\t\tdqp = list_first_entry(&isol.dispose, struct xfs_dquot, q_lru);\n\t\tlist_del_init(&dqp->q_lru);\n\t\txfs_qm_dqfree_one(dqp);\n\t}\n\n\treturn freed;\n}"
  },
  {
    "function_name": "xfs_qm_dquot_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "430-515",
    "snippet": "static enum lru_status\nxfs_qm_dquot_isolate(\n\tstruct list_head\t*item,\n\tstruct list_lru_one\t*lru,\n\tspinlock_t\t\t*lru_lock,\n\tvoid\t\t\t*arg)\n\t\t__releases(lru_lock) __acquires(lru_lock)\n{\n\tstruct xfs_dquot\t*dqp = container_of(item,\n\t\t\t\t\t\tstruct xfs_dquot, q_lru);\n\tstruct xfs_qm_isolate\t*isol = arg;\n\n\tif (!xfs_dqlock_nowait(dqp))\n\t\tgoto out_miss_busy;\n\n\t/*\n\t * This dquot has acquired a reference in the meantime remove it from\n\t * the freelist and try again.\n\t */\n\tif (dqp->q_nrefs) {\n\t\txfs_dqunlock(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqwants);\n\n\t\ttrace_xfs_dqreclaim_want(dqp);\n\t\tlist_lru_isolate(lru, &dqp->q_lru);\n\t\tXFS_STATS_DEC(xs_qm_dquot_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t/*\n\t * If the dquot is dirty, flush it. If it's already being flushed, just\n\t * skip it so there is time for the IO to complete before we try to\n\t * reclaim it again on the next LRU pass.\n\t */\n\tif (!xfs_dqflock_nowait(dqp)) {\n\t\txfs_dqunlock(dqp);\n\t\tgoto out_miss_busy;\n\t}\n\n\tif (XFS_DQ_IS_DIRTY(dqp)) {\n\t\tstruct xfs_buf\t*bp = NULL;\n\t\tint\t\terror;\n\n\t\ttrace_xfs_dqreclaim_dirty(dqp);\n\n\t\t/* we have to drop the LRU lock to flush the dquot */\n\t\tspin_unlock(lru_lock);\n\n\t\terror = xfs_qm_dqflush(dqp, &bp);\n\t\tif (error) {\n\t\t\txfs_warn(dqp->q_mount, \"%s: dquot %p flush failed\",\n\t\t\t\t __func__, dqp);\n\t\t\tgoto out_unlock_dirty;\n\t\t}\n\n\t\txfs_buf_delwri_queue(bp, &isol->buffers);\n\t\txfs_buf_relse(bp);\n\t\tgoto out_unlock_dirty;\n\t}\n\txfs_dqfunlock(dqp);\n\n\t/*\n\t * Prevent lookups now that we are past the point of no return.\n\t */\n\tdqp->dq_flags |= XFS_DQ_FREEING;\n\txfs_dqunlock(dqp);\n\n\tASSERT(dqp->q_nrefs == 0);\n\tlist_lru_isolate_move(lru, &dqp->q_lru, &isol->dispose);\n\tXFS_STATS_DEC(xs_qm_dquot_unused);\n\ttrace_xfs_dqreclaim_done(dqp);\n\tXFS_STATS_INC(xs_qm_dqreclaims);\n\treturn LRU_REMOVED;\n\nout_miss_busy:\n\ttrace_xfs_dqreclaim_busy(dqp);\n\tXFS_STATS_INC(xs_qm_dqreclaim_misses);\n\treturn LRU_SKIP;\n\nout_unlock_dirty:\n\ttrace_xfs_dqreclaim_busy(dqp);\n\tXFS_STATS_INC(xs_qm_dqreclaim_misses);\n\txfs_dqunlock(dqp);\n\tspin_lock(lru_lock);\n\treturn LRU_RETRY;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lru_lock"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dqreclaim_misses"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqreclaim_busy",
          "args": [
            "dqp"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dqreclaim_misses"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqreclaim_busy",
          "args": [
            "dqp"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dqreclaims"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqreclaim_done",
          "args": [
            "dqp"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_DEC",
          "args": [
            "xs_qm_dquot_unused"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_isolate_move",
          "args": [
            "lru",
            "&dqp->q_lru",
            "&isol->dispose"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dqp->q_nrefs == 0"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqfunlock",
          "args": [
            "dqp"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqfunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "94-97",
          "snippet": "static inline void xfs_dqfunlock(xfs_dquot_t *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqfunlock(xfs_dquot_t *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_queue",
          "args": [
            "bp",
            "&isol->buffers"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1709-1744",
          "snippet": "bool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nbool\nxfs_buf_delwri_queue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct list_head\t*list)\n{\n\tASSERT(xfs_buf_islocked(bp));\n\tASSERT(!(bp->b_flags & XBF_READ));\n\n\t/*\n\t * If the buffer is already marked delwri it already is queued up\n\t * by someone else for imediate writeout.  Just ignore it in that\n\t * case.\n\t */\n\tif (bp->b_flags & _XBF_DELWRI_Q) {\n\t\ttrace_xfs_buf_delwri_queued(bp, _RET_IP_);\n\t\treturn false;\n\t}\n\n\ttrace_xfs_buf_delwri_queue(bp, _RET_IP_);\n\n\t/*\n\t * If a buffer gets written out synchronously or marked stale while it\n\t * is on a delwri list we lazily remove it. To do this, the other party\n\t * clears the  _XBF_DELWRI_Q flag but otherwise leaves the buffer alone.\n\t * It remains referenced and on the list.  In a rare corner case it\n\t * might get readded to a delwri list after the synchronous writeout, in\n\t * which case we need just need to re-add the flag here.\n\t */\n\tbp->b_flags |= _XBF_DELWRI_Q;\n\tif (list_empty(&bp->b_list)) {\n\t\tatomic_inc(&bp->b_hold);\n\t\tlist_add_tail(&bp->b_list, list);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "dqp->q_mount",
            "\"%s: dquot %p flush failed\"",
            "__func__",
            "dqp"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqflush",
          "args": [
            "dqp",
            "&bp"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "930-1048",
          "snippet": "int\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "lru_lock"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqreclaim_dirty",
          "args": [
            "dqp"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_DIRTY",
          "args": [
            "dqp"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqflock_nowait",
          "args": [
            "dqp"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqflock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "89-92",
          "snippet": "static inline bool xfs_dqflock_nowait(xfs_dquot_t *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool xfs_dqflock_nowait(xfs_dquot_t *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_DEC",
          "args": [
            "xs_qm_dquot_unused"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_isolate",
          "args": [
            "lru",
            "&dqp->q_lru"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqreclaim_want",
          "args": [
            "dqp"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_qm_dqwants"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqlock_nowait",
          "args": [
            "dqp"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "99-102",
          "snippet": "static inline int xfs_dqlock_nowait(struct xfs_dquot *dqp)\n{\n\treturn mutex_trylock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dqlock_nowait(struct xfs_dquot *dqp)\n{\n\treturn mutex_trylock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structxfs_dquot",
            "q_lru"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "lru_lock"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "lru_lock"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nstatic enum lru_status\nxfs_qm_dquot_isolate(\n\tstruct list_head\t*item,\n\tstruct list_lru_one\t*lru,\n\tspinlock_t\t\t*lru_lock,\n\tvoid\t\t\t*arg)\n\t\t__releases(lru_lock) __acquires(lru_lock)\n{\n\tstruct xfs_dquot\t*dqp = container_of(item,\n\t\t\t\t\t\tstruct xfs_dquot, q_lru);\n\tstruct xfs_qm_isolate\t*isol = arg;\n\n\tif (!xfs_dqlock_nowait(dqp))\n\t\tgoto out_miss_busy;\n\n\t/*\n\t * This dquot has acquired a reference in the meantime remove it from\n\t * the freelist and try again.\n\t */\n\tif (dqp->q_nrefs) {\n\t\txfs_dqunlock(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqwants);\n\n\t\ttrace_xfs_dqreclaim_want(dqp);\n\t\tlist_lru_isolate(lru, &dqp->q_lru);\n\t\tXFS_STATS_DEC(xs_qm_dquot_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t/*\n\t * If the dquot is dirty, flush it. If it's already being flushed, just\n\t * skip it so there is time for the IO to complete before we try to\n\t * reclaim it again on the next LRU pass.\n\t */\n\tif (!xfs_dqflock_nowait(dqp)) {\n\t\txfs_dqunlock(dqp);\n\t\tgoto out_miss_busy;\n\t}\n\n\tif (XFS_DQ_IS_DIRTY(dqp)) {\n\t\tstruct xfs_buf\t*bp = NULL;\n\t\tint\t\terror;\n\n\t\ttrace_xfs_dqreclaim_dirty(dqp);\n\n\t\t/* we have to drop the LRU lock to flush the dquot */\n\t\tspin_unlock(lru_lock);\n\n\t\terror = xfs_qm_dqflush(dqp, &bp);\n\t\tif (error) {\n\t\t\txfs_warn(dqp->q_mount, \"%s: dquot %p flush failed\",\n\t\t\t\t __func__, dqp);\n\t\t\tgoto out_unlock_dirty;\n\t\t}\n\n\t\txfs_buf_delwri_queue(bp, &isol->buffers);\n\t\txfs_buf_relse(bp);\n\t\tgoto out_unlock_dirty;\n\t}\n\txfs_dqfunlock(dqp);\n\n\t/*\n\t * Prevent lookups now that we are past the point of no return.\n\t */\n\tdqp->dq_flags |= XFS_DQ_FREEING;\n\txfs_dqunlock(dqp);\n\n\tASSERT(dqp->q_nrefs == 0);\n\tlist_lru_isolate_move(lru, &dqp->q_lru, &isol->dispose);\n\tXFS_STATS_DEC(xs_qm_dquot_unused);\n\ttrace_xfs_dqreclaim_done(dqp);\n\tXFS_STATS_INC(xs_qm_dqreclaims);\n\treturn LRU_REMOVED;\n\nout_miss_busy:\n\ttrace_xfs_dqreclaim_busy(dqp);\n\tXFS_STATS_INC(xs_qm_dqreclaim_misses);\n\treturn LRU_SKIP;\n\nout_unlock_dirty:\n\ttrace_xfs_dqreclaim_busy(dqp);\n\tXFS_STATS_INC(xs_qm_dqreclaim_misses);\n\txfs_dqunlock(dqp);\n\tspin_lock(lru_lock);\n\treturn LRU_RETRY;\n}"
  },
  {
    "function_name": "xfs_qm_dqdetach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "401-423",
    "snippet": "void\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "ip->i_pdquot"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_is_quota_inode",
          "args": [
            "&ip->i_mount->m_sb",
            "ip->i_ino"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_is_quota_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "575-581",
          "snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dquot_dqdetach",
          "args": [
            "ip"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}"
  },
  {
    "function_name": "xfs_qm_dqattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "379-394",
    "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach_locked",
          "args": [
            "ip",
            "flags"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "330-377",
          "snippet": "int\nxfs_qm_dqattach_locked(\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror = 0;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (XFS_IS_UQUOTA_ON(mp) && !ip->i_udquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_uid, XFS_DQ_USER,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_udquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_udquot);\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp) && !ip->i_gdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_gid, XFS_DQ_GROUP,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_gdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_gdquot);\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp) && !ip->i_pdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, xfs_get_projid(ip), XFS_DQ_PROJ,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_pdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_pdquot);\n\t}\n\ndone:\n\t/*\n\t * Don't worry about the dquots that we may have attached before any\n\t * error - they'll get detached later if it has not already been done.\n\t */\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nint\nxfs_qm_dqattach_locked(\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror = 0;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (XFS_IS_UQUOTA_ON(mp) && !ip->i_udquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_uid, XFS_DQ_USER,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_udquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_udquot);\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp) && !ip->i_gdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_gid, XFS_DQ_GROUP,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_gdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_gdquot);\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp) && !ip->i_pdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, xfs_get_projid(ip), XFS_DQ_PROJ,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_pdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_pdquot);\n\t}\n\ndone:\n\t/*\n\t * Don't worry about the dquots that we may have attached before any\n\t * error - they'll get detached later if it has not already been done.\n\t */\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_need_dqattach",
          "args": [
            "ip"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_need_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "306-321",
          "snippet": "static bool\nxfs_qm_need_dqattach(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn false;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn false;\n\tif (!XFS_NOT_DQATTACHED(mp, ip))\n\t\treturn false;\n\tif (xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_qm_need_dqattach(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn false;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn false;\n\tif (!XFS_NOT_DQATTACHED(mp, ip))\n\t\treturn false;\n\tif (xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_dqattach_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "330-377",
    "snippet": "int\nxfs_qm_dqattach_locked(\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror = 0;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (XFS_IS_UQUOTA_ON(mp) && !ip->i_udquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_uid, XFS_DQ_USER,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_udquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_udquot);\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp) && !ip->i_gdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_gid, XFS_DQ_GROUP,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_gdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_gdquot);\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp) && !ip->i_pdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, xfs_get_projid(ip), XFS_DQ_PROJ,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_pdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_pdquot);\n\t}\n\ndone:\n\t/*\n\t * Don't worry about the dquots that we may have attached before any\n\t * error - they'll get detached later if it has not already been done.\n\t */\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_pdquot"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach_one",
          "args": [
            "ip",
            "xfs_get_projid(ip)",
            "XFS_DQ_PROJ",
            "flags & XFS_QMOPT_DQALLOC",
            "&ip->i_pdquot"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "259-304",
          "snippet": "STATIC int\nxfs_qm_dqattach_one(\n\txfs_inode_t\t*ip,\n\txfs_dqid_t\tid,\n\tuint\t\ttype,\n\tuint\t\tdoalloc,\n\txfs_dquot_t\t**IO_idqpp)\n{\n\txfs_dquot_t\t*dqp;\n\tint\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\terror = 0;\n\n\t/*\n\t * See if we already have it in the inode itself. IO_idqpp is &i_udquot\n\t * or &i_gdquot. This made the code look weird, but made the logic a lot\n\t * simpler.\n\t */\n\tdqp = *IO_idqpp;\n\tif (dqp) {\n\t\ttrace_xfs_dqattach_found(dqp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Find the dquot from somewhere. This bumps the reference count of\n\t * dquot and returns it locked.  This can return ENOENT if dquot didn't\n\t * exist on disk and we didn't ask it to allocate; ESRCH if quotas got\n\t * turned off suddenly.\n\t */\n\terror = xfs_qm_dqget(ip->i_mount, ip, id, type,\n\t\t\t     doalloc | XFS_QMOPT_DOWARN, &dqp);\n\tif (error)\n\t\treturn error;\n\n\ttrace_xfs_dqattach_get(dqp);\n\n\t/*\n\t * dqget may have dropped and re-acquired the ilock, but it guarantees\n\t * that the dquot returned is the one that should go in the inode.\n\t */\n\t*IO_idqpp = dqp;\n\txfs_dqunlock(dqp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_dqattach_one(\n\txfs_inode_t\t*ip,\n\txfs_dqid_t\tid,\n\tuint\t\ttype,\n\tuint\t\tdoalloc,\n\txfs_dquot_t\t**IO_idqpp)\n{\n\txfs_dquot_t\t*dqp;\n\tint\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\terror = 0;\n\n\t/*\n\t * See if we already have it in the inode itself. IO_idqpp is &i_udquot\n\t * or &i_gdquot. This made the code look weird, but made the logic a lot\n\t * simpler.\n\t */\n\tdqp = *IO_idqpp;\n\tif (dqp) {\n\t\ttrace_xfs_dqattach_found(dqp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Find the dquot from somewhere. This bumps the reference count of\n\t * dquot and returns it locked.  This can return ENOENT if dquot didn't\n\t * exist on disk and we didn't ask it to allocate; ESRCH if quotas got\n\t * turned off suddenly.\n\t */\n\terror = xfs_qm_dqget(ip->i_mount, ip, id, type,\n\t\t\t     doalloc | XFS_QMOPT_DOWARN, &dqp);\n\tif (error)\n\t\treturn error;\n\n\ttrace_xfs_dqattach_get(dqp);\n\n\t/*\n\t * dqget may have dropped and re-acquired the ilock, but it guarantees\n\t * that the dquot returned is the one that should go in the inode.\n\t */\n\t*IO_idqpp = dqp;\n\txfs_dqunlock(dqp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_gdquot"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_udquot"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_need_dqattach",
          "args": [
            "ip"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_need_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "306-321",
          "snippet": "static bool\nxfs_qm_need_dqattach(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn false;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn false;\n\tif (!XFS_NOT_DQATTACHED(mp, ip))\n\t\treturn false;\n\tif (xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_qm_need_dqattach(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn false;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn false;\n\tif (!XFS_NOT_DQATTACHED(mp, ip))\n\t\treturn false;\n\tif (xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nint\nxfs_qm_dqattach_locked(\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror = 0;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (XFS_IS_UQUOTA_ON(mp) && !ip->i_udquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_uid, XFS_DQ_USER,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_udquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_udquot);\n\t}\n\n\tif (XFS_IS_GQUOTA_ON(mp) && !ip->i_gdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, ip->i_d.di_gid, XFS_DQ_GROUP,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_gdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_gdquot);\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(mp) && !ip->i_pdquot) {\n\t\terror = xfs_qm_dqattach_one(ip, xfs_get_projid(ip), XFS_DQ_PROJ,\n\t\t\t\t\t\tflags & XFS_QMOPT_DQALLOC,\n\t\t\t\t\t\t&ip->i_pdquot);\n\t\tif (error)\n\t\t\tgoto done;\n\t\tASSERT(ip->i_pdquot);\n\t}\n\ndone:\n\t/*\n\t * Don't worry about the dquots that we may have attached before any\n\t * error - they'll get detached later if it has not already been done.\n\t */\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_qm_need_dqattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "306-321",
    "snippet": "static bool\nxfs_qm_need_dqattach(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn false;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn false;\n\tif (!XFS_NOT_DQATTACHED(mp, ip))\n\t\treturn false;\n\tif (xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_is_quota_inode",
          "args": [
            "&mp->m_sb",
            "ip->i_ino"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_is_quota_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "575-581",
          "snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_is_quota_inode(struct xfs_sb *sbp, xfs_ino_t ino)\n{\n\treturn (ino == sbp->sb_uquotino ||\n\t\tino == sbp->sb_gquotino ||\n\t\tino == sbp->sb_pquotino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_NOT_DQATTACHED",
          "args": [
            "mp",
            "ip"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_qm_need_dqattach(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn false;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn false;\n\tif (!XFS_NOT_DQATTACHED(mp, ip))\n\t\treturn false;\n\tif (xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_qm_dqattach_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "259-304",
    "snippet": "STATIC int\nxfs_qm_dqattach_one(\n\txfs_inode_t\t*ip,\n\txfs_dqid_t\tid,\n\tuint\t\ttype,\n\tuint\t\tdoalloc,\n\txfs_dquot_t\t**IO_idqpp)\n{\n\txfs_dquot_t\t*dqp;\n\tint\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\terror = 0;\n\n\t/*\n\t * See if we already have it in the inode itself. IO_idqpp is &i_udquot\n\t * or &i_gdquot. This made the code look weird, but made the logic a lot\n\t * simpler.\n\t */\n\tdqp = *IO_idqpp;\n\tif (dqp) {\n\t\ttrace_xfs_dqattach_found(dqp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Find the dquot from somewhere. This bumps the reference count of\n\t * dquot and returns it locked.  This can return ENOENT if dquot didn't\n\t * exist on disk and we didn't ask it to allocate; ESRCH if quotas got\n\t * turned off suddenly.\n\t */\n\terror = xfs_qm_dqget(ip->i_mount, ip, id, type,\n\t\t\t     doalloc | XFS_QMOPT_DOWARN, &dqp);\n\tif (error)\n\t\treturn error;\n\n\ttrace_xfs_dqattach_get(dqp);\n\n\t/*\n\t * dqget may have dropped and re-acquired the ilock, but it guarantees\n\t * that the dquot returned is the one that should go in the inode.\n\t */\n\t*IO_idqpp = dqp;\n\txfs_dqunlock(dqp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqattach_get",
          "args": [
            "dqp"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqget",
          "args": [
            "ip->i_mount",
            "ip",
            "id",
            "type",
            "doalloc | XFS_QMOPT_DOWARN",
            "&dqp"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "698-831",
          "snippet": "int\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqget(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\t  /* locked inode (optional) */\n\txfs_dqid_t\tid,\t  /* uid/projid/gid depending on type */\n\tuint\t\ttype,\t  /* XFS_DQ_USER/XFS_DQ_PROJ/XFS_DQ_GROUP */\n\tuint\t\tflags,\t  /* DQALLOC, DQSUSER, DQREPAIR, DOWARN */\n\txfs_dquot_t\t**O_dqpp) /* OUT : locked incore dquot */\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root *tree = xfs_dquot_tree(qi, type);\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\tif ((! XFS_IS_UQUOTA_ON(mp) && type == XFS_DQ_USER) ||\n\t    (! XFS_IS_PQUOTA_ON(mp) && type == XFS_DQ_PROJ) ||\n\t    (! XFS_IS_GQUOTA_ON(mp) && type == XFS_DQ_GROUP)) {\n\t\treturn -ESRCH;\n\t}\n\n#ifdef DEBUG\n\tif (xfs_do_dqerror) {\n\t\tif ((xfs_dqerror_target == mp->m_ddev_targp) &&\n\t\t    (xfs_dqreq_num++ % xfs_dqerror_mod) == 0) {\n\t\t\txfs_debug(mp, \"Returning error in dqget\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tASSERT(type == XFS_DQ_USER ||\n\t       type == XFS_DQ_PROJ ||\n\t       type == XFS_DQ_GROUP);\n\tif (ip) {\n\t\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\t\tASSERT(xfs_inode_dquot(ip, type) == NULL);\n\t}\n#endif\n\nrestart:\n\tmutex_lock(&qi->qi_tree_lock);\n\tdqp = radix_tree_lookup(tree, id);\n\tif (dqp) {\n\t\txfs_dqlock(dqp);\n\t\tif (dqp->dq_flags & XFS_DQ_FREEING) {\n\t\t\txfs_dqunlock(dqp);\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\ttrace_xfs_dqget_freeing(dqp);\n\t\t\tdelay(1);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tdqp->q_nrefs++;\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\ttrace_xfs_dqget_hit(dqp);\n\t\tXFS_STATS_INC(xs_qm_dqcachehits);\n\t\t*O_dqpp = dqp;\n\t\treturn 0;\n\t}\n\tmutex_unlock(&qi->qi_tree_lock);\n\tXFS_STATS_INC(xs_qm_dqcachemisses);\n\n\t/*\n\t * Dquot cache miss. We don't want to keep the inode lock across\n\t * a (potential) disk read. Also we don't want to deal with the lock\n\t * ordering between quotainode and this inode. OTOH, dropping the inode\n\t * lock here means dealing with a chown that can happen before\n\t * we re-acquire the lock.\n\t */\n\tif (ip)\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\terror = xfs_qm_dqread(mp, id, type, flags, &dqp);\n\n\tif (ip)\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\tif (error)\n\t\treturn error;\n\n\tif (ip) {\n\t\t/*\n\t\t * A dquot could be attached to this inode by now, since\n\t\t * we had dropped the ilock.\n\t\t */\n\t\tif (xfs_this_quota_on(mp, type)) {\n\t\t\tstruct xfs_dquot\t*dqp1;\n\n\t\t\tdqp1 = xfs_inode_dquot(ip, type);\n\t\t\tif (dqp1) {\n\t\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\t\tdqp = dqp1;\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tgoto dqret;\n\t\t\t}\n\t\t} else {\n\t\t\t/* inode stays locked on return */\n\t\t\txfs_qm_dqdestroy(dqp);\n\t\t\treturn -ESRCH;\n\t\t}\n\t}\n\n\tmutex_lock(&qi->qi_tree_lock);\n\terror = radix_tree_insert(tree, id, dqp);\n\tif (unlikely(error)) {\n\t\tWARN_ON(error != -EEXIST);\n\n\t\t/*\n\t\t * Duplicate found. Just throw away the new dquot and start\n\t\t * over.\n\t\t */\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\ttrace_xfs_dqget_dup(dqp);\n\t\txfs_qm_dqdestroy(dqp);\n\t\tXFS_STATS_INC(xs_qm_dquot_dups);\n\t\tgoto restart;\n\t}\n\n\t/*\n\t * We return a locked dquot to the caller, with a reference taken\n\t */\n\txfs_dqlock(dqp);\n\tdqp->q_nrefs = 1;\n\n\tqi->qi_dquots++;\n\tmutex_unlock(&qi->qi_tree_lock);\n\n dqret:\n\tASSERT((ip == NULL) || xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\ttrace_xfs_dqget_miss(dqp);\n\t*O_dqpp = dqp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dqattach_found",
          "args": [
            "dqp"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_dqattach_one(\n\txfs_inode_t\t*ip,\n\txfs_dqid_t\tid,\n\tuint\t\ttype,\n\tuint\t\tdoalloc,\n\txfs_dquot_t\t**IO_idqpp)\n{\n\txfs_dquot_t\t*dqp;\n\tint\t\terror;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\terror = 0;\n\n\t/*\n\t * See if we already have it in the inode itself. IO_idqpp is &i_udquot\n\t * or &i_gdquot. This made the code look weird, but made the logic a lot\n\t * simpler.\n\t */\n\tdqp = *IO_idqpp;\n\tif (dqp) {\n\t\ttrace_xfs_dqattach_found(dqp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Find the dquot from somewhere. This bumps the reference count of\n\t * dquot and returns it locked.  This can return ENOENT if dquot didn't\n\t * exist on disk and we didn't ask it to allocate; ESRCH if quotas got\n\t * turned off suddenly.\n\t */\n\terror = xfs_qm_dqget(ip->i_mount, ip, id, type,\n\t\t\t     doalloc | XFS_QMOPT_DOWARN, &dqp);\n\tif (error)\n\t\treturn error;\n\n\ttrace_xfs_dqattach_get(dqp);\n\n\t/*\n\t * dqget may have dropped and re-acquired the ilock, but it guarantees\n\t * that the dquot returned is the one that should go in the inode.\n\t */\n\t*IO_idqpp = dqp;\n\txfs_dqunlock(dqp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_unmount_quotas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "225-257",
    "snippet": "void\nxfs_qm_unmount_quotas(\n\txfs_mount_t\t*mp)\n{\n\t/*\n\t * Release the dquots that root inode, et al might be holding,\n\t * before we flush quotas and blow away the quotainfo structure.\n\t */\n\tASSERT(mp->m_rootip);\n\txfs_qm_dqdetach(mp->m_rootip);\n\tif (mp->m_rbmip)\n\t\txfs_qm_dqdetach(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\txfs_qm_dqdetach(mp->m_rsumip);\n\n\t/*\n\t * Release the quota inodes.\n\t */\n\tif (mp->m_quotainfo) {\n\t\tif (mp->m_quotainfo->qi_uquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_uquotaip);\n\t\t\tmp->m_quotainfo->qi_uquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_gquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_gquotaip);\n\t\t\tmp->m_quotainfo->qi_gquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_pquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_pquotaip);\n\t\t\tmp->m_quotainfo->qi_pquotaip = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
      "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "mp->m_quotainfo->qi_pquotaip"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "mp->m_quotainfo->qi_gquotaip"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "mp->m_quotainfo->qi_uquotaip"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqdetach",
          "args": [
            "mp->m_rsumip"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqdetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "401-423",
          "snippet": "void\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqdetach(\n\txfs_inode_t\t*ip)\n{\n\tif (!(ip->i_udquot || ip->i_gdquot || ip->i_pdquot))\n\t\treturn;\n\n\ttrace_xfs_dquot_dqdetach(ip);\n\n\tASSERT(!xfs_is_quota_inode(&ip->i_mount->m_sb, ip->i_ino));\n\tif (ip->i_udquot) {\n\t\txfs_qm_dqrele(ip->i_udquot);\n\t\tip->i_udquot = NULL;\n\t}\n\tif (ip->i_gdquot) {\n\t\txfs_qm_dqrele(ip->i_gdquot);\n\t\tip->i_gdquot = NULL;\n\t}\n\tif (ip->i_pdquot) {\n\t\txfs_qm_dqrele(ip->i_pdquot);\n\t\tip->i_pdquot = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_rootip"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nvoid\nxfs_qm_unmount_quotas(\n\txfs_mount_t\t*mp)\n{\n\t/*\n\t * Release the dquots that root inode, et al might be holding,\n\t * before we flush quotas and blow away the quotainfo structure.\n\t */\n\tASSERT(mp->m_rootip);\n\txfs_qm_dqdetach(mp->m_rootip);\n\tif (mp->m_rbmip)\n\t\txfs_qm_dqdetach(mp->m_rbmip);\n\tif (mp->m_rsumip)\n\t\txfs_qm_dqdetach(mp->m_rsumip);\n\n\t/*\n\t * Release the quota inodes.\n\t */\n\tif (mp->m_quotainfo) {\n\t\tif (mp->m_quotainfo->qi_uquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_uquotaip);\n\t\t\tmp->m_quotainfo->qi_uquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_gquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_gquotaip);\n\t\t\tmp->m_quotainfo->qi_gquotaip = NULL;\n\t\t}\n\t\tif (mp->m_quotainfo->qi_pquotaip) {\n\t\t\tIRELE(mp->m_quotainfo->qi_pquotaip);\n\t\t\tmp->m_quotainfo->qi_pquotaip = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_qm_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "212-220",
    "snippet": "void\nxfs_qm_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_quotainfo) {\n\t\txfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_destroy_quotainfo",
          "args": [
            "mp"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_destroy_quotainfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "680-707",
          "snippet": "void\nxfs_qm_destroy_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\n\tif (qi->qi_uquotaip) {\n\t\tIRELE(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL; /* paranoia */\n\t}\n\tif (qi->qi_gquotaip) {\n\t\tIRELE(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\tIRELE(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_init_quotainos(xfs_mount_t *);",
            "STATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\txfs_qm_init_quotainos(xfs_mount_t *);\nSTATIC int\txfs_qm_init_quotainfo(xfs_mount_t *);\n\nvoid\nxfs_qm_destroy_quotainfo(\n\txfs_mount_t\t*mp)\n{\n\txfs_quotainfo_t *qi;\n\n\tqi = mp->m_quotainfo;\n\tASSERT(qi != NULL);\n\n\tunregister_shrinker(&qi->qi_shrinker);\n\tlist_lru_destroy(&qi->qi_lru);\n\n\tif (qi->qi_uquotaip) {\n\t\tIRELE(qi->qi_uquotaip);\n\t\tqi->qi_uquotaip = NULL; /* paranoia */\n\t}\n\tif (qi->qi_gquotaip) {\n\t\tIRELE(qi->qi_gquotaip);\n\t\tqi->qi_gquotaip = NULL;\n\t}\n\tif (qi->qi_pquotaip) {\n\t\tIRELE(qi->qi_pquotaip);\n\t\tqi->qi_pquotaip = NULL;\n\t}\n\tmutex_destroy(&qi->qi_quotaofflock);\n\tkmem_free(qi);\n\tmp->m_quotainfo = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqpurge_all",
          "args": [
            "mp",
            "XFS_QMOPT_QUOTALL"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqpurge_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "196-207",
          "snippet": "void\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags)\n{\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_GQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags)\n{\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_GQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_unmount(\n\tstruct xfs_mount\t*mp)\n{\n\tif (mp->m_quotainfo) {\n\t\txfs_qm_dqpurge_all(mp, XFS_QMOPT_QUOTALL);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t}\n}"
  },
  {
    "function_name": "xfs_qm_dqpurge_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "196-207",
    "snippet": "void\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags)\n{\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_GQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dquot_walk",
          "args": [
            "mp",
            "XFS_DQ_PROJ",
            "xfs_qm_dqpurge",
            "NULL"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dquot_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "61-122",
          "snippet": "STATIC int\nxfs_qm_dquot_walk(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\ttype,\n\tint\t\t\t(*execute)(struct xfs_dquot *dqp, void *data),\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tuint32_t\t\tnext_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tnr_found;\n\nrestart:\n\tskipped = 0;\n\tnext_index = 0;\n\tnr_found = 0;\n\n\twhile (1) {\n\t\tstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\tmutex_lock(&qi->qi_tree_lock);\n\t\tnr_found = radix_tree_gang_lookup(tree, (void **)batch,\n\t\t\t\t\tnext_index, XFS_DQ_LOOKUP_BATCH);\n\t\tif (!nr_found) {\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_dquot *dqp = batch[i];\n\n\t\t\tnext_index = be32_to_cpu(dqp->q_core.d_id) + 1;\n\n\t\t\terror = execute(batch[i], data);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (last_error == -EFSCORRUPTED) {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\n\treturn last_error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_DQ_LOOKUP_BATCH\t32"
          ],
          "globals_used": [
            "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_DQ_LOOKUP_BATCH\t32\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_dquot_walk(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\ttype,\n\tint\t\t\t(*execute)(struct xfs_dquot *dqp, void *data),\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tuint32_t\t\tnext_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tnr_found;\n\nrestart:\n\tskipped = 0;\n\tnext_index = 0;\n\tnr_found = 0;\n\n\twhile (1) {\n\t\tstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\tmutex_lock(&qi->qi_tree_lock);\n\t\tnr_found = radix_tree_gang_lookup(tree, (void **)batch,\n\t\t\t\t\tnext_index, XFS_DQ_LOOKUP_BATCH);\n\t\tif (!nr_found) {\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_dquot *dqp = batch[i];\n\n\t\t\tnext_index = be32_to_cpu(dqp->q_core.d_id) + 1;\n\n\t\t\terror = execute(batch[i], data);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (last_error == -EFSCORRUPTED) {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\n\treturn last_error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqpurge_all(\n\tstruct xfs_mount\t*mp,\n\tuint\t\t\tflags)\n{\n\tif (flags & XFS_QMOPT_UQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_USER, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_GQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_GROUP, xfs_qm_dqpurge, NULL);\n\tif (flags & XFS_QMOPT_PQUOTA)\n\t\txfs_qm_dquot_walk(mp, XFS_DQ_PROJ, xfs_qm_dqpurge, NULL);\n}"
  },
  {
    "function_name": "xfs_qm_dqpurge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "128-191",
    "snippet": "STATIC int\nxfs_qm_dqpurge(\n\tstruct xfs_dquot\t*dqp,\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\n\txfs_dqlock(dqp);\n\tif ((dqp->dq_flags & XFS_DQ_FREEING) || dqp->q_nrefs != 0) {\n\t\txfs_dqunlock(dqp);\n\t\treturn -EAGAIN;\n\t}\n\n\tdqp->dq_flags |= XFS_DQ_FREEING;\n\n\txfs_dqflock(dqp);\n\n\t/*\n\t * If we are turning this type of quotas off, we don't care\n\t * about the dirty metadata sitting in this dquot. OTOH, if\n\t * we're unmounting, we do care, so we flush it and wait.\n\t */\n\tif (XFS_DQ_IS_DIRTY(dqp)) {\n\t\tstruct xfs_buf\t*bp = NULL;\n\t\tint\t\terror;\n\n\t\t/*\n\t\t * We don't care about getting disk errors here. We need\n\t\t * to purge this dquot anyway, so we go ahead regardless.\n\t\t */\n\t\terror = xfs_qm_dqflush(dqp, &bp);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: dquot %p flush failed\",\n\t\t\t\t__func__, dqp);\n\t\t} else {\n\t\t\terror = xfs_bwrite(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\t\txfs_dqflock(dqp);\n\t}\n\n\tASSERT(atomic_read(&dqp->q_pincount) == 0);\n\tASSERT(XFS_FORCED_SHUTDOWN(mp) ||\n\t       !(dqp->q_logitem.qli_item.li_flags & XFS_LI_IN_AIL));\n\n\txfs_dqfunlock(dqp);\n\txfs_dqunlock(dqp);\n\n\tradix_tree_delete(xfs_dquot_tree(qi, dqp->q_core.d_flags),\n\t\t\t  be32_to_cpu(dqp->q_core.d_id));\n\tqi->qi_dquots--;\n\n\t/*\n\t * We move dquots to the freelist as soon as their reference count\n\t * hits zero, so it really should be on the freelist here.\n\t */\n\tASSERT(!list_empty(&dqp->q_lru));\n\tlist_lru_del(&qi->qi_lru, &dqp->q_lru);\n\tXFS_STATS_DEC(xs_qm_dquot_unused);\n\n\txfs_qm_dqdestroy(dqp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqdestroy",
          "args": [
            "dqp"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqdestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "71-81",
          "snippet": "void\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_zone\t\t*xfs_qm_dqzone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct kmem_zone\t\t*xfs_qm_dqzone;\n\nvoid\nxfs_qm_dqdestroy(\n\txfs_dquot_t\t*dqp)\n{\n\tASSERT(list_empty(&dqp->q_lru));\n\n\tmutex_destroy(&dqp->q_qlock);\n\tkmem_zone_free(xfs_qm_dqzone, dqp);\n\n\tXFS_STATS_DEC(xs_qm_dquot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_DEC",
          "args": [
            "xs_qm_dquot_unused"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&qi->qi_lru",
            "&dqp->q_lru"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!list_empty(&dqp->q_lru)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dqp->q_lru"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "xfs_dquot_tree(qi, dqp->q_core.d_flags)",
            "be32_to_cpu(dqp->q_core.d_id)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_id"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dquot_tree",
          "args": [
            "qi",
            "dqp->q_core.d_flags"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.h",
          "lines": "88-104",
          "snippet": "static inline struct radix_tree_root *\nxfs_dquot_tree(\n\tstruct xfs_quotainfo\t*qi,\n\tint\t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\treturn &qi->qi_uquota_tree;\n\tcase XFS_DQ_GROUP:\n\t\treturn &qi->qi_gquota_tree;\n\tcase XFS_DQ_PROJ:\n\t\treturn &qi->qi_pquota_tree;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n\nstatic inline struct radix_tree_root *\nxfs_dquot_tree(\n\tstruct xfs_quotainfo\t*qi,\n\tint\t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\treturn &qi->qi_uquota_tree;\n\tcase XFS_DQ_GROUP:\n\t\treturn &qi->qi_gquota_tree;\n\tcase XFS_DQ_PROJ:\n\t\treturn &qi->qi_pquota_tree;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqunlock",
          "args": [
            "dqp"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "109-112",
          "snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqunlock(struct xfs_dquot *dqp)\n{\n\tmutex_unlock(&dqp->q_qlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dqfunlock",
          "args": [
            "dqp"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqfunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "94-97",
          "snippet": "static inline void xfs_dqfunlock(xfs_dquot_t *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqfunlock(xfs_dquot_t *dqp)\n{\n\tcomplete(&dqp->q_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(mp) ||\n\t       !(dqp->q_logitem.qli_item.li_flags & XFS_LI_IN_AIL)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&dqp->q_pincount) == 0"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dqp->q_pincount"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqflock",
          "args": [
            "dqp"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqflock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "89-92",
          "snippet": "static inline bool xfs_dqflock_nowait(xfs_dquot_t *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool xfs_dqflock_nowait(xfs_dquot_t *dqp)\n{\n\treturn try_wait_for_completion(&dqp->q_flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bwrite",
          "args": [
            "bp"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1077-1095",
          "snippet": "int\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: dquot %p flush failed\"",
            "__func__",
            "dqp"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqflush",
          "args": [
            "dqp",
            "&bp"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "930-1048",
          "snippet": "int\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqflush(\n\tstruct xfs_dquot\t*dqp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_disk_dquot\t*ddqp;\n\tint\t\t\terror;\n\n\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\tASSERT(!completion_done(&dqp->q_flush));\n\n\ttrace_xfs_dqflush(dqp);\n\n\t*bpp = NULL;\n\n\txfs_qm_dqunpin_wait(dqp);\n\n\t/*\n\t * This may have been unpinned because the filesystem is shutting\n\t * down forcibly. If that's the case we must not write this dquot\n\t * to disk, because the log record didn't make it to disk.\n\t *\n\t * We also have to remove the log item from the AIL in this case,\n\t * as we wait for an emptry AIL as part of the unmount process.\n\t */\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item\t*lip = &dqp->q_logitem.qli_item;\n\t\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\t\tspin_lock(&mp->m_ail->xa_lock);\n\t\tif (lip->li_flags & XFS_LI_IN_AIL)\n\t\t\txfs_trans_ail_delete(mp->m_ail, lip,\n\t\t\t\t\t     SHUTDOWN_CORRUPT_INCORE);\n\t\telse\n\t\t\tspin_unlock(&mp->m_ail->xa_lock);\n\t\terror = -EIO;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Get the buffer containing the on-disk dquot\n\t */\n\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dqp->q_blkno,\n\t\t\t\t   mp->m_quotainfo->qi_dqchunklen, 0, &bp,\n\t\t\t\t   &xfs_dquot_buf_ops);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Calculate the location of the dquot inside the buffer.\n\t */\n\tddqp = bp->b_addr + dqp->q_bufoffset;\n\n\t/*\n\t * A simple sanity check in case we got a corrupted dquot..\n\t */\n\terror = xfs_dqcheck(mp, &dqp->q_core, be32_to_cpu(ddqp->d_id), 0,\n\t\t\t   XFS_QMOPT_DOWARN, \"dqflush (incore copy)\");\n\tif (error) {\n\t\txfs_buf_relse(bp);\n\t\txfs_dqfunlock(dqp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\treturn -EIO;\n\t}\n\n\t/* This is the only portion of data that needs to persist */\n\tmemcpy(ddqp, &dqp->q_core, sizeof(xfs_disk_dquot_t));\n\n\t/*\n\t * Clear the dirty field and remember the flush lsn for later use.\n\t */\n\tdqp->dq_flags &= ~XFS_DQ_DIRTY;\n\n\txfs_trans_ail_copy_lsn(mp->m_ail, &dqp->q_logitem.qli_flush_lsn,\n\t\t\t\t\t&dqp->q_logitem.qli_item.li_lsn);\n\n\t/*\n\t * copy the lsn into the on-disk dquot now while we have the in memory\n\t * dquot here. This can't be done later in the write verifier as we\n\t * can't get access to the log item at that point in time.\n\t *\n\t * We also calculate the CRC here so that the on-disk dquot in the\n\t * buffer always has a valid CRC. This ensures there is no possibility\n\t * of a dquot without an up-to-date CRC getting to disk.\n\t */\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dqblk *dqb = (struct xfs_dqblk *)ddqp;\n\n\t\tdqb->dd_lsn = cpu_to_be64(dqp->q_logitem.qli_item.li_lsn);\n\t\txfs_update_cksum((char *)dqb, sizeof(struct xfs_dqblk),\n\t\t\t\t XFS_DQUOT_CRC_OFF);\n\t}\n\n\t/*\n\t * Attach an iodone routine so that we can remove this dquot from the\n\t * AIL and release the flush lock once the dquot is synced to disk.\n\t */\n\txfs_buf_attach_iodone(bp, xfs_qm_dqflush_done,\n\t\t\t\t  &dqp->q_logitem.qli_item);\n\n\t/*\n\t * If the buffer is pinned then push on the log so we won't\n\t * get stuck waiting in the write for too long.\n\t */\n\tif (xfs_buf_ispinned(bp)) {\n\t\ttrace_xfs_dqflush_force(dqp);\n\t\txfs_log_force(mp, 0);\n\t}\n\n\ttrace_xfs_dqflush_done(dqp);\n\t*bpp = bp;\n\treturn 0;\n\nout_unlock:\n\txfs_dqfunlock(dqp);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DQ_IS_DIRTY",
          "args": [
            "dqp"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dqlock",
          "args": [
            "dqp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dqlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.h",
          "lines": "104-107",
          "snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_dqlock(struct xfs_dquot *dqp)\n{\n\tmutex_lock(&dqp->q_qlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_dqpurge(\n\tstruct xfs_dquot\t*dqp,\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_mount\t*mp = dqp->q_mount;\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\n\txfs_dqlock(dqp);\n\tif ((dqp->dq_flags & XFS_DQ_FREEING) || dqp->q_nrefs != 0) {\n\t\txfs_dqunlock(dqp);\n\t\treturn -EAGAIN;\n\t}\n\n\tdqp->dq_flags |= XFS_DQ_FREEING;\n\n\txfs_dqflock(dqp);\n\n\t/*\n\t * If we are turning this type of quotas off, we don't care\n\t * about the dirty metadata sitting in this dquot. OTOH, if\n\t * we're unmounting, we do care, so we flush it and wait.\n\t */\n\tif (XFS_DQ_IS_DIRTY(dqp)) {\n\t\tstruct xfs_buf\t*bp = NULL;\n\t\tint\t\terror;\n\n\t\t/*\n\t\t * We don't care about getting disk errors here. We need\n\t\t * to purge this dquot anyway, so we go ahead regardless.\n\t\t */\n\t\terror = xfs_qm_dqflush(dqp, &bp);\n\t\tif (error) {\n\t\t\txfs_warn(mp, \"%s: dquot %p flush failed\",\n\t\t\t\t__func__, dqp);\n\t\t} else {\n\t\t\terror = xfs_bwrite(bp);\n\t\t\txfs_buf_relse(bp);\n\t\t}\n\t\txfs_dqflock(dqp);\n\t}\n\n\tASSERT(atomic_read(&dqp->q_pincount) == 0);\n\tASSERT(XFS_FORCED_SHUTDOWN(mp) ||\n\t       !(dqp->q_logitem.qli_item.li_flags & XFS_LI_IN_AIL));\n\n\txfs_dqfunlock(dqp);\n\txfs_dqunlock(dqp);\n\n\tradix_tree_delete(xfs_dquot_tree(qi, dqp->q_core.d_flags),\n\t\t\t  be32_to_cpu(dqp->q_core.d_id));\n\tqi->qi_dquots--;\n\n\t/*\n\t * We move dquots to the freelist as soon as their reference count\n\t * hits zero, so it really should be on the freelist here.\n\t */\n\tASSERT(!list_empty(&dqp->q_lru));\n\tlist_lru_del(&qi->qi_lru, &dqp->q_lru);\n\tXFS_STATS_DEC(xs_qm_dquot_unused);\n\n\txfs_qm_dqdestroy(dqp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_qm_dquot_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
    "lines": "61-122",
    "snippet": "STATIC int\nxfs_qm_dquot_walk(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\ttype,\n\tint\t\t\t(*execute)(struct xfs_dquot *dqp, void *data),\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tuint32_t\t\tnext_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tnr_found;\n\nrestart:\n\tskipped = 0;\n\tnext_index = 0;\n\tnr_found = 0;\n\n\twhile (1) {\n\t\tstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\tmutex_lock(&qi->qi_tree_lock);\n\t\tnr_found = radix_tree_gang_lookup(tree, (void **)batch,\n\t\t\t\t\tnext_index, XFS_DQ_LOOKUP_BATCH);\n\t\tif (!nr_found) {\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_dquot *dqp = batch[i];\n\n\t\t\tnext_index = be32_to_cpu(dqp->q_core.d_id) + 1;\n\n\t\t\terror = execute(batch[i], data);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (last_error == -EFSCORRUPTED) {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\n\treturn last_error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_itable.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define XFS_DQ_LOOKUP_BATCH\t32"
    ],
    "globals_used": [
      "STATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "delay",
          "args": [
            "1"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "181-184",
          "snippet": "static inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline void delay(long ticks)\n{\n\tschedule_timeout_uninterruptible(ticks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execute",
          "args": [
            "batch[i]",
            "data"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dqp->q_core.d_id"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "tree",
            "(void **)batch",
            "next_index",
            "XFS_DQ_LOOKUP_BATCH"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&qi->qi_tree_lock"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dquot_tree",
          "args": [
            "qi",
            "type"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dquot_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.h",
          "lines": "88-104",
          "snippet": "static inline struct radix_tree_root *\nxfs_dquot_tree(\n\tstruct xfs_quotainfo\t*qi,\n\tint\t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\treturn &qi->qi_uquota_tree;\n\tcase XFS_DQ_GROUP:\n\t\treturn &qi->qi_gquota_tree;\n\tcase XFS_DQ_PROJ:\n\t\treturn &qi->qi_pquota_tree;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n\nstatic inline struct radix_tree_root *\nxfs_dquot_tree(\n\tstruct xfs_quotainfo\t*qi,\n\tint\t\t\ttype)\n{\n\tswitch (type) {\n\tcase XFS_DQ_USER:\n\t\treturn &qi->qi_uquota_tree;\n\tcase XFS_DQ_GROUP:\n\t\treturn &qi->qi_gquota_tree;\n\tcase XFS_DQ_PROJ:\n\t\treturn &qi->qi_pquota_tree;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_DQ_LOOKUP_BATCH\t32\n\nSTATIC void\txfs_qm_dqfree_one(struct xfs_dquot *dqp);\n\nSTATIC int\nxfs_qm_dquot_walk(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\ttype,\n\tint\t\t\t(*execute)(struct xfs_dquot *dqp, void *data),\n\tvoid\t\t\t*data)\n{\n\tstruct xfs_quotainfo\t*qi = mp->m_quotainfo;\n\tstruct radix_tree_root\t*tree = xfs_dquot_tree(qi, type);\n\tuint32_t\t\tnext_index;\n\tint\t\t\tlast_error = 0;\n\tint\t\t\tskipped;\n\tint\t\t\tnr_found;\n\nrestart:\n\tskipped = 0;\n\tnext_index = 0;\n\tnr_found = 0;\n\n\twhile (1) {\n\t\tstruct xfs_dquot *batch[XFS_DQ_LOOKUP_BATCH];\n\t\tint\t\terror = 0;\n\t\tint\t\ti;\n\n\t\tmutex_lock(&qi->qi_tree_lock);\n\t\tnr_found = radix_tree_gang_lookup(tree, (void **)batch,\n\t\t\t\t\tnext_index, XFS_DQ_LOOKUP_BATCH);\n\t\tif (!nr_found) {\n\t\t\tmutex_unlock(&qi->qi_tree_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < nr_found; i++) {\n\t\t\tstruct xfs_dquot *dqp = batch[i];\n\n\t\t\tnext_index = be32_to_cpu(dqp->q_core.d_id) + 1;\n\n\t\t\terror = execute(batch[i], data);\n\t\t\tif (error == -EAGAIN) {\n\t\t\t\tskipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error && last_error != -EFSCORRUPTED)\n\t\t\t\tlast_error = error;\n\t\t}\n\n\t\tmutex_unlock(&qi->qi_tree_lock);\n\n\t\t/* bail out if the filesystem is corrupted.  */\n\t\tif (last_error == -EFSCORRUPTED) {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (skipped) {\n\t\tdelay(1);\n\t\tgoto restart;\n\t}\n\n\treturn last_error;\n}"
  }
]