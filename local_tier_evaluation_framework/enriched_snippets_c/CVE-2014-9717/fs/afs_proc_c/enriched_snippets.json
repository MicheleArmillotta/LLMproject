[
  {
    "function_name": "afs_proc_cell_servers_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "648-666",
    "snippet": "static int afs_proc_cell_servers_show(struct seq_file *m, void *v)\n{\n\tstruct afs_cell *cell = m->private;\n\tstruct afs_server *server = list_entry(v, struct afs_server, link);\n\tchar ipaddr[20];\n\n\t/* display header on line 1 */\n\tif (v == &cell->servers) {\n\t\tseq_puts(m, \"USE ADDR            STATE\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one cell per line on subsequent lines */\n\tsprintf(ipaddr, \"%pI4\", &server->addr);\n\tseq_printf(m, \"%3d %-15.15s %5d\\n\",\n\t\t   atomic_read(&server->usage), ipaddr, server->fs_state);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%3d %-15.15s %5d\\n\"",
            "atomic_read(&server->usage)",
            "ipaddr",
            "server->fs_state"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&server->usage"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ipaddr",
            "\"%pI4\"",
            "&server->addr"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"USE ADDR            STATE\\n\""
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structafs_server",
            "link"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v)\n{\n\tstruct afs_cell *cell = m->private;\n\tstruct afs_server *server = list_entry(v, struct afs_server, link);\n\tchar ipaddr[20];\n\n\t/* display header on line 1 */\n\tif (v == &cell->servers) {\n\t\tseq_puts(m, \"USE ADDR            STATE\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one cell per line on subsequent lines */\n\tsprintf(ipaddr, \"%pI4\", &server->addr);\n\tseq_printf(m, \"%3d %-15.15s %5d\\n\",\n\t\t   atomic_read(&server->usage), ipaddr, server->fs_state);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cell_servers_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "637-643",
    "snippet": "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v)\n\t__releases(p->private->servers_lock)\n{\n\tstruct afs_cell *cell = p->private;\n\n\tread_unlock(&cell->servers_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&cell->servers_lock"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "p->private->servers_lock"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v)\n\t__releases(p->private->servers_lock)\n{\n\tstruct afs_cell *cell = p->private;\n\n\tread_unlock(&cell->servers_lock);\n}"
  },
  {
    "function_name": "afs_proc_cell_servers_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "625-632",
    "snippet": "static void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *_pos)\n{\n\tstruct afs_cell *cell = p->private;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\treturn seq_list_next(v, &cell->servers, _pos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);",
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&cell->servers",
            "_pos"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "779-786",
          "snippet": "struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"cell=%p pos=%Ld\"",
            "cell",
            "*_pos"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *_pos)\n{\n\tstruct afs_cell *cell = p->private;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\treturn seq_list_next(v, &cell->servers, _pos);\n}"
  },
  {
    "function_name": "afs_proc_cell_servers_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "610-620",
    "snippet": "static void *afs_proc_cell_servers_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(m->private->servers_lock)\n{\n\tstruct afs_cell *cell = m->private;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\n\t/* lock the list against modification */\n\tread_lock(&cell->servers_lock);\n\treturn seq_list_start_head(&cell->servers, *_pos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);",
      "static void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start_head",
          "args": [
            "&cell->servers",
            "*_pos"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_start_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "770-776",
          "snippet": "struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&cell->servers_lock"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"cell=%p pos=%Ld\"",
            "cell",
            "*_pos"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "m->private->servers_lock"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);\nstatic void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\n\nstatic void *afs_proc_cell_servers_start(struct seq_file *m, loff_t *_pos)\n\t__acquires(m->private->servers_lock)\n{\n\tstruct afs_cell *cell = m->private;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\n\t/* lock the list against modification */\n\tread_lock(&cell->servers_lock);\n\treturn seq_list_start_head(&cell->servers, *_pos);\n}"
  },
  {
    "function_name": "afs_proc_cell_servers_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "587-604",
    "snippet": "static int afs_proc_cell_servers_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_cell *cell;\n\tstruct seq_file *m;\n\tint ret;\n\n\tcell = PDE_DATA(inode);\n\tif (!cell)\n\t\treturn -ENOENT;\n\n\tret = seq_open(file, &afs_proc_cell_servers_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = cell;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_proc_cells_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);",
      "static int afs_proc_cell_servers_open(struct inode *inode, struct file *file);",
      "static const struct seq_operations afs_proc_cell_servers_ops = {\n\t.start\t= afs_proc_cell_servers_start,\n\t.next\t= afs_proc_cell_servers_next,\n\t.stop\t= afs_proc_cell_servers_stop,\n\t.show\t= afs_proc_cell_servers_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&afs_proc_cell_servers_ops"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic int afs_proc_cells_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);\nstatic int afs_proc_cell_servers_open(struct inode *inode, struct file *file);\nstatic const struct seq_operations afs_proc_cell_servers_ops = {\n\t.start\t= afs_proc_cell_servers_start,\n\t.next\t= afs_proc_cell_servers_next,\n\t.stop\t= afs_proc_cell_servers_stop,\n\t.show\t= afs_proc_cell_servers_show,\n};\n\nstatic int afs_proc_cell_servers_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_cell *cell;\n\tstruct seq_file *m;\n\tint ret;\n\n\tcell = PDE_DATA(inode);\n\tif (!cell)\n\t\treturn -ENOENT;\n\n\tret = seq_open(file, &afs_proc_cell_servers_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = cell;\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cell_vlservers_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "568-581",
    "snippet": "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v)\n{\n\tstruct in_addr *addr = v;\n\n\t/* display header on line 1 */\n\tif (v == (struct in_addr *) 1) {\n\t\tseq_puts(m, \"ADDRESS\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one cell per line on subsequent lines */\n\tseq_printf(m, \"%pI4\\n\", &addr->s_addr);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%pI4\\n\"",
            "&addr->s_addr"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"ADDRESS\\n\""
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v)\n{\n\tstruct in_addr *addr = v;\n\n\t/* display header on line 1 */\n\tif (v == (struct in_addr *) 1) {\n\t\tseq_puts(m, \"ADDRESS\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one cell per line on subsequent lines */\n\tseq_printf(m, \"%pI4\\n\", &addr->s_addr);\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cell_vlservers_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "558-563",
    "snippet": "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v)\n{\n\tstruct afs_cell *cell = p->private;\n\n\tup_read(&cell->vl_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cell->vl_sem"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v)\n{\n\tstruct afs_cell *cell = p->private;\n\n\tup_read(&cell->vl_sem);\n}"
  },
  {
    "function_name": "afs_proc_cell_vlservers_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "539-553",
    "snippet": "static void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *_pos)\n{\n\tstruct afs_cell *cell = p->private;\n\tloff_t pos;\n\n\t_enter(\"cell=%p{nad=%u} pos=%Ld\", cell, cell->vl_naddrs, *_pos);\n\n\tpos = *_pos;\n\t(*_pos)++;\n\tif (pos >= cell->vl_naddrs)\n\t\treturn NULL;\n\n\treturn &cell->vl_addrs[pos];\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);",
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"cell=%p{nad=%u} pos=%Ld\"",
            "cell",
            "cell->vl_naddrs",
            "*_pos"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *_pos)\n{\n\tstruct afs_cell *cell = p->private;\n\tloff_t pos;\n\n\t_enter(\"cell=%p{nad=%u} pos=%Ld\", cell, cell->vl_naddrs, *_pos);\n\n\tpos = *_pos;\n\t(*_pos)++;\n\tif (pos >= cell->vl_naddrs)\n\t\treturn NULL;\n\n\treturn &cell->vl_addrs[pos];\n}"
  },
  {
    "function_name": "afs_proc_cell_vlservers_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "515-534",
    "snippet": "static void *afs_proc_cell_vlservers_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct afs_cell *cell = m->private;\n\tloff_t pos = *_pos;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\n\t/* lock the list against modification */\n\tdown_read(&cell->vl_sem);\n\n\t/* allow for the header line */\n\tif (!pos)\n\t\treturn (void *) 1;\n\tpos--;\n\n\tif (pos >= cell->vl_naddrs)\n\t\treturn NULL;\n\n\treturn &cell->vl_addrs[pos];\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);",
      "static void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cell->vl_sem"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"cell=%p pos=%Ld\"",
            "cell",
            "*_pos"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);\nstatic void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\n\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct afs_cell *cell = m->private;\n\tloff_t pos = *_pos;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\n\t/* lock the list against modification */\n\tdown_read(&cell->vl_sem);\n\n\t/* allow for the header line */\n\tif (!pos)\n\t\treturn (void *) 1;\n\tpos--;\n\n\tif (pos >= cell->vl_naddrs)\n\t\treturn NULL;\n\n\treturn &cell->vl_addrs[pos];\n}"
  },
  {
    "function_name": "afs_proc_cell_vlservers_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "491-509",
    "snippet": "static int afs_proc_cell_vlservers_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_cell *cell;\n\tstruct seq_file *m;\n\tint ret;\n\n\tcell = PDE_DATA(inode);\n\tif (!cell)\n\t\treturn -ENOENT;\n\n\tret = seq_open(file, &afs_proc_cell_vlservers_ops);\n\tif (ret<0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = cell;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_proc_cells_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);",
      "static const struct seq_operations afs_proc_cell_vlservers_ops = {\n\t.start\t= afs_proc_cell_vlservers_start,\n\t.next\t= afs_proc_cell_vlservers_next,\n\t.stop\t= afs_proc_cell_vlservers_stop,\n\t.show\t= afs_proc_cell_vlservers_show,\n};",
      "static int afs_proc_cell_servers_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&afs_proc_cell_vlservers_ops"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic int afs_proc_cells_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);\nstatic const struct seq_operations afs_proc_cell_vlservers_ops = {\n\t.start\t= afs_proc_cell_vlservers_start,\n\t.next\t= afs_proc_cell_vlservers_next,\n\t.stop\t= afs_proc_cell_vlservers_stop,\n\t.show\t= afs_proc_cell_vlservers_show,\n};\nstatic int afs_proc_cell_servers_open(struct inode *inode, struct file *file);\n\nstatic int afs_proc_cell_vlservers_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_cell *cell;\n\tstruct seq_file *m;\n\tint ret;\n\n\tcell = PDE_DATA(inode);\n\tif (!cell)\n\t\treturn -ENOENT;\n\n\tret = seq_open(file, &afs_proc_cell_vlservers_ops);\n\tif (ret<0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = cell;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cell_volumes_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "463-485",
    "snippet": "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v)\n{\n\tstruct afs_cell *cell = m->private;\n\tstruct afs_vlocation *vlocation =\n\t\tlist_entry(v, struct afs_vlocation, link);\n\n\t/* display header on line 1 */\n\tif (v == &cell->vl_list) {\n\t\tseq_puts(m, \"USE STT VLID[0]  VLID[1]  VLID[2]  NAME\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one cell per line on subsequent lines */\n\tseq_printf(m, \"%3d %s %08x %08x %08x %s\\n\",\n\t\t   atomic_read(&vlocation->usage),\n\t\t   afs_vlocation_states[vlocation->state],\n\t\t   vlocation->vldb.vid[0],\n\t\t   vlocation->vldb.vid[1],\n\t\t   vlocation->vldb.vid[2],\n\t\t   vlocation->vldb.name);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);",
      "static const char afs_vlocation_states[][4] = {\n\t[AFS_VL_NEW]\t\t\t= \"New\",\n\t[AFS_VL_CREATING]\t\t= \"Crt\",\n\t[AFS_VL_VALID]\t\t\t= \"Val\",\n\t[AFS_VL_NO_VOLUME]\t\t= \"NoV\",\n\t[AFS_VL_UPDATING]\t\t= \"Upd\",\n\t[AFS_VL_VOLUME_DELETED]\t\t= \"Del\",\n\t[AFS_VL_UNCERTAIN]\t\t= \"Unc\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%3d %s %08x %08x %08x %s\\n\"",
            "atomic_read(&vlocation->usage)",
            "afs_vlocation_states[vlocation->state]",
            "vlocation->vldb.vid[0]",
            "vlocation->vldb.vid[1]",
            "vlocation->vldb.vid[2]",
            "vlocation->vldb.name"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&vlocation->usage"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"USE STT VLID[0]  VLID[1]  VLID[2]  NAME\\n\""
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structafs_vlocation",
            "link"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\nstatic const char afs_vlocation_states[][4] = {\n\t[AFS_VL_NEW]\t\t\t= \"New\",\n\t[AFS_VL_CREATING]\t\t= \"Crt\",\n\t[AFS_VL_VALID]\t\t\t= \"Val\",\n\t[AFS_VL_NO_VOLUME]\t\t= \"NoV\",\n\t[AFS_VL_UPDATING]\t\t= \"Upd\",\n\t[AFS_VL_VOLUME_DELETED]\t\t= \"Del\",\n\t[AFS_VL_UNCERTAIN]\t\t= \"Unc\",\n};\n\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v)\n{\n\tstruct afs_cell *cell = m->private;\n\tstruct afs_vlocation *vlocation =\n\t\tlist_entry(v, struct afs_vlocation, link);\n\n\t/* display header on line 1 */\n\tif (v == &cell->vl_list) {\n\t\tseq_puts(m, \"USE STT VLID[0]  VLID[1]  VLID[2]  NAME\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one cell per line on subsequent lines */\n\tseq_printf(m, \"%3d %s %08x %08x %08x %s\\n\",\n\t\t   atomic_read(&vlocation->usage),\n\t\t   afs_vlocation_states[vlocation->state],\n\t\t   vlocation->vldb.vid[0],\n\t\t   vlocation->vldb.vid[1],\n\t\t   vlocation->vldb.vid[2],\n\t\t   vlocation->vldb.name);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cell_volumes_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "443-448",
    "snippet": "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v)\n{\n\tstruct afs_cell *cell = p->private;\n\n\tup_read(&cell->vl_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cell->vl_sem"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v)\n{\n\tstruct afs_cell *cell = p->private;\n\n\tup_read(&cell->vl_sem);\n}"
  },
  {
    "function_name": "afs_proc_cell_volumes_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "431-438",
    "snippet": "static void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *_pos)\n{\n\tstruct afs_cell *cell = p->private;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\treturn seq_list_next(v, &cell->vl_list, _pos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);",
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&cell->vl_list",
            "_pos"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "779-786",
          "snippet": "struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"cell=%p pos=%Ld\"",
            "cell",
            "*_pos"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *_pos)\n{\n\tstruct afs_cell *cell = p->private;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\treturn seq_list_next(v, &cell->vl_list, _pos);\n}"
  },
  {
    "function_name": "afs_proc_cell_volumes_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "417-426",
    "snippet": "static void *afs_proc_cell_volumes_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct afs_cell *cell = m->private;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\n\t/* lock the list against modification */\n\tdown_read(&cell->vl_sem);\n\treturn seq_list_start_head(&cell->vl_list, *_pos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);",
      "static void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start_head",
          "args": [
            "&cell->vl_list",
            "*_pos"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_start_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "770-776",
          "snippet": "struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cell->vl_sem"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"cell=%p pos=%Ld\"",
            "cell",
            "*_pos"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);\nstatic void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\n\nstatic void *afs_proc_cell_volumes_start(struct seq_file *m, loff_t *_pos)\n{\n\tstruct afs_cell *cell = m->private;\n\n\t_enter(\"cell=%p pos=%Ld\", cell, *_pos);\n\n\t/* lock the list against modification */\n\tdown_read(&cell->vl_sem);\n\treturn seq_list_start_head(&cell->vl_list, *_pos);\n}"
  },
  {
    "function_name": "afs_proc_cell_volumes_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "393-411",
    "snippet": "static int afs_proc_cell_volumes_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_cell *cell;\n\tstruct seq_file *m;\n\tint ret;\n\n\tcell = PDE_DATA(inode);\n\tif (!cell)\n\t\treturn -ENOENT;\n\n\tret = seq_open(file, &afs_proc_cell_volumes_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = cell;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_proc_cells_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);",
      "static const struct seq_operations afs_proc_cell_volumes_ops = {\n\t.start\t= afs_proc_cell_volumes_start,\n\t.next\t= afs_proc_cell_volumes_next,\n\t.stop\t= afs_proc_cell_volumes_stop,\n\t.show\t= afs_proc_cell_volumes_show,\n};",
      "static int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);",
      "static int afs_proc_cell_servers_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&afs_proc_cell_volumes_ops"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic int afs_proc_cells_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);\nstatic const struct seq_operations afs_proc_cell_volumes_ops = {\n\t.start\t= afs_proc_cell_volumes_start,\n\t.next\t= afs_proc_cell_volumes_next,\n\t.stop\t= afs_proc_cell_volumes_stop,\n\t.show\t= afs_proc_cell_volumes_show,\n};\nstatic int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);\nstatic int afs_proc_cell_servers_open(struct inode *inode, struct file *file);\n\nstatic int afs_proc_cell_volumes_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_cell *cell;\n\tstruct seq_file *m;\n\tint ret;\n\n\tcell = PDE_DATA(inode);\n\tif (!cell)\n\t\treturn -ENOENT;\n\n\tret = seq_open(file, &afs_proc_cell_volumes_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = cell;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cell_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "381-388",
    "snippet": "void afs_proc_cell_remove(struct afs_cell *cell)\n{\n\t_enter(\"\");\n\n\tremove_proc_subtree(cell->name, proc_afs);\n\n\t_leave(\"\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_afs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"\""
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_proc_subtree",
          "args": [
            "cell->name",
            "proc_afs"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "557-601",
          "snippet": "int remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nint remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic struct proc_dir_entry *proc_afs;\n\nvoid afs_proc_cell_remove(struct afs_cell *cell)\n{\n\t_enter(\"\");\n\n\tremove_proc_subtree(cell->name, proc_afs);\n\n\t_leave(\"\");\n}"
  },
  {
    "function_name": "afs_proc_cell_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "350-376",
    "snippet": "int afs_proc_cell_setup(struct afs_cell *cell)\n{\n\tstruct proc_dir_entry *dir;\n\n\t_enter(\"%p{%s}\", cell, cell->name);\n\n\tdir = proc_mkdir(cell->name, proc_afs);\n\tif (!dir)\n\t\tgoto error_dir;\n\n\tif (!proc_create_data(\"servers\", 0, dir,\n\t\t\t     &afs_proc_cell_servers_fops, cell) ||\n\t    !proc_create_data(\"vlservers\", 0, dir,\n\t\t\t     &afs_proc_cell_vlservers_fops, cell) ||\n\t    !proc_create_data(\"volumes\", 0, dir,\n\t\t\t     &afs_proc_cell_volumes_fops, cell))\n\t\tgoto error_tree;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_tree:\n\tremove_proc_subtree(cell->name, proc_afs);\nerror_dir:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_afs;",
      "static const struct file_operations afs_proc_cell_volumes_fops = {\n\t.open\t\t= afs_proc_cell_volumes_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};",
      "static const struct file_operations afs_proc_cell_vlservers_fops = {\n\t.open\t\t= afs_proc_cell_vlservers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};",
      "static const struct file_operations afs_proc_cell_servers_fops = {\n\t.open\t\t= afs_proc_cell_servers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_proc_subtree",
          "args": [
            "cell->name",
            "proc_afs"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "557-601",
          "snippet": "int remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nint remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"volumes\"",
            "0",
            "dir",
            "&afs_proc_cell_volumes_fops",
            "cell"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "458-489",
          "snippet": "struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "cell->name",
            "proc_afs"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%p{%s}\"",
            "cell",
            "cell->name"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic struct proc_dir_entry *proc_afs;\nstatic const struct file_operations afs_proc_cell_volumes_fops = {\n\t.open\t\t= afs_proc_cell_volumes_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\nstatic const struct file_operations afs_proc_cell_vlservers_fops = {\n\t.open\t\t= afs_proc_cell_vlservers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\nstatic const struct file_operations afs_proc_cell_servers_fops = {\n\t.open\t\t= afs_proc_cell_servers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nint afs_proc_cell_setup(struct afs_cell *cell)\n{\n\tstruct proc_dir_entry *dir;\n\n\t_enter(\"%p{%s}\", cell, cell->name);\n\n\tdir = proc_mkdir(cell->name, proc_afs);\n\tif (!dir)\n\t\tgoto error_dir;\n\n\tif (!proc_create_data(\"servers\", 0, dir,\n\t\t\t     &afs_proc_cell_servers_fops, cell) ||\n\t    !proc_create_data(\"vlservers\", 0, dir,\n\t\t\t     &afs_proc_cell_vlservers_fops, cell) ||\n\t    !proc_create_data(\"volumes\", 0, dir,\n\t\t\t     &afs_proc_cell_volumes_fops, cell))\n\t\tgoto error_tree;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_tree:\n\tremove_proc_subtree(cell->name, proc_afs);\nerror_dir:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "afs_proc_rootcell_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "307-345",
    "snippet": "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos)\n{\n\tchar *kbuf, *s;\n\tint ret;\n\n\t/* start by dragging the command into memory */\n\tif (size <= 1 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tret = -ENOMEM;\n\tkbuf = kmalloc(size + 1, GFP_KERNEL);\n\tif (!kbuf)\n\t\tgoto nomem;\n\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, size) != 0)\n\t\tgoto infault;\n\tkbuf[size] = 0;\n\n\t/* trim to first NL */\n\ts = memchr(kbuf, '\\n', size);\n\tif (s)\n\t\t*s = 0;\n\n\t/* determine command to perform */\n\t_debug(\"rootcell=%s\", kbuf);\n\n\tret = afs_cell_init(kbuf);\n\tif (ret >= 0)\n\t\tret = size;\t/* consume everything, always */\n\ninfault:\n\tkfree(kbuf);\nnomem:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_proc_cells_open(struct inode *inode, struct file *file);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);",
      "static int afs_proc_cell_servers_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kbuf"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_cell_init",
          "args": [
            "kbuf"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cell_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "226-263",
          "snippet": "int afs_cell_init(char *rootcell)\n{\n\tstruct afs_cell *old_root, *new_root;\n\tchar *cp;\n\n\t_enter(\"\");\n\n\tif (!rootcell) {\n\t\t/* module is loaded with no parameters, or built statically.\n\t\t * - in the future we might initialize cell DB here.\n\t\t */\n\t\t_leave(\" = 0 [no root]\");\n\t\treturn 0;\n\t}\n\n\tcp = strchr(rootcell, ':');\n\tif (!cp)\n\t\t_debug(\"kAFS: no VL server IP addresses specified\");\n\telse\n\t\t*cp++ = 0;\n\n\t/* allocate a cell record for the root cell */\n\tnew_root = afs_cell_create(rootcell, strlen(rootcell), cp, false);\n\tif (IS_ERR(new_root)) {\n\t\t_leave(\" = %ld\", PTR_ERR(new_root));\n\t\treturn PTR_ERR(new_root);\n\t}\n\n\t/* install the new cell */\n\twrite_lock(&afs_cells_lock);\n\told_root = afs_cell_root;\n\tafs_cell_root = new_root;\n\twrite_unlock(&afs_cells_lock);\n\tafs_put_cell(old_root);\n\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static struct afs_cell *afs_cell_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic struct afs_cell *afs_cell_root;\n\nint afs_cell_init(char *rootcell)\n{\n\tstruct afs_cell *old_root, *new_root;\n\tchar *cp;\n\n\t_enter(\"\");\n\n\tif (!rootcell) {\n\t\t/* module is loaded with no parameters, or built statically.\n\t\t * - in the future we might initialize cell DB here.\n\t\t */\n\t\t_leave(\" = 0 [no root]\");\n\t\treturn 0;\n\t}\n\n\tcp = strchr(rootcell, ':');\n\tif (!cp)\n\t\t_debug(\"kAFS: no VL server IP addresses specified\");\n\telse\n\t\t*cp++ = 0;\n\n\t/* allocate a cell record for the root cell */\n\tnew_root = afs_cell_create(rootcell, strlen(rootcell), cp, false);\n\tif (IS_ERR(new_root)) {\n\t\t_leave(\" = %ld\", PTR_ERR(new_root));\n\t\treturn PTR_ERR(new_root);\n\t}\n\n\t/* install the new cell */\n\twrite_lock(&afs_cells_lock);\n\told_root = afs_cell_root;\n\tafs_cell_root = new_root;\n\twrite_unlock(&afs_cells_lock);\n\tafs_put_cell(old_root);\n\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"rootcell=%s\"",
            "kbuf"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "kbuf",
            "'\\n'",
            "size"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kbuf",
            "buf",
            "size"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic int afs_proc_cells_open(struct inode *inode, struct file *file);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);\nstatic int afs_proc_cell_servers_open(struct inode *inode, struct file *file);\n\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos)\n{\n\tchar *kbuf, *s;\n\tint ret;\n\n\t/* start by dragging the command into memory */\n\tif (size <= 1 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tret = -ENOMEM;\n\tkbuf = kmalloc(size + 1, GFP_KERNEL);\n\tif (!kbuf)\n\t\tgoto nomem;\n\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, size) != 0)\n\t\tgoto infault;\n\tkbuf[size] = 0;\n\n\t/* trim to first NL */\n\ts = memchr(kbuf, '\\n', size);\n\tif (s)\n\t\t*s = 0;\n\n\t/* determine command to perform */\n\t_debug(\"rootcell=%s\", kbuf);\n\n\tret = afs_cell_init(kbuf);\n\tif (ret >= 0)\n\t\tret = size;\t/* consume everything, always */\n\ninfault:\n\tkfree(kbuf);\nnomem:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_proc_rootcell_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "297-301",
    "snippet": "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_proc_cells_open(struct inode *inode, struct file *file);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);",
      "static int afs_proc_cell_servers_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic int afs_proc_cells_open(struct inode *inode, struct file *file);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);\nstatic int afs_proc_cell_servers_open(struct inode *inode, struct file *file);\n\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cells_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "223-295",
    "snippet": "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos)\n{\n\tchar *kbuf, *name, *args;\n\tint ret;\n\n\t/* start by dragging the command into memory */\n\tif (size <= 1 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tkbuf = kmalloc(size + 1, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, size) != 0)\n\t\tgoto done;\n\tkbuf[size] = 0;\n\n\t/* trim to first NL */\n\tname = memchr(kbuf, '\\n', size);\n\tif (name)\n\t\t*name = 0;\n\n\t/* split into command, name and argslist */\n\tname = strchr(kbuf, ' ');\n\tif (!name)\n\t\tgoto inval;\n\tdo {\n\t\t*name++ = 0;\n\t} while(*name == ' ');\n\tif (!*name)\n\t\tgoto inval;\n\n\targs = strchr(name, ' ');\n\tif (!args)\n\t\tgoto inval;\n\tdo {\n\t\t*args++ = 0;\n\t} while(*args == ' ');\n\tif (!*args)\n\t\tgoto inval;\n\n\t/* determine command to perform */\n\t_debug(\"cmd=%s name=%s args=%s\", kbuf, name, args);\n\n\tif (strcmp(kbuf, \"add\") == 0) {\n\t\tstruct afs_cell *cell;\n\n\t\tcell = afs_cell_create(name, strlen(name), args, false);\n\t\tif (IS_ERR(cell)) {\n\t\t\tret = PTR_ERR(cell);\n\t\t\tgoto done;\n\t\t}\n\n\t\tafs_put_cell(cell);\n\t\tprintk(\"kAFS: Added new cell '%s'\\n\", name);\n\t} else {\n\t\tgoto inval;\n\t}\n\n\tret = size;\n\ndone:\n\tkfree(kbuf);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\ninval:\n\tret = -EINVAL;\n\tprintk(\"kAFS: Invalid Command on /proc/fs/afs/cells file\\n\");\n\tgoto done;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_proc_cells_open(struct inode *inode, struct file *file);",
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);",
      "static int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);",
      "static int afs_proc_cell_servers_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"kAFS: Invalid Command on /proc/fs/afs/cells file\\n\""
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kbuf"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_put_cell",
          "args": [
            "cell"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_cell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "343-370",
          "snippet": "void afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(afs_cells_freeable_wq);\n\nvoid afs_put_cell(struct afs_cell *cell)\n{\n\tif (!cell)\n\t\treturn;\n\n\t_enter(\"%p{%d,%s}\", cell, atomic_read(&cell->usage), cell->name);\n\n\tASSERTCMP(atomic_read(&cell->usage), >, 0);\n\n\t/* to prevent a race, the decrement and the dequeue must be effectively\n\t * atomic */\n\twrite_lock(&afs_cells_lock);\n\n\tif (likely(!atomic_dec_and_test(&cell->usage))) {\n\t\twrite_unlock(&afs_cells_lock);\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tASSERT(list_empty(&cell->servers));\n\tASSERT(list_empty(&cell->vl_list));\n\n\twrite_unlock(&afs_cells_lock);\n\n\twake_up(&afs_cells_freeable_wq);\n\n\t_leave(\" [unused]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cell"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cell"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_cell_create",
          "args": [
            "name",
            "strlen(name)",
            "args",
            "false"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cell_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "150-219",
          "snippet": "struct afs_cell *afs_cell_create(const char *name, unsigned namesz,\n\t\t\t\t char *vllist, bool retref)\n{\n\tstruct afs_cell *cell;\n\tint ret;\n\n\t_enter(\"%*.*s,%s\", namesz, namesz, name ?: \"\", vllist);\n\n\tdown_write(&afs_cells_sem);\n\tread_lock(&afs_cells_lock);\n\tlist_for_each_entry(cell, &afs_cells, link) {\n\t\tif (strncasecmp(cell->name, name, namesz) == 0)\n\t\t\tgoto duplicate_name;\n\t}\n\tread_unlock(&afs_cells_lock);\n\n\tcell = afs_cell_alloc(name, namesz, vllist);\n\tif (IS_ERR(cell)) {\n\t\t_leave(\" = %ld\", PTR_ERR(cell));\n\t\tup_write(&afs_cells_sem);\n\t\treturn cell;\n\t}\n\n\t/* add a proc directory for this cell */\n\tret = afs_proc_cell_setup(cell);\n\tif (ret < 0)\n\t\tgoto error;\n\n#ifdef CONFIG_AFS_FSCACHE\n\t/* put it up for caching (this never returns an error) */\n\tcell->cache = fscache_acquire_cookie(afs_cache_netfs.primary_index,\n\t\t\t\t\t     &afs_cell_cache_index_def,\n\t\t\t\t\t     cell, true);\n#endif\n\n\t/* add to the cell lists */\n\twrite_lock(&afs_cells_lock);\n\tlist_add_tail(&cell->link, &afs_cells);\n\twrite_unlock(&afs_cells_lock);\n\n\tdown_write(&afs_proc_cells_sem);\n\tlist_add_tail(&cell->proc_link, &afs_proc_cells);\n\tup_write(&afs_proc_cells_sem);\n\tup_write(&afs_cells_sem);\n\n\t_leave(\" = %p\", cell);\n\treturn cell;\n\nerror:\n\tup_write(&afs_cells_sem);\n\tkey_put(cell->anonymous_key);\n\tkfree(cell);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n\nduplicate_name:\n\tif (retref && !IS_ERR(cell))\n\t\tafs_get_cell(cell);\n\n\tread_unlock(&afs_cells_lock);\n\tup_write(&afs_cells_sem);\n\n\tif (retref) {\n\t\t_leave(\" = %p\", cell);\n\t\treturn cell;\n\t}\n\n\t_leave(\" = -EEXIST\");\n\treturn ERR_PTR(-EEXIST);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(afs_cells);",
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_RWSEM(afs_cells_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(afs_cells);\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_RWSEM(afs_cells_sem);\n\nstruct afs_cell *afs_cell_create(const char *name, unsigned namesz,\n\t\t\t\t char *vllist, bool retref)\n{\n\tstruct afs_cell *cell;\n\tint ret;\n\n\t_enter(\"%*.*s,%s\", namesz, namesz, name ?: \"\", vllist);\n\n\tdown_write(&afs_cells_sem);\n\tread_lock(&afs_cells_lock);\n\tlist_for_each_entry(cell, &afs_cells, link) {\n\t\tif (strncasecmp(cell->name, name, namesz) == 0)\n\t\t\tgoto duplicate_name;\n\t}\n\tread_unlock(&afs_cells_lock);\n\n\tcell = afs_cell_alloc(name, namesz, vllist);\n\tif (IS_ERR(cell)) {\n\t\t_leave(\" = %ld\", PTR_ERR(cell));\n\t\tup_write(&afs_cells_sem);\n\t\treturn cell;\n\t}\n\n\t/* add a proc directory for this cell */\n\tret = afs_proc_cell_setup(cell);\n\tif (ret < 0)\n\t\tgoto error;\n\n#ifdef CONFIG_AFS_FSCACHE\n\t/* put it up for caching (this never returns an error) */\n\tcell->cache = fscache_acquire_cookie(afs_cache_netfs.primary_index,\n\t\t\t\t\t     &afs_cell_cache_index_def,\n\t\t\t\t\t     cell, true);\n#endif\n\n\t/* add to the cell lists */\n\twrite_lock(&afs_cells_lock);\n\tlist_add_tail(&cell->link, &afs_cells);\n\twrite_unlock(&afs_cells_lock);\n\n\tdown_write(&afs_proc_cells_sem);\n\tlist_add_tail(&cell->proc_link, &afs_proc_cells);\n\tup_write(&afs_proc_cells_sem);\n\tup_write(&afs_cells_sem);\n\n\t_leave(\" = %p\", cell);\n\treturn cell;\n\nerror:\n\tup_write(&afs_cells_sem);\n\tkey_put(cell->anonymous_key);\n\tkfree(cell);\n\t_leave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n\nduplicate_name:\n\tif (retref && !IS_ERR(cell))\n\t\tafs_get_cell(cell);\n\n\tread_unlock(&afs_cells_lock);\n\tup_write(&afs_cells_sem);\n\n\tif (retref) {\n\t\t_leave(\" = %p\", cell);\n\t\treturn cell;\n\t}\n\n\t_leave(\" = -EEXIST\");\n\treturn ERR_PTR(-EEXIST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kbuf",
            "\"add\""
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"cmd=%s name=%s args=%s\"",
            "kbuf",
            "name",
            "args"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "' '"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "kbuf",
            "' '"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "kbuf",
            "'\\n'",
            "size"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kbuf",
            "buf",
            "size"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic int afs_proc_cells_open(struct inode *inode, struct file *file);\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\nstatic int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);\nstatic int afs_proc_cell_servers_open(struct inode *inode, struct file *file);\n\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos)\n{\n\tchar *kbuf, *name, *args;\n\tint ret;\n\n\t/* start by dragging the command into memory */\n\tif (size <= 1 || size >= PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tkbuf = kmalloc(size + 1, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tret = -EFAULT;\n\tif (copy_from_user(kbuf, buf, size) != 0)\n\t\tgoto done;\n\tkbuf[size] = 0;\n\n\t/* trim to first NL */\n\tname = memchr(kbuf, '\\n', size);\n\tif (name)\n\t\t*name = 0;\n\n\t/* split into command, name and argslist */\n\tname = strchr(kbuf, ' ');\n\tif (!name)\n\t\tgoto inval;\n\tdo {\n\t\t*name++ = 0;\n\t} while(*name == ' ');\n\tif (!*name)\n\t\tgoto inval;\n\n\targs = strchr(name, ' ');\n\tif (!args)\n\t\tgoto inval;\n\tdo {\n\t\t*args++ = 0;\n\t} while(*args == ' ');\n\tif (!*args)\n\t\tgoto inval;\n\n\t/* determine command to perform */\n\t_debug(\"cmd=%s name=%s args=%s\", kbuf, name, args);\n\n\tif (strcmp(kbuf, \"add\") == 0) {\n\t\tstruct afs_cell *cell;\n\n\t\tcell = afs_cell_create(name, strlen(name), args, false);\n\t\tif (IS_ERR(cell)) {\n\t\t\tret = PTR_ERR(cell);\n\t\t\tgoto done;\n\t\t}\n\n\t\tafs_put_cell(cell);\n\t\tprintk(\"kAFS: Added new cell '%s'\\n\", name);\n\t} else {\n\t\tgoto inval;\n\t}\n\n\tret = size;\n\ndone:\n\tkfree(kbuf);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n\ninval:\n\tret = -EINVAL;\n\tprintk(\"kAFS: Invalid Command on /proc/fs/afs/cells file\\n\");\n\tgoto done;\n}"
  },
  {
    "function_name": "afs_proc_cells_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "203-217",
    "snippet": "static int afs_proc_cells_show(struct seq_file *m, void *v)\n{\n\tstruct afs_cell *cell = list_entry(v, struct afs_cell, proc_link);\n\n\tif (v == &afs_proc_cells) {\n\t\t/* display header on line 1 */\n\t\tseq_puts(m, \"USE NAME\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one cell per line on subsequent lines */\n\tseq_printf(m, \"%3d %s\\n\",\n\t\t   atomic_read(&cell->usage), cell->name);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%3d %s\\n\"",
            "atomic_read(&cell->usage)",
            "cell->name"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cell->usage"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"USE NAME\\n\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structafs_cell",
            "proc_link"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic int afs_proc_cells_show(struct seq_file *m, void *v)\n{\n\tstruct afs_cell *cell = list_entry(v, struct afs_cell, proc_link);\n\n\tif (v == &afs_proc_cells) {\n\t\t/* display header on line 1 */\n\t\tseq_puts(m, \"USE NAME\\n\");\n\t\treturn 0;\n\t}\n\n\t/* display one cell per line on subsequent lines */\n\tseq_printf(m, \"%3d %s\\n\",\n\t\t   atomic_read(&cell->usage), cell->name);\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cells_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "195-198",
    "snippet": "static void afs_proc_cells_stop(struct seq_file *p, void *v)\n{\n\tup_read(&afs_proc_cells_sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&afs_proc_cells_sem"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v)\n{\n\tup_read(&afs_proc_cells_sem);\n}"
  },
  {
    "function_name": "afs_proc_cells_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "187-190",
    "snippet": "static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &afs_proc_cells, pos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);",
      "static void afs_proc_cells_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cells_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_volumes_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);",
      "static void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);",
      "static void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);",
      "static void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);",
      "static void afs_proc_cell_servers_stop(struct seq_file *p, void *v);",
      "static int afs_proc_cell_servers_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&afs_proc_cells",
            "pos"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "779-786",
          "snippet": "struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic void *afs_proc_cells_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos);\nstatic void afs_proc_cells_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cells_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_volumes_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_volumes_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void afs_proc_cell_volumes_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_volumes_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_vlservers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_vlservers_next(struct seq_file *p, void *v,\n\t\t\t\t\t  loff_t *pos);\nstatic void afs_proc_cell_vlservers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_vlservers_show(struct seq_file *m, void *v);\nstatic void *afs_proc_cell_servers_start(struct seq_file *p, loff_t *pos);\nstatic void *afs_proc_cell_servers_next(struct seq_file *p, void *v,\n\t\t\t\t\tloff_t *pos);\nstatic void afs_proc_cell_servers_stop(struct seq_file *p, void *v);\nstatic int afs_proc_cell_servers_show(struct seq_file *m, void *v);\n\nstatic void *afs_proc_cells_next(struct seq_file *p, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &afs_proc_cells, pos);\n}"
  },
  {
    "function_name": "afs_proc_cells_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "177-182",
    "snippet": "static void *afs_proc_cells_start(struct seq_file *m, loff_t *_pos)\n{\n\t/* lock the list against modification */\n\tdown_read(&afs_proc_cells_sem);\n\treturn seq_list_start_head(&afs_proc_cells, *_pos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);",
      "static ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start_head",
          "args": [
            "&afs_proc_cells",
            "*_pos"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_start_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "770-776",
          "snippet": "struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&afs_proc_cells_sem"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic ssize_t afs_proc_cells_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t size, loff_t *_pos);\nstatic ssize_t afs_proc_rootcell_write(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t size, loff_t *_pos);\n\nstatic void *afs_proc_cells_start(struct seq_file *m, loff_t *_pos)\n{\n\t/* lock the list against modification */\n\tdown_read(&afs_proc_cells_sem);\n\treturn seq_list_start_head(&afs_proc_cells, *_pos);\n}"
  },
  {
    "function_name": "afs_proc_cells_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "158-171",
    "snippet": "static int afs_proc_cells_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &afs_proc_cells_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = PDE_DATA(inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_proc_cells_open(struct inode *inode, struct file *file);",
      "static const struct seq_operations afs_proc_cells_ops = {\n\t.start\t= afs_proc_cells_start,\n\t.next\t= afs_proc_cells_next,\n\t.stop\t= afs_proc_cells_stop,\n\t.show\t= afs_proc_cells_show,\n};",
      "static int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);",
      "static int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);",
      "static int afs_proc_cell_servers_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&afs_proc_cells_ops"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic int afs_proc_cells_open(struct inode *inode, struct file *file);\nstatic const struct seq_operations afs_proc_cells_ops = {\n\t.start\t= afs_proc_cells_start,\n\t.next\t= afs_proc_cells_next,\n\t.stop\t= afs_proc_cells_stop,\n\t.show\t= afs_proc_cells_show,\n};\nstatic int afs_proc_cell_volumes_open(struct inode *inode, struct file *file);\nstatic int afs_proc_cell_vlservers_open(struct inode *inode,\n\t\t\t\t\tstruct file *file);\nstatic int afs_proc_cell_servers_open(struct inode *inode, struct file *file);\n\nstatic int afs_proc_cells_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &afs_proc_cells_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = PDE_DATA(inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_proc_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "150-153",
    "snippet": "void afs_proc_cleanup(void)\n{\n\tremove_proc_subtree(\"fs/afs\", NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_subtree",
          "args": [
            "\"fs/afs\"",
            "NULL"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "557-601",
          "snippet": "int remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nint remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid afs_proc_cleanup(void)\n{\n\tremove_proc_subtree(\"fs/afs\", NULL);\n}"
  },
  {
    "function_name": "afs_proc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
    "lines": "125-145",
    "snippet": "int afs_proc_init(void)\n{\n\t_enter(\"\");\n\n\tproc_afs = proc_mkdir(\"fs/afs\", NULL);\n\tif (!proc_afs)\n\t\tgoto error_dir;\n\n\tif (!proc_create(\"cells\", 0644, proc_afs, &afs_proc_cells_fops) ||\n\t    !proc_create(\"rootcell\", 0644, proc_afs, &afs_proc_rootcell_fops))\n\t\tgoto error_tree;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_tree:\n\tremove_proc_subtree(\"fs/afs\", NULL);\nerror_dir:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_afs;",
      "static const struct file_operations afs_proc_cells_fops = {\n\t.open\t\t= afs_proc_cells_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= afs_proc_cells_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};",
      "static const struct file_operations afs_proc_rootcell_fops = {\n\t.read\t\t= afs_proc_rootcell_read,\n\t.write\t\t= afs_proc_rootcell_write,\n\t.llseek\t\t= no_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOMEM\""
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_proc_subtree",
          "args": [
            "\"fs/afs\"",
            "NULL"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "557-601",
          "snippet": "int remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nint remove_proc_subtree(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *root = NULL, *de, *next;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\tlen = strlen(fn);\n\n\troot = pde_subdir_find(parent, fn, len);\n\tif (!root) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn -ENOENT;\n\t}\n\trb_erase(&root->subdir_node, &parent->subdir);\n\n\tde = root;\n\twhile (1) {\n\t\tnext = pde_subdir_first(de);\n\t\tif (next) {\n\t\t\trb_erase(&next->subdir_node, &de->subdir);\n\t\t\tde = next;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&proc_subdir_lock);\n\n\t\tproc_entry_rundown(de);\n\t\tnext = de->parent;\n\t\tif (S_ISDIR(de->mode))\n\t\t\tnext->nlink--;\n\t\tde->nlink = 0;\n\t\tif (de == root)\n\t\t\tbreak;\n\t\tpde_put(de);\n\n\t\tspin_lock(&proc_subdir_lock);\n\t\tde = next;\n\t}\n\tpde_put(root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"rootcell\"",
            "0644",
            "proc_afs",
            "&afs_proc_rootcell_fops"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_proc_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/proc.c",
          "lines": "228-252",
          "snippet": "static int\nnfs_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\tint flags)\n{\n\tstruct nfs_createdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_CREATE],\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  create %pd\\n\", dentry);\n\tdata = nfs_alloc_createdata(dir, dentry, sattr);\n\tif (data == NULL)\n\t\tgoto out;\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_mark_for_revalidate(dir);\n\tif (status == 0)\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr, NULL);\n\tnfs_free_createdata(data);\nout:\n\tdprintk(\"NFS reply create: %d\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/in.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/param.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/freezer.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/pagemap.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/param.h>\n#include <linux/types.h>\n\nstatic int\nnfs_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n\t\tint flags)\n{\n\tstruct nfs_createdata *data;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs_procedures[NFSPROC_CREATE],\n\t};\n\tint status = -ENOMEM;\n\n\tdprintk(\"NFS call  create %pd\\n\", dentry);\n\tdata = nfs_alloc_createdata(dir, dentry, sattr);\n\tif (data == NULL)\n\t\tgoto out;\n\tmsg.rpc_argp = &data->arg;\n\tmsg.rpc_resp = &data->res;\n\tstatus = rpc_call_sync(NFS_CLIENT(dir), &msg, 0);\n\tnfs_mark_for_revalidate(dir);\n\tif (status == 0)\n\t\tstatus = nfs_instantiate(dentry, data->res.fh, data->res.fattr, NULL);\n\tnfs_free_createdata(data);\nout:\n\tdprintk(\"NFS reply create: %d\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"fs/afs\"",
            "NULL"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic struct proc_dir_entry *proc_afs;\nstatic const struct file_operations afs_proc_cells_fops = {\n\t.open\t\t= afs_proc_cells_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= afs_proc_cells_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\nstatic const struct file_operations afs_proc_rootcell_fops = {\n\t.read\t\t= afs_proc_rootcell_read,\n\t.write\t\t= afs_proc_rootcell_write,\n\t.llseek\t\t= no_llseek,\n};\n\nint afs_proc_init(void)\n{\n\t_enter(\"\");\n\n\tproc_afs = proc_mkdir(\"fs/afs\", NULL);\n\tif (!proc_afs)\n\t\tgoto error_dir;\n\n\tif (!proc_create(\"cells\", 0644, proc_afs, &afs_proc_cells_fops) ||\n\t    !proc_create(\"rootcell\", 0644, proc_afs, &afs_proc_rootcell_fops))\n\t\tgoto error_tree;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_tree:\n\tremove_proc_subtree(\"fs/afs\", NULL);\nerror_dir:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
  }
]