[
  {
    "function_name": "rty_idx_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "963-985",
    "snippet": "d_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b(c);\n\n\tubifs_",
          "args": [
            "e"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_leb(c);\n\n\t/* Fin",
          "args": [
            "l"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_idx_leb(c);\n\n\t/* Nex",
          "args": [],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\t/*\n\t *",
          "args": [
            "W"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nd_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}"
  },
  {
    "function_name": "_idx_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "927-953",
    "snippet": "nd_dirtiest_idx_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint lnum;\n\n\twhile (1) {\n\t\tif (!c->dirty_idx.cnt)\n\t\t\treturn -ENOSPC;\n\t\t/* The lprops pointers were replaced by LEB numbers */\n\t\tlnum = (size_t)c->dirty_idx.arr[--c->dirty_idx.cnt];\n\t\tlp = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lp))\n\t\t\treturn PTR_ERR(lp);\n\t\tif ((lp->flags & LPROPS_TAKEN) || !(lp->flags & LPROPS_INDEX))\n\t\t\tcontinue;\n\t\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\t\tif (IS_ERR(lp))\n\t\t\treturn PTR_ERR(lp);\n\t\tbreak;\n\t}\n\tdbg_find(\"LEB %d, dirty %d and free %d flags %#x\", lp->lnum, lp->dirty,\n\t\t lp->free, lp->flags);\n\tubifs_assert(lp->flags & LPROPS_TAKEN);\n\tubifs_assert(lp->flags & LPROPS_INDEX);\n\treturn lnum;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lp->flags &",
          "args": [
            "PROPS_INDEX);\n\treturn ln"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp->flags &",
          "args": [
            "PROPS_TAKEN);\n\tubifs_ass"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d, dir",
          "args": [
            "y %d and free %d flags %#x\", lp->lnum, l",
            ">dirty,",
            "lp->free",
            ">flags);",
            "ubifs_ass"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "break",
          "args": [],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lp(c, lp, LPROP",
          "args": [
            "_",
            ",",
            "ROPS_NC,",
            "lp",
            "PROPS_TAKEN, 0);\n\t\tif (I",
            "E"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if ((",
          "args": [
            "p-"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, lnum);",
          "args": [
            "f",
            "IS_E"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nnd_dirtiest_idx_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint lnum;\n\n\twhile (1) {\n\t\tif (!c->dirty_idx.cnt)\n\t\t\treturn -ENOSPC;\n\t\t/* The lprops pointers were replaced by LEB numbers */\n\t\tlnum = (size_t)c->dirty_idx.arr[--c->dirty_idx.cnt];\n\t\tlp = ubifs_lpt_lookup(c, lnum);\n\t\tif (IS_ERR(lp))\n\t\t\treturn PTR_ERR(lp);\n\t\tif ((lp->flags & LPROPS_TAKEN) || !(lp->flags & LPROPS_INDEX))\n\t\t\tcontinue;\n\t\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\t\tif (IS_ERR(lp))\n\t\t\treturn PTR_ERR(lp);\n\t\tbreak;\n\t}\n\tdbg_find(\"LEB %d, dirty %d and free %d flags %#x\", lp->lnum, lp->dirty,\n\t\t lp->free, lp->flags);\n\tubifs_assert(lp->flags & LPROPS_TAKEN);\n\tubifs_assert(lp->flags & LPROPS_INDEX);\n\treturn lnum;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "b(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "898-921",
    "snippet": "t_idx_gc_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err, lnum;\n\n\terr = ubifs_get_idx_gc_leb(c);\n\tif (err < 0)\n\t\treturn err;\n\tlnum = err;\n\t/*\n\t * The LEB was due to be unmapped after the commit but\n\t * it is needed now for this commit.\n\t */\n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_INDEX, -1);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\tdbg_find(\"LEB %d, dirty %d and free %d flags %#x\",\n\t\t lp->lnum, lp->dirty, lp->free, lp->flags);\n\treturn lnum;\n}\n\n/**\n * find",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "%d, dir",
          "args": [
            "y %d and free %d flags %#x\",\n\t\t lp->lnum",
            ">dirty,",
            "->free, l",
            ">flags);",
            "return ln"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_fi",
          "args": [
            "d("
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "P"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lp(c, lp, LPROP",
          "args": [
            "_",
            ",",
            "ROPS_NC,",
            "lp-",
            "PROPS_INDEX, -1);\n\tif (I",
            "ER"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp = u",
          "args": [
            "if"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, lnum);\n\ti",
          "args": [
            "S_ER"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_gc_leb(c);\n\tif (err",
          "args": [
            "<"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nt_idx_gc_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lp;\n\tint err, lnum;\n\n\terr = ubifs_get_idx_gc_leb(c);\n\tif (err < 0)\n\t\treturn err;\n\tlnum = err;\n\t/*\n\t * The LEB was due to be unmapped after the commit but\n\t * it is needed now for this commit.\n\t */\n\tlp = ubifs_lpt_lookup_dirty(c, lnum);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_INDEX, -1);\n\tif (IS_ERR(lp))\n\t\treturn PTR_ERR(lp);\n\tdbg_find(\"LEB %d, dirty %d and free %d flags %#x\",\n\t\t lp->lnum, lp->dirty, lp->free, lp->flags);\n\treturn lnum;\n}\n\n/**\n * find"
  },
  {
    "function_name": "x_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "838-892",
    "snippet": "nd_dirty_idx_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i, ret;\n\n\t/* Check all structures in memory first */\n\tdata.lnum = -1;\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t/* All pnodes are in memory, so skip scan */\n\t\treturn -ENOSPC;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_dirty_idx_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn err;\nfound:\n\tubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn PTR_ERR(lprops);\n\tubifs_assert(lprops->lnum == data.lnum);\n\tubifs_assert(lprops->free + lprops->dirty >= c->min_idx_node_sz);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert((lprops->flags & LPROPS_INDEX));\n\n\tdbg_find(\"found dirty LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lprops->lnum, lprops->free, lprops->dirty, lprops->flags);\n\n\tlprops = ubifs_change_lp(c, lprops, LPROPS_NC, LPROPS_NC,\n\t\t\t\t lprops->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lprops))\n\t\treturn PTR_ERR(lprops);\n\n\treturn lprops->lnum;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s);\n\n\tr",
          "args": [
            "turn l"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))\n\t\tr",
          "args": [
            "turn P"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp(c, lprops, L",
          "args": [
            "R",
            "S_NC,",
            "ROPS_NC,",
            "lprops",
            "| LPROPS_TAKEN, 0);\n\tif (IS",
            "R"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd dirty",
          "args": [
            "LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lprops->",
            "lprops->fre",
            "lprops->dir",
            ", lprops->fla",
            ");\n\n\tlprops ="
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(lprops->fla",
          "args": [
            "s & LPROPS_INDEX));\n\n\tdbg_find"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_TAKEN));\n\tubifs_ass"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->free",
          "args": [
            "+ lprops->dirty >= c->min_idx_node_sz);\n\tubifs_ass"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->lnum",
          "args": [
            "== data.lnum);\n\tubifs_ass"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s);\n\tub",
          "args": [
            "fs_ass"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))\n\t\tr",
          "args": [
            "turn P"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, data.lnum",
          "args": [
            ";",
            "if (IS_ER"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.lnum >=",
          "args": [
            "c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_nolock(c, -1, c->ls",
          "args": [
            "a",
            "ln",
            ",\n\t\t\t\t    (ub",
            "an_callback)scan_dirty_idx_cb,\n\t\t\t\t    &da",
            "err)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_cb(c, lprops, 1",
          "args": [
            "ata);",
            "i",
            "(ret"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "ncat_l",
            "t, list) {\n\t\tr",
            "= s"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_cb(c, lprops, 1",
          "args": [
            "ata);",
            "i",
            "(ret"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "rdi_id",
            "list, list) {\n\t\tr",
            "= s"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_cb(c, lprops, 1",
          "args": [
            "ata);",
            "i",
            "(ret"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nnd_dirty_idx_leb(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i, ret;\n\n\t/* Check all structures in memory first */\n\tdata.lnum = -1;\n\theap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tlist_for_each_entry(lprops, &c->frdi_idx_list, list) {\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tret = scan_dirty_idx_cb(c, lprops, 1, &data);\n\t\tif (ret & LPT_SCAN_STOP)\n\t\t\tgoto found;\n\t}\n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t/* All pnodes are in memory, so skip scan */\n\t\treturn -ENOSPC;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_dirty_idx_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn err;\nfound:\n\tubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn PTR_ERR(lprops);\n\tubifs_assert(lprops->lnum == data.lnum);\n\tubifs_assert(lprops->free + lprops->dirty >= c->min_idx_node_sz);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert((lprops->flags & LPROPS_INDEX));\n\n\tdbg_find(\"found dirty LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lprops->lnum, lprops->free, lprops->dirty, lprops->flags);\n\n\tlprops = ubifs_change_lp(c, lprops, LPROPS_NC, LPROPS_NC,\n\t\t\t\t lprops->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lprops))\n\t\treturn PTR_ERR(lprops);\n\n\treturn lprops->lnum;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "x_cb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "805-826",
    "snippet": "an_dirty_idx_cb(struct ubifs_info *c,\n\t\t\t   const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t   struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t/* Exclude LEBs that are currently in use */\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t/* Determine whether to add these LEB properties to the tree */\n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t/* Exclude non-index LEBs */\n\tif (!(lprops->flags & LPROPS_INDEX))\n\t\treturn ret;\n\t/* Exclude LEBs with too little space */\n\tif (lprops->free + lprops->dirty < c->min_idx_node_sz)\n\t\treturn ret;\n\t/* Finally we found space */\n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n/**\n * find",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "props))",
          "args": [
            "t |= L"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nan_dirty_idx_cb(struct ubifs_info *c,\n\t\t\t   const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t   struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t/* Exclude LEBs that are currently in use */\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t/* Determine whether to add these LEB properties to the tree */\n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t/* Exclude non-index LEBs */\n\tif (!(lprops->flags & LPROPS_INDEX))\n\t\treturn ret;\n\t/* Exclude LEBs with too little space */\n\tif (lprops->free + lprops->dirty < c->min_idx_node_sz)\n\t\treturn ret;\n\t/* Finally we found space */\n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n/**\n * find"
  },
  {
    "function_name": "rty_idx_lnums(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "767-791",
    "snippet": "e_dirty_idx_lnums(struct ubifs_info *c)\n{\n\tint i;\n\n\tubifs_get_lprops(c);\n\t/* Copy the LPROPS_DIRTY_IDX heap */\n\tc->dirty_idx.cnt = c->lpt_heap[LPROPS_DIRTY_IDX - 1].cnt;\n\tmemcpy(c->dirty_idx.arr, c->lpt_heap[LPROPS_DIRTY_IDX - 1].arr,\n\t       sizeof(void *) * c->dirty_idx.cnt);\n\t/* Sort it so that the dirtiest is now at the end */\n\tsort(c->dirty_idx.arr, c->dirty_idx.cnt, sizeof(void *),\n\t     (int (*)(const void *, const void *))cmp_dirty_idx,\n\t     (void (*)(void *, void *, int))swap_dirty_idx);\n\tdbg_find(\"found %d dirty index LEBs\", c->dirty_idx.cnt);\n\tif (c->dirty_idx.cnt)\n\t\tdbg_find(\"dirtiest index LEB is %d with dirty %d and free %d\",\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->lnum,\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->dirty,\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->free);\n\t/* Replace the lprops pointers with LEB numbers */\n\tfor (i = 0; i < c->dirty_idx.cnt; i++)\n\t\tc->dirty_idx.arr[i] = (void *)(size_t)c->dirty_idx.arr[i]->lnum;\n\tubifs_release_lprops(c);\n\treturn 0;\n}\n\n/**\n * scan",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            ";"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tiest in",
          "args": [
            "ex LEB is %d with dirty %d and free %d\",\n\t\t\t c->dirt",
            "arr[c->dirty_idx.cnt - 1]->lnum,\n\t\t\t c->dirt",
            "arr[c->dirty_idx.cnt - 1]->dirty,\n\t\t\t c->dirt",
            "arr[c->dirty_idx.cnt - 1]->free);\n\t/* Replac"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd %d di",
          "args": [
            "ty index LEBs\", c->dirty_id",
            "cnt);\n\tif (c->di"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_idx",
          "args": [
            "arr, c->dirty_id",
            "cnt, sizeof(void",
            "),\n\t     (int",
            "t void *, const void *))cmp_dirty_idx,\n\t     (void",
            "d *, void *, int))swap_dirty_idx);\n\tdbg_find("
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ty_idx",
          "args": [
            "arr, c->lpt_heap",
            "PROPS_DIRTY_IDX - 1].arr,\n\t       siz",
            ") * c->dirty_idx.cnt);\n\t/* Sort i"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\t/* Copy",
          "args": [
            "t"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\ne_dirty_idx_lnums(struct ubifs_info *c)\n{\n\tint i;\n\n\tubifs_get_lprops(c);\n\t/* Copy the LPROPS_DIRTY_IDX heap */\n\tc->dirty_idx.cnt = c->lpt_heap[LPROPS_DIRTY_IDX - 1].cnt;\n\tmemcpy(c->dirty_idx.arr, c->lpt_heap[LPROPS_DIRTY_IDX - 1].arr,\n\t       sizeof(void *) * c->dirty_idx.cnt);\n\t/* Sort it so that the dirtiest is now at the end */\n\tsort(c->dirty_idx.arr, c->dirty_idx.cnt, sizeof(void *),\n\t     (int (*)(const void *, const void *))cmp_dirty_idx,\n\t     (void (*)(void *, void *, int))swap_dirty_idx);\n\tdbg_find(\"found %d dirty index LEBs\", c->dirty_idx.cnt);\n\tif (c->dirty_idx.cnt)\n\t\tdbg_find(\"dirtiest index LEB is %d with dirty %d and free %d\",\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->lnum,\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->dirty,\n\t\t\t c->dirty_idx.arr[c->dirty_idx.cnt - 1]->free);\n\t/* Replace the lprops pointers with LEB numbers */\n\tfor (i = 0; i < c->dirty_idx.cnt; i++)\n\t\tc->dirty_idx.arr[i] = (void *)(size_t)c->dirty_idx.arr[i]->lnum;\n\tubifs_release_lprops(c);\n\treturn 0;\n}\n\n/**\n * scan"
  },
  {
    "function_name": "x(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "750-757",
    "snippet": "wap_dirty_idx(struct ubifs_lprops **a, struct ubifs_lprops **b,\n\t\t\t   int size)\n{\n\tstruct ubifs_lprops *t = *a;\n\n\t*a = *b;\n\t*b = t;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nwap_dirty_idx(struct ubifs_lprops **a, struct ubifs_lprops **b,\n\t\t\t   int size)\n{\n\tstruct ubifs_lprops *t = *a;\n\n\t*a = *b;\n\t*b = t;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "741-748",
    "snippet": "p_dirty_idx(const struct ubifs_lprops **a,\n\t\t\t const struct ubifs_lprops **b)\n{\n\tconst struct ubifs_lprops *lpa = *a;\n\tconst struct ubifs_lprops *lpb = *b;\n\n\treturn lpa->dirty + lpa->free - lpb->dirty - lpb->free;\n}\n\nstatic void",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\np_dirty_idx(const struct ubifs_lprops **a,\n\t\t\t const struct ubifs_lprops **b)\n{\n\tconst struct ubifs_lprops *lpa = *a;\n\tconst struct ubifs_lprops *lpb = *b;\n\n\treturn lpa->dirty + lpa->free - lpb->dirty - lpb->free;\n}\n\nstatic void"
  },
  {
    "function_name": "ee_leb_for_idx(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "673-739",
    "snippet": "d_free_leb_for_idx(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lprops;\n\tint lnum = -1, err, flags;\n\n\tubifs_get_lprops(c);\n\n\tlprops = ubifs_fast_find_empty(c);\n\tif (!lprops) {\n\t\tlprops = ubifs_fast_find_freeable(c);\n\t\tif (!lprops) {\n\t\t\t/*\n\t\t\t * The first condition means the following: go scan the\n\t\t\t * LPT if there are uncategorized lprops, which means\n\t\t\t * there may be freeable LEBs there (UBIFS does not\n\t\t\t * store the information about freeable LEBs in the\n\t\t\t * master node).\n\t\t\t */\n\t\t\tif (c->in_a_category_cnt != c->main_lebs ||\n\t\t\t    c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {\n\t\t\t\tubifs_assert(c->freeable_cnt == 0);\n\t\t\t\tlprops = scan_for_leb_for_idx(c);\n\t\t\t\tif (IS_ERR(lprops)) {\n\t\t\t\t\terr = PTR_ERR(lprops);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!lprops) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tlnum = lprops->lnum;\n\n\tdbg_find(\"found LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lnum, lprops->free, lprops->dirty, lprops->flags);\n\n\tflags = lprops->flags | LPROPS_TAKEN | LPROPS_INDEX;\n\tlprops = ubifs_change_lp(c, lprops, c->leb_size, 0, flags, 0);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tubifs_release_lprops(c);\n\n\t/*\n\t * Ensure that empty LEBs have been unmapped. They may not have been,\n\t * for example, because of an unclean unmount. Also LEBs that were\n\t * freeable LEBs (free + dirty == leb_size) will not have been unmapped.\n\t */\n\terr = ubifs_leb_unmap(c, lnum);\n\tif (err) {\n\t\tubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t    LPROPS_TAKEN | LPROPS_INDEX, 0);\n\t\treturn err;\n\t}\n\n\treturn lnum;\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\nstatic int",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum, LPR",
          "args": [
            "P",
            "NC,",
            "ROPS_NC,",
            "R",
            "| LPROPS_INDEX, 0);\n\t\tretur",
            "e"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lprops(c);\n\n\t/*\n\t *",
          "args": [
            "E"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s);\n\t\tg",
          "args": [
            "to out"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp(c, lprops, c",
          "args": [
            ">",
            "b_size",
            "0, flags, 0",
            "f (IS",
            "R"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd LEB %",
          "args": [
            ", free %d, dirty %d, flags %#x\",\n\t\t lnum, lp",
            ">fre",
            "lprops->dir",
            ", lprops->fla",
            ");\n\n\tflags ="
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s);",
          "args": [
            "goto"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_idx(c);\n\t\t\t\tif (",
          "args": [
            "S"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->freeable_",
          "args": [
            "nt == 0);\n\t\t\t\tlprops"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_freeable(c);\n\t\tif (!l",
          "args": [
            "r"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_empty(c);\n\tif (!lp",
          "args": [
            "o"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\tlprops",
          "args": [
            "="
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nd_free_leb_for_idx(struct ubifs_info *c)\n{\n\tconst struct ubifs_lprops *lprops;\n\tint lnum = -1, err, flags;\n\n\tubifs_get_lprops(c);\n\n\tlprops = ubifs_fast_find_empty(c);\n\tif (!lprops) {\n\t\tlprops = ubifs_fast_find_freeable(c);\n\t\tif (!lprops) {\n\t\t\t/*\n\t\t\t * The first condition means the following: go scan the\n\t\t\t * LPT if there are uncategorized lprops, which means\n\t\t\t * there may be freeable LEBs there (UBIFS does not\n\t\t\t * store the information about freeable LEBs in the\n\t\t\t * master node).\n\t\t\t */\n\t\t\tif (c->in_a_category_cnt != c->main_lebs ||\n\t\t\t    c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {\n\t\t\t\tubifs_assert(c->freeable_cnt == 0);\n\t\t\t\tlprops = scan_for_leb_for_idx(c);\n\t\t\t\tif (IS_ERR(lprops)) {\n\t\t\t\t\terr = PTR_ERR(lprops);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!lprops) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tlnum = lprops->lnum;\n\n\tdbg_find(\"found LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lnum, lprops->free, lprops->dirty, lprops->flags);\n\n\tflags = lprops->flags | LPROPS_TAKEN | LPROPS_INDEX;\n\tlprops = ubifs_change_lp(c, lprops, c->leb_size, 0, flags, 0);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tubifs_release_lprops(c);\n\n\t/*\n\t * Ensure that empty LEBs have been unmapped. They may not have been,\n\t * for example, because of an unclean unmount. Also LEBs that were\n\t * freeable LEBs (free + dirty == leb_size) will not have been unmapped.\n\t */\n\terr = ubifs_leb_unmap(c, lnum);\n\tif (err) {\n\t\tubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t    LPROPS_TAKEN | LPROPS_INDEX, 0);\n\t\treturn err;\n\t}\n\n\treturn lnum;\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\nstatic int"
  },
  {
    "function_name": "for_idx(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "633-655",
    "snippet": "struct ubifs_lprops *scan_for_leb_for_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct scan_data data;\n\tint err;\n\n\tdata.lnum = -1;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_idx_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(lprops->lnum == data.lnum);\n\tubifs_assert(lprops->free + lprops->dirty == c->leb_size);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_INDEX));\n\treturn lp"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_TAKEN));\n\tubifs_ass"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->free",
          "args": [
            "+ lprops->dirty == c->leb_size);\n\tubifs_ass"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->lnum",
          "args": [
            "== data.lnum);\n\tubifs_ass"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))\n\t\tr",
          "args": [
            "turn l"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, data.lnum",
          "args": [
            ";",
            "if (IS_ER"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.lnum >=",
          "args": [
            "c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs",
          "args": [
            "ass"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "rty_idx_leb(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
          "lines": "963-985",
          "snippet": "d_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * struc",
            "ux/sort.h>\n#include \"ubi"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nd_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "n_nolock(c, -1, c->ls",
          "args": [
            "a",
            "ln",
            ",\n\t\t\t\t    (ub",
            "an_callback)scan_for_idx_cb,\n\t\t\t\t    &da",
            "err)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nstruct ubifs_lprops *scan_for_leb_for_idx(struct ubifs_info *c)\n{\n\tstruct ubifs_lprops *lprops;\n\tstruct scan_data data;\n\tint err;\n\n\tdata.lnum = -1;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_idx_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(lprops->lnum == data.lnum);\n\tubifs_assert(lprops->free + lprops->dirty == c->leb_size);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "cb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "602-627",
    "snippet": "an_for_idx_cb(struct ubifs_info *c,\n\t\t\t   const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t   struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t/* Exclude LEBs that are currently in use */\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t/* Determine whether to add these LEB properties to the tree */\n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t/* Exclude index LEBS */\n\tif (lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t/* Exclude LEBs that cannot be made empty */\n\tif (lprops->free + lprops->dirty != c->leb_size)\n\t\treturn ret;\n\t/*\n\t * We are allocating for the index so it is safe to allocate LEBs with\n\t * only free and dirty space, because write buffers are sync'd at commit\n\t * start.\n\t */\n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n/**\n * scan",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "props))",
          "args": [
            "t |= L"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nan_for_idx_cb(struct ubifs_info *c,\n\t\t\t   const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t   struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t/* Exclude LEBs that are currently in use */\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t/* Determine whether to add these LEB properties to the tree */\n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t/* Exclude index LEBS */\n\tif (lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t/* Exclude LEBs that cannot be made empty */\n\tif (lprops->free + lprops->dirty != c->leb_size)\n\t\treturn ret;\n\t/*\n\t * We are allocating for the index so it is safe to allocate LEBs with\n\t * only free and dirty space, because write buffers are sync'd at commit\n\t * start.\n\t */\n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n/**\n * scan"
  },
  {
    "function_name": "ee_space(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "493-588",
    "snippet": "d_free_space(struct ubifs_info *c, int min_space, int *offs,\n\t\t\t  int squeeze)\n{\n\tconst struct ubifs_lprops *lprops;\n\tint lebs, rsvd_idx_lebs, pick_free = 0, err, lnum, flags;\n\n\tdbg_find(\"min_space %d\", min_space);\n\tubifs_get_lprops(c);\n\n\t/* Check if there are enough empty LEBs for commit */\n\tspin_lock(&c->space_lock);\n\tif (c->bi.min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = c->bi.min_idx_lebs -  c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tif (rsvd_idx_lebs < lebs)\n\t\t/*\n\t\t * OK to allocate an empty LEB, but we still don't want to go\n\t\t * looking for one if there aren't any.\n\t\t */\n\t\tif (c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {\n\t\t\tpick_free = 1;\n\t\t\t/*\n\t\t\t * Because we release the space lock, we must account\n\t\t\t * for this allocation here. After the LEB properties\n\t\t\t * flags have been updated, we subtract one. Note, the\n\t\t\t * result of this is that lprops also decreases\n\t\t\t * @taken_empty_lebs in 'ubifs_change_lp()', so it is\n\t\t\t * off by one for a short period of time which may\n\t\t\t * introduce a small disturbance to budgeting\n\t\t\t * calculations, but this is harmless because at the\n\t\t\t * worst case this would make the budgeting subsystem\n\t\t\t * be more pessimistic than needed.\n\t\t\t *\n\t\t\t * Fundamentally, this is about serialization of the\n\t\t\t * budgeting and lprops subsystems. We could make the\n\t\t\t * @space_lock a mutex and avoid dropping it before\n\t\t\t * calling 'ubifs_change_lp()', but mutex is more\n\t\t\t * heavy-weight, and we want budgeting to be as fast as\n\t\t\t * possible.\n\t\t\t */\n\t\t\tc->lst.taken_empty_lebs += 1;\n\t\t}\n\tspin_unlock(&c->space_lock);\n\n\tlprops = do_find_free_space(c, min_space, pick_free, squeeze);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tlnum = lprops->lnum;\n\tflags = lprops->flags | LPROPS_TAKEN;\n\n\tlprops = ubifs_change_lp(c, lprops, LPROPS_NC, LPROPS_NC, flags, 0);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tif (pick_free) {\n\t\tspin_lock(&c->space_lock);\n\t\tc->lst.taken_empty_lebs -= 1;\n\t\tspin_unlock(&c->space_lock);\n\t}\n\n\t*offs = c->leb_size - lprops->free;\n\tubifs_release_lprops(c);\n\n\tif (*offs == 0) {\n\t\t/*\n\t\t * Ensure that empty LEBs have been unmapped. They may not have\n\t\t * been, for example, because of an unclean unmount.  Also\n\t\t * LEBs that were freeable LEBs (free + dirty == leb_size) will\n\t\t * not have been unmapped.\n\t\t */\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdbg_find(\"found LEB %d, free %d\", lnum, c->leb_size - *offs);\n\tubifs_assert(*offs <= c->leb_size - min_space);\n\treturn lnum;\n\nout:\n\tif (pick_free) {\n\t\tspin_lock(&c->space_lock);\n\t\tc->lst.taken_empty_lebs -= 1;\n\t\tspin_unlock(&c->space_lock);\n\t}\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * scan",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\t}\n\tubifs_"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\t\tc->lst.t"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*offs <= c->",
          "args": [
            "eb_size - min_space);\n\treturn ln"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd LEB %",
          "args": [
            ", free %d\", lnum, c->le",
            "size",
            "*offs);\n\tubifs_ass"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "f",
            "err)"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_lprops(c);\n\n\tif (*o",
          "args": [
            "f"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\t}\n\n\t*offs"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\t\tc->lst.t"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s);\n\t\tg",
          "args": [
            "to out"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp(c, lprops, L",
          "args": [
            "R",
            "S_NC,",
            "ROPS_NC,",
            "ags, 0);",
            "f (IS",
            "R"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s);\n\t\tg",
          "args": [
            "to out"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")) {",
          "args": [
            "err ="
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, min_space",
          "args": [
            "ck_free,",
            "ueeze);",
            "(IS_ER"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\n\tlprops ="
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\tif (c->bi"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\t/* Che",
          "args": [
            "k"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_space %",
          "args": [
            "\", min_space);",
            "ubifs_get"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nd_free_space(struct ubifs_info *c, int min_space, int *offs,\n\t\t\t  int squeeze)\n{\n\tconst struct ubifs_lprops *lprops;\n\tint lebs, rsvd_idx_lebs, pick_free = 0, err, lnum, flags;\n\n\tdbg_find(\"min_space %d\", min_space);\n\tubifs_get_lprops(c);\n\n\t/* Check if there are enough empty LEBs for commit */\n\tspin_lock(&c->space_lock);\n\tif (c->bi.min_idx_lebs > c->lst.idx_lebs)\n\t\trsvd_idx_lebs = c->bi.min_idx_lebs -  c->lst.idx_lebs;\n\telse\n\t\trsvd_idx_lebs = 0;\n\tlebs = c->lst.empty_lebs + c->freeable_cnt + c->idx_gc_cnt -\n\t       c->lst.taken_empty_lebs;\n\tif (rsvd_idx_lebs < lebs)\n\t\t/*\n\t\t * OK to allocate an empty LEB, but we still don't want to go\n\t\t * looking for one if there aren't any.\n\t\t */\n\t\tif (c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {\n\t\t\tpick_free = 1;\n\t\t\t/*\n\t\t\t * Because we release the space lock, we must account\n\t\t\t * for this allocation here. After the LEB properties\n\t\t\t * flags have been updated, we subtract one. Note, the\n\t\t\t * result of this is that lprops also decreases\n\t\t\t * @taken_empty_lebs in 'ubifs_change_lp()', so it is\n\t\t\t * off by one for a short period of time which may\n\t\t\t * introduce a small disturbance to budgeting\n\t\t\t * calculations, but this is harmless because at the\n\t\t\t * worst case this would make the budgeting subsystem\n\t\t\t * be more pessimistic than needed.\n\t\t\t *\n\t\t\t * Fundamentally, this is about serialization of the\n\t\t\t * budgeting and lprops subsystems. We could make the\n\t\t\t * @space_lock a mutex and avoid dropping it before\n\t\t\t * calling 'ubifs_change_lp()', but mutex is more\n\t\t\t * heavy-weight, and we want budgeting to be as fast as\n\t\t\t * possible.\n\t\t\t */\n\t\t\tc->lst.taken_empty_lebs += 1;\n\t\t}\n\tspin_unlock(&c->space_lock);\n\n\tlprops = do_find_free_space(c, min_space, pick_free, squeeze);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tlnum = lprops->lnum;\n\tflags = lprops->flags | LPROPS_TAKEN;\n\n\tlprops = ubifs_change_lp(c, lprops, LPROPS_NC, LPROPS_NC, flags, 0);\n\tif (IS_ERR(lprops)) {\n\t\terr = PTR_ERR(lprops);\n\t\tgoto out;\n\t}\n\n\tif (pick_free) {\n\t\tspin_lock(&c->space_lock);\n\t\tc->lst.taken_empty_lebs -= 1;\n\t\tspin_unlock(&c->space_lock);\n\t}\n\n\t*offs = c->leb_size - lprops->free;\n\tubifs_release_lprops(c);\n\n\tif (*offs == 0) {\n\t\t/*\n\t\t * Ensure that empty LEBs have been unmapped. They may not have\n\t\t * been, for example, because of an unclean unmount.  Also\n\t\t * LEBs that were freeable LEBs (free + dirty == leb_size) will\n\t\t * not have been unmapped.\n\t\t */\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdbg_find(\"found LEB %d, free %d\", lnum, c->leb_size - *offs);\n\tubifs_assert(*offs <= c->leb_size - min_space);\n\treturn lnum;\n\nout:\n\tif (pick_free) {\n\t\tspin_lock(&c->space_lock);\n\t\tc->lst.taken_empty_lebs -= 1;\n\t\tspin_unlock(&c->space_lock);\n\t}\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * scan"
  },
  {
    "function_name": "space(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "406-475",
    "snippet": "struct ubifs_lprops *do_find_free_space(struct ubifs_info *c,\n\t\t\t\t\t      int min_space, int pick_free,\n\t\t\t\t\t      int squeeze)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i;\n\n\tif (squeeze) {\n\t\tlprops = ubifs_fast_find_free(c);\n\t\tif (lprops && lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\tif (pick_free) {\n\t\tlprops = ubifs_fast_find_empty(c);\n\t\tif (lprops)\n\t\t\treturn lprops;\n\t}\n\tif (!squeeze) {\n\t\tlprops = ubifs_fast_find_free(c);\n\t\tif (lprops && lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t/* There may be an LEB with enough free space on the dirty heap */\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tif (lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t/*\n\t * A LEB may have fallen off of the bottom of the free heap, and ended\n\t * up as uncategorized even though it has enough free space for us now,\n\t * so check the uncategorized list. N.B. neither empty nor freeable LEBs\n\t * can end up as uncategorized because they are kept on lists not\n\t * finite-sized heaps.\n\t */\n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tif (lprops->flags & LPROPS_TAKEN)\n\t\t\tcontinue;\n\t\tif (lprops->flags & LPROPS_INDEX)\n\t\t\tcontinue;\n\t\tif (lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t/* We have looked everywhere in main memory, now scan the flash */\n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t/* All pnodes are in memory, so skip scan */\n\t\treturn ERR_PTR(-ENOSPC);\n\tdata.min_space = min_space;\n\tdata.pick_free = pick_free;\n\tdata.lnum = -1;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_free_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(lprops->lnum == data.lnum);\n\tubifs_assert(lprops->free >= min_space);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_INDEX));\n\treturn lp"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_TAKEN));\n\tubifs_ass"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->free",
          "args": [
            ">= min_space);\n\tubifs_ass"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->lnum",
          "args": [
            "== data.lnum);\n\tubifs_ass"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))\n\t\tr",
          "args": [
            "turn l"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, data.lnum",
          "args": [
            ";",
            "if (IS_ER"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.lnum >=",
          "args": [
            "c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs",
          "args": [
            "ass"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "rty_idx_leb(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
          "lines": "963-985",
          "snippet": "d_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * struc",
            "ux/sort.h>\n#include \"ubi"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nd_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "n_nolock(c, -1, c->ls",
          "args": [
            "a",
            "ln",
            ",\n\t\t\t\t    (ub",
            "an_callback)scan_for_free_cb,\n\t\t\t\t    &da",
            "err)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PC);\n\td",
          "args": [
            "ta.min_"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "ncat_l",
            "t, list) {\n\t\ti",
            "(lpr"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_free(c);\n\t\tif (lp",
          "args": [
            "o"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_empty(c);\n\t\tif (lp",
          "args": [
            "o"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_free(c);\n\t\tif (lp",
          "args": [
            "o"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nstruct ubifs_lprops *do_find_free_space(struct ubifs_info *c,\n\t\t\t\t\t      int min_space, int pick_free,\n\t\t\t\t\t      int squeeze)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i;\n\n\tif (squeeze) {\n\t\tlprops = ubifs_fast_find_free(c);\n\t\tif (lprops && lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\tif (pick_free) {\n\t\tlprops = ubifs_fast_find_empty(c);\n\t\tif (lprops)\n\t\t\treturn lprops;\n\t}\n\tif (!squeeze) {\n\t\tlprops = ubifs_fast_find_free(c);\n\t\tif (lprops && lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t/* There may be an LEB with enough free space on the dirty heap */\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tif (lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t/*\n\t * A LEB may have fallen off of the bottom of the free heap, and ended\n\t * up as uncategorized even though it has enough free space for us now,\n\t * so check the uncategorized list. N.B. neither empty nor freeable LEBs\n\t * can end up as uncategorized because they are kept on lists not\n\t * finite-sized heaps.\n\t */\n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tif (lprops->flags & LPROPS_TAKEN)\n\t\t\tcontinue;\n\t\tif (lprops->flags & LPROPS_INDEX)\n\t\t\tcontinue;\n\t\tif (lprops->free >= min_space)\n\t\t\treturn lprops;\n\t}\n\t/* We have looked everywhere in main memory, now scan the flash */\n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t/* All pnodes are in memory, so skip scan */\n\t\treturn ERR_PTR(-ENOSPC);\n\tdata.min_space = min_space;\n\tdata.pick_free = pick_free;\n\tdata.lnum = -1;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_free_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(lprops->lnum == data.lnum);\n\tubifs_assert(lprops->free >= min_space);\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_cb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "362-394",
    "snippet": "an_for_free_cb(struct ubifs_info *c,\n\t\t\t    const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t    struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t/* Exclude LEBs that are currently in use */\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t/* Determine whether to add these LEB properties to the tree */\n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t/* Exclude index LEBs */\n\tif (lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t/* Exclude LEBs with too little space */\n\tif (lprops->free < data->min_space)\n\t\treturn ret;\n\t/* If specified, exclude empty LEBs */\n\tif (!data->pick_free && lprops->free == c->leb_size)\n\t\treturn ret;\n\t/*\n\t * LEBs that have only free and dirty space must not be allocated\n\t * because they may have been unmapped already or they may have data\n\t * that is obsolete only because of nodes that are still sitting in a\n\t * wbuf.\n\t */\n\tif (lprops->free + lprops->dirty == c->leb_size && lprops->dirty > 0)\n\t\treturn ret;\n\t/* Finally we found space */\n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n/**\n * do_f",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "props))",
          "args": [
            "t |= L"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nan_for_free_cb(struct ubifs_info *c,\n\t\t\t    const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t    struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t/* Exclude LEBs that are currently in use */\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t/* Determine whether to add these LEB properties to the tree */\n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t/* Exclude index LEBs */\n\tif (lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t/* Exclude LEBs with too little space */\n\tif (lprops->free < data->min_space)\n\t\treturn ret;\n\t/* If specified, exclude empty LEBs */\n\tif (!data->pick_free && lprops->free == c->leb_size)\n\t\treturn ret;\n\t/*\n\t * LEBs that have only free and dirty space must not be allocated\n\t * because they may have been unmapped already or they may have data\n\t * that is obsolete only because of nodes that are still sitting in a\n\t * wbuf.\n\t */\n\tif (lprops->free + lprops->dirty == c->leb_size && lprops->dirty > 0)\n\t\treturn ret;\n\t/* Finally we found space */\n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n/**\n * do_f"
  },
  {
    "function_name": "rty_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "233-348",
    "snippet": "d_dirty_leb(struct ubifs_info *c, struct ubifs_lprops *ret_lp,\n\t\t\t int min_space, int pick_free)\n{\n\tint err = 0, sum, exclude_index = pick_free == 2 ? 1 : 0;\n\tconst struct ubifs_lprops *lp = NULL, *idx_lp = NULL;\n\tstruct ubifs_lpt_heap *heap, *idx_heap;\n\n\tubifs_get_lprops(c);\n\n\tif (pick_free) {\n\t\tint lebs, rsvd_idx_lebs = 0;\n\n\t\tspin_lock(&c->space_lock);\n\t\tlebs = c->lst.empty_lebs + c->idx_gc_cnt;\n\t\tlebs += c->freeable_cnt - c->lst.taken_empty_lebs;\n\n\t\t/*\n\t\t * Note, the index may consume more LEBs than have been reserved\n\t\t * for it. It is OK because it might be consolidated by GC.\n\t\t * But if the index takes fewer LEBs than it is reserved for it,\n\t\t * this function must avoid picking those reserved LEBs.\n\t\t */\n\t\tif (c->bi.min_idx_lebs >= c->lst.idx_lebs) {\n\t\t\trsvd_idx_lebs = c->bi.min_idx_lebs -  c->lst.idx_lebs;\n\t\t\texclude_index = 1;\n\t\t}\n\t\tspin_unlock(&c->space_lock);\n\n\t\t/* Check if there are enough free LEBs for the index */\n\t\tif (rsvd_idx_lebs < lebs) {\n\t\t\t/* OK, try to find an empty LEB */\n\t\t\tlp = ubifs_fast_find_empty(c);\n\t\t\tif (lp)\n\t\t\t\tgoto found;\n\n\t\t\t/* Or a freeable LEB */\n\t\t\tlp = ubifs_fast_find_freeable(c);\n\t\t\tif (lp)\n\t\t\t\tgoto found;\n\t\t} else\n\t\t\t/*\n\t\t\t * We cannot pick free/freeable LEBs in the below code.\n\t\t\t */\n\t\t\tpick_free = 0;\n\t} else {\n\t\tspin_lock(&c->space_lock);\n\t\texclude_index = (c->bi.min_idx_lebs >= c->lst.idx_lebs);\n\t\tspin_unlock(&c->space_lock);\n\t}\n\n\t/* Look on the dirty and dirty index heaps */\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tidx_heap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\n\tif (idx_heap->cnt && !exclude_index) {\n\t\tidx_lp = idx_heap->arr[0];\n\t\tsum = idx_lp->free + idx_lp->dirty;\n\t\t/*\n\t\t * Since we reserve thrice as much space for the index than it\n\t\t * actually takes, it does not make sense to pick indexing LEBs\n\t\t * with less than, say, half LEB of dirty space. May be half is\n\t\t * not the optimal boundary - this should be tested and\n\t\t * checked. This boundary should determine how much we use\n\t\t * in-the-gaps to consolidate the index comparing to how much\n\t\t * we use garbage collector to consolidate it. The \"half\"\n\t\t * criteria just feels to be fine.\n\t\t */\n\t\tif (sum < min_space || sum < c->half_leb_size)\n\t\t\tidx_lp = NULL;\n\t}\n\n\tif (heap->cnt) {\n\t\tlp = heap->arr[0];\n\t\tif (lp->dirty + lp->free < min_space)\n\t\t\tlp = NULL;\n\t}\n\n\t/* Pick the LEB with most space */\n\tif (idx_lp && lp) {\n\t\tif (idx_lp->free + idx_lp->dirty >= lp->free + lp->dirty)\n\t\t\tlp = idx_lp;\n\t} else if (idx_lp && !lp)\n\t\tlp = idx_lp;\n\n\tif (lp) {\n\t\tubifs_assert(lp->free + lp->dirty >= c->dead_wm);\n\t\tgoto found;\n\t}\n\n\t/* Did not find a dirty LEB on the dirty heaps, have to scan */\n\tdbg_find(\"scanning LPT for a dirty LEB\");\n\tlp = scan_for_dirty(c, min_space, pick_free, exclude_index);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\tubifs_assert(lp->dirty >= c->dead_wm ||\n\t\t     (pick_free && lp->free + lp->dirty == c->leb_size));\n\nfound:\n\tdbg_find(\"found LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lp->lnum, lp->free, lp->dirty, lp->flags);\n\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tmemcpy(ret_lp, lp, sizeof(struct ubifs_lprops));\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * scan",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_lprops(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", lp,",
          "args": [
            "izeof(",
            "ru",
            "ubifs_lprops));\n\nout:\n\tubi"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ut"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err",
          "args": [
            "="
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2544-2564",
          "snippet": "static void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_handle_error(struct super_block *sb)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (osb->s_mount_opt & OCFS2_MOUNT_ERRORS_PANIC)\n\t\tpanic(\"OCFS2: (device %s): panic forced after error\\n\",\n\t\t      sb->s_id);\n\n\tocfs2_set_osb_flag(osb, OCFS2_OSB_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY &&\n\t    (ocfs2_is_soft_readonly(osb) ||\n\t     ocfs2_is_hard_readonly(osb)))\n\t\treturn;\n\n\tprintk(KERN_CRIT \"File system is now read-only due to the potential \"\n\t       \"of on-disk corruption. Please run fsck.ocfs2 once the file \"\n\t       \"system is unmounted.\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\tocfs2_set_ro_flag(osb, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lp(c, lp, LPROP",
          "args": [
            "_",
            ",",
            "ROPS_NC,",
            "lp-",
            "PROPS_TAKEN, 0);\n\tif (IS",
            "R"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd LEB %",
          "args": [
            ", free %d, dirty %d, flags %#x\",\n\t\t lp->lnum",
            ">free, l",
            ">dirty,",
            "->flags);",
            "lp = ubi"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp->dirty >=",
          "args": [
            "c->dead_wm ||\n\t\t     (pick_free && lp->free + lp->dirty == c->leb_size));\n\nfound:\n\td"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "goto",
          "args": [
            "ut"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(c, min_space",
          "args": [
            "ck_free,",
            "clude_ind",
            ");\n\tif (IS_ER"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nning LP",
          "args": [
            "for a dirty LEB\");\n\tlp = scan"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp->free + l",
          "args": [
            "->dirty >= c->dead_wm);\n\t\tgoto fou"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\t}\n\n\t/* Lo"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\t\texclude_"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_freeable(c);\n\t\t\tif (l",
          "args": [
            ")"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_empty(c);\n\t\t\tif (l",
          "args": [
            ")"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->space_lo",
          "args": [
            "k);\n\n\t\t/* Chec"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">space_lo",
          "args": [
            "k);\n\t\tlebs = c"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops(c);\n\n\tif (pi",
          "args": [
            "k"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nd_dirty_leb(struct ubifs_info *c, struct ubifs_lprops *ret_lp,\n\t\t\t int min_space, int pick_free)\n{\n\tint err = 0, sum, exclude_index = pick_free == 2 ? 1 : 0;\n\tconst struct ubifs_lprops *lp = NULL, *idx_lp = NULL;\n\tstruct ubifs_lpt_heap *heap, *idx_heap;\n\n\tubifs_get_lprops(c);\n\n\tif (pick_free) {\n\t\tint lebs, rsvd_idx_lebs = 0;\n\n\t\tspin_lock(&c->space_lock);\n\t\tlebs = c->lst.empty_lebs + c->idx_gc_cnt;\n\t\tlebs += c->freeable_cnt - c->lst.taken_empty_lebs;\n\n\t\t/*\n\t\t * Note, the index may consume more LEBs than have been reserved\n\t\t * for it. It is OK because it might be consolidated by GC.\n\t\t * But if the index takes fewer LEBs than it is reserved for it,\n\t\t * this function must avoid picking those reserved LEBs.\n\t\t */\n\t\tif (c->bi.min_idx_lebs >= c->lst.idx_lebs) {\n\t\t\trsvd_idx_lebs = c->bi.min_idx_lebs -  c->lst.idx_lebs;\n\t\t\texclude_index = 1;\n\t\t}\n\t\tspin_unlock(&c->space_lock);\n\n\t\t/* Check if there are enough free LEBs for the index */\n\t\tif (rsvd_idx_lebs < lebs) {\n\t\t\t/* OK, try to find an empty LEB */\n\t\t\tlp = ubifs_fast_find_empty(c);\n\t\t\tif (lp)\n\t\t\t\tgoto found;\n\n\t\t\t/* Or a freeable LEB */\n\t\t\tlp = ubifs_fast_find_freeable(c);\n\t\t\tif (lp)\n\t\t\t\tgoto found;\n\t\t} else\n\t\t\t/*\n\t\t\t * We cannot pick free/freeable LEBs in the below code.\n\t\t\t */\n\t\t\tpick_free = 0;\n\t} else {\n\t\tspin_lock(&c->space_lock);\n\t\texclude_index = (c->bi.min_idx_lebs >= c->lst.idx_lebs);\n\t\tspin_unlock(&c->space_lock);\n\t}\n\n\t/* Look on the dirty and dirty index heaps */\n\theap = &c->lpt_heap[LPROPS_DIRTY - 1];\n\tidx_heap = &c->lpt_heap[LPROPS_DIRTY_IDX - 1];\n\n\tif (idx_heap->cnt && !exclude_index) {\n\t\tidx_lp = idx_heap->arr[0];\n\t\tsum = idx_lp->free + idx_lp->dirty;\n\t\t/*\n\t\t * Since we reserve thrice as much space for the index than it\n\t\t * actually takes, it does not make sense to pick indexing LEBs\n\t\t * with less than, say, half LEB of dirty space. May be half is\n\t\t * not the optimal boundary - this should be tested and\n\t\t * checked. This boundary should determine how much we use\n\t\t * in-the-gaps to consolidate the index comparing to how much\n\t\t * we use garbage collector to consolidate it. The \"half\"\n\t\t * criteria just feels to be fine.\n\t\t */\n\t\tif (sum < min_space || sum < c->half_leb_size)\n\t\t\tidx_lp = NULL;\n\t}\n\n\tif (heap->cnt) {\n\t\tlp = heap->arr[0];\n\t\tif (lp->dirty + lp->free < min_space)\n\t\t\tlp = NULL;\n\t}\n\n\t/* Pick the LEB with most space */\n\tif (idx_lp && lp) {\n\t\tif (idx_lp->free + idx_lp->dirty >= lp->free + lp->dirty)\n\t\t\tlp = idx_lp;\n\t} else if (idx_lp && !lp)\n\t\tlp = idx_lp;\n\n\tif (lp) {\n\t\tubifs_assert(lp->free + lp->dirty >= c->dead_wm);\n\t\tgoto found;\n\t}\n\n\t/* Did not find a dirty LEB on the dirty heaps, have to scan */\n\tdbg_find(\"scanning LPT for a dirty LEB\");\n\tlp = scan_for_dirty(c, min_space, pick_free, exclude_index);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\tubifs_assert(lp->dirty >= c->dead_wm ||\n\t\t     (pick_free && lp->free + lp->dirty == c->leb_size));\n\nfound:\n\tdbg_find(\"found LEB %d, free %d, dirty %d, flags %#x\",\n\t\t lp->lnum, lp->free, lp->dirty, lp->flags);\n\n\tlp = ubifs_change_lp(c, lp, LPROPS_NC, LPROPS_NC,\n\t\t\t     lp->flags | LPROPS_TAKEN, 0);\n\tif (IS_ERR(lp)) {\n\t\terr = PTR_ERR(lp);\n\t\tgoto out;\n\t}\n\n\tmemcpy(ret_lp, lp, sizeof(struct ubifs_lprops));\n\nout:\n\tubifs_release_lprops(c);\n\treturn err;\n}\n\n/**\n * scan"
  },
  {
    "function_name": "y(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "136-199",
    "snippet": "struct ubifs_lprops *scan_for_dirty(struct ubifs_info *c,\n\t\t\t\t\t\t int min_space, int pick_free,\n\t\t\t\t\t\t int exclude_index)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i;\n\n\t/* There may be an LEB with enough dirty space on the free heap */\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tif (lprops->free + lprops->dirty < min_space)\n\t\t\tcontinue;\n\t\tif (lprops->dirty < c->dead_wm)\n\t\t\tcontinue;\n\t\treturn lprops;\n\t}\n\t/*\n\t * A LEB may have fallen off of the bottom of the dirty heap, and ended\n\t * up as uncategorized even though it has enough dirty space for us now,\n\t * so check the uncategorized list. N.B. neither empty nor freeable LEBs\n\t * can end up as uncategorized because they are kept on lists not\n\t * finite-sized heaps.\n\t */\n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tif (lprops->flags & LPROPS_TAKEN)\n\t\t\tcontinue;\n\t\tif (lprops->free + lprops->dirty < min_space)\n\t\t\tcontinue;\n\t\tif (exclude_index && (lprops->flags & LPROPS_INDEX))\n\t\t\tcontinue;\n\t\tif (lprops->dirty < c->dead_wm)\n\t\t\tcontinue;\n\t\treturn lprops;\n\t}\n\t/* We have looked everywhere in main memory, now scan the flash */\n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t/* All pnodes are in memory, so skip scan */\n\t\treturn ERR_PTR(-ENOSPC);\n\tdata.min_space = min_space;\n\tdata.pick_free = pick_free;\n\tdata.lnum = -1;\n\tdata.exclude_index = exclude_index;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_dirty_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(lprops->lnum == data.lnum);\n\tubifs_assert(lprops->free + lprops->dirty >= min_space);\n\tubifs_assert(lprops->dirty >= c->dead_wm ||\n\t\t     (pick_free &&\n\t\t      lprops->free + lprops->dirty == c->leb_size));\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!exclude_index || !(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "!exclude_ind",
          "args": [
            "x || !(lprops->flags & LPROPS_INDEX));\n\treturn lp"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lprops->fl",
          "args": [
            "gs & LPROPS_TAKEN));\n\tubifs_ass"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->dirt",
          "args": [
            ">= c->dead_wm ||\n\t\t     (pick_free &&\n\t\t      lprops->free + lprops->dirty == c->leb_size));\n\tubifs_ass"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->free",
          "args": [
            "+ lprops->dirty >= min_space);\n\tubifs_ass"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lprops->lnum",
          "args": [
            "== data.lnum);\n\tubifs_ass"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "))\n\t\tr",
          "args": [
            "turn l"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup_dirty(c, data.lnum",
          "args": [
            ";",
            "if (IS_ER"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.lnum >=",
          "args": [
            "c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs",
          "args": [
            "ass"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "rty_idx_leb(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
          "lines": "963-985",
          "snippet": "d_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * struc",
            "ux/sort.h>\n#include \"ubi"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nd_dirty_idx_leb(struct ubifs_info *c)\n{\n\tint err;\n\n\tubifs_get_lprops(c);\n\n\t/*\n\t * We made an array of the dirtiest index LEB numbers as at the start of\n\t * last commit.  Try that array first.\n\t */\n\terr = find_dirtiest_idx_leb(c);\n\n\t/* Next try scanning the entire LPT */\n\tif (err == -ENOSPC)\n\t\terr = find_dirty_idx_leb(c);\n\n\t/* Finally take any index LEBs awaiting trivial GC */\n\tif (err == -ENOSPC)\n\t\terr = get_idx_gc_leb(c);\n\n\tubifs_release_lprops(c);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "n_nolock(c, -1, c->ls",
          "args": [
            "a",
            "ln",
            ",\n\t\t\t\t    (ub",
            "an_callback)scan_for_dirty_cb,\n\t\t\t\t    &da",
            "err)"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PC);\n\td",
          "args": [
            "ta.min_"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(lprops, &c->",
          "args": [
            "ncat_l",
            "t, list) {\n\t\ti",
            "(lpr"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nstruct ubifs_lprops *scan_for_dirty(struct ubifs_info *c,\n\t\t\t\t\t\t int min_space, int pick_free,\n\t\t\t\t\t\t int exclude_index)\n{\n\tconst struct ubifs_lprops *lprops;\n\tstruct ubifs_lpt_heap *heap;\n\tstruct scan_data data;\n\tint err, i;\n\n\t/* There may be an LEB with enough dirty space on the free heap */\n\theap = &c->lpt_heap[LPROPS_FREE - 1];\n\tfor (i = 0; i < heap->cnt; i++) {\n\t\tlprops = heap->arr[i];\n\t\tif (lprops->free + lprops->dirty < min_space)\n\t\t\tcontinue;\n\t\tif (lprops->dirty < c->dead_wm)\n\t\t\tcontinue;\n\t\treturn lprops;\n\t}\n\t/*\n\t * A LEB may have fallen off of the bottom of the dirty heap, and ended\n\t * up as uncategorized even though it has enough dirty space for us now,\n\t * so check the uncategorized list. N.B. neither empty nor freeable LEBs\n\t * can end up as uncategorized because they are kept on lists not\n\t * finite-sized heaps.\n\t */\n\tlist_for_each_entry(lprops, &c->uncat_list, list) {\n\t\tif (lprops->flags & LPROPS_TAKEN)\n\t\t\tcontinue;\n\t\tif (lprops->free + lprops->dirty < min_space)\n\t\t\tcontinue;\n\t\tif (exclude_index && (lprops->flags & LPROPS_INDEX))\n\t\t\tcontinue;\n\t\tif (lprops->dirty < c->dead_wm)\n\t\t\tcontinue;\n\t\treturn lprops;\n\t}\n\t/* We have looked everywhere in main memory, now scan the flash */\n\tif (c->pnodes_have >= c->pnode_cnt)\n\t\t/* All pnodes are in memory, so skip scan */\n\t\treturn ERR_PTR(-ENOSPC);\n\tdata.min_space = min_space;\n\tdata.pick_free = pick_free;\n\tdata.lnum = -1;\n\tdata.exclude_index = exclude_index;\n\terr = ubifs_lpt_scan_nolock(c, -1, c->lscan_lnum,\n\t\t\t\t    (ubifs_lpt_scan_callback)scan_for_dirty_cb,\n\t\t\t\t    &data);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tubifs_assert(data.lnum >= c->main_first && data.lnum < c->leb_cnt);\n\tc->lscan_lnum = data.lnum;\n\tlprops = ubifs_lpt_lookup_dirty(c, data.lnum);\n\tif (IS_ERR(lprops))\n\t\treturn lprops;\n\tubifs_assert(lprops->lnum == data.lnum);\n\tubifs_assert(lprops->free + lprops->dirty >= min_space);\n\tubifs_assert(lprops->dirty >= c->dead_wm ||\n\t\t     (pick_free &&\n\t\t      lprops->free + lprops->dirty == c->leb_size));\n\tubifs_assert(!(lprops->flags & LPROPS_TAKEN));\n\tubifs_assert(!exclude_index || !(lprops->flags & LPROPS_INDEX));\n\treturn lprops;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "y_cb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "95-123",
    "snippet": "an_for_dirty_cb(struct ubifs_info *c,\n\t\t\t     const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t     struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t/* Exclude LEBs that are currently in use */\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t/* Determine whether to add these LEB properties to the tree */\n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t/* Exclude LEBs with too little space */\n\tif (lprops->free + lprops->dirty < data->min_space)\n\t\treturn ret;\n\t/* If specified, exclude index LEBs */\n\tif (data->exclude_index && lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t/* If specified, exclude empty or freeable LEBs */\n\tif (lprops->free + lprops->dirty == c->leb_size) {\n\t\tif (!data->pick_free)\n\t\t\treturn ret;\n\t/* Exclude LEBs with too little dirty space (unless it is empty) */\n\t} else if (lprops->dirty < c->dead_wm)\n\t\treturn ret;\n\t/* Finally we found space */\n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n/**\n * scan",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "props))",
          "args": [
            "t |= L"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nan_for_dirty_cb(struct ubifs_info *c,\n\t\t\t     const struct ubifs_lprops *lprops, int in_tree,\n\t\t\t     struct scan_data *data)\n{\n\tint ret = LPT_SCAN_CONTINUE;\n\n\t/* Exclude LEBs that are currently in use */\n\tif (lprops->flags & LPROPS_TAKEN)\n\t\treturn LPT_SCAN_CONTINUE;\n\t/* Determine whether to add these LEB properties to the tree */\n\tif (!in_tree && valuable(c, lprops))\n\t\tret |= LPT_SCAN_ADD;\n\t/* Exclude LEBs with too little space */\n\tif (lprops->free + lprops->dirty < data->min_space)\n\t\treturn ret;\n\t/* If specified, exclude index LEBs */\n\tif (data->exclude_index && lprops->flags & LPROPS_INDEX)\n\t\treturn ret;\n\t/* If specified, exclude empty or freeable LEBs */\n\tif (lprops->free + lprops->dirty == c->leb_size) {\n\t\tif (!data->pick_free)\n\t\t\treturn ret;\n\t/* Exclude LEBs with too little dirty space (unless it is empty) */\n\t} else if (lprops->dirty < c->dead_wm)\n\t\treturn ret;\n\t/* Finally we found space */\n\tdata->lnum = lprops->lnum;\n\treturn LPT_SCAN_ADD | LPT_SCAN_STOP;\n}\n\n/**\n * scan"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/find.c",
    "lines": "54-81",
    "snippet": "luable(struct ubifs_info *c, const struct ubifs_lprops *lprops)\n{\n\tint n, cat = lprops->flags & LPROPS_CAT_MASK;\n\tstruct ubifs_lpt_heap *heap;\n\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\theap = &c->lpt_heap[cat - 1];\n\t\tif (heap->cnt < heap->max_cnt)\n\t\t\treturn 1;\n\t\tif (lprops->free + lprops->dirty >= c->dark_wm)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase LPROPS_EMPTY:\n\t\tn = c->lst.empty_lebs + c->freeable_cnt -\n\t\t    c->lst.taken_empty_lebs;\n\t\tif (n < c->lsave_cnt)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase LPROPS_FREEABLE:\n\t\treturn 1;\n\tcase LPROPS_FRDI_IDX:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * scan",
    "includes": [
      "fs.h\"\n\n/**\n * struc",
      "ux/sort.h>\n#include \"ubi"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * struc\nux/sort.h>\n#include \"ubi\n\nluable(struct ubifs_info *c, const struct ubifs_lprops *lprops)\n{\n\tint n, cat = lprops->flags & LPROPS_CAT_MASK;\n\tstruct ubifs_lpt_heap *heap;\n\n\tswitch (cat) {\n\tcase LPROPS_DIRTY:\n\tcase LPROPS_DIRTY_IDX:\n\tcase LPROPS_FREE:\n\t\theap = &c->lpt_heap[cat - 1];\n\t\tif (heap->cnt < heap->max_cnt)\n\t\t\treturn 1;\n\t\tif (lprops->free + lprops->dirty >= c->dark_wm)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase LPROPS_EMPTY:\n\t\tn = c->lst.empty_lebs + c->freeable_cnt -\n\t\t    c->lst.taken_empty_lebs;\n\t\tif (n < c->lsave_cnt)\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase LPROPS_FREEABLE:\n\t\treturn 1;\n\tcase LPROPS_FRDI_IDX:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/**\n * scan"
  }
]