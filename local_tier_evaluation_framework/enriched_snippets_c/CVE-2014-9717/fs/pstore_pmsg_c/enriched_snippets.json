[
  {
    "function_name": "pstore_register_pmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/pmsg.c",
    "lines": "83-114",
    "snippet": "void pstore_register_pmsg(void)\n{\n\tstruct device *pmsg_device;\n\n\tpmsg_major = register_chrdev(0, PMSG_NAME, &pmsg_fops);\n\tif (pmsg_major < 0) {\n\t\tpr_err(\"register_chrdev failed\\n\");\n\t\tgoto err;\n\t}\n\n\tpmsg_class = class_create(THIS_MODULE, PMSG_NAME);\n\tif (IS_ERR(pmsg_class)) {\n\t\tpr_err(\"device class file already in use\\n\");\n\t\tgoto err_class;\n\t}\n\tpmsg_class->devnode = pmsg_devnode;\n\n\tpmsg_device = device_create(pmsg_class, NULL, MKDEV(pmsg_major, 0),\n\t\t\t\t\tNULL, \"%s%d\", PMSG_NAME, 0);\n\tif (IS_ERR(pmsg_device)) {\n\t\tpr_err(\"failed to create device\\n\");\n\t\tgoto err_device;\n\t}\n\treturn;\n\nerr_device:\n\tclass_destroy(pmsg_class);\nerr_class:\n\tunregister_chrdev(pmsg_major, PMSG_NAME);\nerr:\n\treturn;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>"
    ],
    "macros_used": [
      "#define PMSG_NAME \"pmsg\""
    ],
    "globals_used": [
      "static const struct file_operations pmsg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= noop_llseek,\n\t.write\t\t= write_pmsg,\n};",
      "static struct class *pmsg_class;",
      "static int pmsg_major;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_chrdev",
          "args": [
            "pmsg_major",
            "PMSG_NAME"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "285-296",
          "snippet": "void unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "class_destroy",
          "args": [
            "pmsg_class"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to create device\\n\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pmsg_device"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create",
          "args": [
            "pmsg_class",
            "NULL",
            "MKDEV(pmsg_major, 0)",
            "NULL",
            "\"%s%d\"",
            "PMSG_NAME",
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "pmsg_major",
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"device class file already in use\\n\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pmsg_class"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "class_create",
          "args": [
            "THIS_MODULE",
            "PMSG_NAME"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"register_chrdev failed\\n\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_chrdev",
          "args": [
            "0",
            "PMSG_NAME",
            "&pmsg_fops"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "register_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "174-197",
          "snippet": "int register_chrdev_region(dev_t from, unsigned count, const char *name)\n{\n\tstruct char_device_struct *cd;\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tcd = __register_chrdev_region(MAJOR(n), MINOR(n),\n\t\t\t       next - n, name);\n\t\tif (IS_ERR(cd))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tto = n;\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n\treturn PTR_ERR(cd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];\n\nint register_chrdev_region(dev_t from, unsigned count, const char *name)\n{\n\tstruct char_device_struct *cd;\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tcd = __register_chrdev_region(MAJOR(n), MINOR(n),\n\t\t\t       next - n, name);\n\t\tif (IS_ERR(cd))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tto = n;\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n\treturn PTR_ERR(cd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n\n#define PMSG_NAME \"pmsg\"\n\nstatic const struct file_operations pmsg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= noop_llseek,\n\t.write\t\t= write_pmsg,\n};\nstatic struct class *pmsg_class;\nstatic int pmsg_major;\n\nvoid pstore_register_pmsg(void)\n{\n\tstruct device *pmsg_device;\n\n\tpmsg_major = register_chrdev(0, PMSG_NAME, &pmsg_fops);\n\tif (pmsg_major < 0) {\n\t\tpr_err(\"register_chrdev failed\\n\");\n\t\tgoto err;\n\t}\n\n\tpmsg_class = class_create(THIS_MODULE, PMSG_NAME);\n\tif (IS_ERR(pmsg_class)) {\n\t\tpr_err(\"device class file already in use\\n\");\n\t\tgoto err_class;\n\t}\n\tpmsg_class->devnode = pmsg_devnode;\n\n\tpmsg_device = device_create(pmsg_class, NULL, MKDEV(pmsg_major, 0),\n\t\t\t\t\tNULL, \"%s%d\", PMSG_NAME, 0);\n\tif (IS_ERR(pmsg_device)) {\n\t\tpr_err(\"failed to create device\\n\");\n\t\tgoto err_device;\n\t}\n\treturn;\n\nerr_device:\n\tclass_destroy(pmsg_class);\nerr_class:\n\tunregister_chrdev(pmsg_major, PMSG_NAME);\nerr:\n\treturn;\n}"
  },
  {
    "function_name": "pmsg_devnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/pmsg.c",
    "lines": "76-81",
    "snippet": "static char *pmsg_devnode(struct device *dev, umode_t *mode)\n{\n\tif (mode)\n\t\t*mode = 0220;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n\nstatic char *pmsg_devnode(struct device *dev, umode_t *mode)\n{\n\tif (mode)\n\t\t*mode = 0220;\n\treturn NULL;\n}"
  },
  {
    "function_name": "write_pmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pstore/pmsg.c",
    "lines": "24-62",
    "snippet": "static ssize_t write_pmsg(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tsize_t i, buffer_size;\n\tchar *buffer;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!access_ok(VERIFY_READ, buf, count))\n\t\treturn -EFAULT;\n\n\tbuffer_size = count;\n\tif (buffer_size > PMSG_MAX_BOUNCE_BUFFER_SIZE)\n\t\tbuffer_size = PMSG_MAX_BOUNCE_BUFFER_SIZE;\n\tbuffer = vmalloc(buffer_size);\n\n\tmutex_lock(&pmsg_lock);\n\tfor (i = 0; i < count; ) {\n\t\tsize_t c = min(count - i, buffer_size);\n\t\tu64 id;\n\t\tlong ret;\n\n\t\tret = __copy_from_user(buffer, buf + i, c);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tmutex_unlock(&pmsg_lock);\n\t\t\tvfree(buffer);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpsinfo->write_buf(PSTORE_TYPE_PMSG, 0, &id, 0, buffer, 0, c,\n\t\t\t\t  psinfo);\n\n\t\ti += c;\n\t}\n\n\tmutex_unlock(&pmsg_lock);\n\tvfree(buffer);\n\treturn count;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/fs.h>",
      "#include <linux/device.h>",
      "#include <linux/cdev.h>"
    ],
    "macros_used": [
      "#define PMSG_MAX_BOUNCE_BUFFER_SIZE (2*PAGE_SIZE)"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(pmsg_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "buffer"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pmsg_lock"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psinfo->write_buf",
          "args": [
            "PSTORE_TYPE_PMSG",
            "0",
            "&id",
            "0",
            "buffer",
            "0",
            "c",
            "psinfo"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "buffer"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pmsg_lock"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != 0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buffer",
            "buf + i",
            "c"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count - i",
            "buffer_size"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pmsg_lock"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "buffer_size"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "buf",
            "count"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n\n#define PMSG_MAX_BOUNCE_BUFFER_SIZE (2*PAGE_SIZE)\n\nstatic DEFINE_MUTEX(pmsg_lock);\n\nstatic ssize_t write_pmsg(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tsize_t i, buffer_size;\n\tchar *buffer;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (!access_ok(VERIFY_READ, buf, count))\n\t\treturn -EFAULT;\n\n\tbuffer_size = count;\n\tif (buffer_size > PMSG_MAX_BOUNCE_BUFFER_SIZE)\n\t\tbuffer_size = PMSG_MAX_BOUNCE_BUFFER_SIZE;\n\tbuffer = vmalloc(buffer_size);\n\n\tmutex_lock(&pmsg_lock);\n\tfor (i = 0; i < count; ) {\n\t\tsize_t c = min(count - i, buffer_size);\n\t\tu64 id;\n\t\tlong ret;\n\n\t\tret = __copy_from_user(buffer, buf + i, c);\n\t\tif (unlikely(ret != 0)) {\n\t\t\tmutex_unlock(&pmsg_lock);\n\t\t\tvfree(buffer);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpsinfo->write_buf(PSTORE_TYPE_PMSG, 0, &id, 0, buffer, 0, c,\n\t\t\t\t  psinfo);\n\n\t\ti += c;\n\t}\n\n\tmutex_unlock(&pmsg_lock);\n\tvfree(buffer);\n\treturn count;\n}"
  }
]