[
  {
    "function_name": "nfs_destroy_writepagecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "2006-2012",
    "snippet": "void nfs_destroy_writepagecache(void)\n{\n\tmempool_destroy(nfs_commit_mempool);\n\tkmem_cache_destroy(nfs_cdata_cachep);\n\tmempool_destroy(nfs_wdata_mempool);\n\tkmem_cache_destroy(nfs_wdata_cachep);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs_wdata_cachep;",
      "static mempool_t *nfs_wdata_mempool;",
      "static struct kmem_cache *nfs_cdata_cachep;",
      "static mempool_t *nfs_commit_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs_wdata_cachep"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "nfs_wdata_mempool"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs_cdata_cachep"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct kmem_cache *nfs_wdata_cachep;\nstatic mempool_t *nfs_wdata_mempool;\nstatic struct kmem_cache *nfs_cdata_cachep;\nstatic mempool_t *nfs_commit_mempool;\n\nvoid nfs_destroy_writepagecache(void)\n{\n\tmempool_destroy(nfs_commit_mempool);\n\tkmem_cache_destroy(nfs_cdata_cachep);\n\tmempool_destroy(nfs_wdata_mempool);\n\tkmem_cache_destroy(nfs_wdata_cachep);\n}"
  },
  {
    "function_name": "nfs_init_writepagecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1949-2004",
    "snippet": "int __init nfs_init_writepagecache(void)\n{\n\tnfs_wdata_cachep = kmem_cache_create(\"nfs_write_data\",\n\t\t\t\t\t     sizeof(struct nfs_pgio_header),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (nfs_wdata_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs_wdata_mempool = mempool_create_slab_pool(MIN_POOL_WRITE,\n\t\t\t\t\t\t     nfs_wdata_cachep);\n\tif (nfs_wdata_mempool == NULL)\n\t\tgoto out_destroy_write_cache;\n\n\tnfs_cdata_cachep = kmem_cache_create(\"nfs_commit_data\",\n\t\t\t\t\t     sizeof(struct nfs_commit_data),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (nfs_cdata_cachep == NULL)\n\t\tgoto out_destroy_write_mempool;\n\n\tnfs_commit_mempool = mempool_create_slab_pool(MIN_POOL_COMMIT,\n\t\t\t\t\t\t      nfs_cdata_cachep);\n\tif (nfs_commit_mempool == NULL)\n\t\tgoto out_destroy_commit_cache;\n\n\t/*\n\t * NFS congestion size, scale with available memory.\n\t *\n\t *  64MB:    8192k\n\t * 128MB:   11585k\n\t * 256MB:   16384k\n\t * 512MB:   23170k\n\t *   1GB:   32768k\n\t *   2GB:   46340k\n\t *   4GB:   65536k\n\t *   8GB:   92681k\n\t *  16GB:  131072k\n\t *\n\t * This allows larger machines to have larger/more transfers.\n\t * Limit the default to 256M\n\t */\n\tnfs_congestion_kb = (16*int_sqrt(totalram_pages)) << (PAGE_SHIFT-10);\n\tif (nfs_congestion_kb > 256*1024)\n\t\tnfs_congestion_kb = 256*1024;\n\n\treturn 0;\n\nout_destroy_commit_cache:\n\tkmem_cache_destroy(nfs_cdata_cachep);\nout_destroy_write_mempool:\n\tmempool_destroy(nfs_wdata_mempool);\nout_destroy_write_cache:\n\tkmem_cache_destroy(nfs_wdata_cachep);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MIN_POOL_COMMIT\t\t(4)",
      "#define MIN_POOL_WRITE\t\t(32)"
    ],
    "globals_used": [
      "static struct kmem_cache *nfs_wdata_cachep;",
      "static mempool_t *nfs_wdata_mempool;",
      "static struct kmem_cache *nfs_cdata_cachep;",
      "static mempool_t *nfs_commit_mempool;",
      "int nfs_congestion_kb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs_wdata_cachep"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "nfs_wdata_mempool"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs_cdata_cachep"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_sqrt",
          "args": [
            "totalram_pages"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_create_slab_pool",
          "args": [
            "MIN_POOL_COMMIT",
            "nfs_cdata_cachep"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfs_commit_data\"",
            "sizeof(struct nfs_commit_data)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_create_slab_pool",
          "args": [
            "MIN_POOL_WRITE",
            "nfs_wdata_cachep"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfs_write_data\"",
            "sizeof(struct nfs_pgio_header)",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "NULL"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define MIN_POOL_COMMIT\t\t(4)\n#define MIN_POOL_WRITE\t\t(32)\n\nstatic struct kmem_cache *nfs_wdata_cachep;\nstatic mempool_t *nfs_wdata_mempool;\nstatic struct kmem_cache *nfs_cdata_cachep;\nstatic mempool_t *nfs_commit_mempool;\nint nfs_congestion_kb;\n\nint __init nfs_init_writepagecache(void)\n{\n\tnfs_wdata_cachep = kmem_cache_create(\"nfs_write_data\",\n\t\t\t\t\t     sizeof(struct nfs_pgio_header),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (nfs_wdata_cachep == NULL)\n\t\treturn -ENOMEM;\n\n\tnfs_wdata_mempool = mempool_create_slab_pool(MIN_POOL_WRITE,\n\t\t\t\t\t\t     nfs_wdata_cachep);\n\tif (nfs_wdata_mempool == NULL)\n\t\tgoto out_destroy_write_cache;\n\n\tnfs_cdata_cachep = kmem_cache_create(\"nfs_commit_data\",\n\t\t\t\t\t     sizeof(struct nfs_commit_data),\n\t\t\t\t\t     0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     NULL);\n\tif (nfs_cdata_cachep == NULL)\n\t\tgoto out_destroy_write_mempool;\n\n\tnfs_commit_mempool = mempool_create_slab_pool(MIN_POOL_COMMIT,\n\t\t\t\t\t\t      nfs_cdata_cachep);\n\tif (nfs_commit_mempool == NULL)\n\t\tgoto out_destroy_commit_cache;\n\n\t/*\n\t * NFS congestion size, scale with available memory.\n\t *\n\t *  64MB:    8192k\n\t * 128MB:   11585k\n\t * 256MB:   16384k\n\t * 512MB:   23170k\n\t *   1GB:   32768k\n\t *   2GB:   46340k\n\t *   4GB:   65536k\n\t *   8GB:   92681k\n\t *  16GB:  131072k\n\t *\n\t * This allows larger machines to have larger/more transfers.\n\t * Limit the default to 256M\n\t */\n\tnfs_congestion_kb = (16*int_sqrt(totalram_pages)) << (PAGE_SHIFT-10);\n\tif (nfs_congestion_kb > 256*1024)\n\t\tnfs_congestion_kb = 256*1024;\n\n\treturn 0;\n\nout_destroy_commit_cache:\n\tkmem_cache_destroy(nfs_cdata_cachep);\nout_destroy_write_mempool:\n\tmempool_destroy(nfs_wdata_mempool);\nout_destroy_write_cache:\n\tkmem_cache_destroy(nfs_wdata_cachep);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "nfs_migrate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1928-1946",
    "snippet": "int nfs_migrate_page(struct address_space *mapping, struct page *newpage,\n\t\tstruct page *page, enum migrate_mode mode)\n{\n\t/*\n\t * If PagePrivate is set, then the page is currently associated with\n\t * an in-progress read or write request. Don't try to migrate it.\n\t *\n\t * FIXME: we could do this in principle, but we'll need a way to ensure\n\t *        that we can safely release the inode reference while holding\n\t *        the page lock.\n\t */\n\tif (PagePrivate(page))\n\t\treturn -EBUSY;\n\n\tif (!nfs_fscache_release_page(page, GFP_KERNEL))\n\t\treturn -EBUSY;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_page",
          "args": [
            "mapping",
            "newpage",
            "page",
            "mode"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_migrate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1928-1946",
          "snippet": "int nfs_migrate_page(struct address_space *mapping, struct page *newpage,\n\t\tstruct page *page, enum migrate_mode mode)\n{\n\t/*\n\t * If PagePrivate is set, then the page is currently associated with\n\t * an in-progress read or write request. Don't try to migrate it.\n\t *\n\t * FIXME: we could do this in principle, but we'll need a way to ensure\n\t *        that we can safely release the inode reference while holding\n\t *        the page lock.\n\t */\n\tif (PagePrivate(page))\n\t\treturn -EBUSY;\n\n\tif (!nfs_fscache_release_page(page, GFP_KERNEL))\n\t\treturn -EBUSY;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "nfs_fscache_release_page",
          "args": [
            "page",
            "GFP_KERNEL"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fscache_release_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/fscache.c",
          "lines": "260-277",
          "snippet": "int nfs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct fscache_cookie *cookie = nfs_i_fscache(page->mapping->host);\n\n\t\tBUG_ON(!cookie);\n\t\tdfprintk(FSCACHE, \"NFS: fscache releasepage (0x%p/0x%p/0x%p)\\n\",\n\t\t\t cookie, page, NFS_I(page->mapping->host));\n\n\t\tif (!fscache_maybe_release_page(cookie, page, gfp))\n\t\t\treturn 0;\n\n\t\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/in6.h>",
            "#include <linux/nfs_fs_sb.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/in6.h>\n#include <linux/nfs_fs_sb.h>\n#include <linux/nfs_fs.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nint nfs_fscache_release_page(struct page *page, gfp_t gfp)\n{\n\tif (PageFsCache(page)) {\n\t\tstruct fscache_cookie *cookie = nfs_i_fscache(page->mapping->host);\n\n\t\tBUG_ON(!cookie);\n\t\tdfprintk(FSCACHE, \"NFS: fscache releasepage (0x%p/0x%p/0x%p)\\n\",\n\t\t\t cookie, page, NFS_I(page->mapping->host));\n\n\t\tif (!fscache_maybe_release_page(cookie, page, gfp))\n\t\t\treturn 0;\n\n\t\tnfs_inc_fscache_stats(page->mapping->host,\n\t\t\t\t      NFSIOS_FSCACHE_PAGES_UNCACHED);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_migrate_page(struct address_space *mapping, struct page *newpage,\n\t\tstruct page *page, enum migrate_mode mode)\n{\n\t/*\n\t * If PagePrivate is set, then the page is currently associated with\n\t * an in-progress read or write request. Don't try to migrate it.\n\t *\n\t * FIXME: we could do this in principle, but we'll need a way to ensure\n\t *        that we can safely release the inode reference while holding\n\t *        the page lock.\n\t */\n\tif (PagePrivate(page))\n\t\treturn -EBUSY;\n\n\tif (!nfs_fscache_release_page(page, GFP_KERNEL))\n\t\treturn -EBUSY;\n\n\treturn migrate_page(mapping, newpage, page, mode);\n}"
  },
  {
    "function_name": "nfs_wb_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1893-1925",
    "snippet": "int nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_nfs_writeback_page_exit",
          "args": [
            "inode",
            "ret"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_commit_inode",
          "args": [
            "inode",
            "FLUSH_SYNC"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1757-1794",
          "snippet": "int nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_writepage_locked",
          "args": [
            "page",
            "&wbc"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_writepage_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "597-611",
          "snippet": "static int nfs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\tint err;\n\n\tnfs_pageio_init_write(&pgio, page->mapping->host, wb_priority(wbc),\n\t\t\t\tfalse, &nfs_async_write_completion_ops);\n\terr = nfs_do_writepage(page, wbc, &pgio);\n\tnfs_pageio_complete(&pgio);\n\tif (err < 0)\n\t\treturn err;\n\tif (pgio.pg_error < 0)\n\t\treturn pgio.pg_error;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);",
            "static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {\n\t.error_cleanup = nfs_async_write_error,\n\t.completion = nfs_write_completion,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\nstatic const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {\n\t.error_cleanup = nfs_async_write_error,\n\t.completion = nfs_write_completion,\n};\n\nstatic int nfs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\tint err;\n\n\tnfs_pageio_init_write(&pgio, page->mapping->host, wb_priority(wbc),\n\t\t\t\tfalse, &nfs_async_write_completion_ops);\n\terr = nfs_do_writepage(page, wbc, &pgio);\n\tnfs_pageio_complete(&pgio);\n\tif (err < 0)\n\t\treturn err;\n\tif (pgio.pg_error < 0)\n\t\treturn pgio.pg_error;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page_dirty_for_io",
          "args": [
            "page"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_nfs_writeback_page_enter",
          "args": [
            "inode"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "PAGE_CACHE_SIZE - 1"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_offset",
          "args": [
            "page"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_wb_page_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1860-1888",
    "snippet": "int nfs_wb_page_cancel(struct inode *inode, struct page *page)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\twait_on_page_writeback(page);\n\n\t/* blocking call to cancel all requests and join to a single (head)\n\t * request */\n\treq = nfs_lock_and_join_requests(page, false);\n\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t} else if (req) {\n\t\t/* all requests from this page have been cancelled by\n\t\t * nfs_lock_and_join_requests, so just remove the head\n\t\t * request from the inode / page_private pointer and\n\t\t * release it */\n\t\tnfs_inode_remove_request(req);\n\t\t/*\n\t\t * In case nfs_inode_remove_request has marked the\n\t\t * page as being dirty\n\t\t */\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_unlock_and_release_request",
          "args": [
            "req"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unlock_and_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "410-414",
          "snippet": "void nfs_unlock_and_release_request(struct nfs_page *req)\n{\n\tnfs_unlock_request(req);\n\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_unlock_and_release_request(struct nfs_page *req)\n{\n\tnfs_unlock_request(req);\n\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_dirty_page",
          "args": [
            "page",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inode_remove_request",
          "args": [
            "req"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inode_remove_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "703-730",
          "snippet": "static void nfs_inode_remove_request(struct nfs_page *req)\n{\n\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_page *head;\n\n\tif (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {\n\t\thead = req->wb_head;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (likely(!PageSwapCache(head->wb_page))) {\n\t\t\tset_page_private(head->wb_page, 0);\n\t\t\tClearPagePrivate(head->wb_page);\n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_page(head->wb_page, PG_private);\n\t\t\tclear_bit(PG_MAPPED, &head->wb_flags);\n\t\t}\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tif (test_and_clear_bit(PG_INODE_REF, &req->wb_flags))\n\t\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_inode_remove_request(struct nfs_page *req)\n{\n\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_page *head;\n\n\tif (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {\n\t\thead = req->wb_head;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (likely(!PageSwapCache(head->wb_page))) {\n\t\t\tset_page_private(head->wb_page, 0);\n\t\t\tClearPagePrivate(head->wb_page);\n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_page(head->wb_page, PG_private);\n\t\t\tclear_bit(PG_MAPPED, &head->wb_flags);\n\t\t}\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tif (test_and_clear_bit(PG_INODE_REF, &req->wb_flags))\n\t\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_lock_and_join_requests",
          "args": [
            "page",
            "false"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_lock_and_join_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "427-546",
          "snippet": "static struct nfs_page *\nnfs_lock_and_join_requests(struct page *page, bool nonblock)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *head, *subreq;\n\tstruct nfs_page *destroy_list = NULL;\n\tunsigned int total_bytes;\n\tint ret;\n\ntry_again:\n\ttotal_bytes = 0;\n\n\tWARN_ON_ONCE(destroy_list);\n\n\tspin_lock(&inode->i_lock);\n\n\t/*\n\t * A reference is taken only on the head request which acts as a\n\t * reference to the whole page group - the group will not be destroyed\n\t * until the head reference is released.\n\t */\n\thead = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\n\tif (!head) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn NULL;\n\t}\n\n\t/* holding inode lock, so always make a non-blocking call to try the\n\t * page group lock */\n\tret = nfs_page_group_lock(head, true);\n\tif (ret < 0) {\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (!nonblock && ret == -EAGAIN) {\n\t\t\tnfs_page_group_lock_wait(head);\n\t\t\tnfs_release_request(head);\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tnfs_release_request(head);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* lock each request in the page group */\n\tsubreq = head;\n\tdo {\n\t\t/*\n\t\t * Subrequests are always contiguous, non overlapping\n\t\t * and in order - but may be repeated (mirrored writes).\n\t\t */\n\t\tif (subreq->wb_offset == (head->wb_offset + total_bytes)) {\n\t\t\t/* keep track of how many bytes this group covers */\n\t\t\ttotal_bytes += subreq->wb_bytes;\n\t\t} else if (WARN_ON_ONCE(subreq->wb_offset < head->wb_offset ||\n\t\t\t    ((subreq->wb_offset + subreq->wb_bytes) >\n\t\t\t     (head->wb_offset + total_bytes)))) {\n\t\t\tnfs_page_group_unlock(head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tif (!nfs_lock_request(subreq)) {\n\t\t\t/* releases page group bit lock and\n\t\t\t * inode spin lock and all references */\n\t\t\tret = nfs_unroll_locks_and_wait(inode, head,\n\t\t\t\tsubreq, nonblock);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto try_again;\n\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* Now that all requests are locked, make sure they aren't on any list.\n\t * Commit list removal accounting is done after locks are dropped */\n\tsubreq = head;\n\tdo {\n\t\tnfs_clear_request_commit(subreq);\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* unlink subrequests from head, destroy them later */\n\tif (head->wb_this_page != head) {\n\t\t/* destroy list will be terminated by head */\n\t\tdestroy_list = head->wb_this_page;\n\t\thead->wb_this_page = head;\n\n\t\t/* change head request to cover whole range that\n\t\t * the former page group covered */\n\t\thead->wb_bytes = total_bytes;\n\t}\n\n\t/*\n\t * prepare head request to be added to new pgio descriptor\n\t */\n\tnfs_page_group_clear_bits(head);\n\n\t/*\n\t * some part of the group was still on the inode list - otherwise\n\t * the group wouldn't be involved in async write.\n\t * grab a reference for the head request, iff it needs one.\n\t */\n\tif (!test_and_set_bit(PG_INODE_REF, &head->wb_flags))\n\t\tkref_get(&head->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\n\t/* drop lock to clean uprequests on destroy list */\n\tspin_unlock(&inode->i_lock);\n\n\tnfs_destroy_unlinked_subrequests(destroy_list, head);\n\n\t/* still holds ref on head from nfs_page_find_head_request_locked\n\t * and still has lock on head from lock loop */\n\treturn head;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_lock_and_join_requests(struct page *page, bool nonblock)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *head, *subreq;\n\tstruct nfs_page *destroy_list = NULL;\n\tunsigned int total_bytes;\n\tint ret;\n\ntry_again:\n\ttotal_bytes = 0;\n\n\tWARN_ON_ONCE(destroy_list);\n\n\tspin_lock(&inode->i_lock);\n\n\t/*\n\t * A reference is taken only on the head request which acts as a\n\t * reference to the whole page group - the group will not be destroyed\n\t * until the head reference is released.\n\t */\n\thead = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\n\tif (!head) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn NULL;\n\t}\n\n\t/* holding inode lock, so always make a non-blocking call to try the\n\t * page group lock */\n\tret = nfs_page_group_lock(head, true);\n\tif (ret < 0) {\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (!nonblock && ret == -EAGAIN) {\n\t\t\tnfs_page_group_lock_wait(head);\n\t\t\tnfs_release_request(head);\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tnfs_release_request(head);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* lock each request in the page group */\n\tsubreq = head;\n\tdo {\n\t\t/*\n\t\t * Subrequests are always contiguous, non overlapping\n\t\t * and in order - but may be repeated (mirrored writes).\n\t\t */\n\t\tif (subreq->wb_offset == (head->wb_offset + total_bytes)) {\n\t\t\t/* keep track of how many bytes this group covers */\n\t\t\ttotal_bytes += subreq->wb_bytes;\n\t\t} else if (WARN_ON_ONCE(subreq->wb_offset < head->wb_offset ||\n\t\t\t    ((subreq->wb_offset + subreq->wb_bytes) >\n\t\t\t     (head->wb_offset + total_bytes)))) {\n\t\t\tnfs_page_group_unlock(head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tif (!nfs_lock_request(subreq)) {\n\t\t\t/* releases page group bit lock and\n\t\t\t * inode spin lock and all references */\n\t\t\tret = nfs_unroll_locks_and_wait(inode, head,\n\t\t\t\tsubreq, nonblock);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto try_again;\n\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* Now that all requests are locked, make sure they aren't on any list.\n\t * Commit list removal accounting is done after locks are dropped */\n\tsubreq = head;\n\tdo {\n\t\tnfs_clear_request_commit(subreq);\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* unlink subrequests from head, destroy them later */\n\tif (head->wb_this_page != head) {\n\t\t/* destroy list will be terminated by head */\n\t\tdestroy_list = head->wb_this_page;\n\t\thead->wb_this_page = head;\n\n\t\t/* change head request to cover whole range that\n\t\t * the former page group covered */\n\t\thead->wb_bytes = total_bytes;\n\t}\n\n\t/*\n\t * prepare head request to be added to new pgio descriptor\n\t */\n\tnfs_page_group_clear_bits(head);\n\n\t/*\n\t * some part of the group was still on the inode list - otherwise\n\t * the group wouldn't be involved in async write.\n\t * grab a reference for the head request, iff it needs one.\n\t */\n\tif (!test_and_set_bit(PG_INODE_REF, &head->wb_flags))\n\t\tkref_get(&head->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\n\t/* drop lock to clean uprequests on destroy list */\n\tspin_unlock(&inode->i_lock);\n\n\tnfs_destroy_unlinked_subrequests(destroy_list, head);\n\n\t/* still holds ref on head from nfs_page_find_head_request_locked\n\t * and still has lock on head from lock loop */\n\treturn head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_wb_page_cancel(struct inode *inode, struct page *page)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\twait_on_page_writeback(page);\n\n\t/* blocking call to cancel all requests and join to a single (head)\n\t * request */\n\treq = nfs_lock_and_join_requests(page, false);\n\n\tif (IS_ERR(req)) {\n\t\tret = PTR_ERR(req);\n\t} else if (req) {\n\t\t/* all requests from this page have been cancelled by\n\t\t * nfs_lock_and_join_requests, so just remove the head\n\t\t * request from the inode / page_private pointer and\n\t\t * release it */\n\t\tnfs_inode_remove_request(req);\n\t\t/*\n\t\t * In case nfs_inode_remove_request has marked the\n\t\t * page as being dirty\n\t\t */\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_wb_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1841-1857",
    "snippet": "int nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_inode_enter(inode);\n\n\tret = sync_inode(inode, &wbc);\n\n\ttrace_nfs_writeback_inode_exit(inode, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_nfs_writeback_inode_exit",
          "args": [
            "inode",
            "ret"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_inode",
          "args": [
            "inode",
            "&wbc"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_async_inode_return_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.c",
          "lines": "715-739",
          "snippet": "int nfs_async_inode_return_delegation(struct inode *inode,\n\t\t\t\t      const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_delegation *delegation;\n\n\tfilemap_flush(inode->i_mapping);\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL)\n\t\tgoto out_enoent;\n\n\tif (!clp->cl_mvops->match_stateid(&delegation->stateid, stateid))\n\t\tgoto out_enoent;\n\tnfs_mark_return_delegation(server, delegation);\n\trcu_read_unlock();\n\n\tnfs_delegation_run_state_manager(clp);\n\treturn 0;\nout_enoent:\n\trcu_read_unlock();\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n\nint nfs_async_inode_return_delegation(struct inode *inode,\n\t\t\t\t      const nfs4_stateid *stateid)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct nfs_delegation *delegation;\n\n\tfilemap_flush(inode->i_mapping);\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL)\n\t\tgoto out_enoent;\n\n\tif (!clp->cl_mvops->match_stateid(&delegation->stateid, stateid))\n\t\tgoto out_enoent;\n\tnfs_mark_return_delegation(server, delegation);\n\trcu_read_unlock();\n\n\tnfs_delegation_run_state_manager(clp);\n\treturn 0;\nout_enoent:\n\trcu_read_unlock();\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_nfs_writeback_inode_enter",
          "args": [
            "inode"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_wb_all(struct inode *inode)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = LONG_MAX,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_inode_enter(inode);\n\n\tret = sync_inode(inode, &wbc);\n\n\ttrace_nfs_writeback_inode_exit(inode, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1832-1835",
    "snippet": "int nfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn nfs_commit_unstable_pages(inode, wbc);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_commit_unstable_pages",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_unstable_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1796-1830",
          "snippet": "static int nfs_commit_unstable_pages(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint flags = FLUSH_SYNC;\n\tint ret = 0;\n\n\t/* no commits means nothing needs to be done */\n\tif (!nfsi->commit_info.ncommit)\n\t\treturn ret;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\t\t/* Don't commit yet if this is a non-blocking flush and there\n\t\t * are a lot of outstanding writes for this mapping.\n\t\t */\n\t\tif (nfsi->commit_info.ncommit <= (nfsi->nrequests >> 1))\n\t\t\tgoto out_mark_dirty;\n\n\t\t/* don't wait for the COMMIT response */\n\t\tflags = 0;\n\t}\n\n\tret = nfs_commit_inode(inode, flags);\n\tif (ret >= 0) {\n\t\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\tif (ret < wbc->nr_to_write)\n\t\t\t\twbc->nr_to_write -= ret;\n\t\t\telse\n\t\t\t\twbc->nr_to_write = 0;\n\t\t}\n\t\treturn 0;\n\t}\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int nfs_commit_unstable_pages(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint flags = FLUSH_SYNC;\n\tint ret = 0;\n\n\t/* no commits means nothing needs to be done */\n\tif (!nfsi->commit_info.ncommit)\n\t\treturn ret;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\t\t/* Don't commit yet if this is a non-blocking flush and there\n\t\t * are a lot of outstanding writes for this mapping.\n\t\t */\n\t\tif (nfsi->commit_info.ncommit <= (nfsi->nrequests >> 1))\n\t\t\tgoto out_mark_dirty;\n\n\t\t/* don't wait for the COMMIT response */\n\t\tflags = 0;\n\t}\n\n\tret = nfs_commit_inode(inode, flags);\n\tif (ret >= 0) {\n\t\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\tif (ret < wbc->nr_to_write)\n\t\t\t\twbc->nr_to_write -= ret;\n\t\t\telse\n\t\t\t\twbc->nr_to_write = 0;\n\t\t}\n\t\treturn 0;\n\t}\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn nfs_commit_unstable_pages(inode, wbc);\n}"
  },
  {
    "function_name": "nfs_commit_unstable_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1796-1830",
    "snippet": "static int nfs_commit_unstable_pages(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint flags = FLUSH_SYNC;\n\tint ret = 0;\n\n\t/* no commits means nothing needs to be done */\n\tif (!nfsi->commit_info.ncommit)\n\t\treturn ret;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\t\t/* Don't commit yet if this is a non-blocking flush and there\n\t\t * are a lot of outstanding writes for this mapping.\n\t\t */\n\t\tif (nfsi->commit_info.ncommit <= (nfsi->nrequests >> 1))\n\t\t\tgoto out_mark_dirty;\n\n\t\t/* don't wait for the COMMIT response */\n\t\tflags = 0;\n\t}\n\n\tret = nfs_commit_inode(inode, flags);\n\tif (ret >= 0) {\n\t\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\tif (ret < wbc->nr_to_write)\n\t\t\t\twbc->nr_to_write -= ret;\n\t\t\telse\n\t\t\t\twbc->nr_to_write = 0;\n\t\t}\n\t\treturn 0;\n\t}\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "I_DIRTY_DATASYNC"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_commit_inode",
          "args": [
            "inode",
            "flags"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1757-1794",
          "snippet": "int nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int nfs_commit_unstable_pages(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tint flags = FLUSH_SYNC;\n\tint ret = 0;\n\n\t/* no commits means nothing needs to be done */\n\tif (!nfsi->commit_info.ncommit)\n\t\treturn ret;\n\n\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\t\t/* Don't commit yet if this is a non-blocking flush and there\n\t\t * are a lot of outstanding writes for this mapping.\n\t\t */\n\t\tif (nfsi->commit_info.ncommit <= (nfsi->nrequests >> 1))\n\t\t\tgoto out_mark_dirty;\n\n\t\t/* don't wait for the COMMIT response */\n\t\tflags = 0;\n\t}\n\n\tret = nfs_commit_inode(inode, flags);\n\tif (ret >= 0) {\n\t\tif (wbc->sync_mode == WB_SYNC_NONE) {\n\t\t\tif (ret < wbc->nr_to_write)\n\t\t\t\twbc->nr_to_write -= ret;\n\t\t\telse\n\t\t\t\twbc->nr_to_write = 0;\n\t\t}\n\t\treturn 0;\n\t}\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_commit_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1757-1794",
    "snippet": "int nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "I_DIRTY_DATASYNC"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_commit_clear_lock",
          "args": [
            "NFS_I(inode)"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_clear_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1519-1524",
          "snippet": "static void nfs_commit_clear_lock(struct nfs_inode *nfsi)\n{\n\tclear_bit(NFS_INO_COMMIT, &nfsi->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&nfsi->flags, NFS_INO_COMMIT);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_commit_clear_lock(struct nfs_inode *nfsi)\n{\n\tclear_bit(NFS_INO_COMMIT, &nfsi->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&nfsi->flags, NFS_INO_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_bit_action",
          "args": [
            "&NFS_I(inode)->flags",
            "NFS_INO_COMMIT",
            "nfs_wait_bit_killable",
            "TASK_KILLABLE"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_generic_commit_list",
          "args": [
            "inode",
            "&head",
            "how",
            "&cinfo"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_generic_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1746-1755",
          "snippet": "int nfs_generic_commit_list(struct inode *inode, struct list_head *head,\n\t\t\t    int how, struct nfs_commit_info *cinfo)\n{\n\tint status;\n\n\tstatus = pnfs_commit_list(inode, head, how, cinfo);\n\tif (status == PNFS_NOT_ATTEMPTED)\n\t\tstatus = nfs_commit_list(inode, head, how, cinfo);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_generic_commit_list(struct inode *inode, struct list_head *head,\n\t\t\t    int how, struct nfs_commit_info *cinfo)\n{\n\tint status;\n\n\tstatus = pnfs_commit_list(inode, head, how, cinfo);\n\tif (status == PNFS_NOT_ATTEMPTED)\n\t\tstatus = nfs_commit_list(inode, head, how, cinfo);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_scan_commit",
          "args": [
            "inode",
            "&head",
            "&cinfo"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_scan_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "956-972",
          "snippet": "int\nnfs_scan_commit(struct inode *inode, struct list_head *dst,\n\t\tstruct nfs_commit_info *cinfo)\n{\n\tint ret = 0;\n\n\tspin_lock(cinfo->lock);\n\tif (cinfo->mds->ncommit > 0) {\n\t\tconst int max = INT_MAX;\n\n\t\tret = nfs_scan_commit_list(&cinfo->mds->list, dst,\n\t\t\t\t\t   cinfo, max);\n\t\tret += pnfs_scan_commit_lists(inode, cinfo, max - ret);\n\t}\n\tspin_unlock(cinfo->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint\nnfs_scan_commit(struct inode *inode, struct list_head *dst,\n\t\tstruct nfs_commit_info *cinfo)\n{\n\tint ret = 0;\n\n\tspin_lock(cinfo->lock);\n\tif (cinfo->mds->ncommit > 0) {\n\t\tconst int max = INT_MAX;\n\n\t\tret = nfs_scan_commit_list(&cinfo->mds->list, dst,\n\t\t\t\t\t   cinfo, max);\n\t\tret += pnfs_scan_commit_lists(inode, cinfo, max - ret);\n\t}\n\tspin_unlock(cinfo->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_init_cinfo_from_inode",
          "args": [
            "&cinfo",
            "inode"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "819-827",
          "snippet": "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_commit_set_lock",
          "args": [
            "NFS_I(inode)",
            "may_wait"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_set_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1504-1517",
          "snippet": "static int nfs_commit_set_lock(struct nfs_inode *nfsi, int may_wait)\n{\n\tint ret;\n\n\tif (!test_and_set_bit(NFS_INO_COMMIT, &nfsi->flags))\n\t\treturn 1;\n\tif (!may_wait)\n\t\treturn 0;\n\tret = out_of_line_wait_on_bit_lock(&nfsi->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\treturn (ret < 0) ? ret : 1;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nfs_commit_set_lock(struct nfs_inode *nfsi, int may_wait)\n{\n\tint ret;\n\n\tif (!test_and_set_bit(NFS_INO_COMMIT, &nfsi->flags))\n\t\treturn 1;\n\tif (!may_wait)\n\t\treturn 0;\n\tret = out_of_line_wait_on_bit_lock(&nfsi->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\treturn (ret < 0) ? ret : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "head"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_commit_inode(struct inode *inode, int how)\n{\n\tLIST_HEAD(head);\n\tstruct nfs_commit_info cinfo;\n\tint may_wait = how & FLUSH_SYNC;\n\tint res;\n\n\tres = nfs_commit_set_lock(NFS_I(inode), may_wait);\n\tif (res <= 0)\n\t\tgoto out_mark_dirty;\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\tres = nfs_scan_commit(inode, &head, &cinfo);\n\tif (res) {\n\t\tint error;\n\n\t\terror = nfs_generic_commit_list(inode, &head, how, &cinfo);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (!may_wait)\n\t\t\tgoto out_mark_dirty;\n\t\terror = wait_on_bit_action(&NFS_I(inode)->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t} else\n\t\tnfs_commit_clear_lock(NFS_I(inode));\n\treturn res;\n\t/* Note: If we exit without ensuring that the commit is complete,\n\t * we must mark the inode as dirty. Otherwise, future calls to\n\t * sync_inode() with the WB_SYNC_ALL flag set will fail to ensure\n\t * that the data is on the disk.\n\t */\nout_mark_dirty:\n\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\treturn res;\n}"
  },
  {
    "function_name": "nfs_generic_commit_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1746-1755",
    "snippet": "int nfs_generic_commit_list(struct inode *inode, struct list_head *head,\n\t\t\t    int how, struct nfs_commit_info *cinfo)\n{\n\tint status;\n\n\tstatus = pnfs_commit_list(inode, head, how, cinfo);\n\tif (status == PNFS_NOT_ATTEMPTED)\n\t\tstatus = nfs_commit_list(inode, head, how, cinfo);\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_commit_list",
          "args": [
            "inode",
            "head",
            "how",
            "cinfo"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1643-1663",
          "snippet": "static int\nnfs_commit_list(struct inode *inode, struct list_head *head, int how,\n\t\tstruct nfs_commit_info *cinfo)\n{\n\tstruct nfs_commit_data\t*data;\n\n\tdata = nfs_commitdata_alloc();\n\n\tif (!data)\n\t\tgoto out_bad;\n\n\t/* Set up the argument struct */\n\tnfs_init_commit(data, head, NULL, cinfo);\n\tatomic_inc(&cinfo->mds->rpcs_out);\n\treturn nfs_initiate_commit(NFS_CLIENT(inode), data, NFS_PROTO(inode),\n\t\t\t\t   data->mds_ops, how, 0);\n out_bad:\n\tnfs_retry_commit(head, NULL, cinfo, 0);\n\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int\nnfs_commit_list(struct inode *inode, struct list_head *head, int how,\n\t\tstruct nfs_commit_info *cinfo)\n{\n\tstruct nfs_commit_data\t*data;\n\n\tdata = nfs_commitdata_alloc();\n\n\tif (!data)\n\t\tgoto out_bad;\n\n\t/* Set up the argument struct */\n\tnfs_init_commit(data, head, NULL, cinfo);\n\tatomic_inc(&cinfo->mds->rpcs_out);\n\treturn nfs_initiate_commit(NFS_CLIENT(inode), data, NFS_PROTO(inode),\n\t\t\t\t   data->mds_ops, how, 0);\n out_bad:\n\tnfs_retry_commit(head, NULL, cinfo, 0);\n\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_commit_list",
          "args": [
            "inode",
            "head",
            "how",
            "cinfo"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "602-607",
          "snippet": "static inline int\npnfs_commit_list(struct inode *inode, struct list_head *mds_pages, int how,\n\t\t struct nfs_commit_info *cinfo)\n{\n\treturn PNFS_NOT_ATTEMPTED;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline int\npnfs_commit_list(struct inode *inode, struct list_head *mds_pages, int how,\n\t\t struct nfs_commit_info *cinfo)\n{\n\treturn PNFS_NOT_ATTEMPTED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_generic_commit_list(struct inode *inode, struct list_head *head,\n\t\t\t    int how, struct nfs_commit_info *cinfo)\n{\n\tint status;\n\n\tstatus = pnfs_commit_list(inode, head, how, cinfo);\n\tif (status == PNFS_NOT_ATTEMPTED)\n\t\tstatus = nfs_commit_list(inode, head, how, cinfo);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_commit_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1727-1733",
    "snippet": "static void nfs_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tnfs_commitdata_release(calldata);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_commitdata_release",
          "args": [
            "calldata"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commitdata_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1526-1530",
          "snippet": "void nfs_commitdata_release(struct nfs_commit_data *data)\n{\n\tput_nfs_open_context(data->context);\n\tnfs_commit_free(data);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_commitdata_release(struct nfs_commit_data *data)\n{\n\tput_nfs_open_context(data->context);\n\tnfs_commit_free(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->completion_ops->completion",
          "args": [
            "data"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_commit_release(void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tdata->completion_ops->completion(data);\n\tnfs_commitdata_release(calldata);\n}"
  },
  {
    "function_name": "nfs_commit_release_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1679-1725",
    "snippet": "static void nfs_commit_release_pages(struct nfs_commit_data *data)\n{\n\tstruct nfs_page\t*req;\n\tint status = data->task.tk_status;\n\tstruct nfs_commit_info cinfo;\n\tstruct nfs_server *nfss;\n\n\twhile (!list_empty(&data->pages)) {\n\t\treq = nfs_list_entry(data->pages.next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_clear_page_commit(req->wb_page);\n\n\t\tdprintk(\"NFS:       commit (%s/%llu %d@%lld)\",\n\t\t\treq->wb_context->dentry->d_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(req->wb_context->dentry->d_inode),\n\t\t\treq->wb_bytes,\n\t\t\t(long long)req_offset(req));\n\t\tif (status < 0) {\n\t\t\tnfs_context_set_write_error(req->wb_context, status);\n\t\t\tnfs_inode_remove_request(req);\n\t\t\tdprintk(\", error = %d\\n\", status);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/* Okay, COMMIT succeeded, apparently. Check the verifier\n\t\t * returned by the server against all stored verfs. */\n\t\tif (!memcmp(&req->wb_verf, &data->verf.verifier, sizeof(req->wb_verf))) {\n\t\t\t/* We have a match */\n\t\t\tnfs_inode_remove_request(req);\n\t\t\tdprintk(\" OK\\n\");\n\t\t\tgoto next;\n\t\t}\n\t\t/* We have a mismatch. Write the page again */\n\t\tdprintk(\" mismatch\\n\");\n\t\tnfs_mark_request_dirty(req);\n\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &req->wb_context->flags);\n\tnext:\n\t\tnfs_unlock_and_release_request(req);\n\t}\n\tnfss = NFS_SERVER(data->inode);\n\tif (atomic_long_read(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n\n\tnfs_init_cinfo(&cinfo, data->inode, data->dreq);\n\tif (atomic_dec_and_test(&cinfo.mds->rpcs_out))\n\t\tnfs_commit_clear_lock(NFS_I(data->inode));\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
    ],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_commit_clear_lock",
          "args": [
            "NFS_I(data->inode)"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_clear_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1519-1524",
          "snippet": "static void nfs_commit_clear_lock(struct nfs_inode *nfsi)\n{\n\tclear_bit(NFS_INO_COMMIT, &nfsi->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&nfsi->flags, NFS_INO_COMMIT);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_commit_clear_lock(struct nfs_inode *nfsi)\n{\n\tclear_bit(NFS_INO_COMMIT, &nfsi->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&nfsi->flags, NFS_INO_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "data->inode"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&cinfo.mds->rpcs_out"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_init_cinfo",
          "args": [
            "&cinfo",
            "data->inode",
            "data->dreq"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "829-837",
          "snippet": "void nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq)\n{\n\tif (dreq)\n\t\tnfs_init_cinfo_from_dreq(cinfo, dreq);\n\telse\n\t\tnfs_init_cinfo_from_inode(cinfo, inode);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nvoid nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq)\n{\n\tif (dreq)\n\t\tnfs_init_cinfo_from_dreq(cinfo, dreq);\n\telse\n\t\tnfs_init_cinfo_from_inode(cinfo, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bdi_congested",
          "args": [
            "&nfss->backing_dev_info",
            "BLK_RW_ASYNC"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&nfss->writeback"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "data->inode"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_unlock_and_release_request",
          "args": [
            "req"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unlock_and_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "410-414",
          "snippet": "void nfs_unlock_and_release_request(struct nfs_page *req)\n{\n\tnfs_unlock_request(req);\n\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_unlock_and_release_request(struct nfs_page *req)\n{\n\tnfs_unlock_request(req);\n\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_CONTEXT_RESEND_WRITES",
            "&req->wb_context->flags"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_request_dirty",
          "args": [
            "req"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_request_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "732-736",
          "snippet": "static void\nnfs_mark_request_dirty(struct nfs_page *req)\n{\n\t__set_page_dirty_nobuffers(req->wb_page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void\nnfs_mark_request_dirty(struct nfs_page *req)\n{\n\t__set_page_dirty_nobuffers(req->wb_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\" mismatch\\n\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\" OK\\n\""
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inode_remove_request",
          "args": [
            "req"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inode_remove_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "703-730",
          "snippet": "static void nfs_inode_remove_request(struct nfs_page *req)\n{\n\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_page *head;\n\n\tif (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {\n\t\thead = req->wb_head;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (likely(!PageSwapCache(head->wb_page))) {\n\t\t\tset_page_private(head->wb_page, 0);\n\t\t\tClearPagePrivate(head->wb_page);\n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_page(head->wb_page, PG_private);\n\t\t\tclear_bit(PG_MAPPED, &head->wb_flags);\n\t\t}\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tif (test_and_clear_bit(PG_INODE_REF, &req->wb_flags))\n\t\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_inode_remove_request(struct nfs_page *req)\n{\n\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_page *head;\n\n\tif (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {\n\t\thead = req->wb_head;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (likely(!PageSwapCache(head->wb_page))) {\n\t\t\tset_page_private(head->wb_page, 0);\n\t\t\tClearPagePrivate(head->wb_page);\n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_page(head->wb_page, PG_private);\n\t\t\tclear_bit(PG_MAPPED, &head->wb_flags);\n\t\t}\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tif (test_and_clear_bit(PG_INODE_REF, &req->wb_flags))\n\t\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&req->wb_verf",
            "&data->verf.verifier",
            "sizeof(req->wb_verf)"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\", error = %d\\n\"",
            "status"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_context_set_write_error",
          "args": [
            "req->wb_context",
            "status"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_context_set_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "93-98",
          "snippet": "static void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)\n{\n\tctx->error = error;\n\tsmp_wmb();\n\tset_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)\n{\n\tctx->error = error;\n\tsmp_wmb();\n\tset_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS:       commit (%s/%llu %d@%lld)\"",
            "req->wb_context->dentry->d_sb->s_id",
            "(unsigned long long)NFS_FILEID(req->wb_context->dentry->d_inode)",
            "req->wb_bytes",
            "(long long)req_offset(req)"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_FILEID",
          "args": [
            "req->wb_context->dentry->d_inode"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_clear_page_commit",
          "args": [
            "req->wb_page"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_clear_page_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "852-857",
          "snippet": "static void\nnfs_clear_page_commit(struct page *page)\n{\n\tdec_zone_page_state(page, NR_UNSTABLE_NFS);\n\tdec_bdi_stat(inode_to_bdi(page_file_mapping(page)->host), BDI_RECLAIMABLE);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void\nnfs_clear_page_commit(struct page *page)\n{\n\tdec_zone_page_state(page, NR_UNSTABLE_NFS);\n\tdec_bdi_stat(inode_to_bdi(page_file_mapping(page)->host), BDI_RECLAIMABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_list_remove_request",
          "args": [
            "req"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "data->pages.next"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&data->pages"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_commit_release_pages(struct nfs_commit_data *data)\n{\n\tstruct nfs_page\t*req;\n\tint status = data->task.tk_status;\n\tstruct nfs_commit_info cinfo;\n\tstruct nfs_server *nfss;\n\n\twhile (!list_empty(&data->pages)) {\n\t\treq = nfs_list_entry(data->pages.next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_clear_page_commit(req->wb_page);\n\n\t\tdprintk(\"NFS:       commit (%s/%llu %d@%lld)\",\n\t\t\treq->wb_context->dentry->d_sb->s_id,\n\t\t\t(unsigned long long)NFS_FILEID(req->wb_context->dentry->d_inode),\n\t\t\treq->wb_bytes,\n\t\t\t(long long)req_offset(req));\n\t\tif (status < 0) {\n\t\t\tnfs_context_set_write_error(req->wb_context, status);\n\t\t\tnfs_inode_remove_request(req);\n\t\t\tdprintk(\", error = %d\\n\", status);\n\t\t\tgoto next;\n\t\t}\n\n\t\t/* Okay, COMMIT succeeded, apparently. Check the verifier\n\t\t * returned by the server against all stored verfs. */\n\t\tif (!memcmp(&req->wb_verf, &data->verf.verifier, sizeof(req->wb_verf))) {\n\t\t\t/* We have a match */\n\t\t\tnfs_inode_remove_request(req);\n\t\t\tdprintk(\" OK\\n\");\n\t\t\tgoto next;\n\t\t}\n\t\t/* We have a mismatch. Write the page again */\n\t\tdprintk(\" mismatch\\n\");\n\t\tnfs_mark_request_dirty(req);\n\t\tset_bit(NFS_CONTEXT_RESEND_WRITES, &req->wb_context->flags);\n\tnext:\n\t\tnfs_unlock_and_release_request(req);\n\t}\n\tnfss = NFS_SERVER(data->inode);\n\tif (atomic_long_read(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n\n\tnfs_init_cinfo(&cinfo, data->inode, data->dreq);\n\tif (atomic_dec_and_test(&cinfo.mds->rpcs_out))\n\t\tnfs_commit_clear_lock(NFS_I(data->inode));\n}"
  },
  {
    "function_name": "nfs_commit_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1668-1677",
    "snippet": "static void nfs_commit_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_commit_data\t*data = calldata;\n\n        dprintk(\"NFS: %5u nfs_commit_done (status %d)\\n\",\n                                task->tk_pid, task->tk_status);\n\n\t/* Call the NFS version-specific code */\n\tNFS_PROTO(data->inode)->commit_done(task, data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "task",
            "data"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "data->inode"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %5u nfs_commit_done (status %d)\\n\"",
            "task->tk_pid",
            "task->tk_status"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_commit_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_commit_data\t*data = calldata;\n\n        dprintk(\"NFS: %5u nfs_commit_done (status %d)\\n\",\n                                task->tk_pid, task->tk_status);\n\n\t/* Call the NFS version-specific code */\n\tNFS_PROTO(data->inode)->commit_done(task, data);\n}"
  },
  {
    "function_name": "nfs_commit_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1643-1663",
    "snippet": "static int\nnfs_commit_list(struct inode *inode, struct list_head *head, int how,\n\t\tstruct nfs_commit_info *cinfo)\n{\n\tstruct nfs_commit_data\t*data;\n\n\tdata = nfs_commitdata_alloc();\n\n\tif (!data)\n\t\tgoto out_bad;\n\n\t/* Set up the argument struct */\n\tnfs_init_commit(data, head, NULL, cinfo);\n\tatomic_inc(&cinfo->mds->rpcs_out);\n\treturn nfs_initiate_commit(NFS_CLIENT(inode), data, NFS_PROTO(inode),\n\t\t\t\t   data->mds_ops, how, 0);\n out_bad:\n\tnfs_retry_commit(head, NULL, cinfo, 0);\n\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cinfo->completion_ops->error_cleanup",
          "args": [
            "NFS_I(inode)"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_retry_commit",
          "args": [
            "head",
            "NULL",
            "cinfo",
            "0"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_retry_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1622-1637",
          "snippet": "void nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx)\n{\n\tstruct nfs_page *req;\n\n\twhile (!list_empty(page_list)) {\n\t\treq = nfs_list_entry(page_list->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\t\tif (!cinfo->dreq)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx)\n{\n\tstruct nfs_page *req;\n\n\twhile (!list_empty(page_list)) {\n\t\treq = nfs_list_entry(page_list->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\t\tif (!cinfo->dreq)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_initiate_commit",
          "args": [
            "NFS_CLIENT(inode)",
            "data",
            "NFS_PROTO(inode)",
            "data->mds_ops",
            "how",
            "0"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_initiate_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1533-1570",
          "snippet": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_CLIENT",
          "args": [
            "inode"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cinfo->mds->rpcs_out"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_init_commit",
          "args": [
            "data",
            "head",
            "NULL",
            "cinfo"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1588-1619",
          "snippet": "void nfs_init_commit(struct nfs_commit_data *data,\n\t\t     struct list_head *head,\n\t\t     struct pnfs_layout_segment *lseg,\n\t\t     struct nfs_commit_info *cinfo)\n{\n\tstruct nfs_page *first = nfs_list_entry(head->next);\n\tstruct inode *inode = first->wb_context->dentry->d_inode;\n\n\t/* Set up the RPC argument and reply structs\n\t * NB: take care not to mess about with data->commit et al. */\n\n\tlist_splice_init(head, &data->pages);\n\n\tdata->inode\t  = inode;\n\tdata->cred\t  = first->wb_context->cred;\n\tdata->lseg\t  = lseg; /* reference transferred */\n\t/* only set lwb for pnfs commit */\n\tif (lseg)\n\t\tdata->lwb = nfs_get_lwb(&data->pages);\n\tdata->mds_ops     = &nfs_commit_ops;\n\tdata->completion_ops = cinfo->completion_ops;\n\tdata->dreq\t  = cinfo->dreq;\n\n\tdata->args.fh     = NFS_FH(data->inode);\n\t/* Note: we always request a commit of the entire inode */\n\tdata->args.offset = 0;\n\tdata->args.count  = 0;\n\tdata->context     = get_nfs_open_context(first->wb_context);\n\tdata->res.fattr   = &data->fattr;\n\tdata->res.verf    = &data->verf;\n\tnfs_fattr_init(&data->fattr);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_call_ops nfs_commit_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct rpc_call_ops nfs_commit_ops = {\n\t.rpc_call_prepare = nfs_commit_prepare,\n\t.rpc_call_done = nfs_commit_done,\n\t.rpc_release = nfs_commit_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nfs_commit_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct rpc_call_ops nfs_commit_ops = {\n\t.rpc_call_prepare = nfs_commit_prepare,\n\t.rpc_call_done = nfs_commit_done,\n\t.rpc_release = nfs_commit_release,\n};\n\nvoid nfs_init_commit(struct nfs_commit_data *data,\n\t\t     struct list_head *head,\n\t\t     struct pnfs_layout_segment *lseg,\n\t\t     struct nfs_commit_info *cinfo)\n{\n\tstruct nfs_page *first = nfs_list_entry(head->next);\n\tstruct inode *inode = first->wb_context->dentry->d_inode;\n\n\t/* Set up the RPC argument and reply structs\n\t * NB: take care not to mess about with data->commit et al. */\n\n\tlist_splice_init(head, &data->pages);\n\n\tdata->inode\t  = inode;\n\tdata->cred\t  = first->wb_context->cred;\n\tdata->lseg\t  = lseg; /* reference transferred */\n\t/* only set lwb for pnfs commit */\n\tif (lseg)\n\t\tdata->lwb = nfs_get_lwb(&data->pages);\n\tdata->mds_ops     = &nfs_commit_ops;\n\tdata->completion_ops = cinfo->completion_ops;\n\tdata->dreq\t  = cinfo->dreq;\n\n\tdata->args.fh     = NFS_FH(data->inode);\n\t/* Note: we always request a commit of the entire inode */\n\tdata->args.offset = 0;\n\tdata->args.count  = 0;\n\tdata->context     = get_nfs_open_context(first->wb_context);\n\tdata->res.fattr   = &data->fattr;\n\tdata->res.verf    = &data->verf;\n\tnfs_fattr_init(&data->fattr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_commitdata_alloc",
          "args": [],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commitdata_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "61-70",
          "snippet": "struct nfs_commit_data *nfs_commitdata_alloc(void)\n{\n\tstruct nfs_commit_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOIO);\n\n\tif (p) {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tINIT_LIST_HEAD(&p->pages);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static mempool_t *nfs_commit_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic mempool_t *nfs_commit_mempool;\n\nstruct nfs_commit_data *nfs_commitdata_alloc(void)\n{\n\tstruct nfs_commit_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOIO);\n\n\tif (p) {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tINIT_LIST_HEAD(&p->pages);\n\t}\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int\nnfs_commit_list(struct inode *inode, struct list_head *head, int how,\n\t\tstruct nfs_commit_info *cinfo)\n{\n\tstruct nfs_commit_data\t*data;\n\n\tdata = nfs_commitdata_alloc();\n\n\tif (!data)\n\t\tgoto out_bad;\n\n\t/* Set up the argument struct */\n\tnfs_init_commit(data, head, NULL, cinfo);\n\tatomic_inc(&cinfo->mds->rpcs_out);\n\treturn nfs_initiate_commit(NFS_CLIENT(inode), data, NFS_PROTO(inode),\n\t\t\t\t   data->mds_ops, how, 0);\n out_bad:\n\tnfs_retry_commit(head, NULL, cinfo, 0);\n\tcinfo->completion_ops->error_cleanup(NFS_I(inode));\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "nfs_retry_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1622-1637",
    "snippet": "void nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx)\n{\n\tstruct nfs_page *req;\n\n\twhile (!list_empty(page_list)) {\n\t\treq = nfs_list_entry(page_list->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\t\tif (!cinfo->dreq)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_unlock_and_release_request",
          "args": [
            "req"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unlock_and_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "410-414",
          "snippet": "void nfs_unlock_and_release_request(struct nfs_page *req)\n{\n\tnfs_unlock_request(req);\n\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_unlock_and_release_request(struct nfs_page *req)\n{\n\tnfs_unlock_request(req);\n\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_clear_page_commit",
          "args": [
            "req->wb_page"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_clear_page_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "852-857",
          "snippet": "static void\nnfs_clear_page_commit(struct page *page)\n{\n\tdec_zone_page_state(page, NR_UNSTABLE_NFS);\n\tdec_bdi_stat(inode_to_bdi(page_file_mapping(page)->host), BDI_RECLAIMABLE);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void\nnfs_clear_page_commit(struct page *page)\n{\n\tdec_zone_page_state(page, NR_UNSTABLE_NFS);\n\tdec_bdi_stat(inode_to_bdi(page_file_mapping(page)->host), BDI_RECLAIMABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_request_commit",
          "args": [
            "req",
            "lseg",
            "cinfo",
            "ds_commit_idx"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_request_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "843-850",
          "snippet": "void\nnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\tstruct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\tif (pnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx))\n\t\treturn;\n\tnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\tstruct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\tif (pnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx))\n\t\treturn;\n\tnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_list_remove_request",
          "args": [
            "req"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "page_list->next"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "page_list"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid nfs_retry_commit(struct list_head *page_list,\n\t\t      struct pnfs_layout_segment *lseg,\n\t\t      struct nfs_commit_info *cinfo,\n\t\t      u32 ds_commit_idx)\n{\n\tstruct nfs_page *req;\n\n\twhile (!list_empty(page_list)) {\n\t\treq = nfs_list_entry(page_list->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx);\n\t\tif (!cinfo->dreq)\n\t\t\tnfs_clear_page_commit(req->wb_page);\n\t\tnfs_unlock_and_release_request(req);\n\t}\n}"
  },
  {
    "function_name": "nfs_init_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1588-1619",
    "snippet": "void nfs_init_commit(struct nfs_commit_data *data,\n\t\t     struct list_head *head,\n\t\t     struct pnfs_layout_segment *lseg,\n\t\t     struct nfs_commit_info *cinfo)\n{\n\tstruct nfs_page *first = nfs_list_entry(head->next);\n\tstruct inode *inode = first->wb_context->dentry->d_inode;\n\n\t/* Set up the RPC argument and reply structs\n\t * NB: take care not to mess about with data->commit et al. */\n\n\tlist_splice_init(head, &data->pages);\n\n\tdata->inode\t  = inode;\n\tdata->cred\t  = first->wb_context->cred;\n\tdata->lseg\t  = lseg; /* reference transferred */\n\t/* only set lwb for pnfs commit */\n\tif (lseg)\n\t\tdata->lwb = nfs_get_lwb(&data->pages);\n\tdata->mds_ops     = &nfs_commit_ops;\n\tdata->completion_ops = cinfo->completion_ops;\n\tdata->dreq\t  = cinfo->dreq;\n\n\tdata->args.fh     = NFS_FH(data->inode);\n\t/* Note: we always request a commit of the entire inode */\n\tdata->args.offset = 0;\n\tdata->args.count  = 0;\n\tdata->context     = get_nfs_open_context(first->wb_context);\n\tdata->res.fattr   = &data->fattr;\n\tdata->res.verf    = &data->verf;\n\tnfs_fattr_init(&data->fattr);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops nfs_commit_ops;",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static const struct rpc_call_ops nfs_commit_ops = {\n\t.rpc_call_prepare = nfs_commit_prepare,\n\t.rpc_call_done = nfs_commit_done,\n\t.rpc_release = nfs_commit_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_fattr_init",
          "args": [
            "&data->fattr"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fattr_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1286-1293",
          "snippet": "void nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nvoid nfs_fattr_init(struct nfs_fattr *fattr)\n{\n\tfattr->valid = 0;\n\tfattr->time_start = jiffies;\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n\tfattr->owner_name = NULL;\n\tfattr->group_name = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs_open_context",
          "args": [
            "first->wb_context"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "803-808",
          "snippet": "struct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct nfs_open_context *get_nfs_open_context(struct nfs_open_context *ctx)\n{\n\tif (ctx != NULL)\n\t\tatomic_inc(&ctx->lock_context.count);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_FH",
          "args": [
            "data->inode"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_get_lwb",
          "args": [
            "&data->pages"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_get_lwb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1573-1583",
          "snippet": "static loff_t nfs_get_lwb(struct list_head *head)\n{\n\tloff_t lwb = 0;\n\tstruct nfs_page *req;\n\n\tlist_for_each_entry(req, head, wb_list)\n\t\tif (lwb < (req_offset(req) + req->wb_bytes))\n\t\t\tlwb = req_offset(req) + req->wb_bytes;\n\n\treturn lwb;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic loff_t nfs_get_lwb(struct list_head *head)\n{\n\tloff_t lwb = 0;\n\tstruct nfs_page *req;\n\n\tlist_for_each_entry(req, head, wb_list)\n\t\tif (lwb < (req_offset(req) + req->wb_bytes))\n\t\t\tlwb = req_offset(req) + req->wb_bytes;\n\n\treturn lwb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "head",
            "&data->pages"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "head->next"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct rpc_call_ops nfs_commit_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct rpc_call_ops nfs_commit_ops = {\n\t.rpc_call_prepare = nfs_commit_prepare,\n\t.rpc_call_done = nfs_commit_done,\n\t.rpc_release = nfs_commit_release,\n};\n\nvoid nfs_init_commit(struct nfs_commit_data *data,\n\t\t     struct list_head *head,\n\t\t     struct pnfs_layout_segment *lseg,\n\t\t     struct nfs_commit_info *cinfo)\n{\n\tstruct nfs_page *first = nfs_list_entry(head->next);\n\tstruct inode *inode = first->wb_context->dentry->d_inode;\n\n\t/* Set up the RPC argument and reply structs\n\t * NB: take care not to mess about with data->commit et al. */\n\n\tlist_splice_init(head, &data->pages);\n\n\tdata->inode\t  = inode;\n\tdata->cred\t  = first->wb_context->cred;\n\tdata->lseg\t  = lseg; /* reference transferred */\n\t/* only set lwb for pnfs commit */\n\tif (lseg)\n\t\tdata->lwb = nfs_get_lwb(&data->pages);\n\tdata->mds_ops     = &nfs_commit_ops;\n\tdata->completion_ops = cinfo->completion_ops;\n\tdata->dreq\t  = cinfo->dreq;\n\n\tdata->args.fh     = NFS_FH(data->inode);\n\t/* Note: we always request a commit of the entire inode */\n\tdata->args.offset = 0;\n\tdata->args.count  = 0;\n\tdata->context     = get_nfs_open_context(first->wb_context);\n\tdata->res.fattr   = &data->fattr;\n\tdata->res.verf    = &data->verf;\n\tnfs_fattr_init(&data->fattr);\n}"
  },
  {
    "function_name": "nfs_get_lwb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1573-1583",
    "snippet": "static loff_t nfs_get_lwb(struct list_head *head)\n{\n\tloff_t lwb = 0;\n\tstruct nfs_page *req;\n\n\tlist_for_each_entry(req, head, wb_list)\n\t\tif (lwb < (req_offset(req) + req->wb_bytes))\n\t\t\tlwb = req_offset(req) + req->wb_bytes;\n\n\treturn lwb;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "req",
            "head",
            "wb_list"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic loff_t nfs_get_lwb(struct list_head *head)\n{\n\tloff_t lwb = 0;\n\tstruct nfs_page *req;\n\n\tlist_for_each_entry(req, head, wb_list)\n\t\tif (lwb < (req_offset(req) + req->wb_bytes))\n\t\t\tlwb = req_offset(req) + req->wb_bytes;\n\n\treturn lwb;\n}"
  },
  {
    "function_name": "nfs_initiate_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1533-1570",
    "snippet": "int nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_task",
          "args": [
            "task"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_wait_for_completion_task",
          "args": [
            "task"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "task"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "task"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_run_task",
          "args": [
            "&task_setup_data"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_protect",
          "args": [
            "NFS_SERVER(data->inode)->nfs_client",
            "NFS_SP4_MACH_CRED_COMMIT",
            "&task_setup_data.rpc_client",
            "&msg"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_protect_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "366-370",
          "snippet": "static inline void\nnfs4_state_protect_write(struct nfs_client *clp, struct rpc_clnt **clntp,\n\t\t\t struct rpc_message *msg, struct nfs_pgio_header *hdr)\n{\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void\nnfs4_state_protect_write(struct nfs_client *clp, struct rpc_clnt **clntp,\n\t\t\t struct rpc_message *msg, struct nfs_pgio_header *hdr)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "data->inode"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %5u initiated commit call\\n\"",
            "data->task.tk_pid"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_ops->commit_setup",
          "args": [
            "data",
            "&msg"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_task_priority",
          "args": [
            "how"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "flush_task_priority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1260-1269",
          "snippet": "static int flush_task_priority(int how)\n{\n\tswitch (how & (FLUSH_HIGHPRI|FLUSH_LOWPRI)) {\n\t\tcase FLUSH_HIGHPRI:\n\t\t\treturn RPC_PRIORITY_HIGH;\n\t\tcase FLUSH_LOWPRI:\n\t\t\treturn RPC_PRIORITY_LOW;\n\t}\n\treturn RPC_PRIORITY_NORMAL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int flush_task_priority(int how)\n{\n\tswitch (how & (FLUSH_HIGHPRI|FLUSH_LOWPRI)) {\n\t\tcase FLUSH_HIGHPRI:\n\t\t\treturn RPC_PRIORITY_HIGH;\n\t\tcase FLUSH_LOWPRI:\n\t\t\treturn RPC_PRIORITY_LOW;\n\t}\n\treturn RPC_PRIORITY_NORMAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint nfs_initiate_commit(struct rpc_clnt *clnt, struct nfs_commit_data *data,\n\t\t\tconst struct nfs_rpc_ops *nfs_ops,\n\t\t\tconst struct rpc_call_ops *call_ops,\n\t\t\tint how, int flags)\n{\n\tstruct rpc_task *task;\n\tint priority = flush_task_priority(how);\n\tstruct rpc_message msg = {\n\t\t.rpc_argp = &data->args,\n\t\t.rpc_resp = &data->res,\n\t\t.rpc_cred = data->cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.task = &data->task,\n\t\t.rpc_client = clnt,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = call_ops,\n\t\t.callback_data = data,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC | flags,\n\t\t.priority = priority,\n\t};\n\t/* Set up the initial task struct.  */\n\tnfs_ops->commit_setup(data, &msg);\n\n\tdprintk(\"NFS: %5u initiated commit call\\n\", data->task.tk_pid);\n\n\tnfs4_state_protect(NFS_SERVER(data->inode)->nfs_client,\n\t\tNFS_SP4_MACH_CRED_COMMIT, &task_setup_data.rpc_client, &msg);\n\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tif (how & FLUSH_SYNC)\n\t\trpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_commitdata_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1526-1530",
    "snippet": "void nfs_commitdata_release(struct nfs_commit_data *data)\n{\n\tput_nfs_open_context(data->context);\n\tnfs_commit_free(data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_commit_free",
          "args": [
            "data"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "73-76",
          "snippet": "void nfs_commit_free(struct nfs_commit_data *p)\n{\n\tmempool_free(p, nfs_commit_mempool);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static mempool_t *nfs_commit_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic mempool_t *nfs_commit_mempool;\n\nvoid nfs_commit_free(struct nfs_commit_data *p)\n{\n\tmempool_free(p, nfs_commit_mempool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_nfs_open_context",
          "args": [
            "data->context"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs_open_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "833-836",
          "snippet": "void put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid put_nfs_open_context(struct nfs_open_context *ctx)\n{\n\t__put_nfs_open_context(ctx, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_commitdata_release(struct nfs_commit_data *data)\n{\n\tput_nfs_open_context(data->context);\n\tnfs_commit_free(data);\n}"
  },
  {
    "function_name": "nfs_commit_clear_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1519-1524",
    "snippet": "static void nfs_commit_clear_lock(struct nfs_inode *nfsi)\n{\n\tclear_bit(NFS_INO_COMMIT, &nfsi->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&nfsi->flags, NFS_INO_COMMIT);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&nfsi->flags",
            "NFS_INO_COMMIT"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFS_INO_COMMIT",
            "&nfsi->flags"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_commit_clear_lock(struct nfs_inode *nfsi)\n{\n\tclear_bit(NFS_INO_COMMIT, &nfsi->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&nfsi->flags, NFS_INO_COMMIT);\n}"
  },
  {
    "function_name": "nfs_commit_set_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1504-1517",
    "snippet": "static int nfs_commit_set_lock(struct nfs_inode *nfsi, int may_wait)\n{\n\tint ret;\n\n\tif (!test_and_set_bit(NFS_INO_COMMIT, &nfsi->flags))\n\t\treturn 1;\n\tif (!may_wait)\n\t\treturn 0;\n\tret = out_of_line_wait_on_bit_lock(&nfsi->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\treturn (ret < 0) ? ret : 1;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out_of_line_wait_on_bit_lock",
          "args": [
            "&nfsi->flags",
            "NFS_INO_COMMIT",
            "nfs_wait_bit_killable",
            "TASK_KILLABLE"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFS_INO_COMMIT",
            "&nfsi->flags"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int nfs_commit_set_lock(struct nfs_inode *nfsi, int may_wait)\n{\n\tint ret;\n\n\tif (!test_and_set_bit(NFS_INO_COMMIT, &nfsi->flags))\n\t\treturn 1;\n\tif (!may_wait)\n\t\treturn 0;\n\tret = out_of_line_wait_on_bit_lock(&nfsi->flags,\n\t\t\t\tNFS_INO_COMMIT,\n\t\t\t\tnfs_wait_bit_killable,\n\t\t\t\tTASK_KILLABLE);\n\treturn (ret < 0) ? ret : 1;\n}"
  },
  {
    "function_name": "nfs_writeback_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1462-1501",
    "snippet": "static void nfs_writeback_result(struct rpc_task *task,\n\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_args\t*argp = &hdr->args;\n\tstruct nfs_pgio_res\t*resp = &hdr->res;\n\n\tif (resp->count < argp->count) {\n\t\tstatic unsigned long    complain;\n\n\t\t/* This a short write! */\n\t\tnfs_inc_stats(hdr->inode, NFSIOS_SHORTWRITE);\n\n\t\t/* Has the server at least made some progress? */\n\t\tif (resp->count == 0) {\n\t\t\tif (time_before(complain, jiffies)) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"NFS: Server wrote zero bytes, expected %u.\\n\",\n\t\t\t\t       argp->count);\n\t\t\t\tcomplain = jiffies + 300 * HZ;\n\t\t\t}\n\t\t\tnfs_set_pgio_error(hdr, -EIO, argp->offset);\n\t\t\ttask->tk_status = -EIO;\n\t\t\treturn;\n\t\t}\n\t\t/* Was this an NFSv2 write or an NFSv3 stable write? */\n\t\tif (resp->verf->committed != NFS_UNSTABLE) {\n\t\t\t/* Resend from where the server left off */\n\t\t\thdr->mds_offset += resp->count;\n\t\t\targp->offset += resp->count;\n\t\t\targp->pgbase += resp->count;\n\t\t\targp->count -= resp->count;\n\t\t} else {\n\t\t\t/* Resend as a stable write in order to avoid\n\t\t\t * headaches in the case of a server crash.\n\t\t\t */\n\t\t\targp->stable = NFS_FILE_SYNC;\n\t\t}\n\t\trpc_restart_call_prepare(task);\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_set_pgio_error",
          "args": [
            "hdr",
            "-EIO",
            "argp->offset"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_pgio_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "77-87",
          "snippet": "void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos)\n{\n\tspin_lock(&hdr->lock);\n\tif (pos < hdr->io_start + hdr->good_bytes) {\n\t\tset_bit(NFS_IOHDR_ERROR, &hdr->flags);\n\t\tclear_bit(NFS_IOHDR_EOF, &hdr->flags);\n\t\thdr->good_bytes = pos - hdr->io_start;\n\t\thdr->error = error;\n\t}\n\tspin_unlock(&hdr->lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos)\n{\n\tspin_lock(&hdr->lock);\n\tif (pos < hdr->io_start + hdr->good_bytes) {\n\t\tset_bit(NFS_IOHDR_ERROR, &hdr->flags);\n\t\tclear_bit(NFS_IOHDR_EOF, &hdr->flags);\n\t\thdr->good_bytes = pos - hdr->io_start;\n\t\thdr->error = error;\n\t}\n\tspin_unlock(&hdr->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\t       \"NFS: Server wrote zero bytes, expected %u.\\n\"",
            "argp->count"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "complain",
            "jiffies"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "hdr->inode",
            "NFSIOS_SHORTWRITE"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_writeback_result(struct rpc_task *task,\n\t\t\t\t struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_pgio_args\t*argp = &hdr->args;\n\tstruct nfs_pgio_res\t*resp = &hdr->res;\n\n\tif (resp->count < argp->count) {\n\t\tstatic unsigned long    complain;\n\n\t\t/* This a short write! */\n\t\tnfs_inc_stats(hdr->inode, NFSIOS_SHORTWRITE);\n\n\t\t/* Has the server at least made some progress? */\n\t\tif (resp->count == 0) {\n\t\t\tif (time_before(complain, jiffies)) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"NFS: Server wrote zero bytes, expected %u.\\n\",\n\t\t\t\t       argp->count);\n\t\t\t\tcomplain = jiffies + 300 * HZ;\n\t\t\t}\n\t\t\tnfs_set_pgio_error(hdr, -EIO, argp->offset);\n\t\t\ttask->tk_status = -EIO;\n\t\t\treturn;\n\t\t}\n\t\t/* Was this an NFSv2 write or an NFSv3 stable write? */\n\t\tif (resp->verf->committed != NFS_UNSTABLE) {\n\t\t\t/* Resend from where the server left off */\n\t\t\thdr->mds_offset += resp->count;\n\t\t\targp->offset += resp->count;\n\t\t\targp->pgbase += resp->count;\n\t\t\targp->count -= resp->count;\n\t\t} else {\n\t\t\t/* Resend as a stable write in order to avoid\n\t\t\t * headaches in the case of a server crash.\n\t\t\t */\n\t\t\targp->stable = NFS_FILE_SYNC;\n\t\t}\n\t\trpc_restart_call_prepare(task);\n\t}\n}"
  },
  {
    "function_name": "nfs_writeback_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1413-1457",
    "snippet": "static int nfs_writeback_done(struct rpc_task *task,\n\t\t\t      struct nfs_pgio_header *hdr,\n\t\t\t      struct inode *inode)\n{\n\tint status;\n\n\t/*\n\t * ->write_done will attempt to use post-op attributes to detect\n\t * conflicting writes by other clients.  A strict interpretation\n\t * of close-to-open would allow us to continue caching even if\n\t * another writer had changed the file, but some applications\n\t * depend on tighter cache coherency when writing.\n\t */\n\tstatus = NFS_PROTO(inode)->write_done(task, hdr);\n\tif (status != 0)\n\t\treturn status;\n\tnfs_add_stats(inode, NFSIOS_SERVERWRITTENBYTES, hdr->res.count);\n\n\tif (hdr->res.verf->committed < hdr->args.stable &&\n\t    task->tk_status >= 0) {\n\t\t/* We tried a write call, but the server did not\n\t\t * commit data to stable storage even though we\n\t\t * requested it.\n\t\t * Note: There is a known bug in Tru64 < 5.0 in which\n\t\t *\t the server reports NFS_DATA_SYNC, but performs\n\t\t *\t NFS_FILE_SYNC. We therefore implement this checking\n\t\t *\t as a dprintk() in order to avoid filling syslog.\n\t\t */\n\t\tstatic unsigned long    complain;\n\n\t\t/* Note this will print the MDS for a DS write */\n\t\tif (time_before(complain, jiffies)) {\n\t\t\tdprintk(\"NFS:       faulty NFS server %s:\"\n\t\t\t\t\" (committed = %d) != (stable = %d)\\n\",\n\t\t\t\tNFS_SERVER(inode)->nfs_client->cl_hostname,\n\t\t\t\thdr->res.verf->committed, hdr->args.stable);\n\t\t\tcomplain = jiffies + 300 * HZ;\n\t\t}\n\t}\n\n\t/* Deal with the suid/sgid bit corner case */\n\tif (nfs_should_remove_suid(inode))\n\t\tnfs_mark_for_revalidate(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_mark_for_revalidate",
          "args": [
            "inode"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_should_remove_suid",
          "args": [
            "inode"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_should_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1358-1378",
          "snippet": "static int nfs_should_remove_suid(const struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int nfs_should_remove_suid(const struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS:       faulty NFS server %s:\"\n\t\t\t\t\" (committed = %d) != (stable = %d)\\n\"",
            "NFS_SERVER(inode)->nfs_client->cl_hostname",
            "hdr->res.verf->committed",
            "hdr->args.stable"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "complain",
            "jiffies"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_add_stats",
          "args": [
            "inode",
            "NFSIOS_SERVERWRITTENBYTES",
            "hdr->res.count"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_add_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "44-49",
          "snippet": "static inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_add_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_bytecounters stat,\n\t\t\t\t long addend)\n{\n\tnfs_add_server_stats(NFS_SERVER(inode), stat, addend);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "task",
            "hdr"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int nfs_writeback_done(struct rpc_task *task,\n\t\t\t      struct nfs_pgio_header *hdr,\n\t\t\t      struct inode *inode)\n{\n\tint status;\n\n\t/*\n\t * ->write_done will attempt to use post-op attributes to detect\n\t * conflicting writes by other clients.  A strict interpretation\n\t * of close-to-open would allow us to continue caching even if\n\t * another writer had changed the file, but some applications\n\t * depend on tighter cache coherency when writing.\n\t */\n\tstatus = NFS_PROTO(inode)->write_done(task, hdr);\n\tif (status != 0)\n\t\treturn status;\n\tnfs_add_stats(inode, NFSIOS_SERVERWRITTENBYTES, hdr->res.count);\n\n\tif (hdr->res.verf->committed < hdr->args.stable &&\n\t    task->tk_status >= 0) {\n\t\t/* We tried a write call, but the server did not\n\t\t * commit data to stable storage even though we\n\t\t * requested it.\n\t\t * Note: There is a known bug in Tru64 < 5.0 in which\n\t\t *\t the server reports NFS_DATA_SYNC, but performs\n\t\t *\t NFS_FILE_SYNC. We therefore implement this checking\n\t\t *\t as a dprintk() in order to avoid filling syslog.\n\t\t */\n\t\tstatic unsigned long    complain;\n\n\t\t/* Note this will print the MDS for a DS write */\n\t\tif (time_before(complain, jiffies)) {\n\t\t\tdprintk(\"NFS:       faulty NFS server %s:\"\n\t\t\t\t\" (committed = %d) != (stable = %d)\\n\",\n\t\t\t\tNFS_SERVER(inode)->nfs_client->cl_hostname,\n\t\t\t\thdr->res.verf->committed, hdr->args.stable);\n\t\t\tcomplain = jiffies + 300 * HZ;\n\t\t}\n\t}\n\n\t/* Deal with the suid/sgid bit corner case */\n\tif (nfs_should_remove_suid(inode))\n\t\tnfs_mark_for_revalidate(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_writeback_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1396-1407",
    "snippet": "void nfs_writeback_update_inode(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_fattr *fattr = hdr->res.fattr;\n\tstruct inode *inode = hdr->inode;\n\n\tif (fattr == NULL)\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tnfs_writeback_check_extend(hdr, fattr);\n\tnfs_post_op_update_inode_force_wcc_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_post_op_update_inode_force_wcc_locked",
          "args": [
            "inode",
            "fattr"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_post_op_update_inode_force_wcc_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1530-1566",
          "snippet": "int nfs_post_op_update_inode_force_wcc_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\t/* Don't do a WCC update if these attributes are already stale */\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0 ||\n\t\t\t!nfs_inode_attrs_need_update(inode, fattr)) {\n\t\tfattr->valid &= ~(NFS_ATTR_FATTR_PRECHANGE\n\t\t\t\t| NFS_ATTR_FATTR_PRESIZE\n\t\t\t\t| NFS_ATTR_FATTR_PREMTIME\n\t\t\t\t| NFS_ATTR_FATTR_PRECTIME);\n\t\tgoto out_noforce;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECHANGE) == 0) {\n\t\tfattr->pre_change_attr = inode->i_version;\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECHANGE;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECTIME) == 0) {\n\t\tmemcpy(&fattr->pre_ctime, &inode->i_ctime, sizeof(fattr->pre_ctime));\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_MTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PREMTIME) == 0) {\n\t\tmemcpy(&fattr->pre_mtime, &inode->i_mtime, sizeof(fattr->pre_mtime));\n\t\tfattr->valid |= NFS_ATTR_FATTR_PREMTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_SIZE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRESIZE) == 0) {\n\t\tfattr->pre_size = i_size_read(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRESIZE;\n\t}\nout_noforce:\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr);\n\treturn status;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);",
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nint nfs_post_op_update_inode_force_wcc_locked(struct inode *inode, struct nfs_fattr *fattr)\n{\n\tint status;\n\n\t/* Don't do a WCC update if these attributes are already stale */\n\tif ((fattr->valid & NFS_ATTR_FATTR) == 0 ||\n\t\t\t!nfs_inode_attrs_need_update(inode, fattr)) {\n\t\tfattr->valid &= ~(NFS_ATTR_FATTR_PRECHANGE\n\t\t\t\t| NFS_ATTR_FATTR_PRESIZE\n\t\t\t\t| NFS_ATTR_FATTR_PREMTIME\n\t\t\t\t| NFS_ATTR_FATTR_PRECTIME);\n\t\tgoto out_noforce;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CHANGE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECHANGE) == 0) {\n\t\tfattr->pre_change_attr = inode->i_version;\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECHANGE;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_CTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRECTIME) == 0) {\n\t\tmemcpy(&fattr->pre_ctime, &inode->i_ctime, sizeof(fattr->pre_ctime));\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRECTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_MTIME) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PREMTIME) == 0) {\n\t\tmemcpy(&fattr->pre_mtime, &inode->i_mtime, sizeof(fattr->pre_mtime));\n\t\tfattr->valid |= NFS_ATTR_FATTR_PREMTIME;\n\t}\n\tif ((fattr->valid & NFS_ATTR_FATTR_SIZE) != 0 &&\n\t\t\t(fattr->valid & NFS_ATTR_FATTR_PRESIZE) == 0) {\n\t\tfattr->pre_size = i_size_read(inode);\n\t\tfattr->valid |= NFS_ATTR_FATTR_PRESIZE;\n\t}\nout_noforce:\n\tstatus = nfs_post_op_update_inode_locked(inode, fattr);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_writeback_check_extend",
          "args": [
            "hdr",
            "fattr"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_writeback_check_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1380-1394",
          "snippet": "static void nfs_writeback_check_extend(struct nfs_pgio_header *hdr,\n\t\tstruct nfs_fattr *fattr)\n{\n\tstruct nfs_pgio_args *argp = &hdr->args;\n\tstruct nfs_pgio_res *resp = &hdr->res;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_SIZE))\n\t\treturn;\n\tif (argp->offset + resp->count != fattr->size)\n\t\treturn;\n\tif (nfs_size_to_loff_t(fattr->size) < i_size_read(hdr->inode))\n\t\treturn;\n\t/* Set attribute barrier */\n\tnfs_fattr_set_barrier(fattr);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_writeback_check_extend(struct nfs_pgio_header *hdr,\n\t\tstruct nfs_fattr *fattr)\n{\n\tstruct nfs_pgio_args *argp = &hdr->args;\n\tstruct nfs_pgio_res *resp = &hdr->res;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_SIZE))\n\t\treturn;\n\tif (argp->offset + resp->count != fattr->size)\n\t\treturn;\n\tif (nfs_size_to_loff_t(fattr->size) < i_size_read(hdr->inode))\n\t\treturn;\n\t/* Set attribute barrier */\n\tnfs_fattr_set_barrier(fattr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nvoid nfs_writeback_update_inode(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_fattr *fattr = hdr->res.fattr;\n\tstruct inode *inode = hdr->inode;\n\n\tif (fattr == NULL)\n\t\treturn;\n\tspin_lock(&inode->i_lock);\n\tnfs_writeback_check_extend(hdr, fattr);\n\tnfs_post_op_update_inode_force_wcc_locked(inode, fattr);\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "nfs_writeback_check_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1380-1394",
    "snippet": "static void nfs_writeback_check_extend(struct nfs_pgio_header *hdr,\n\t\tstruct nfs_fattr *fattr)\n{\n\tstruct nfs_pgio_args *argp = &hdr->args;\n\tstruct nfs_pgio_res *resp = &hdr->res;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_SIZE))\n\t\treturn;\n\tif (argp->offset + resp->count != fattr->size)\n\t\treturn;\n\tif (nfs_size_to_loff_t(fattr->size) < i_size_read(hdr->inode))\n\t\treturn;\n\t/* Set attribute barrier */\n\tnfs_fattr_set_barrier(fattr);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_fattr_set_barrier",
          "args": [
            "fattr"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_fattr_set_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "1307-1310",
          "snippet": "void nfs_fattr_set_barrier(struct nfs_fattr *fattr)\n{\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nfs_update_inode(struct inode *, struct nfs_fattr *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int nfs_update_inode(struct inode *, struct nfs_fattr *);\n\nvoid nfs_fattr_set_barrier(struct nfs_fattr *fattr)\n{\n\tfattr->gencount = nfs_inc_attr_generation_counter();\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "hdr->inode"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_size_to_loff_t",
          "args": [
            "fattr->size"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_writeback_check_extend(struct nfs_pgio_header *hdr,\n\t\tstruct nfs_fattr *fattr)\n{\n\tstruct nfs_pgio_args *argp = &hdr->args;\n\tstruct nfs_pgio_res *resp = &hdr->res;\n\n\tif (!(fattr->valid & NFS_ATTR_FATTR_SIZE))\n\t\treturn;\n\tif (argp->offset + resp->count != fattr->size)\n\t\treturn;\n\tif (nfs_size_to_loff_t(fattr->size) < i_size_read(hdr->inode))\n\t\treturn;\n\t/* Set attribute barrier */\n\tnfs_fattr_set_barrier(fattr);\n}"
  },
  {
    "function_name": "nfs_should_remove_suid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1358-1378",
    "snippet": "static int nfs_should_remove_suid(const struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kill && S_ISREG(mode)"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(mode & S_ISGID) && (mode & S_IXGRP)"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mode & S_ISUID"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int nfs_should_remove_suid(const struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_writeback_release_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1350-1353",
    "snippet": "static void nfs_writeback_release_common(struct nfs_pgio_header *hdr)\n{\n\t/* do nothing! */\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_writeback_release_common(struct nfs_pgio_header *hdr)\n{\n\t/* do nothing! */\n}"
  },
  {
    "function_name": "nfs_commit_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1343-1348",
    "snippet": "void nfs_commit_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tNFS_PROTO(data->inode)->commit_rpc_prepare(task, data);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "task",
            "data"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "data->inode"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nvoid nfs_commit_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs_commit_data *data = calldata;\n\n\tNFS_PROTO(data->inode)->commit_rpc_prepare(task, data);\n}"
  },
  {
    "function_name": "nfs_pageio_reset_write_mds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1329-1339",
    "snippet": "void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "pgio->pg_inode"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pageio_stop_mirroring",
          "args": [
            "pgio"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_stop_mirroring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "892-896",
          "snippet": "void nfs_pageio_stop_mirroring(struct nfs_pageio_descriptor *pgio)\n{\n\tpgio->pg_mirror_count = 1;\n\tpgio->pg_mirror_idx = 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pageio_stop_mirroring(struct nfs_pageio_descriptor *pgio)\n{\n\tpgio->pg_mirror_count = 1;\n\tpgio->pg_mirror_idx = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\n\tpgio->pg_ops = &nfs_pgio_rw_ops;\n\n\tnfs_pageio_stop_mirroring(pgio);\n\n\tmirror = &pgio->pg_mirrors[0];\n\tmirror->pg_bsize = NFS_SERVER(pgio->pg_inode)->wsize;\n}"
  },
  {
    "function_name": "nfs_pageio_init_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1313-1326",
    "snippet": "void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct inode *inode, int ioflags, bool force_mds,\n\t\t\t       const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_write_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_write_ops,\n\t\t\tserver->wsize, ioflags);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct nfs_rw_ops nfs_rw_write_ops;",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static const struct nfs_rw_ops nfs_rw_write_ops = {\n\t.rw_mode\t\t= FMODE_WRITE,\n\t.rw_alloc_header\t= nfs_writehdr_alloc,\n\t.rw_free_header\t\t= nfs_writehdr_free,\n\t.rw_release\t\t= nfs_writeback_release_common,\n\t.rw_done\t\t= nfs_writeback_done,\n\t.rw_result\t\t= nfs_writeback_result,\n\t.rw_initiate\t\t= nfs_initiate_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_init",
          "args": [
            "pgio",
            "inode",
            "pg_ops",
            "compl_ops",
            "&nfs_rw_write_ops",
            "server->wsize",
            "ioflags"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "718-759",
          "snippet": "void nfs_pageio_init(struct nfs_pageio_descriptor *desc,\n\t\t     struct inode *inode,\n\t\t     const struct nfs_pageio_ops *pg_ops,\n\t\t     const struct nfs_pgio_completion_ops *compl_ops,\n\t\t     const struct nfs_rw_ops *rw_ops,\n\t\t     size_t bsize,\n\t\t     int io_flags)\n{\n\tstruct nfs_pgio_mirror *new;\n\tint i;\n\n\tdesc->pg_moreio = 0;\n\tdesc->pg_inode = inode;\n\tdesc->pg_ops = pg_ops;\n\tdesc->pg_completion_ops = compl_ops;\n\tdesc->pg_rw_ops = rw_ops;\n\tdesc->pg_ioflags = io_flags;\n\tdesc->pg_error = 0;\n\tdesc->pg_lseg = NULL;\n\tdesc->pg_dreq = NULL;\n\tdesc->pg_layout_private = NULL;\n\tdesc->pg_bsize = bsize;\n\n\tdesc->pg_mirror_count = 1;\n\tdesc->pg_mirror_idx = 0;\n\n\tif (pg_ops->pg_get_mirror_count) {\n\t\t/* until we have a request, we don't have an lseg and no\n\t\t * idea how many mirrors there will be */\n\t\tnew = kcalloc(NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX,\n\t\t\t      sizeof(struct nfs_pgio_mirror), GFP_KERNEL);\n\t\tdesc->pg_mirrors_dynamic = new;\n\t\tdesc->pg_mirrors = new;\n\n\t\tfor (i = 0; i < NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX; i++)\n\t\t\tnfs_pageio_mirror_init(&desc->pg_mirrors[i], bsize);\n\t} else {\n\t\tdesc->pg_mirrors_dynamic = NULL;\n\t\tdesc->pg_mirrors = desc->pg_mirrors_static;\n\t\tnfs_pageio_mirror_init(&desc->pg_mirrors[0], bsize);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pageio_init(struct nfs_pageio_descriptor *desc,\n\t\t     struct inode *inode,\n\t\t     const struct nfs_pageio_ops *pg_ops,\n\t\t     const struct nfs_pgio_completion_ops *compl_ops,\n\t\t     const struct nfs_rw_ops *rw_ops,\n\t\t     size_t bsize,\n\t\t     int io_flags)\n{\n\tstruct nfs_pgio_mirror *new;\n\tint i;\n\n\tdesc->pg_moreio = 0;\n\tdesc->pg_inode = inode;\n\tdesc->pg_ops = pg_ops;\n\tdesc->pg_completion_ops = compl_ops;\n\tdesc->pg_rw_ops = rw_ops;\n\tdesc->pg_ioflags = io_flags;\n\tdesc->pg_error = 0;\n\tdesc->pg_lseg = NULL;\n\tdesc->pg_dreq = NULL;\n\tdesc->pg_layout_private = NULL;\n\tdesc->pg_bsize = bsize;\n\n\tdesc->pg_mirror_count = 1;\n\tdesc->pg_mirror_idx = 0;\n\n\tif (pg_ops->pg_get_mirror_count) {\n\t\t/* until we have a request, we don't have an lseg and no\n\t\t * idea how many mirrors there will be */\n\t\tnew = kcalloc(NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX,\n\t\t\t      sizeof(struct nfs_pgio_mirror), GFP_KERNEL);\n\t\tdesc->pg_mirrors_dynamic = new;\n\t\tdesc->pg_mirrors = new;\n\n\t\tfor (i = 0; i < NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX; i++)\n\t\t\tnfs_pageio_mirror_init(&desc->pg_mirrors[i], bsize);\n\t} else {\n\t\tdesc->pg_mirrors_dynamic = NULL;\n\t\tdesc->pg_mirrors = desc->pg_mirrors_static;\n\t\tnfs_pageio_mirror_init(&desc->pg_mirrors[0], bsize);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_rw_ops nfs_rw_write_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_rw_ops nfs_rw_write_ops = {\n\t.rw_mode\t\t= FMODE_WRITE,\n\t.rw_alloc_header\t= nfs_writehdr_alloc,\n\t.rw_free_header\t\t= nfs_writehdr_free,\n\t.rw_release\t\t= nfs_writeback_release_common,\n\t.rw_done\t\t= nfs_writeback_done,\n\t.rw_result\t\t= nfs_writeback_result,\n\t.rw_initiate\t\t= nfs_initiate_write,\n};\n\nvoid nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct inode *inode, int ioflags, bool force_mds,\n\t\t\t       const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_write_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_write_ops,\n\t\t\tserver->wsize, ioflags);\n}"
  },
  {
    "function_name": "nfs_async_write_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1297-1306",
    "snippet": "static void nfs_async_write_error(struct list_head *head)\n{\n\tstruct nfs_page\t*req;\n\n\twhile (!list_empty(head)) {\n\t\treq = nfs_list_entry(head->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_redirty_request(req);\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_redirty_request",
          "args": [
            "req"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_redirty_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1289-1295",
          "snippet": "static void nfs_redirty_request(struct nfs_page *req)\n{\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_request(req);\n\tnfs_end_page_writeback(req);\n\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void nfs_redirty_request(struct nfs_page *req)\n{\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_request(req);\n\tnfs_end_page_writeback(req);\n\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_list_remove_request",
          "args": [
            "req"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "head->next"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void nfs_async_write_error(struct list_head *head)\n{\n\tstruct nfs_page\t*req;\n\n\twhile (!list_empty(head)) {\n\t\treq = nfs_list_entry(head->next);\n\t\tnfs_list_remove_request(req);\n\t\tnfs_redirty_request(req);\n\t}\n}"
  },
  {
    "function_name": "nfs_redirty_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1289-1295",
    "snippet": "static void nfs_redirty_request(struct nfs_page *req)\n{\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_request(req);\n\tnfs_end_page_writeback(req);\n\tnfs_release_request(req);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "req"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_end_page_writeback",
          "args": [
            "req"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_unlock_request",
          "args": [
            "req"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unlock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "394-404",
          "snippet": "void nfs_unlock_request(struct nfs_page *req)\n{\n\tif (!NFS_WBACK_BUSY(req)) {\n\t\tprintk(KERN_ERR \"NFS: Invalid unlock attempted\\n\");\n\t\tBUG();\n\t}\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_BUSY, &req->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&req->wb_flags, PG_BUSY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_unlock_request(struct nfs_page *req)\n{\n\tif (!NFS_WBACK_BUSY(req)) {\n\t\tprintk(KERN_ERR \"NFS: Invalid unlock attempted\\n\");\n\t\tBUG();\n\t}\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_BUSY, &req->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&req->wb_flags, PG_BUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_request_dirty",
          "args": [
            "req"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_request_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "732-736",
          "snippet": "static void\nnfs_mark_request_dirty(struct nfs_page *req)\n{\n\t__set_page_dirty_nobuffers(req->wb_page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void\nnfs_mark_request_dirty(struct nfs_page *req)\n{\n\t__set_page_dirty_nobuffers(req->wb_page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void nfs_redirty_request(struct nfs_page *req)\n{\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_request(req);\n\tnfs_end_page_writeback(req);\n\tnfs_release_request(req);\n}"
  },
  {
    "function_name": "nfs_initiate_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1271-1283",
    "snippet": "static void nfs_initiate_write(struct nfs_pgio_header *hdr,\n\t\t\t       struct rpc_message *msg,\n\t\t\t       const struct nfs_rpc_ops *rpc_ops,\n\t\t\t       struct rpc_task_setup *task_setup_data, int how)\n{\n\tint priority = flush_task_priority(how);\n\n\ttask_setup_data->priority = priority;\n\trpc_ops->write_setup(hdr, msg);\n\n\tnfs4_state_protect_write(NFS_SERVER(hdr->inode)->nfs_client,\n\t\t\t\t &task_setup_data->rpc_client, msg, hdr);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_state_protect_write",
          "args": [
            "NFS_SERVER(hdr->inode)->nfs_client",
            "&task_setup_data->rpc_client",
            "msg",
            "hdr"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_protect_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4_fs.h",
          "lines": "366-370",
          "snippet": "static inline void\nnfs4_state_protect_write(struct nfs_client *clp, struct rpc_clnt **clntp,\n\t\t\t struct rpc_message *msg, struct nfs_pgio_header *hdr)\n{\n}",
          "includes": [
            "#include <linux/seqlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seqlock.h>\n\nstatic inline void\nnfs4_state_protect_write(struct nfs_client *clp, struct rpc_clnt **clntp,\n\t\t\t struct rpc_message *msg, struct nfs_pgio_header *hdr)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "hdr->inode"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ops->write_setup",
          "args": [
            "hdr",
            "msg"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_task_priority",
          "args": [
            "how"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "flush_task_priority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1260-1269",
          "snippet": "static int flush_task_priority(int how)\n{\n\tswitch (how & (FLUSH_HIGHPRI|FLUSH_LOWPRI)) {\n\t\tcase FLUSH_HIGHPRI:\n\t\t\treturn RPC_PRIORITY_HIGH;\n\t\tcase FLUSH_LOWPRI:\n\t\t\treturn RPC_PRIORITY_LOW;\n\t}\n\treturn RPC_PRIORITY_NORMAL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int flush_task_priority(int how)\n{\n\tswitch (how & (FLUSH_HIGHPRI|FLUSH_LOWPRI)) {\n\t\tcase FLUSH_HIGHPRI:\n\t\t\treturn RPC_PRIORITY_HIGH;\n\t\tcase FLUSH_LOWPRI:\n\t\t\treturn RPC_PRIORITY_LOW;\n\t}\n\treturn RPC_PRIORITY_NORMAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_initiate_write(struct nfs_pgio_header *hdr,\n\t\t\t       struct rpc_message *msg,\n\t\t\t       const struct nfs_rpc_ops *rpc_ops,\n\t\t\t       struct rpc_task_setup *task_setup_data, int how)\n{\n\tint priority = flush_task_priority(how);\n\n\ttask_setup_data->priority = priority;\n\trpc_ops->write_setup(hdr, msg);\n\n\tnfs4_state_protect_write(NFS_SERVER(hdr->inode)->nfs_client,\n\t\t\t\t &task_setup_data->rpc_client, msg, hdr);\n}"
  },
  {
    "function_name": "flush_task_priority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1260-1269",
    "snippet": "static int flush_task_priority(int how)\n{\n\tswitch (how & (FLUSH_HIGHPRI|FLUSH_LOWPRI)) {\n\t\tcase FLUSH_HIGHPRI:\n\t\t\treturn RPC_PRIORITY_HIGH;\n\t\tcase FLUSH_LOWPRI:\n\t\t\treturn RPC_PRIORITY_LOW;\n\t}\n\treturn RPC_PRIORITY_NORMAL;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int flush_task_priority(int how)\n{\n\tswitch (how & (FLUSH_HIGHPRI|FLUSH_LOWPRI)) {\n\t\tcase FLUSH_HIGHPRI:\n\t\t\treturn RPC_PRIORITY_HIGH;\n\t\tcase FLUSH_LOWPRI:\n\t\t\treturn RPC_PRIORITY_LOW;\n\t}\n\treturn RPC_PRIORITY_NORMAL;\n}"
  },
  {
    "function_name": "nfs_updatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1232-1258",
    "snippet": "int nfs_updatepage(struct file *file, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode\t*inode = page_file_mapping(page)->host;\n\tint\t\tstatus = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);\n\n\tdprintk(\"NFS:       nfs_updatepage(%pD2 %d@%lld)\\n\",\n\t\tfile, count, (long long)(page_file_offset(page) + offset));\n\n\tif (nfs_can_extend_write(file, page, inode)) {\n\t\tcount = max(count + offset, nfs_page_length(page));\n\t\toffset = 0;\n\t}\n\n\tstatus = nfs_writepage_setup(ctx, page, offset, count);\n\tif (status < 0)\n\t\tnfs_set_pageerror(page);\n\telse\n\t\t__set_page_dirty_nobuffers(page);\n\n\tdprintk(\"NFS:       nfs_updatepage returns %d (isize %lld)\\n\",\n\t\t\tstatus, (long long)i_size_read(inode));\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS:       nfs_updatepage returns %d (isize %lld)\\n\"",
            "status",
            "(long long)i_size_read(inode)"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_set_pageerror",
          "args": [
            "page"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_pageerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "164-167",
          "snippet": "static void nfs_set_pageerror(struct page *page)\n{\n\tnfs_zap_mapping(page_file_mapping(page)->host, page_file_mapping(page));\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_pageerror(struct page *page)\n{\n\tnfs_zap_mapping(page_file_mapping(page)->host, page_file_mapping(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_writepage_setup",
          "args": [
            "ctx",
            "page",
            "offset",
            "count"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_writepage_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1075-1089",
          "snippet": "static int nfs_writepage_setup(struct nfs_open_context *ctx, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_page\t*req;\n\n\treq = nfs_setup_write_request(ctx, page, offset, count);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\t/* Update file length */\n\tnfs_grow_file(page, offset, count);\n\tnfs_mark_uptodate(req);\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_and_release_request(req);\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_writepage_setup(struct nfs_open_context *ctx, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_page\t*req;\n\n\treq = nfs_setup_write_request(ctx, page, offset, count);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\t/* Update file length */\n\tnfs_grow_file(page, offset, count);\n\tnfs_mark_uptodate(req);\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_and_release_request(req);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "count + offset",
            "nfs_page_length(page)"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_super_set_maxbytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "593-599",
          "snippet": "static inline\nvoid nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)\n{\n\tsb->s_maxbytes = (loff_t)maxfilesize;\n\tif (sb->s_maxbytes > MAX_LFS_FILESIZE || sb->s_maxbytes <= 0)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
            "loff_t nfs_file_llseek(struct file *, loff_t, int);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\n\nstatic inline\nvoid nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)\n{\n\tsb->s_maxbytes = (loff_t)maxfilesize;\n\tif (sb->s_maxbytes > MAX_LFS_FILESIZE || sb->s_maxbytes <= 0)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_length",
          "args": [
            "page"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "617-631",
          "snippet": "static inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
            "loff_t nfs_file_llseek(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\n\nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_can_extend_write",
          "args": [
            "file",
            "page",
            "inode"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_can_extend_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1192-1224",
          "snippet": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tint ret;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (!nfs_write_pageuptodate(page, inode))\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (!flctx || (list_empty_careful(&flctx->flc_flock) &&\n\t\t       list_empty_careful(&flctx->flc_posix)))\n\t\treturn 0;\n\n\t/* Check to see if there are whole file write locks */\n\tret = 0;\n\tspin_lock(&flctx->flc_lock);\n\tif (!list_empty(&flctx->flc_posix)) {\n\t\tfl = list_first_entry(&flctx->flc_posix, struct file_lock,\n\t\t\t\t\tfl_list);\n\t\tif (is_whole_file_wrlock(fl))\n\t\t\tret = 1;\n\t} else if (!list_empty(&flctx->flc_flock)) {\n\t\tfl = list_first_entry(&flctx->flc_flock, struct file_lock,\n\t\t\t\t\tfl_list);\n\t\tif (fl->fl_type == F_WRLCK)\n\t\t\tret = 1;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tint ret;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (!nfs_write_pageuptodate(page, inode))\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (!flctx || (list_empty_careful(&flctx->flc_flock) &&\n\t\t       list_empty_careful(&flctx->flc_posix)))\n\t\treturn 0;\n\n\t/* Check to see if there are whole file write locks */\n\tret = 0;\n\tspin_lock(&flctx->flc_lock);\n\tif (!list_empty(&flctx->flc_posix)) {\n\t\tfl = list_first_entry(&flctx->flc_posix, struct file_lock,\n\t\t\t\t\tfl_list);\n\t\tif (is_whole_file_wrlock(fl))\n\t\t\tret = 1;\n\t} else if (!list_empty(&flctx->flc_flock)) {\n\t\tfl = list_first_entry(&flctx->flc_flock, struct file_lock,\n\t\t\t\t\tfl_list);\n\t\tif (fl->fl_type == F_WRLCK)\n\t\t\tret = 1;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS:       nfs_updatepage(%pD2 %d@%lld)\\n\"",
            "file",
            "count",
            "(long long)(page_file_offset(page) + offset)"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_offset",
          "args": [
            "page"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSUPDATEPAGE"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "file"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_updatepage(struct file *file, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode\t*inode = page_file_mapping(page)->host;\n\tint\t\tstatus = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);\n\n\tdprintk(\"NFS:       nfs_updatepage(%pD2 %d@%lld)\\n\",\n\t\tfile, count, (long long)(page_file_offset(page) + offset));\n\n\tif (nfs_can_extend_write(file, page, inode)) {\n\t\tcount = max(count + offset, nfs_page_length(page));\n\t\toffset = 0;\n\t}\n\n\tstatus = nfs_writepage_setup(ctx, page, offset, count);\n\tif (status < 0)\n\t\tnfs_set_pageerror(page);\n\telse\n\t\t__set_page_dirty_nobuffers(page);\n\n\tdprintk(\"NFS:       nfs_updatepage returns %d (isize %lld)\\n\",\n\t\t\tstatus, (long long)i_size_read(inode));\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_can_extend_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1192-1224",
    "snippet": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tint ret;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (!nfs_write_pageuptodate(page, inode))\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (!flctx || (list_empty_careful(&flctx->flc_flock) &&\n\t\t       list_empty_careful(&flctx->flc_posix)))\n\t\treturn 0;\n\n\t/* Check to see if there are whole file write locks */\n\tret = 0;\n\tspin_lock(&flctx->flc_lock);\n\tif (!list_empty(&flctx->flc_posix)) {\n\t\tfl = list_first_entry(&flctx->flc_posix, struct file_lock,\n\t\t\t\t\tfl_list);\n\t\tif (is_whole_file_wrlock(fl))\n\t\t\tret = 1;\n\t} else if (!list_empty(&flctx->flc_flock)) {\n\t\tfl = list_first_entry(&flctx->flc_flock, struct file_lock,\n\t\t\t\t\tfl_list);\n\t\tif (fl->fl_type == F_WRLCK)\n\t\t\tret = 1;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&flctx->flc_flock",
            "structfile_lock",
            "fl_list"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&flctx->flc_flock"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_whole_file_wrlock",
          "args": [
            "fl"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "is_whole_file_wrlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1177-1182",
          "snippet": "static bool\nis_whole_file_wrlock(struct file_lock *fl)\n{\n\treturn fl->fl_start == 0 && fl->fl_end == OFFSET_MAX &&\n\t\t\tfl->fl_type == F_WRLCK;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic bool\nis_whole_file_wrlock(struct file_lock *fl)\n{\n\treturn fl->fl_start == 0 && fl->fl_end == OFFSET_MAX &&\n\t\t\tfl->fl_type == F_WRLCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&flctx->flc_posix",
            "structfile_lock",
            "fl_list"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&flctx->flc_posix"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&flctx->flc_flock"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "FMODE_WRITE"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_write_pageuptodate",
          "args": [
            "page",
            "inode"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_write_pageuptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1160-1175",
          "snippet": "static bool nfs_write_pageuptodate(struct page *page, struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\treturn false;\n\tsmp_rmb();\n\tif (test_bit(NFS_INO_INVALIDATING, &nfsi->flags))\n\t\treturn false;\nout:\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn false;\n\treturn PageUptodate(page) != 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic bool nfs_write_pageuptodate(struct page *page, struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\treturn false;\n\tsmp_rmb();\n\tif (test_bit(NFS_INO_INVALIDATING, &nfsi->flags))\n\t\treturn false;\nout:\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn false;\n\treturn PageUptodate(page) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tint ret;\n\tstruct file_lock_context *flctx = inode->i_flctx;\n\tstruct file_lock *fl;\n\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (!nfs_write_pageuptodate(page, inode))\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (!flctx || (list_empty_careful(&flctx->flc_flock) &&\n\t\t       list_empty_careful(&flctx->flc_posix)))\n\t\treturn 0;\n\n\t/* Check to see if there are whole file write locks */\n\tret = 0;\n\tspin_lock(&flctx->flc_lock);\n\tif (!list_empty(&flctx->flc_posix)) {\n\t\tfl = list_first_entry(&flctx->flc_posix, struct file_lock,\n\t\t\t\t\tfl_list);\n\t\tif (is_whole_file_wrlock(fl))\n\t\t\tret = 1;\n\t} else if (!list_empty(&flctx->flc_flock)) {\n\t\tfl = list_first_entry(&flctx->flc_flock, struct file_lock,\n\t\t\t\t\tfl_list);\n\t\tif (fl->fl_type == F_WRLCK)\n\t\t\tret = 1;\n\t}\n\tspin_unlock(&flctx->flc_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "is_whole_file_wrlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1177-1182",
    "snippet": "static bool\nis_whole_file_wrlock(struct file_lock *fl)\n{\n\treturn fl->fl_start == 0 && fl->fl_end == OFFSET_MAX &&\n\t\t\tfl->fl_type == F_WRLCK;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic bool\nis_whole_file_wrlock(struct file_lock *fl)\n{\n\treturn fl->fl_start == 0 && fl->fl_end == OFFSET_MAX &&\n\t\t\tfl->fl_type == F_WRLCK;\n}"
  },
  {
    "function_name": "nfs_write_pageuptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1160-1175",
    "snippet": "static bool nfs_write_pageuptodate(struct page *page, struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\treturn false;\n\tsmp_rmb();\n\tif (test_bit(NFS_INO_INVALIDATING, &nfsi->flags))\n\t\treturn false;\nout:\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn false;\n\treturn PageUptodate(page) != 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_INO_INVALIDATING",
            "&nfsi->flags"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_have_delegated_attributes",
          "args": [
            "inode"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_have_delegated_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/delegation.h",
          "lines": "67-71",
          "snippet": "static inline int nfs_have_delegated_attributes(struct inode *inode)\n{\n\treturn NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&\n\t\t!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int nfs_have_delegated_attributes(struct inode *inode)\n{\n\treturn NFS_PROTO(inode)->have_delegation(inode, FMODE_READ) &&\n\t\t!(NFS_I(inode)->cache_validity & NFS_INO_REVAL_FORCED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic bool nfs_write_pageuptodate(struct page *page, struct inode *inode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tif (nfs_have_delegated_attributes(inode))\n\t\tgoto out;\n\tif (nfsi->cache_validity & NFS_INO_REVAL_PAGECACHE)\n\t\treturn false;\n\tsmp_rmb();\n\tif (test_bit(NFS_INO_INVALIDATING, &nfsi->flags))\n\t\treturn false;\nout:\n\tif (nfsi->cache_validity & NFS_INO_INVALID_DATA)\n\t\treturn false;\n\treturn PageUptodate(page) != 0;\n}"
  },
  {
    "function_name": "nfs_ctx_key_to_expire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1150-1153",
    "snippet": "bool nfs_ctx_key_to_expire(struct nfs_open_context *ctx)\n{\n\treturn rpcauth_cred_key_to_expire(ctx->cred);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpcauth_cred_key_to_expire",
          "args": [
            "ctx->cred"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool nfs_ctx_key_to_expire(struct nfs_open_context *ctx)\n{\n\treturn rpcauth_cred_key_to_expire(ctx->cred);\n}"
  },
  {
    "function_name": "nfs_key_timeout_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1138-1145",
    "snippet": "int\nnfs_key_timeout_notify(struct file *filp, struct inode *inode)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\tstruct rpc_auth *auth = NFS_SERVER(inode)->client->cl_auth;\n\n\treturn rpcauth_key_timeout_notify(auth, ctx->cred);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpcauth_key_timeout_notify",
          "args": [
            "auth",
            "ctx->cred"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "filp"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint\nnfs_key_timeout_notify(struct file *filp, struct inode *inode)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(filp);\n\tstruct rpc_auth *auth = NFS_SERVER(inode)->client->cl_auth;\n\n\treturn rpcauth_key_timeout_notify(auth, ctx->cred);\n}"
  },
  {
    "function_name": "nfs_flush_incompatible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1091-1126",
    "snippet": "int nfs_flush_incompatible(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct nfs_lock_context *l_ctx;\n\tstruct file_lock_context *flctx = file_inode(file)->i_flctx;\n\tstruct nfs_page\t*req;\n\tint do_flush, status;\n\t/*\n\t * Look for a request corresponding to this page. If there\n\t * is one, and it belongs to another file, we flush it out\n\t * before we try to copy anything into the page. Do this\n\t * due to the lack of an ACCESS-type call in NFSv2.\n\t * Also do the same if we find a request from an existing\n\t * dropped page.\n\t */\n\tdo {\n\t\treq = nfs_page_find_head_request(page);\n\t\tif (req == NULL)\n\t\t\treturn 0;\n\t\tl_ctx = req->wb_lock_context;\n\t\tdo_flush = req->wb_page != page || req->wb_context != ctx;\n\t\t/* for now, flush if more than 1 request in page_group */\n\t\tdo_flush |= req->wb_this_page != req;\n\t\tif (l_ctx && flctx &&\n\t\t    !(list_empty_careful(&flctx->flc_posix) &&\n\t\t      list_empty_careful(&flctx->flc_flock))) {\n\t\t\tdo_flush |= l_ctx->lockowner.l_owner != current->files\n\t\t\t\t|| l_ctx->lockowner.l_pid != current->tgid;\n\t\t}\n\t\tnfs_release_request(req);\n\t\tif (!do_flush)\n\t\t\treturn 0;\n\t\tstatus = nfs_wb_page(page_file_mapping(page)->host, page);\n\t} while (status == 0);\n\treturn status;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_wb_page",
          "args": [
            "page_file_mapping(page)->host",
            "page"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wb_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1893-1925",
          "snippet": "int nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "req"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&flctx->flc_flock"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&flctx->flc_posix"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_find_head_request",
          "args": [
            "page"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_find_head_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "131-140",
          "snippet": "static struct nfs_page *nfs_page_find_head_request(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *req = NULL;\n\n\tspin_lock(&inode->i_lock);\n\treq = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\tspin_unlock(&inode->i_lock);\n\treturn req;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *nfs_page_find_head_request(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *req = NULL;\n\n\tspin_lock(&inode->i_lock);\n\treq = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\tspin_unlock(&inode->i_lock);\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_file_open_context",
          "args": [
            "file"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_flush_incompatible(struct file *file, struct page *page)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct nfs_lock_context *l_ctx;\n\tstruct file_lock_context *flctx = file_inode(file)->i_flctx;\n\tstruct nfs_page\t*req;\n\tint do_flush, status;\n\t/*\n\t * Look for a request corresponding to this page. If there\n\t * is one, and it belongs to another file, we flush it out\n\t * before we try to copy anything into the page. Do this\n\t * due to the lack of an ACCESS-type call in NFSv2.\n\t * Also do the same if we find a request from an existing\n\t * dropped page.\n\t */\n\tdo {\n\t\treq = nfs_page_find_head_request(page);\n\t\tif (req == NULL)\n\t\t\treturn 0;\n\t\tl_ctx = req->wb_lock_context;\n\t\tdo_flush = req->wb_page != page || req->wb_context != ctx;\n\t\t/* for now, flush if more than 1 request in page_group */\n\t\tdo_flush |= req->wb_this_page != req;\n\t\tif (l_ctx && flctx &&\n\t\t    !(list_empty_careful(&flctx->flc_posix) &&\n\t\t      list_empty_careful(&flctx->flc_flock))) {\n\t\t\tdo_flush |= l_ctx->lockowner.l_owner != current->files\n\t\t\t\t|| l_ctx->lockowner.l_pid != current->tgid;\n\t\t}\n\t\tnfs_release_request(req);\n\t\tif (!do_flush)\n\t\t\treturn 0;\n\t\tstatus = nfs_wb_page(page_file_mapping(page)->host, page);\n\t} while (status == 0);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs_writepage_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1075-1089",
    "snippet": "static int nfs_writepage_setup(struct nfs_open_context *ctx, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_page\t*req;\n\n\treq = nfs_setup_write_request(ctx, page, offset, count);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\t/* Update file length */\n\tnfs_grow_file(page, offset, count);\n\tnfs_mark_uptodate(req);\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_and_release_request(req);\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_unlock_and_release_request",
          "args": [
            "req"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unlock_and_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "410-414",
          "snippet": "void nfs_unlock_and_release_request(struct nfs_page *req)\n{\n\tnfs_unlock_request(req);\n\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_unlock_and_release_request(struct nfs_page *req)\n{\n\tnfs_unlock_request(req);\n\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_request_dirty",
          "args": [
            "req"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_request_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "732-736",
          "snippet": "static void\nnfs_mark_request_dirty(struct nfs_page *req)\n{\n\t__set_page_dirty_nobuffers(req->wb_page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void\nnfs_mark_request_dirty(struct nfs_page *req)\n{\n\t__set_page_dirty_nobuffers(req->wb_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_uptodate",
          "args": [
            "req"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "234-241",
          "snippet": "static void nfs_mark_uptodate(struct nfs_page *req)\n{\n\tif (PageUptodate(req->wb_page))\n\t\treturn;\n\tif (!nfs_page_group_covers_page(req))\n\t\treturn;\n\tSetPageUptodate(req->wb_page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void nfs_mark_uptodate(struct nfs_page *req)\n{\n\tif (PageUptodate(req->wb_page))\n\t\treturn;\n\tif (!nfs_page_group_covers_page(req))\n\t\treturn;\n\tSetPageUptodate(req->wb_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_grow_file",
          "args": [
            "page",
            "offset",
            "count"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_grow_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "143-161",
          "snippet": "static void nfs_grow_file(struct page *page, unsigned int offset, unsigned int count)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tloff_t end, i_size;\n\tpgoff_t end_index;\n\n\tspin_lock(&inode->i_lock);\n\ti_size = i_size_read(inode);\n\tend_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\tif (i_size > 0 && page_file_index(page) < end_index)\n\t\tgoto out;\n\tend = page_file_offset(page) + ((loff_t)offset+count);\n\tif (i_size >= end)\n\t\tgoto out;\n\ti_size_write(inode, end);\n\tnfs_inc_stats(inode, NFSIOS_EXTENDWRITE);\nout:\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_grow_file(struct page *page, unsigned int offset, unsigned int count)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tloff_t end, i_size;\n\tpgoff_t end_index;\n\n\tspin_lock(&inode->i_lock);\n\ti_size = i_size_read(inode);\n\tend_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\tif (i_size > 0 && page_file_index(page) < end_index)\n\t\tgoto out;\n\tend = page_file_offset(page) + ((loff_t)offset+count);\n\tif (i_size >= end)\n\t\tgoto out;\n\ti_size_write(inode, end);\n\tnfs_inc_stats(inode, NFSIOS_EXTENDWRITE);\nout:\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_setup_write_request",
          "args": [
            "ctx",
            "page",
            "offset",
            "count"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_setup_write_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1058-1073",
          "snippet": "static struct nfs_page * nfs_setup_write_request(struct nfs_open_context* ctx,\n\t\tstruct page *page, unsigned int offset, unsigned int bytes)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page\t*req;\n\n\treq = nfs_try_to_update_request(inode, page, offset, bytes);\n\tif (req != NULL)\n\t\tgoto out;\n\treq = nfs_create_request(ctx, page, NULL, offset, bytes);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tnfs_inode_add_request(inode, req);\nout:\n\treturn req;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page * nfs_setup_write_request(struct nfs_open_context* ctx,\n\t\tstruct page *page, unsigned int offset, unsigned int bytes)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page\t*req;\n\n\treq = nfs_try_to_update_request(inode, page, offset, bytes);\n\tif (req != NULL)\n\t\tgoto out;\n\treq = nfs_create_request(ctx, page, NULL, offset, bytes);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tnfs_inode_add_request(inode, req);\nout:\n\treturn req;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_writepage_setup(struct nfs_open_context *ctx, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_page\t*req;\n\n\treq = nfs_setup_write_request(ctx, page, offset, count);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\t/* Update file length */\n\tnfs_grow_file(page, offset, count);\n\tnfs_mark_uptodate(req);\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_and_release_request(req);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_setup_write_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "1058-1073",
    "snippet": "static struct nfs_page * nfs_setup_write_request(struct nfs_open_context* ctx,\n\t\tstruct page *page, unsigned int offset, unsigned int bytes)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page\t*req;\n\n\treq = nfs_try_to_update_request(inode, page, offset, bytes);\n\tif (req != NULL)\n\t\tgoto out;\n\treq = nfs_create_request(ctx, page, NULL, offset, bytes);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tnfs_inode_add_request(inode, req);\nout:\n\treturn req;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_inode_add_request",
          "args": [
            "inode",
            "req"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inode_add_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "668-698",
          "snippet": "static void nfs_inode_add_request(struct inode *inode, struct nfs_page *req)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t/* Lock the request! */\n\tnfs_lock_request(req);\n\n\tspin_lock(&inode->i_lock);\n\tif (!nfsi->nrequests &&\n\t    NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\tinode->i_version++;\n\t/*\n\t * Swap-space should not get truncated. Hence no need to plug the race\n\t * with invalidate/truncate.\n\t */\n\tif (likely(!PageSwapCache(req->wb_page))) {\n\t\tset_bit(PG_MAPPED, &req->wb_flags);\n\t\tSetPagePrivate(req->wb_page);\n\t\tset_page_private(req->wb_page, (unsigned long)req);\n\t}\n\tnfsi->nrequests++;\n\t/* this a head request for a page group - mark it as having an\n\t * extra reference so sub groups can follow suit.\n\t * This flag also informs pgio layer when to bump nrequests when\n\t * adding subrequests. */\n\tWARN_ON(test_and_set_bit(PG_INODE_REF, &req->wb_flags));\n\tkref_get(&req->wb_kref);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_inode_add_request(struct inode *inode, struct nfs_page *req)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t/* Lock the request! */\n\tnfs_lock_request(req);\n\n\tspin_lock(&inode->i_lock);\n\tif (!nfsi->nrequests &&\n\t    NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\tinode->i_version++;\n\t/*\n\t * Swap-space should not get truncated. Hence no need to plug the race\n\t * with invalidate/truncate.\n\t */\n\tif (likely(!PageSwapCache(req->wb_page))) {\n\t\tset_bit(PG_MAPPED, &req->wb_flags);\n\t\tSetPagePrivate(req->wb_page);\n\t\tset_page_private(req->wb_page, (unsigned long)req);\n\t}\n\tnfsi->nrequests++;\n\t/* this a head request for a page group - mark it as having an\n\t * extra reference so sub groups can follow suit.\n\t * This flag also informs pgio layer when to bump nrequests when\n\t * adding subrequests. */\n\tWARN_ON(test_and_set_bit(PG_INODE_REF, &req->wb_flags));\n\tkref_get(&req->wb_kref);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_create_request",
          "args": [
            "ctx",
            "page",
            "NULL",
            "offset",
            "bytes"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "351-388",
          "snippet": "struct nfs_page *\nnfs_create_request(struct nfs_open_context *ctx, struct page *page,\n\t\t   struct nfs_page *last, unsigned int offset,\n\t\t   unsigned int count)\n{\n\tstruct nfs_page\t\t*req;\n\tstruct nfs_lock_context *l_ctx;\n\n\tif (test_bit(NFS_CONTEXT_BAD, &ctx->flags))\n\t\treturn ERR_PTR(-EBADF);\n\t/* try to allocate the request struct */\n\treq = nfs_page_alloc();\n\tif (req == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* get lock context early so we can deal with alloc failures */\n\tl_ctx = nfs_get_lock_context(ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tnfs_page_free(req);\n\t\treturn ERR_CAST(l_ctx);\n\t}\n\treq->wb_lock_context = l_ctx;\n\tnfs_iocounter_inc(&l_ctx->io_count);\n\n\t/* Initialize the request struct. Initially, we assume a\n\t * long write-back delay. This will be adjusted in\n\t * update_nfs_request below if the region is not locked. */\n\treq->wb_page    = page;\n\treq->wb_index\t= page_file_index(page);\n\tpage_cache_get(page);\n\treq->wb_offset  = offset;\n\treq->wb_pgbase\t= offset;\n\treq->wb_bytes   = count;\n\treq->wb_context = get_nfs_open_context(ctx);\n\tkref_init(&req->wb_kref);\n\tnfs_page_group_init(req, last);\n\treturn req;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_page *\nnfs_create_request(struct nfs_open_context *ctx, struct page *page,\n\t\t   struct nfs_page *last, unsigned int offset,\n\t\t   unsigned int count)\n{\n\tstruct nfs_page\t\t*req;\n\tstruct nfs_lock_context *l_ctx;\n\n\tif (test_bit(NFS_CONTEXT_BAD, &ctx->flags))\n\t\treturn ERR_PTR(-EBADF);\n\t/* try to allocate the request struct */\n\treq = nfs_page_alloc();\n\tif (req == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* get lock context early so we can deal with alloc failures */\n\tl_ctx = nfs_get_lock_context(ctx);\n\tif (IS_ERR(l_ctx)) {\n\t\tnfs_page_free(req);\n\t\treturn ERR_CAST(l_ctx);\n\t}\n\treq->wb_lock_context = l_ctx;\n\tnfs_iocounter_inc(&l_ctx->io_count);\n\n\t/* Initialize the request struct. Initially, we assume a\n\t * long write-back delay. This will be adjusted in\n\t * update_nfs_request below if the region is not locked. */\n\treq->wb_page    = page;\n\treq->wb_index\t= page_file_index(page);\n\tpage_cache_get(page);\n\treq->wb_offset  = offset;\n\treq->wb_pgbase\t= offset;\n\treq->wb_bytes   = count;\n\treq->wb_context = get_nfs_open_context(ctx);\n\tkref_init(&req->wb_kref);\n\tnfs_page_group_init(req, last);\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_try_to_update_request",
          "args": [
            "inode",
            "page",
            "offset",
            "bytes"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_try_to_update_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "981-1049",
          "snippet": "static struct nfs_page *nfs_try_to_update_request(struct inode *inode,\n\t\tstruct page *page,\n\t\tunsigned int offset,\n\t\tunsigned int bytes)\n{\n\tstruct nfs_page *req;\n\tunsigned int rqend;\n\tunsigned int end;\n\tint error;\n\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\n\tend = offset + bytes;\n\tspin_lock(&inode->i_lock);\n\n\tfor (;;) {\n\t\treq = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\t\tif (req == NULL)\n\t\t\tgoto out_unlock;\n\n\t\t/* should be handled by nfs_flush_incompatible */\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t\trqend = req->wb_offset + req->wb_bytes;\n\t\t/*\n\t\t * Tell the caller to flush out the request if\n\t\t * the offsets are non-contiguous.\n\t\t * Note: nfs_flush_incompatible() will already\n\t\t * have flushed out requests having wrong owners.\n\t\t */\n\t\tif (offset > rqend\n\t\t    || end < req->wb_offset)\n\t\t\tgoto out_flushme;\n\n\t\tif (nfs_lock_request(req))\n\t\t\tbreak;\n\n\t\t/* The request is locked, so wait and then retry */\n\t\tspin_unlock(&inode->i_lock);\n\t\terror = nfs_wait_on_request(req);\n\t\tnfs_release_request(req);\n\t\tif (error != 0)\n\t\t\tgoto out_err;\n\t\tspin_lock(&inode->i_lock);\n\t}\n\n\t/* Okay, the request matches. Update the region */\n\tif (offset < req->wb_offset) {\n\t\treq->wb_offset = offset;\n\t\treq->wb_pgbase = offset;\n\t}\n\tif (end > rqend)\n\t\treq->wb_bytes = end - req->wb_offset;\n\telse\n\t\treq->wb_bytes = rqend - req->wb_offset;\nout_unlock:\n\tif (req)\n\t\tnfs_clear_request_commit(req);\n\tspin_unlock(&inode->i_lock);\n\treturn req;\nout_flushme:\n\tspin_unlock(&inode->i_lock);\n\tnfs_release_request(req);\n\terror = nfs_wb_page(inode, page);\nout_err:\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *nfs_try_to_update_request(struct inode *inode,\n\t\tstruct page *page,\n\t\tunsigned int offset,\n\t\tunsigned int bytes)\n{\n\tstruct nfs_page *req;\n\tunsigned int rqend;\n\tunsigned int end;\n\tint error;\n\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\n\tend = offset + bytes;\n\tspin_lock(&inode->i_lock);\n\n\tfor (;;) {\n\t\treq = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\t\tif (req == NULL)\n\t\t\tgoto out_unlock;\n\n\t\t/* should be handled by nfs_flush_incompatible */\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t\trqend = req->wb_offset + req->wb_bytes;\n\t\t/*\n\t\t * Tell the caller to flush out the request if\n\t\t * the offsets are non-contiguous.\n\t\t * Note: nfs_flush_incompatible() will already\n\t\t * have flushed out requests having wrong owners.\n\t\t */\n\t\tif (offset > rqend\n\t\t    || end < req->wb_offset)\n\t\t\tgoto out_flushme;\n\n\t\tif (nfs_lock_request(req))\n\t\t\tbreak;\n\n\t\t/* The request is locked, so wait and then retry */\n\t\tspin_unlock(&inode->i_lock);\n\t\terror = nfs_wait_on_request(req);\n\t\tnfs_release_request(req);\n\t\tif (error != 0)\n\t\t\tgoto out_err;\n\t\tspin_lock(&inode->i_lock);\n\t}\n\n\t/* Okay, the request matches. Update the region */\n\tif (offset < req->wb_offset) {\n\t\treq->wb_offset = offset;\n\t\treq->wb_pgbase = offset;\n\t}\n\tif (end > rqend)\n\t\treq->wb_bytes = end - req->wb_offset;\n\telse\n\t\treq->wb_bytes = rqend - req->wb_offset;\nout_unlock:\n\tif (req)\n\t\tnfs_clear_request_commit(req);\n\tspin_unlock(&inode->i_lock);\n\treturn req;\nout_flushme:\n\tspin_unlock(&inode->i_lock);\n\tnfs_release_request(req);\n\terror = nfs_wb_page(inode, page);\nout_err:\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page * nfs_setup_write_request(struct nfs_open_context* ctx,\n\t\tstruct page *page, unsigned int offset, unsigned int bytes)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page\t*req;\n\n\treq = nfs_try_to_update_request(inode, page, offset, bytes);\n\tif (req != NULL)\n\t\tgoto out;\n\treq = nfs_create_request(ctx, page, NULL, offset, bytes);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tnfs_inode_add_request(inode, req);\nout:\n\treturn req;\n}"
  },
  {
    "function_name": "nfs_try_to_update_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "981-1049",
    "snippet": "static struct nfs_page *nfs_try_to_update_request(struct inode *inode,\n\t\tstruct page *page,\n\t\tunsigned int offset,\n\t\tunsigned int bytes)\n{\n\tstruct nfs_page *req;\n\tunsigned int rqend;\n\tunsigned int end;\n\tint error;\n\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\n\tend = offset + bytes;\n\tspin_lock(&inode->i_lock);\n\n\tfor (;;) {\n\t\treq = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\t\tif (req == NULL)\n\t\t\tgoto out_unlock;\n\n\t\t/* should be handled by nfs_flush_incompatible */\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t\trqend = req->wb_offset + req->wb_bytes;\n\t\t/*\n\t\t * Tell the caller to flush out the request if\n\t\t * the offsets are non-contiguous.\n\t\t * Note: nfs_flush_incompatible() will already\n\t\t * have flushed out requests having wrong owners.\n\t\t */\n\t\tif (offset > rqend\n\t\t    || end < req->wb_offset)\n\t\t\tgoto out_flushme;\n\n\t\tif (nfs_lock_request(req))\n\t\t\tbreak;\n\n\t\t/* The request is locked, so wait and then retry */\n\t\tspin_unlock(&inode->i_lock);\n\t\terror = nfs_wait_on_request(req);\n\t\tnfs_release_request(req);\n\t\tif (error != 0)\n\t\t\tgoto out_err;\n\t\tspin_lock(&inode->i_lock);\n\t}\n\n\t/* Okay, the request matches. Update the region */\n\tif (offset < req->wb_offset) {\n\t\treq->wb_offset = offset;\n\t\treq->wb_pgbase = offset;\n\t}\n\tif (end > rqend)\n\t\treq->wb_bytes = end - req->wb_offset;\n\telse\n\t\treq->wb_bytes = rqend - req->wb_offset;\nout_unlock:\n\tif (req)\n\t\tnfs_clear_request_commit(req);\n\tspin_unlock(&inode->i_lock);\n\treturn req;\nout_flushme:\n\tspin_unlock(&inode->i_lock);\n\tnfs_release_request(req);\n\terror = nfs_wb_page(inode, page);\nout_err:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_wb_page",
          "args": [
            "inode",
            "page"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wb_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1893-1925",
          "snippet": "int nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_wb_page(struct inode *inode, struct page *page)\n{\n\tloff_t range_start = page_file_offset(page);\n\tloff_t range_end = range_start + (loff_t)(PAGE_CACHE_SIZE - 1);\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = WB_SYNC_ALL,\n\t\t.nr_to_write = 0,\n\t\t.range_start = range_start,\n\t\t.range_end = range_end,\n\t};\n\tint ret;\n\n\ttrace_nfs_writeback_page_enter(inode);\n\n\tfor (;;) {\n\t\twait_on_page_writeback(page);\n\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\tret = nfs_writepage_locked(page, &wbc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out_error;\n\t\t\tcontinue;\n\t\t}\n\t\tret = 0;\n\t\tif (!PagePrivate(page))\n\t\t\tbreak;\n\t\tret = nfs_commit_inode(inode, FLUSH_SYNC);\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\t}\nout_error:\n\ttrace_nfs_writeback_page_exit(inode, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "req"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_clear_request_commit",
          "args": [
            "req"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_clear_request_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "860-873",
          "snippet": "static void\nnfs_clear_request_commit(struct nfs_page *req)\n{\n\tif (test_bit(PG_CLEAN, &req->wb_flags)) {\n\t\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\t\tstruct nfs_commit_info cinfo;\n\n\t\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\t\tif (!pnfs_clear_request_commit(req, &cinfo)) {\n\t\t\tnfs_request_remove_commit_list(req, &cinfo);\n\t\t}\n\t\tnfs_clear_page_commit(req->wb_page);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void\nnfs_clear_request_commit(struct nfs_page *req)\n{\n\tif (test_bit(PG_CLEAN, &req->wb_flags)) {\n\t\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\t\tstruct nfs_commit_info cinfo;\n\n\t\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\t\tif (!pnfs_clear_request_commit(req, &cinfo)) {\n\t\t\tnfs_request_remove_commit_list(req, &cinfo);\n\t\t}\n\t\tnfs_clear_page_commit(req->wb_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_wait_on_request",
          "args": [
            "req"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wait_on_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "478-483",
          "snippet": "int\nnfs_wait_on_request(struct nfs_page *req)\n{\n\treturn wait_on_bit_io(&req->wb_flags, PG_BUSY,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint\nnfs_wait_on_request(struct nfs_page *req)\n{\n\treturn wait_on_bit_io(&req->wb_flags, PG_BUSY,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_lock_request",
          "args": [
            "req"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "req->wb_this_page != req"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "req->wb_head != req"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_find_head_request_locked",
          "args": [
            "NFS_I(inode)",
            "page"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_find_head_request_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "107-124",
          "snippet": "static struct nfs_page *\nnfs_page_find_head_request_locked(struct nfs_inode *nfsi, struct page *page)\n{\n\tstruct nfs_page *req = NULL;\n\n\tif (PagePrivate(page))\n\t\treq = (struct nfs_page *)page_private(page);\n\telse if (unlikely(PageSwapCache(page)))\n\t\treq = nfs_page_search_commits_for_head_request_locked(nfsi,\n\t\t\tpage);\n\n\tif (req) {\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tkref_get(&req->wb_kref);\n\t}\n\n\treturn req;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_page_find_head_request_locked(struct nfs_inode *nfsi, struct page *page)\n{\n\tstruct nfs_page *req = NULL;\n\n\tif (PagePrivate(page))\n\t\treq = (struct nfs_page *)page_private(page);\n\telse if (unlikely(PageSwapCache(page)))\n\t\treq = nfs_page_search_commits_for_head_request_locked(nfsi,\n\t\t\tpage);\n\n\tif (req) {\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tkref_get(&req->wb_kref);\n\t}\n\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *nfs_try_to_update_request(struct inode *inode,\n\t\tstruct page *page,\n\t\tunsigned int offset,\n\t\tunsigned int bytes)\n{\n\tstruct nfs_page *req;\n\tunsigned int rqend;\n\tunsigned int end;\n\tint error;\n\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\n\tend = offset + bytes;\n\tspin_lock(&inode->i_lock);\n\n\tfor (;;) {\n\t\treq = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\t\tif (req == NULL)\n\t\t\tgoto out_unlock;\n\n\t\t/* should be handled by nfs_flush_incompatible */\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t\trqend = req->wb_offset + req->wb_bytes;\n\t\t/*\n\t\t * Tell the caller to flush out the request if\n\t\t * the offsets are non-contiguous.\n\t\t * Note: nfs_flush_incompatible() will already\n\t\t * have flushed out requests having wrong owners.\n\t\t */\n\t\tif (offset > rqend\n\t\t    || end < req->wb_offset)\n\t\t\tgoto out_flushme;\n\n\t\tif (nfs_lock_request(req))\n\t\t\tbreak;\n\n\t\t/* The request is locked, so wait and then retry */\n\t\tspin_unlock(&inode->i_lock);\n\t\terror = nfs_wait_on_request(req);\n\t\tnfs_release_request(req);\n\t\tif (error != 0)\n\t\t\tgoto out_err;\n\t\tspin_lock(&inode->i_lock);\n\t}\n\n\t/* Okay, the request matches. Update the region */\n\tif (offset < req->wb_offset) {\n\t\treq->wb_offset = offset;\n\t\treq->wb_pgbase = offset;\n\t}\n\tif (end > rqend)\n\t\treq->wb_bytes = end - req->wb_offset;\n\telse\n\t\treq->wb_bytes = rqend - req->wb_offset;\nout_unlock:\n\tif (req)\n\t\tnfs_clear_request_commit(req);\n\tspin_unlock(&inode->i_lock);\n\treturn req;\nout_flushme:\n\tspin_unlock(&inode->i_lock);\n\tnfs_release_request(req);\n\terror = nfs_wb_page(inode, page);\nout_err:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "nfs_scan_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "956-972",
    "snippet": "int\nnfs_scan_commit(struct inode *inode, struct list_head *dst,\n\t\tstruct nfs_commit_info *cinfo)\n{\n\tint ret = 0;\n\n\tspin_lock(cinfo->lock);\n\tif (cinfo->mds->ncommit > 0) {\n\t\tconst int max = INT_MAX;\n\n\t\tret = nfs_scan_commit_list(&cinfo->mds->list, dst,\n\t\t\t\t\t   cinfo, max);\n\t\tret += pnfs_scan_commit_lists(inode, cinfo, max - ret);\n\t}\n\tspin_unlock(cinfo->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "cinfo->lock"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_scan_commit_lists",
          "args": [
            "inode",
            "cinfo",
            "max - ret"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_scan_commit_lists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "628-633",
          "snippet": "static inline int\npnfs_scan_commit_lists(struct inode *inode, struct nfs_commit_info *cinfo,\n\t\t       int max)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline int\npnfs_scan_commit_lists(struct inode *inode, struct nfs_commit_info *cinfo,\n\t\t       int max)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_scan_commit_list",
          "args": [
            "&cinfo->mds->list",
            "dst",
            "cinfo",
            "max"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_scan_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "925-945",
          "snippet": "int\nnfs_scan_commit_list(struct list_head *src, struct list_head *dst,\n\t\t     struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nint\nnfs_scan_commit_list(struct list_head *src, struct list_head *dst,\n\t\t     struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nint\nnfs_scan_commit(struct inode *inode, struct list_head *dst,\n\t\tstruct nfs_commit_info *cinfo)\n{\n\tint ret = 0;\n\n\tspin_lock(cinfo->lock);\n\tif (cinfo->mds->ncommit > 0) {\n\t\tconst int max = INT_MAX;\n\n\t\tret = nfs_scan_commit_list(&cinfo->mds->list, dst,\n\t\t\t\t\t   cinfo, max);\n\t\tret += pnfs_scan_commit_lists(inode, cinfo, max - ret);\n\t}\n\tspin_unlock(cinfo->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_scan_commit_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "925-945",
    "snippet": "int\nnfs_scan_commit_list(struct list_head *src, struct list_head *dst,\n\t\t     struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_list_add_request",
          "args": [
            "req",
            "dst"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_request_remove_commit_list",
          "args": [
            "req",
            "cinfo"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_request_remove_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "808-816",
          "snippet": "void\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_safe_reset_next",
          "args": [
            "req",
            "tmp",
            "wb_list"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&req->wb_kref"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_lock_request",
          "args": [
            "req"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "req",
            "tmp",
            "src",
            "wb_list"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nint\nnfs_scan_commit_list(struct list_head *src, struct list_head *dst,\n\t\t     struct nfs_commit_info *cinfo, int max)\n{\n\tstruct nfs_page *req, *tmp;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(req, tmp, src, wb_list) {\n\t\tif (!nfs_lock_request(req))\n\t\t\tcontinue;\n\t\tkref_get(&req->wb_kref);\n\t\tif (cond_resched_lock(cinfo->lock))\n\t\t\tlist_safe_reset_next(req, tmp, wb_list);\n\t\tnfs_request_remove_commit_list(req, cinfo);\n\t\tnfs_list_add_request(req, dst);\n\t\tret++;\n\t\tif ((ret == max) && !cinfo->dreq)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_reqs_to_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "918-922",
    "snippet": "unsigned long\nnfs_reqs_to_commit(struct nfs_commit_info *cinfo)\n{\n\treturn cinfo->mds->ncommit;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nunsigned long\nnfs_reqs_to_commit(struct nfs_commit_info *cinfo)\n{\n\treturn cinfo->mds->ncommit;\n}"
  },
  {
    "function_name": "nfs_write_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "882-916",
    "snippet": "static void nfs_write_completion(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_commit_info cinfo;\n\tunsigned long bytes = 0;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\tgoto out;\n\tnfs_init_cinfo_from_inode(&cinfo, hdr->inode);\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\n\t\tbytes += req->wb_bytes;\n\t\tnfs_list_remove_request(req);\n\t\tif (test_bit(NFS_IOHDR_ERROR, &hdr->flags) &&\n\t\t    (hdr->good_bytes < bytes)) {\n\t\t\tnfs_set_pageerror(req->wb_page);\n\t\t\tnfs_context_set_write_error(req->wb_context, hdr->error);\n\t\t\tgoto remove_req;\n\t\t}\n\t\tif (nfs_write_need_commit(hdr)) {\n\t\t\tmemcpy(&req->wb_verf, &hdr->verf.verifier, sizeof(req->wb_verf));\n\t\t\tnfs_mark_request_commit(req, hdr->lseg, &cinfo,\n\t\t\t\thdr->pgio_mirror_idx);\n\t\t\tgoto next;\n\t\t}\nremove_req:\n\t\tnfs_inode_remove_request(req);\nnext:\n\t\tnfs_unlock_request(req);\n\t\tnfs_end_page_writeback(req);\n\t\tnfs_release_request(req);\n\t}\nout:\n\thdr->release(hdr);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr->release",
          "args": [
            "hdr"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "req"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_end_page_writeback",
          "args": [
            "req"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_unlock_request",
          "args": [
            "req"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unlock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "394-404",
          "snippet": "void nfs_unlock_request(struct nfs_page *req)\n{\n\tif (!NFS_WBACK_BUSY(req)) {\n\t\tprintk(KERN_ERR \"NFS: Invalid unlock attempted\\n\");\n\t\tBUG();\n\t}\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_BUSY, &req->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&req->wb_flags, PG_BUSY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_unlock_request(struct nfs_page *req)\n{\n\tif (!NFS_WBACK_BUSY(req)) {\n\t\tprintk(KERN_ERR \"NFS: Invalid unlock attempted\\n\");\n\t\tBUG();\n\t}\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_BUSY, &req->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&req->wb_flags, PG_BUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inode_remove_request",
          "args": [
            "req"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inode_remove_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "703-730",
          "snippet": "static void nfs_inode_remove_request(struct nfs_page *req)\n{\n\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_page *head;\n\n\tif (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {\n\t\thead = req->wb_head;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (likely(!PageSwapCache(head->wb_page))) {\n\t\t\tset_page_private(head->wb_page, 0);\n\t\t\tClearPagePrivate(head->wb_page);\n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_page(head->wb_page, PG_private);\n\t\t\tclear_bit(PG_MAPPED, &head->wb_flags);\n\t\t}\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tif (test_and_clear_bit(PG_INODE_REF, &req->wb_flags))\n\t\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_inode_remove_request(struct nfs_page *req)\n{\n\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_page *head;\n\n\tif (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {\n\t\thead = req->wb_head;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (likely(!PageSwapCache(head->wb_page))) {\n\t\t\tset_page_private(head->wb_page, 0);\n\t\t\tClearPagePrivate(head->wb_page);\n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_page(head->wb_page, PG_private);\n\t\t\tclear_bit(PG_MAPPED, &head->wb_flags);\n\t\t}\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tif (test_and_clear_bit(PG_INODE_REF, &req->wb_flags))\n\t\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_mark_request_commit",
          "args": [
            "req",
            "hdr->lseg",
            "&cinfo",
            "hdr->pgio_mirror_idx"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_request_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "843-850",
          "snippet": "void\nnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\tstruct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\tif (pnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx))\n\t\treturn;\n\tnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\tstruct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\tif (pnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx))\n\t\treturn;\n\tnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&req->wb_verf",
            "&hdr->verf.verifier",
            "sizeof(req->wb_verf)"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_write_need_commit",
          "args": [
            "hdr"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_write_need_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "875-880",
          "snippet": "int nfs_write_need_commit(struct nfs_pgio_header *hdr)\n{\n\tif (hdr->verf.committed == NFS_DATA_SYNC)\n\t\treturn hdr->lseg == NULL;\n\treturn hdr->verf.committed != NFS_FILE_SYNC;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint nfs_write_need_commit(struct nfs_pgio_header *hdr)\n{\n\tif (hdr->verf.committed == NFS_DATA_SYNC)\n\t\treturn hdr->lseg == NULL;\n\treturn hdr->verf.committed != NFS_FILE_SYNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_context_set_write_error",
          "args": [
            "req->wb_context",
            "hdr->error"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_context_set_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "93-98",
          "snippet": "static void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)\n{\n\tctx->error = error;\n\tsmp_wmb();\n\tset_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)\n{\n\tctx->error = error;\n\tsmp_wmb();\n\tset_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_pageerror",
          "args": [
            "req->wb_page"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_pageerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "164-167",
          "snippet": "static void nfs_set_pageerror(struct page *page)\n{\n\tnfs_zap_mapping(page_file_mapping(page)->host, page_file_mapping(page));\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_pageerror(struct page *page)\n{\n\tnfs_zap_mapping(page_file_mapping(page)->host, page_file_mapping(page));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFS_IOHDR_ERROR",
            "&hdr->flags"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_list_remove_request",
          "args": [
            "req"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_list_entry",
          "args": [
            "hdr->pages.next"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&hdr->pages"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_init_cinfo_from_inode",
          "args": [
            "&cinfo",
            "hdr->inode"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "819-827",
          "snippet": "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_write_completion(struct nfs_pgio_header *hdr)\n{\n\tstruct nfs_commit_info cinfo;\n\tunsigned long bytes = 0;\n\n\tif (test_bit(NFS_IOHDR_REDO, &hdr->flags))\n\t\tgoto out;\n\tnfs_init_cinfo_from_inode(&cinfo, hdr->inode);\n\twhile (!list_empty(&hdr->pages)) {\n\t\tstruct nfs_page *req = nfs_list_entry(hdr->pages.next);\n\n\t\tbytes += req->wb_bytes;\n\t\tnfs_list_remove_request(req);\n\t\tif (test_bit(NFS_IOHDR_ERROR, &hdr->flags) &&\n\t\t    (hdr->good_bytes < bytes)) {\n\t\t\tnfs_set_pageerror(req->wb_page);\n\t\t\tnfs_context_set_write_error(req->wb_context, hdr->error);\n\t\t\tgoto remove_req;\n\t\t}\n\t\tif (nfs_write_need_commit(hdr)) {\n\t\t\tmemcpy(&req->wb_verf, &hdr->verf.verifier, sizeof(req->wb_verf));\n\t\t\tnfs_mark_request_commit(req, hdr->lseg, &cinfo,\n\t\t\t\thdr->pgio_mirror_idx);\n\t\t\tgoto next;\n\t\t}\nremove_req:\n\t\tnfs_inode_remove_request(req);\nnext:\n\t\tnfs_unlock_request(req);\n\t\tnfs_end_page_writeback(req);\n\t\tnfs_release_request(req);\n\t}\nout:\n\thdr->release(hdr);\n}"
  },
  {
    "function_name": "nfs_write_need_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "875-880",
    "snippet": "int nfs_write_need_commit(struct nfs_pgio_header *hdr)\n{\n\tif (hdr->verf.committed == NFS_DATA_SYNC)\n\t\treturn hdr->lseg == NULL;\n\treturn hdr->verf.committed != NFS_FILE_SYNC;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint nfs_write_need_commit(struct nfs_pgio_header *hdr)\n{\n\tif (hdr->verf.committed == NFS_DATA_SYNC)\n\t\treturn hdr->lseg == NULL;\n\treturn hdr->verf.committed != NFS_FILE_SYNC;\n}"
  },
  {
    "function_name": "nfs_clear_request_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "860-873",
    "snippet": "static void\nnfs_clear_request_commit(struct nfs_page *req)\n{\n\tif (test_bit(PG_CLEAN, &req->wb_flags)) {\n\t\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\t\tstruct nfs_commit_info cinfo;\n\n\t\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\t\tif (!pnfs_clear_request_commit(req, &cinfo)) {\n\t\t\tnfs_request_remove_commit_list(req, &cinfo);\n\t\t}\n\t\tnfs_clear_page_commit(req->wb_page);\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_clear_page_commit",
          "args": [
            "req->wb_page"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_clear_page_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "852-857",
          "snippet": "static void\nnfs_clear_page_commit(struct page *page)\n{\n\tdec_zone_page_state(page, NR_UNSTABLE_NFS);\n\tdec_bdi_stat(inode_to_bdi(page_file_mapping(page)->host), BDI_RECLAIMABLE);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void\nnfs_clear_page_commit(struct page *page)\n{\n\tdec_zone_page_state(page, NR_UNSTABLE_NFS);\n\tdec_bdi_stat(inode_to_bdi(page_file_mapping(page)->host), BDI_RECLAIMABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_request_remove_commit_list",
          "args": [
            "req",
            "&cinfo"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_request_remove_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "808-816",
          "snippet": "void\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_clear_request_commit",
          "args": [
            "req",
            "&cinfo"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_clear_request_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "622-626",
          "snippet": "static inline bool\npnfs_clear_request_commit(struct nfs_page *req, struct nfs_commit_info *cinfo)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline bool\npnfs_clear_request_commit(struct nfs_page *req, struct nfs_commit_info *cinfo)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_init_cinfo_from_inode",
          "args": [
            "&cinfo",
            "inode"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "819-827",
          "snippet": "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PG_CLEAN",
            "&req->wb_flags"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void\nnfs_clear_request_commit(struct nfs_page *req)\n{\n\tif (test_bit(PG_CLEAN, &req->wb_flags)) {\n\t\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\t\tstruct nfs_commit_info cinfo;\n\n\t\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\t\tif (!pnfs_clear_request_commit(req, &cinfo)) {\n\t\t\tnfs_request_remove_commit_list(req, &cinfo);\n\t\t}\n\t\tnfs_clear_page_commit(req->wb_page);\n\t}\n}"
  },
  {
    "function_name": "nfs_clear_page_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "852-857",
    "snippet": "static void\nnfs_clear_page_commit(struct page *page)\n{\n\tdec_zone_page_state(page, NR_UNSTABLE_NFS);\n\tdec_bdi_stat(inode_to_bdi(page_file_mapping(page)->host), BDI_RECLAIMABLE);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_bdi_stat",
          "args": [
            "inode_to_bdi(page_file_mapping(page)->host)",
            "BDI_RECLAIMABLE"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "page_file_mapping(page)->host"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_zone_page_state",
          "args": [
            "page",
            "NR_UNSTABLE_NFS"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void\nnfs_clear_page_commit(struct page *page)\n{\n\tdec_zone_page_state(page, NR_UNSTABLE_NFS);\n\tdec_bdi_stat(inode_to_bdi(page_file_mapping(page)->host), BDI_RECLAIMABLE);\n}"
  },
  {
    "function_name": "nfs_mark_request_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "843-850",
    "snippet": "void\nnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\tstruct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\tif (pnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx))\n\t\treturn;\n\tnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_request_add_commit_list",
          "args": [
            "req",
            "&cinfo->mds->list",
            "cinfo"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_request_add_commit_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "783-794",
          "snippet": "void\nnfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,\n\t\t\t    struct nfs_commit_info *cinfo)\n{\n\tset_bit(PG_CLEAN, &(req)->wb_flags);\n\tspin_lock(cinfo->lock);\n\tnfs_list_add_request(req, dst);\n\tcinfo->mds->ncommit++;\n\tspin_unlock(cinfo->lock);\n\tif (!cinfo->dreq)\n\t\tnfs_mark_page_unstable(req->wb_page);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,\n\t\t\t    struct nfs_commit_info *cinfo)\n{\n\tset_bit(PG_CLEAN, &(req)->wb_flags);\n\tspin_lock(cinfo->lock);\n\tnfs_list_add_request(req, dst);\n\tcinfo->mds->ncommit++;\n\tspin_unlock(cinfo->lock);\n\tif (!cinfo->dreq)\n\t\tnfs_mark_page_unstable(req->wb_page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_mark_request_commit",
          "args": [
            "req",
            "lseg",
            "cinfo",
            "ds_commit_idx"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_mark_request_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "615-620",
          "snippet": "static inline bool\npnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\t struct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\treturn false;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline bool\npnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\t struct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_mark_request_commit(struct nfs_page *req, struct pnfs_layout_segment *lseg,\n\t\t\tstruct nfs_commit_info *cinfo, u32 ds_commit_idx)\n{\n\tif (pnfs_mark_request_commit(req, lseg, cinfo, ds_commit_idx))\n\t\treturn;\n\tnfs_request_add_commit_list(req, &cinfo->mds->list, cinfo);\n}"
  },
  {
    "function_name": "nfs_init_cinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "829-837",
    "snippet": "void nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq)\n{\n\tif (dreq)\n\t\tnfs_init_cinfo_from_dreq(cinfo, dreq);\n\telse\n\t\tnfs_init_cinfo_from_inode(cinfo, inode);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_init_cinfo_from_inode",
          "args": [
            "cinfo",
            "inode"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "819-827",
          "snippet": "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_init_cinfo_from_dreq",
          "args": [
            "cinfo",
            "dreq"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo_from_dreq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "283-291",
          "snippet": "void nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,\n\t\t\t      struct nfs_direct_req *dreq)\n{\n\tcinfo->lock = &dreq->inode->i_lock;\n\tcinfo->mds = &dreq->mds_cinfo;\n\tcinfo->ds = &dreq->ds_cinfo;\n\tcinfo->dreq = dreq;\n\tcinfo->completion_ops = &nfs_direct_commit_completion_ops;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_commit_completion_ops nfs_direct_commit_completion_ops;",
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);",
            "static const struct nfs_commit_completion_ops nfs_direct_commit_completion_ops = {\n\t.completion = nfs_direct_commit_complete,\n\t.error_cleanup = nfs_direct_error_cleanup,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic const struct nfs_commit_completion_ops nfs_direct_commit_completion_ops;\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\nstatic const struct nfs_commit_completion_ops nfs_direct_commit_completion_ops = {\n\t.completion = nfs_direct_commit_complete,\n\t.error_cleanup = nfs_direct_error_cleanup,\n};\n\nvoid nfs_init_cinfo_from_dreq(struct nfs_commit_info *cinfo,\n\t\t\t      struct nfs_direct_req *dreq)\n{\n\tcinfo->lock = &dreq->inode->i_lock;\n\tcinfo->mds = &dreq->mds_cinfo;\n\tcinfo->ds = &dreq->ds_cinfo;\n\tcinfo->dreq = dreq;\n\tcinfo->completion_ops = &nfs_direct_commit_completion_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nvoid nfs_init_cinfo(struct nfs_commit_info *cinfo,\n\t\t    struct inode *inode,\n\t\t    struct nfs_direct_req *dreq)\n{\n\tif (dreq)\n\t\tnfs_init_cinfo_from_dreq(cinfo, dreq);\n\telse\n\t\tnfs_init_cinfo_from_inode(cinfo, inode);\n}"
  },
  {
    "function_name": "nfs_init_cinfo_from_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "819-827",
    "snippet": "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct nfs_commit_completion_ops nfs_commit_completion_ops;",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnfs_get_ds_info",
          "args": [
            "inode"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_get_ds_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "609-613",
          "snippet": "static inline struct pnfs_ds_commit_info *\npnfs_get_ds_info(struct inode *inode)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct pnfs_ds_commit_info *\npnfs_get_ds_info(struct inode *inode)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}"
  },
  {
    "function_name": "nfs_request_remove_commit_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "808-816",
    "snippet": "void\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_list_remove_request",
          "args": [
            "req"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "PG_CLEAN",
            "&(req)->wb_flags"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_remove_commit_list(struct nfs_page *req,\n\t\t\t       struct nfs_commit_info *cinfo)\n{\n\tif (!test_and_clear_bit(PG_CLEAN, &(req)->wb_flags))\n\t\treturn;\n\tnfs_list_remove_request(req);\n\tcinfo->mds->ncommit--;\n}"
  },
  {
    "function_name": "nfs_request_add_commit_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "783-794",
    "snippet": "void\nnfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,\n\t\t\t    struct nfs_commit_info *cinfo)\n{\n\tset_bit(PG_CLEAN, &(req)->wb_flags);\n\tspin_lock(cinfo->lock);\n\tnfs_list_add_request(req, dst);\n\tcinfo->mds->ncommit++;\n\tspin_unlock(cinfo->lock);\n\tif (!cinfo->dreq)\n\t\tnfs_mark_page_unstable(req->wb_page);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_mark_page_unstable",
          "args": [
            "req->wb_page"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_mark_page_unstable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "604-612",
          "snippet": "static inline\nvoid nfs_mark_page_unstable(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\n\tinc_zone_page_state(page, NR_UNSTABLE_NFS);\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_RECLAIMABLE);\n\t __mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline\nvoid nfs_mark_page_unstable(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\n\tinc_zone_page_state(page, NR_UNSTABLE_NFS);\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_RECLAIMABLE);\n\t __mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "cinfo->lock"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_list_add_request",
          "args": [
            "req",
            "dst"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "cinfo->lock"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "PG_CLEAN",
            "&(req)->wb_flags"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nvoid\nnfs_request_add_commit_list(struct nfs_page *req, struct list_head *dst,\n\t\t\t    struct nfs_commit_info *cinfo)\n{\n\tset_bit(PG_CLEAN, &(req)->wb_flags);\n\tspin_lock(cinfo->lock);\n\tnfs_list_add_request(req, dst);\n\tcinfo->mds->ncommit++;\n\tspin_unlock(cinfo->lock);\n\tif (!cinfo->dreq)\n\t\tnfs_mark_page_unstable(req->wb_page);\n}"
  },
  {
    "function_name": "nfs_page_search_commits_for_head_request_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "746-768",
    "snippet": "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct nfs_page *freq, *t;\n\tstruct nfs_commit_info cinfo;\n\tstruct inode *inode = &nfsi->vfs_inode;\n\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\n\t/* search through pnfs commit lists */\n\tfreq = pnfs_search_commit_reqs(inode, &cinfo, page);\n\tif (freq)\n\t\treturn freq->wb_head;\n\n\t/* Linearly search the commit list for the correct request */\n\tlist_for_each_entry_safe(freq, t, &cinfo.mds->list, wb_list) {\n\t\tif (freq->wb_page == page)\n\t\t\treturn freq->wb_head;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "freq",
            "t",
            "&cinfo.mds->list",
            "wb_list"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_search_commit_reqs",
          "args": [
            "inode",
            "&cinfo",
            "page"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_search_commit_reqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.h",
          "lines": "635-640",
          "snippet": "static inline struct nfs_page *\npnfs_search_commit_reqs(struct inode *inode, struct nfs_commit_info *cinfo,\n\t\t\tstruct page *page)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic inline struct nfs_page *\npnfs_search_commit_reqs(struct inode *inode, struct nfs_commit_info *cinfo,\n\t\t\tstruct page *page)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_init_cinfo_from_inode",
          "args": [
            "&cinfo",
            "inode"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_init_cinfo_from_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "819-827",
          "snippet": "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_commit_completion_ops nfs_commit_completion_ops = {\n\t.completion = nfs_commit_release_pages,\n\t.error_cleanup = nfs_commit_clear_lock,\n};\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode)\n{\n\tcinfo->lock = &inode->i_lock;\n\tcinfo->mds = &NFS_I(inode)->commit_info;\n\tcinfo->ds = pnfs_get_ds_info(inode);\n\tcinfo->dreq = NULL;\n\tcinfo->completion_ops = &nfs_commit_completion_ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct nfs_page *freq, *t;\n\tstruct nfs_commit_info cinfo;\n\tstruct inode *inode = &nfsi->vfs_inode;\n\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\n\t/* search through pnfs commit lists */\n\tfreq = pnfs_search_commit_reqs(inode, &cinfo, page);\n\tif (freq)\n\t\treturn freq->wb_head;\n\n\t/* Linearly search the commit list for the correct request */\n\tlist_for_each_entry_safe(freq, t, &cinfo.mds->list, wb_list) {\n\t\tif (freq->wb_page == page)\n\t\t\treturn freq->wb_head;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs_mark_request_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "732-736",
    "snippet": "static void\nnfs_mark_request_dirty(struct nfs_page *req)\n{\n\t__set_page_dirty_nobuffers(req->wb_page);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "req->wb_page"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void\nnfs_mark_request_dirty(struct nfs_page *req)\n{\n\t__set_page_dirty_nobuffers(req->wb_page);\n}"
  },
  {
    "function_name": "nfs_inode_remove_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "703-730",
    "snippet": "static void nfs_inode_remove_request(struct nfs_page *req)\n{\n\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_page *head;\n\n\tif (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {\n\t\thead = req->wb_head;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (likely(!PageSwapCache(head->wb_page))) {\n\t\t\tset_page_private(head->wb_page, 0);\n\t\t\tClearPagePrivate(head->wb_page);\n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_page(head->wb_page, PG_private);\n\t\t\tclear_bit(PG_MAPPED, &head->wb_flags);\n\t\t}\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tif (test_and_clear_bit(PG_INODE_REF, &req->wb_flags))\n\t\tnfs_release_request(req);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "req"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "PG_INODE_REF",
            "&req->wb_flags"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "PG_MAPPED",
            "&head->wb_flags"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_page",
          "args": [
            "head->wb_page",
            "PG_private"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "head->wb_page"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "head->wb_page",
            "0"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageSwapCache(head->wb_page)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "head->wb_page"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_group_sync_on_bit",
          "args": [
            "req",
            "PG_REMOVE"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_sync_on_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "255-264",
          "snippet": "bool nfs_page_group_sync_on_bit(struct nfs_page *req, unsigned int bit)\n{\n\tbool ret;\n\n\tnfs_page_group_lock(req, false);\n\tret = nfs_page_group_sync_on_bit_locked(req, bit);\n\tnfs_page_group_unlock(req);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nbool nfs_page_group_sync_on_bit(struct nfs_page *req, unsigned int bit)\n{\n\tbool ret;\n\n\tnfs_page_group_lock(req, false);\n\tret = nfs_page_group_sync_on_bit_locked(req, bit);\n\tnfs_page_group_unlock(req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_inode_remove_request(struct nfs_page *req)\n{\n\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_page *head;\n\n\tif (nfs_page_group_sync_on_bit(req, PG_REMOVE)) {\n\t\thead = req->wb_head;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (likely(!PageSwapCache(head->wb_page))) {\n\t\t\tset_page_private(head->wb_page, 0);\n\t\t\tClearPagePrivate(head->wb_page);\n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_page(head->wb_page, PG_private);\n\t\t\tclear_bit(PG_MAPPED, &head->wb_flags);\n\t\t}\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfsi->nrequests--;\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\n\tif (test_and_clear_bit(PG_INODE_REF, &req->wb_flags))\n\t\tnfs_release_request(req);\n}"
  },
  {
    "function_name": "nfs_inode_add_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "668-698",
    "snippet": "static void nfs_inode_add_request(struct inode *inode, struct nfs_page *req)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t/* Lock the request! */\n\tnfs_lock_request(req);\n\n\tspin_lock(&inode->i_lock);\n\tif (!nfsi->nrequests &&\n\t    NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\tinode->i_version++;\n\t/*\n\t * Swap-space should not get truncated. Hence no need to plug the race\n\t * with invalidate/truncate.\n\t */\n\tif (likely(!PageSwapCache(req->wb_page))) {\n\t\tset_bit(PG_MAPPED, &req->wb_flags);\n\t\tSetPagePrivate(req->wb_page);\n\t\tset_page_private(req->wb_page, (unsigned long)req);\n\t}\n\tnfsi->nrequests++;\n\t/* this a head request for a page group - mark it as having an\n\t * extra reference so sub groups can follow suit.\n\t * This flag also informs pgio layer when to bump nrequests when\n\t * adding subrequests. */\n\tWARN_ON(test_and_set_bit(PG_INODE_REF, &req->wb_flags));\n\tkref_get(&req->wb_kref);\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&req->wb_kref"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "test_and_set_bit(PG_INODE_REF, &req->wb_flags)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "PG_INODE_REF",
            "&req->wb_flags"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "req->wb_page",
            "(unsigned long)req"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "req->wb_page"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "PG_MAPPED",
            "&req->wb_flags"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!PageSwapCache(req->wb_page)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "req->wb_page"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode",
            "FMODE_WRITE"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_PROTO",
          "args": [
            "inode"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_lock_request",
          "args": [
            "req"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "req->wb_this_page != req"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_inode_add_request(struct inode *inode, struct nfs_page *req)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\n\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t/* Lock the request! */\n\tnfs_lock_request(req);\n\n\tspin_lock(&inode->i_lock);\n\tif (!nfsi->nrequests &&\n\t    NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\tinode->i_version++;\n\t/*\n\t * Swap-space should not get truncated. Hence no need to plug the race\n\t * with invalidate/truncate.\n\t */\n\tif (likely(!PageSwapCache(req->wb_page))) {\n\t\tset_bit(PG_MAPPED, &req->wb_flags);\n\t\tSetPagePrivate(req->wb_page);\n\t\tset_page_private(req->wb_page, (unsigned long)req);\n\t}\n\tnfsi->nrequests++;\n\t/* this a head request for a page group - mark it as having an\n\t * extra reference so sub groups can follow suit.\n\t * This flag also informs pgio layer when to bump nrequests when\n\t * adding subrequests. */\n\tWARN_ON(test_and_set_bit(PG_INODE_REF, &req->wb_flags));\n\tkref_get(&req->wb_kref);\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "nfs_writepages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "631-663",
    "snippet": "int nfs_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned long *bitlock = &NFS_I(inode)->flags;\n\tstruct nfs_pageio_descriptor pgio;\n\tint err;\n\n\t/* Stop dirtying of new pages while we sync */\n\terr = wait_on_bit_lock_action(bitlock, NFS_INO_FLUSHING,\n\t\t\tnfs_wait_bit_killable, TASK_KILLABLE);\n\tif (err)\n\t\tgoto out_err;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSWRITEPAGES);\n\n\tnfs_pageio_init_write(&pgio, inode, wb_priority(wbc), false,\n\t\t\t\t&nfs_async_write_completion_ops);\n\terr = write_cache_pages(mapping, wbc, nfs_writepages_callback, &pgio);\n\tnfs_pageio_complete(&pgio);\n\n\tclear_bit_unlock(NFS_INO_FLUSHING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_FLUSHING);\n\n\tif (err < 0)\n\t\tgoto out_err;\n\terr = pgio.pg_error;\n\tif (err < 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\treturn err;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {\n\t.error_cleanup = nfs_async_write_error,\n\t.completion = nfs_write_completion,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "bitlock",
            "NFS_INO_FLUSHING"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "NFS_INO_FLUSHING",
            "bitlock"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pageio_complete",
          "args": [
            "&pgio"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1244-1254",
          "snippet": "void nfs_pageio_complete(struct nfs_pageio_descriptor *desc)\n{\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++)\n\t\tnfs_pageio_complete_mirror(desc, midx);\n\n\tif (desc->pg_ops->pg_cleanup)\n\t\tdesc->pg_ops->pg_cleanup(desc);\n\tnfs_pageio_cleanup_mirroring(desc);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pageio_complete(struct nfs_pageio_descriptor *desc)\n{\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++)\n\t\tnfs_pageio_complete_mirror(desc, midx);\n\n\tif (desc->pg_ops->pg_cleanup)\n\t\tdesc->pg_ops->pg_cleanup(desc);\n\tnfs_pageio_cleanup_mirroring(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_cache_pages",
          "args": [
            "mapping",
            "wbc",
            "nfs_writepages_callback",
            "&pgio"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_pageio_init_write",
          "args": [
            "&pgio",
            "inode",
            "wb_priority(wbc)",
            "false",
            "&nfs_async_write_completion_ops"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1313-1326",
          "snippet": "void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct inode *inode, int ioflags, bool force_mds,\n\t\t\t       const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_write_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_write_ops,\n\t\t\tserver->wsize, ioflags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_rw_ops nfs_rw_write_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct nfs_rw_ops nfs_rw_write_ops = {\n\t.rw_mode\t\t= FMODE_WRITE,\n\t.rw_alloc_header\t= nfs_writehdr_alloc,\n\t.rw_free_header\t\t= nfs_writehdr_free,\n\t.rw_release\t\t= nfs_writeback_release_common,\n\t.rw_done\t\t= nfs_writeback_done,\n\t.rw_result\t\t= nfs_writeback_result,\n\t.rw_initiate\t\t= nfs_initiate_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_rw_ops nfs_rw_write_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_rw_ops nfs_rw_write_ops = {\n\t.rw_mode\t\t= FMODE_WRITE,\n\t.rw_alloc_header\t= nfs_writehdr_alloc,\n\t.rw_free_header\t\t= nfs_writehdr_free,\n\t.rw_release\t\t= nfs_writeback_release_common,\n\t.rw_done\t\t= nfs_writeback_done,\n\t.rw_result\t\t= nfs_writeback_result,\n\t.rw_initiate\t\t= nfs_initiate_write,\n};\n\nvoid nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct inode *inode, int ioflags, bool force_mds,\n\t\t\t       const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_write_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_write_ops,\n\t\t\tserver->wsize, ioflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_priority",
          "args": [
            "wbc"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "wb_priority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "243-253",
          "snippet": "static int wb_priority(struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tif (wbc->for_reclaim)\n\t\treturn FLUSH_HIGHPRI | FLUSH_STABLE;\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tret = FLUSH_COND_STABLE;\n\tif (wbc->for_kupdate || wbc->for_background)\n\t\tret |= FLUSH_LOWPRI;\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int wb_priority(struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tif (wbc->for_reclaim)\n\t\treturn FLUSH_HIGHPRI | FLUSH_STABLE;\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tret = FLUSH_COND_STABLE;\n\tif (wbc->for_kupdate || wbc->for_background)\n\t\tret |= FLUSH_LOWPRI;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_VFSWRITEPAGES"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit_lock_action",
          "args": [
            "bitlock",
            "NFS_INO_FLUSHING",
            "nfs_wait_bit_killable",
            "TASK_KILLABLE"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {\n\t.error_cleanup = nfs_async_write_error,\n\t.completion = nfs_write_completion,\n};\n\nint nfs_writepages(struct address_space *mapping, struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned long *bitlock = &NFS_I(inode)->flags;\n\tstruct nfs_pageio_descriptor pgio;\n\tint err;\n\n\t/* Stop dirtying of new pages while we sync */\n\terr = wait_on_bit_lock_action(bitlock, NFS_INO_FLUSHING,\n\t\t\tnfs_wait_bit_killable, TASK_KILLABLE);\n\tif (err)\n\t\tgoto out_err;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSWRITEPAGES);\n\n\tnfs_pageio_init_write(&pgio, inode, wb_priority(wbc), false,\n\t\t\t\t&nfs_async_write_completion_ops);\n\terr = write_cache_pages(mapping, wbc, nfs_writepages_callback, &pgio);\n\tnfs_pageio_complete(&pgio);\n\n\tclear_bit_unlock(NFS_INO_FLUSHING, bitlock);\n\tsmp_mb__after_atomic();\n\twake_up_bit(bitlock, NFS_INO_FLUSHING);\n\n\tif (err < 0)\n\t\tgoto out_err;\n\terr = pgio.pg_error;\n\tif (err < 0)\n\t\tgoto out_err;\n\treturn 0;\nout_err:\n\treturn err;\n}"
  },
  {
    "function_name": "nfs_writepages_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "622-629",
    "snippet": "static int nfs_writepages_callback(struct page *page, struct writeback_control *wbc, void *data)\n{\n\tint ret;\n\n\tret = nfs_do_writepage(page, wbc, data);\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_do_writepage",
          "args": [
            "page",
            "wbc",
            "data"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "577-592",
          "snippet": "static int nfs_do_writepage(struct page *page, struct writeback_control *wbc, struct nfs_pageio_descriptor *pgio)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint ret;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSWRITEPAGE);\n\tnfs_inc_stats(inode, NFSIOS_WRITEPAGES);\n\n\tnfs_pageio_cond_complete(pgio, page_file_index(page));\n\tret = nfs_page_async_flush(pgio, page, wbc->sync_mode == WB_SYNC_NONE);\n\tif (ret == -EAGAIN) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_do_writepage(struct page *page, struct writeback_control *wbc, struct nfs_pageio_descriptor *pgio)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint ret;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSWRITEPAGE);\n\tnfs_inc_stats(inode, NFSIOS_WRITEPAGES);\n\n\tnfs_pageio_cond_complete(pgio, page_file_index(page));\n\tret = nfs_page_async_flush(pgio, page, wbc->sync_mode == WB_SYNC_NONE);\n\tif (ret == -EAGAIN) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_writepages_callback(struct page *page, struct writeback_control *wbc, void *data)\n{\n\tint ret;\n\n\tret = nfs_do_writepage(page, wbc, data);\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "613-620",
    "snippet": "int nfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tret = nfs_writepage_locked(page, wbc);\n\tunlock_page(page);\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_writepage_locked",
          "args": [
            "page",
            "wbc"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_writepage_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "597-611",
          "snippet": "static int nfs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\tint err;\n\n\tnfs_pageio_init_write(&pgio, page->mapping->host, wb_priority(wbc),\n\t\t\t\tfalse, &nfs_async_write_completion_ops);\n\terr = nfs_do_writepage(page, wbc, &pgio);\n\tnfs_pageio_complete(&pgio);\n\tif (err < 0)\n\t\treturn err;\n\tif (pgio.pg_error < 0)\n\t\treturn pgio.pg_error;\n\treturn 0;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);",
            "static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {\n\t.error_cleanup = nfs_async_write_error,\n\t.completion = nfs_write_completion,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\nstatic const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {\n\t.error_cleanup = nfs_async_write_error,\n\t.completion = nfs_write_completion,\n};\n\nstatic int nfs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\tint err;\n\n\tnfs_pageio_init_write(&pgio, page->mapping->host, wb_priority(wbc),\n\t\t\t\tfalse, &nfs_async_write_completion_ops);\n\terr = nfs_do_writepage(page, wbc, &pgio);\n\tnfs_pageio_complete(&pgio);\n\tif (err < 0)\n\t\treturn err;\n\tif (pgio.pg_error < 0)\n\t\treturn pgio.pg_error;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nint nfs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tret = nfs_writepage_locked(page, wbc);\n\tunlock_page(page);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_writepage_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "597-611",
    "snippet": "static int nfs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\tint err;\n\n\tnfs_pageio_init_write(&pgio, page->mapping->host, wb_priority(wbc),\n\t\t\t\tfalse, &nfs_async_write_completion_ops);\n\terr = nfs_do_writepage(page, wbc, &pgio);\n\tnfs_pageio_complete(&pgio);\n\tif (err < 0)\n\t\treturn err;\n\tif (pgio.pg_error < 0)\n\t\treturn pgio.pg_error;\n\treturn 0;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);",
      "static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {\n\t.error_cleanup = nfs_async_write_error,\n\t.completion = nfs_write_completion,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_pageio_complete",
          "args": [
            "&pgio"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1244-1254",
          "snippet": "void nfs_pageio_complete(struct nfs_pageio_descriptor *desc)\n{\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++)\n\t\tnfs_pageio_complete_mirror(desc, midx);\n\n\tif (desc->pg_ops->pg_cleanup)\n\t\tdesc->pg_ops->pg_cleanup(desc);\n\tnfs_pageio_cleanup_mirroring(desc);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pageio_complete(struct nfs_pageio_descriptor *desc)\n{\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++)\n\t\tnfs_pageio_complete_mirror(desc, midx);\n\n\tif (desc->pg_ops->pg_cleanup)\n\t\tdesc->pg_ops->pg_cleanup(desc);\n\tnfs_pageio_cleanup_mirroring(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_do_writepage",
          "args": [
            "page",
            "wbc",
            "&pgio"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_writepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "577-592",
          "snippet": "static int nfs_do_writepage(struct page *page, struct writeback_control *wbc, struct nfs_pageio_descriptor *pgio)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint ret;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSWRITEPAGE);\n\tnfs_inc_stats(inode, NFSIOS_WRITEPAGES);\n\n\tnfs_pageio_cond_complete(pgio, page_file_index(page));\n\tret = nfs_page_async_flush(pgio, page, wbc->sync_mode == WB_SYNC_NONE);\n\tif (ret == -EAGAIN) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_do_writepage(struct page *page, struct writeback_control *wbc, struct nfs_pageio_descriptor *pgio)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint ret;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSWRITEPAGE);\n\tnfs_inc_stats(inode, NFSIOS_WRITEPAGES);\n\n\tnfs_pageio_cond_complete(pgio, page_file_index(page));\n\tret = nfs_page_async_flush(pgio, page, wbc->sync_mode == WB_SYNC_NONE);\n\tif (ret == -EAGAIN) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_init_write",
          "args": [
            "&pgio",
            "page->mapping->host",
            "wb_priority(wbc)",
            "false",
            "&nfs_async_write_completion_ops"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_init_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1313-1326",
          "snippet": "void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct inode *inode, int ioflags, bool force_mds,\n\t\t\t       const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_write_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_write_ops,\n\t\t\tserver->wsize, ioflags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfs_rw_ops nfs_rw_write_ops;",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static const struct nfs_rw_ops nfs_rw_write_ops = {\n\t.rw_mode\t\t= FMODE_WRITE,\n\t.rw_alloc_header\t= nfs_writehdr_alloc,\n\t.rw_free_header\t\t= nfs_writehdr_free,\n\t.rw_release\t\t= nfs_writeback_release_common,\n\t.rw_done\t\t= nfs_writeback_done,\n\t.rw_result\t\t= nfs_writeback_result,\n\t.rw_initiate\t\t= nfs_initiate_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_rw_ops nfs_rw_write_ops;\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic const struct nfs_rw_ops nfs_rw_write_ops = {\n\t.rw_mode\t\t= FMODE_WRITE,\n\t.rw_alloc_header\t= nfs_writehdr_alloc,\n\t.rw_free_header\t\t= nfs_writehdr_free,\n\t.rw_release\t\t= nfs_writeback_release_common,\n\t.rw_done\t\t= nfs_writeback_done,\n\t.rw_result\t\t= nfs_writeback_result,\n\t.rw_initiate\t\t= nfs_initiate_write,\n};\n\nvoid nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t       struct inode *inode, int ioflags, bool force_mds,\n\t\t\t       const struct nfs_pgio_completion_ops *compl_ops)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tconst struct nfs_pageio_ops *pg_ops = &nfs_pgio_rw_ops;\n\n#ifdef CONFIG_NFS_V4_1\n\tif (server->pnfs_curr_ld && !force_mds)\n\t\tpg_ops = server->pnfs_curr_ld->pg_write_ops;\n#endif\n\tnfs_pageio_init(pgio, inode, pg_ops, compl_ops, &nfs_rw_write_ops,\n\t\t\tserver->wsize, ioflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_priority",
          "args": [
            "wbc"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "wb_priority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "243-253",
          "snippet": "static int wb_priority(struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tif (wbc->for_reclaim)\n\t\treturn FLUSH_HIGHPRI | FLUSH_STABLE;\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tret = FLUSH_COND_STABLE;\n\tif (wbc->for_kupdate || wbc->for_background)\n\t\tret |= FLUSH_LOWPRI;\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int wb_priority(struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tif (wbc->for_reclaim)\n\t\treturn FLUSH_HIGHPRI | FLUSH_STABLE;\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tret = FLUSH_COND_STABLE;\n\tif (wbc->for_kupdate || wbc->for_background)\n\t\tret |= FLUSH_LOWPRI;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\nstatic const struct nfs_pgio_completion_ops nfs_async_write_completion_ops = {\n\t.error_cleanup = nfs_async_write_error,\n\t.completion = nfs_write_completion,\n};\n\nstatic int nfs_writepage_locked(struct page *page, struct writeback_control *wbc)\n{\n\tstruct nfs_pageio_descriptor pgio;\n\tint err;\n\n\tnfs_pageio_init_write(&pgio, page->mapping->host, wb_priority(wbc),\n\t\t\t\tfalse, &nfs_async_write_completion_ops);\n\terr = nfs_do_writepage(page, wbc, &pgio);\n\tnfs_pageio_complete(&pgio);\n\tif (err < 0)\n\t\treturn err;\n\tif (pgio.pg_error < 0)\n\t\treturn pgio.pg_error;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_do_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "577-592",
    "snippet": "static int nfs_do_writepage(struct page *page, struct writeback_control *wbc, struct nfs_pageio_descriptor *pgio)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint ret;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSWRITEPAGE);\n\tnfs_inc_stats(inode, NFSIOS_WRITEPAGES);\n\n\tnfs_pageio_cond_complete(pgio, page_file_index(page));\n\tret = nfs_page_async_flush(pgio, page, wbc->sync_mode == WB_SYNC_NONE);\n\tif (ret == -EAGAIN) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_async_flush",
          "args": [
            "pgio",
            "page",
            "wbc->sync_mode == WB_SYNC_NONE"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_async_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "552-575",
          "snippet": "static int nfs_page_async_flush(struct nfs_pageio_descriptor *pgio,\n\t\t\t\tstruct page *page, bool nonblock)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\treq = nfs_lock_and_join_requests(page, nonblock);\n\tif (!req)\n\t\tgoto out;\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\n\tnfs_set_page_writeback(page);\n\tWARN_ON_ONCE(test_bit(PG_CLEAN, &req->wb_flags));\n\n\tret = 0;\n\tif (!nfs_pageio_add_request(pgio, req)) {\n\t\tnfs_redirty_request(req);\n\t\tret = pgio->pg_error;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_page_async_flush(struct nfs_pageio_descriptor *pgio,\n\t\t\t\tstruct page *page, bool nonblock)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\treq = nfs_lock_and_join_requests(page, nonblock);\n\tif (!req)\n\t\tgoto out;\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\n\tnfs_set_page_writeback(page);\n\tWARN_ON_ONCE(test_bit(PG_CLEAN, &req->wb_flags));\n\n\tret = 0;\n\tif (!nfs_pageio_add_request(pgio, req)) {\n\t\tnfs_redirty_request(req);\n\t\tret = pgio->pg_error;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_cond_complete",
          "args": [
            "pgio",
            "page_file_index(page)"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_cond_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1267-1281",
          "snippet": "void nfs_pageio_cond_complete(struct nfs_pageio_descriptor *desc, pgoff_t index)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\tstruct nfs_page *prev;\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++) {\n\t\tmirror = &desc->pg_mirrors[midx];\n\t\tif (!list_empty(&mirror->pg_list)) {\n\t\t\tprev = nfs_list_entry(mirror->pg_list.prev);\n\t\t\tif (index != prev->wb_index + 1)\n\t\t\t\tnfs_pageio_complete_mirror(desc, midx);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_pageio_cond_complete(struct nfs_pageio_descriptor *desc, pgoff_t index)\n{\n\tstruct nfs_pgio_mirror *mirror;\n\tstruct nfs_page *prev;\n\tu32 midx;\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++) {\n\t\tmirror = &desc->pg_mirrors[midx];\n\t\tif (!list_empty(&mirror->pg_list)) {\n\t\t\tprev = nfs_list_entry(mirror->pg_list.prev);\n\t\t\tif (index != prev->wb_index + 1)\n\t\t\t\tnfs_pageio_complete_mirror(desc, midx);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_index",
          "args": [
            "page"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_WRITEPAGES"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_do_writepage(struct page *page, struct writeback_control *wbc, struct nfs_pageio_descriptor *pgio)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint ret;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSWRITEPAGE);\n\tnfs_inc_stats(inode, NFSIOS_WRITEPAGES);\n\n\tnfs_pageio_cond_complete(pgio, page_file_index(page));\n\tret = nfs_page_async_flush(pgio, page, wbc->sync_mode == WB_SYNC_NONE);\n\tif (ret == -EAGAIN) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_page_async_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "552-575",
    "snippet": "static int nfs_page_async_flush(struct nfs_pageio_descriptor *pgio,\n\t\t\t\tstruct page *page, bool nonblock)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\treq = nfs_lock_and_join_requests(page, nonblock);\n\tif (!req)\n\t\tgoto out;\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\n\tnfs_set_page_writeback(page);\n\tWARN_ON_ONCE(test_bit(PG_CLEAN, &req->wb_flags));\n\n\tret = 0;\n\tif (!nfs_pageio_add_request(pgio, req)) {\n\t\tnfs_redirty_request(req);\n\t\tret = pgio->pg_error;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_redirty_request",
          "args": [
            "req"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_redirty_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "1289-1295",
          "snippet": "static void nfs_redirty_request(struct nfs_page *req)\n{\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_request(req);\n\tnfs_end_page_writeback(req);\n\tnfs_release_request(req);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void nfs_redirty_request(struct nfs_page *req)\n{\n\tnfs_mark_request_dirty(req);\n\tnfs_unlock_request(req);\n\tnfs_end_page_writeback(req);\n\tnfs_release_request(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pageio_add_request",
          "args": [
            "pgio",
            "req"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pageio_add_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "1138-1183",
          "snippet": "int nfs_pageio_add_request(struct nfs_pageio_descriptor *desc,\n\t\t\t   struct nfs_page *req)\n{\n\tu32 midx;\n\tunsigned int pgbase, offset, bytes;\n\tstruct nfs_page *dupreq, *lastreq;\n\n\tpgbase = req->wb_pgbase;\n\toffset = req->wb_offset;\n\tbytes = req->wb_bytes;\n\n\tnfs_pageio_setup_mirroring(desc, req);\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++) {\n\t\tif (midx) {\n\t\t\tnfs_page_group_lock(req, false);\n\n\t\t\t/* find the last request */\n\t\t\tfor (lastreq = req->wb_head;\n\t\t\t     lastreq->wb_this_page != req->wb_head;\n\t\t\t     lastreq = lastreq->wb_this_page)\n\t\t\t\t;\n\n\t\t\tdupreq = nfs_create_request(req->wb_context,\n\t\t\t\t\treq->wb_page, lastreq, pgbase, bytes);\n\n\t\t\tif (IS_ERR(dupreq)) {\n\t\t\t\tnfs_page_group_unlock(req);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tnfs_lock_request(dupreq);\n\t\t\tnfs_page_group_unlock(req);\n\t\t\tdupreq->wb_offset = offset;\n\t\t\tdupreq->wb_index = req->wb_index;\n\t\t} else\n\t\t\tdupreq = req;\n\n\t\tif (nfs_pgio_has_mirroring(desc))\n\t\t\tdesc->pg_mirror_idx = midx;\n\t\tif (!nfs_pageio_add_request_mirror(desc, dupreq))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint nfs_pageio_add_request(struct nfs_pageio_descriptor *desc,\n\t\t\t   struct nfs_page *req)\n{\n\tu32 midx;\n\tunsigned int pgbase, offset, bytes;\n\tstruct nfs_page *dupreq, *lastreq;\n\n\tpgbase = req->wb_pgbase;\n\toffset = req->wb_offset;\n\tbytes = req->wb_bytes;\n\n\tnfs_pageio_setup_mirroring(desc, req);\n\n\tfor (midx = 0; midx < desc->pg_mirror_count; midx++) {\n\t\tif (midx) {\n\t\t\tnfs_page_group_lock(req, false);\n\n\t\t\t/* find the last request */\n\t\t\tfor (lastreq = req->wb_head;\n\t\t\t     lastreq->wb_this_page != req->wb_head;\n\t\t\t     lastreq = lastreq->wb_this_page)\n\t\t\t\t;\n\n\t\t\tdupreq = nfs_create_request(req->wb_context,\n\t\t\t\t\treq->wb_page, lastreq, pgbase, bytes);\n\n\t\t\tif (IS_ERR(dupreq)) {\n\t\t\t\tnfs_page_group_unlock(req);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tnfs_lock_request(dupreq);\n\t\t\tnfs_page_group_unlock(req);\n\t\t\tdupreq->wb_offset = offset;\n\t\t\tdupreq->wb_index = req->wb_index;\n\t\t} else\n\t\t\tdupreq = req;\n\n\t\tif (nfs_pgio_has_mirroring(desc))\n\t\t\tdesc->pg_mirror_idx = midx;\n\t\tif (!nfs_pageio_add_request_mirror(desc, dupreq))\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_bit(PG_CLEAN, &req->wb_flags)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PG_CLEAN",
            "&req->wb_flags"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_set_page_writeback",
          "args": [
            "page"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_lock_and_join_requests",
          "args": [
            "page",
            "nonblock"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_lock_and_join_requests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "427-546",
          "snippet": "static struct nfs_page *\nnfs_lock_and_join_requests(struct page *page, bool nonblock)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *head, *subreq;\n\tstruct nfs_page *destroy_list = NULL;\n\tunsigned int total_bytes;\n\tint ret;\n\ntry_again:\n\ttotal_bytes = 0;\n\n\tWARN_ON_ONCE(destroy_list);\n\n\tspin_lock(&inode->i_lock);\n\n\t/*\n\t * A reference is taken only on the head request which acts as a\n\t * reference to the whole page group - the group will not be destroyed\n\t * until the head reference is released.\n\t */\n\thead = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\n\tif (!head) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn NULL;\n\t}\n\n\t/* holding inode lock, so always make a non-blocking call to try the\n\t * page group lock */\n\tret = nfs_page_group_lock(head, true);\n\tif (ret < 0) {\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (!nonblock && ret == -EAGAIN) {\n\t\t\tnfs_page_group_lock_wait(head);\n\t\t\tnfs_release_request(head);\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tnfs_release_request(head);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* lock each request in the page group */\n\tsubreq = head;\n\tdo {\n\t\t/*\n\t\t * Subrequests are always contiguous, non overlapping\n\t\t * and in order - but may be repeated (mirrored writes).\n\t\t */\n\t\tif (subreq->wb_offset == (head->wb_offset + total_bytes)) {\n\t\t\t/* keep track of how many bytes this group covers */\n\t\t\ttotal_bytes += subreq->wb_bytes;\n\t\t} else if (WARN_ON_ONCE(subreq->wb_offset < head->wb_offset ||\n\t\t\t    ((subreq->wb_offset + subreq->wb_bytes) >\n\t\t\t     (head->wb_offset + total_bytes)))) {\n\t\t\tnfs_page_group_unlock(head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tif (!nfs_lock_request(subreq)) {\n\t\t\t/* releases page group bit lock and\n\t\t\t * inode spin lock and all references */\n\t\t\tret = nfs_unroll_locks_and_wait(inode, head,\n\t\t\t\tsubreq, nonblock);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto try_again;\n\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* Now that all requests are locked, make sure they aren't on any list.\n\t * Commit list removal accounting is done after locks are dropped */\n\tsubreq = head;\n\tdo {\n\t\tnfs_clear_request_commit(subreq);\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* unlink subrequests from head, destroy them later */\n\tif (head->wb_this_page != head) {\n\t\t/* destroy list will be terminated by head */\n\t\tdestroy_list = head->wb_this_page;\n\t\thead->wb_this_page = head;\n\n\t\t/* change head request to cover whole range that\n\t\t * the former page group covered */\n\t\thead->wb_bytes = total_bytes;\n\t}\n\n\t/*\n\t * prepare head request to be added to new pgio descriptor\n\t */\n\tnfs_page_group_clear_bits(head);\n\n\t/*\n\t * some part of the group was still on the inode list - otherwise\n\t * the group wouldn't be involved in async write.\n\t * grab a reference for the head request, iff it needs one.\n\t */\n\tif (!test_and_set_bit(PG_INODE_REF, &head->wb_flags))\n\t\tkref_get(&head->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\n\t/* drop lock to clean uprequests on destroy list */\n\tspin_unlock(&inode->i_lock);\n\n\tnfs_destroy_unlinked_subrequests(destroy_list, head);\n\n\t/* still holds ref on head from nfs_page_find_head_request_locked\n\t * and still has lock on head from lock loop */\n\treturn head;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_lock_and_join_requests(struct page *page, bool nonblock)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *head, *subreq;\n\tstruct nfs_page *destroy_list = NULL;\n\tunsigned int total_bytes;\n\tint ret;\n\ntry_again:\n\ttotal_bytes = 0;\n\n\tWARN_ON_ONCE(destroy_list);\n\n\tspin_lock(&inode->i_lock);\n\n\t/*\n\t * A reference is taken only on the head request which acts as a\n\t * reference to the whole page group - the group will not be destroyed\n\t * until the head reference is released.\n\t */\n\thead = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\n\tif (!head) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn NULL;\n\t}\n\n\t/* holding inode lock, so always make a non-blocking call to try the\n\t * page group lock */\n\tret = nfs_page_group_lock(head, true);\n\tif (ret < 0) {\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (!nonblock && ret == -EAGAIN) {\n\t\t\tnfs_page_group_lock_wait(head);\n\t\t\tnfs_release_request(head);\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tnfs_release_request(head);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* lock each request in the page group */\n\tsubreq = head;\n\tdo {\n\t\t/*\n\t\t * Subrequests are always contiguous, non overlapping\n\t\t * and in order - but may be repeated (mirrored writes).\n\t\t */\n\t\tif (subreq->wb_offset == (head->wb_offset + total_bytes)) {\n\t\t\t/* keep track of how many bytes this group covers */\n\t\t\ttotal_bytes += subreq->wb_bytes;\n\t\t} else if (WARN_ON_ONCE(subreq->wb_offset < head->wb_offset ||\n\t\t\t    ((subreq->wb_offset + subreq->wb_bytes) >\n\t\t\t     (head->wb_offset + total_bytes)))) {\n\t\t\tnfs_page_group_unlock(head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tif (!nfs_lock_request(subreq)) {\n\t\t\t/* releases page group bit lock and\n\t\t\t * inode spin lock and all references */\n\t\t\tret = nfs_unroll_locks_and_wait(inode, head,\n\t\t\t\tsubreq, nonblock);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto try_again;\n\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* Now that all requests are locked, make sure they aren't on any list.\n\t * Commit list removal accounting is done after locks are dropped */\n\tsubreq = head;\n\tdo {\n\t\tnfs_clear_request_commit(subreq);\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* unlink subrequests from head, destroy them later */\n\tif (head->wb_this_page != head) {\n\t\t/* destroy list will be terminated by head */\n\t\tdestroy_list = head->wb_this_page;\n\t\thead->wb_this_page = head;\n\n\t\t/* change head request to cover whole range that\n\t\t * the former page group covered */\n\t\thead->wb_bytes = total_bytes;\n\t}\n\n\t/*\n\t * prepare head request to be added to new pgio descriptor\n\t */\n\tnfs_page_group_clear_bits(head);\n\n\t/*\n\t * some part of the group was still on the inode list - otherwise\n\t * the group wouldn't be involved in async write.\n\t * grab a reference for the head request, iff it needs one.\n\t */\n\tif (!test_and_set_bit(PG_INODE_REF, &head->wb_flags))\n\t\tkref_get(&head->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\n\t/* drop lock to clean uprequests on destroy list */\n\tspin_unlock(&inode->i_lock);\n\n\tnfs_destroy_unlinked_subrequests(destroy_list, head);\n\n\t/* still holds ref on head from nfs_page_find_head_request_locked\n\t * and still has lock on head from lock loop */\n\treturn head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic int nfs_page_async_flush(struct nfs_pageio_descriptor *pgio,\n\t\t\t\tstruct page *page, bool nonblock)\n{\n\tstruct nfs_page *req;\n\tint ret = 0;\n\n\treq = nfs_lock_and_join_requests(page, nonblock);\n\tif (!req)\n\t\tgoto out;\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\n\tnfs_set_page_writeback(page);\n\tWARN_ON_ONCE(test_bit(PG_CLEAN, &req->wb_flags));\n\n\tret = 0;\n\tif (!nfs_pageio_add_request(pgio, req)) {\n\t\tnfs_redirty_request(req);\n\t\tret = pgio->pg_error;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_lock_and_join_requests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "427-546",
    "snippet": "static struct nfs_page *\nnfs_lock_and_join_requests(struct page *page, bool nonblock)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *head, *subreq;\n\tstruct nfs_page *destroy_list = NULL;\n\tunsigned int total_bytes;\n\tint ret;\n\ntry_again:\n\ttotal_bytes = 0;\n\n\tWARN_ON_ONCE(destroy_list);\n\n\tspin_lock(&inode->i_lock);\n\n\t/*\n\t * A reference is taken only on the head request which acts as a\n\t * reference to the whole page group - the group will not be destroyed\n\t * until the head reference is released.\n\t */\n\thead = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\n\tif (!head) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn NULL;\n\t}\n\n\t/* holding inode lock, so always make a non-blocking call to try the\n\t * page group lock */\n\tret = nfs_page_group_lock(head, true);\n\tif (ret < 0) {\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (!nonblock && ret == -EAGAIN) {\n\t\t\tnfs_page_group_lock_wait(head);\n\t\t\tnfs_release_request(head);\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tnfs_release_request(head);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* lock each request in the page group */\n\tsubreq = head;\n\tdo {\n\t\t/*\n\t\t * Subrequests are always contiguous, non overlapping\n\t\t * and in order - but may be repeated (mirrored writes).\n\t\t */\n\t\tif (subreq->wb_offset == (head->wb_offset + total_bytes)) {\n\t\t\t/* keep track of how many bytes this group covers */\n\t\t\ttotal_bytes += subreq->wb_bytes;\n\t\t} else if (WARN_ON_ONCE(subreq->wb_offset < head->wb_offset ||\n\t\t\t    ((subreq->wb_offset + subreq->wb_bytes) >\n\t\t\t     (head->wb_offset + total_bytes)))) {\n\t\t\tnfs_page_group_unlock(head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tif (!nfs_lock_request(subreq)) {\n\t\t\t/* releases page group bit lock and\n\t\t\t * inode spin lock and all references */\n\t\t\tret = nfs_unroll_locks_and_wait(inode, head,\n\t\t\t\tsubreq, nonblock);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto try_again;\n\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* Now that all requests are locked, make sure they aren't on any list.\n\t * Commit list removal accounting is done after locks are dropped */\n\tsubreq = head;\n\tdo {\n\t\tnfs_clear_request_commit(subreq);\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* unlink subrequests from head, destroy them later */\n\tif (head->wb_this_page != head) {\n\t\t/* destroy list will be terminated by head */\n\t\tdestroy_list = head->wb_this_page;\n\t\thead->wb_this_page = head;\n\n\t\t/* change head request to cover whole range that\n\t\t * the former page group covered */\n\t\thead->wb_bytes = total_bytes;\n\t}\n\n\t/*\n\t * prepare head request to be added to new pgio descriptor\n\t */\n\tnfs_page_group_clear_bits(head);\n\n\t/*\n\t * some part of the group was still on the inode list - otherwise\n\t * the group wouldn't be involved in async write.\n\t * grab a reference for the head request, iff it needs one.\n\t */\n\tif (!test_and_set_bit(PG_INODE_REF, &head->wb_flags))\n\t\tkref_get(&head->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\n\t/* drop lock to clean uprequests on destroy list */\n\tspin_unlock(&inode->i_lock);\n\n\tnfs_destroy_unlinked_subrequests(destroy_list, head);\n\n\t/* still holds ref on head from nfs_page_find_head_request_locked\n\t * and still has lock on head from lock loop */\n\treturn head;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_destroy_unlinked_subrequests",
          "args": [
            "destroy_list",
            "head"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_destroy_unlinked_subrequests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "365-406",
          "snippet": "static void\nnfs_destroy_unlinked_subrequests(struct nfs_page *destroy_list,\n\t\t\t\t struct nfs_page *old_head)\n{\n\twhile (destroy_list) {\n\t\tstruct nfs_page *subreq = destroy_list;\n\n\t\tdestroy_list = (subreq->wb_this_page == old_head) ?\n\t\t\t\t   NULL : subreq->wb_this_page;\n\n\t\tWARN_ON_ONCE(old_head != subreq->wb_head);\n\n\t\t/* make sure old group is not used */\n\t\tsubreq->wb_head = subreq;\n\t\tsubreq->wb_this_page = subreq;\n\n\t\t/* subreq is now totally disconnected from page group or any\n\t\t * write / commit lists. last chance to wake any waiters */\n\t\tnfs_unlock_request(subreq);\n\n\t\tif (!test_bit(PG_TEARDOWN, &subreq->wb_flags)) {\n\t\t\t/* release ref on old head request */\n\t\t\tnfs_release_request(old_head);\n\n\t\t\tnfs_page_group_clear_bits(subreq);\n\n\t\t\t/* release the PG_INODE_REF reference */\n\t\t\tif (test_and_clear_bit(PG_INODE_REF, &subreq->wb_flags))\n\t\t\t\tnfs_release_request(subreq);\n\t\t\telse\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(test_bit(PG_CLEAN, &subreq->wb_flags));\n\t\t\t/* zombie requests have already released the last\n\t\t\t * reference and were waiting on the rest of the\n\t\t\t * group to complete. Since it's no longer part of a\n\t\t\t * group, simply free the request */\n\t\t\tnfs_page_group_clear_bits(subreq);\n\t\t\tnfs_free_request(subreq);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void\nnfs_destroy_unlinked_subrequests(struct nfs_page *destroy_list,\n\t\t\t\t struct nfs_page *old_head)\n{\n\twhile (destroy_list) {\n\t\tstruct nfs_page *subreq = destroy_list;\n\n\t\tdestroy_list = (subreq->wb_this_page == old_head) ?\n\t\t\t\t   NULL : subreq->wb_this_page;\n\n\t\tWARN_ON_ONCE(old_head != subreq->wb_head);\n\n\t\t/* make sure old group is not used */\n\t\tsubreq->wb_head = subreq;\n\t\tsubreq->wb_this_page = subreq;\n\n\t\t/* subreq is now totally disconnected from page group or any\n\t\t * write / commit lists. last chance to wake any waiters */\n\t\tnfs_unlock_request(subreq);\n\n\t\tif (!test_bit(PG_TEARDOWN, &subreq->wb_flags)) {\n\t\t\t/* release ref on old head request */\n\t\t\tnfs_release_request(old_head);\n\n\t\t\tnfs_page_group_clear_bits(subreq);\n\n\t\t\t/* release the PG_INODE_REF reference */\n\t\t\tif (test_and_clear_bit(PG_INODE_REF, &subreq->wb_flags))\n\t\t\t\tnfs_release_request(subreq);\n\t\t\telse\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(test_bit(PG_CLEAN, &subreq->wb_flags));\n\t\t\t/* zombie requests have already released the last\n\t\t\t * reference and were waiting on the rest of the\n\t\t\t * group to complete. Since it's no longer part of a\n\t\t\t * group, simply free the request */\n\t\t\tnfs_page_group_clear_bits(subreq);\n\t\t\tnfs_free_request(subreq);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_group_unlock",
          "args": [
            "head"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "205-216",
          "snippet": "void\nnfs_page_group_unlock(struct nfs_page *req)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_HEADLOCK, &head->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&head->wb_flags, PG_HEADLOCK);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid\nnfs_page_group_unlock(struct nfs_page *req)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_HEADLOCK, &head->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&head->wb_flags, PG_HEADLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&head->wb_kref"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "PG_INODE_REF",
            "&head->wb_flags"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_group_clear_bits",
          "args": [
            "head"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "297-305",
          "snippet": "static void\nnfs_page_group_clear_bits(struct nfs_page *req)\n{\n\tclear_bit(PG_TEARDOWN, &req->wb_flags);\n\tclear_bit(PG_UNLOCKPAGE, &req->wb_flags);\n\tclear_bit(PG_UPTODATE, &req->wb_flags);\n\tclear_bit(PG_WB_END, &req->wb_flags);\n\tclear_bit(PG_REMOVE, &req->wb_flags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void\nnfs_page_group_clear_bits(struct nfs_page *req)\n{\n\tclear_bit(PG_TEARDOWN, &req->wb_flags);\n\tclear_bit(PG_UNLOCKPAGE, &req->wb_flags);\n\tclear_bit(PG_UPTODATE, &req->wb_flags);\n\tclear_bit(PG_WB_END, &req->wb_flags);\n\tclear_bit(PG_REMOVE, &req->wb_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_clear_request_commit",
          "args": [
            "subreq"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_clear_request_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "860-873",
          "snippet": "static void\nnfs_clear_request_commit(struct nfs_page *req)\n{\n\tif (test_bit(PG_CLEAN, &req->wb_flags)) {\n\t\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\t\tstruct nfs_commit_info cinfo;\n\n\t\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\t\tif (!pnfs_clear_request_commit(req, &cinfo)) {\n\t\t\tnfs_request_remove_commit_list(req, &cinfo);\n\t\t}\n\t\tnfs_clear_page_commit(req->wb_page);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void\nnfs_clear_request_commit(struct nfs_page *req)\n{\n\tif (test_bit(PG_CLEAN, &req->wb_flags)) {\n\t\tstruct inode *inode = req->wb_context->dentry->d_inode;\n\t\tstruct nfs_commit_info cinfo;\n\n\t\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\t\tif (!pnfs_clear_request_commit(req, &cinfo)) {\n\t\t\tnfs_request_remove_commit_list(req, &cinfo);\n\t\t}\n\t\tnfs_clear_page_commit(req->wb_page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_unroll_locks_and_wait",
          "args": [
            "inode",
            "head",
            "subreq",
            "nonblock"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unroll_locks_and_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "323-353",
          "snippet": "static int\nnfs_unroll_locks_and_wait(struct inode *inode, struct nfs_page *head,\n\t\t\t  struct nfs_page *req, bool nonblock)\n\t__releases(&inode->i_lock)\n{\n\tstruct nfs_page *tmp;\n\tint ret;\n\n\t/* relinquish all the locks successfully grabbed this run */\n\tfor (tmp = head ; tmp != req; tmp = tmp->wb_this_page)\n\t\tnfs_unlock_request(tmp);\n\n\tWARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));\n\n\t/* grab a ref on the request that will be waited on */\n\tkref_get(&req->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\tspin_unlock(&inode->i_lock);\n\n\t/* release ref from nfs_page_find_head_request_locked */\n\tnfs_release_request(head);\n\n\tif (!nonblock)\n\t\tret = nfs_wait_on_request(req);\n\telse\n\t\tret = -EAGAIN;\n\tnfs_release_request(req);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int\nnfs_unroll_locks_and_wait(struct inode *inode, struct nfs_page *head,\n\t\t\t  struct nfs_page *req, bool nonblock)\n\t__releases(&inode->i_lock)\n{\n\tstruct nfs_page *tmp;\n\tint ret;\n\n\t/* relinquish all the locks successfully grabbed this run */\n\tfor (tmp = head ; tmp != req; tmp = tmp->wb_this_page)\n\t\tnfs_unlock_request(tmp);\n\n\tWARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));\n\n\t/* grab a ref on the request that will be waited on */\n\tkref_get(&req->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\tspin_unlock(&inode->i_lock);\n\n\t/* release ref from nfs_page_find_head_request_locked */\n\tnfs_release_request(head);\n\n\tif (!nonblock)\n\t\tret = nfs_wait_on_request(req);\n\telse\n\t\tret = -EAGAIN;\n\tnfs_release_request(req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_lock_request",
          "args": [
            "subreq"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "subreq->wb_offset < head->wb_offset ||\n\t\t\t    ((subreq->wb_offset + subreq->wb_bytes) >\n\t\t\t     (head->wb_offset + total_bytes))"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "head"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_group_lock_wait",
          "args": [
            "head"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "190-199",
          "snippet": "void\nnfs_page_group_lock_wait(struct nfs_page *req)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\twait_on_bit(&head->wb_flags, PG_HEADLOCK,\n\t\tTASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid\nnfs_page_group_lock_wait(struct nfs_page *req)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\twait_on_bit(&head->wb_flags, PG_HEADLOCK,\n\t\tTASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_group_lock",
          "args": [
            "head",
            "true"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "167-182",
          "snippet": "int\nnfs_page_group_lock(struct nfs_page *req, bool nonblock)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tif (!test_and_set_bit(PG_HEADLOCK, &head->wb_flags))\n\t\treturn 0;\n\n\tif (!nonblock)\n\t\treturn wait_on_bit_lock(&head->wb_flags, PG_HEADLOCK,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint\nnfs_page_group_lock(struct nfs_page *req, bool nonblock)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tif (!test_and_set_bit(PG_HEADLOCK, &head->wb_flags))\n\t\treturn 0;\n\n\tif (!nonblock)\n\t\treturn wait_on_bit_lock(&head->wb_flags, PG_HEADLOCK,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_find_head_request_locked",
          "args": [
            "NFS_I(inode)",
            "page"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_find_head_request_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "107-124",
          "snippet": "static struct nfs_page *\nnfs_page_find_head_request_locked(struct nfs_inode *nfsi, struct page *page)\n{\n\tstruct nfs_page *req = NULL;\n\n\tif (PagePrivate(page))\n\t\treq = (struct nfs_page *)page_private(page);\n\telse if (unlikely(PageSwapCache(page)))\n\t\treq = nfs_page_search_commits_for_head_request_locked(nfsi,\n\t\t\tpage);\n\n\tif (req) {\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tkref_get(&req->wb_kref);\n\t}\n\n\treturn req;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_page_find_head_request_locked(struct nfs_inode *nfsi, struct page *page)\n{\n\tstruct nfs_page *req = NULL;\n\n\tif (PagePrivate(page))\n\t\treq = (struct nfs_page *)page_private(page);\n\telse if (unlikely(PageSwapCache(page)))\n\t\treq = nfs_page_search_commits_for_head_request_locked(nfsi,\n\t\t\tpage);\n\n\tif (req) {\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tkref_get(&req->wb_kref);\n\t}\n\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "destroy_list"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_lock_and_join_requests(struct page *page, bool nonblock)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *head, *subreq;\n\tstruct nfs_page *destroy_list = NULL;\n\tunsigned int total_bytes;\n\tint ret;\n\ntry_again:\n\ttotal_bytes = 0;\n\n\tWARN_ON_ONCE(destroy_list);\n\n\tspin_lock(&inode->i_lock);\n\n\t/*\n\t * A reference is taken only on the head request which acts as a\n\t * reference to the whole page group - the group will not be destroyed\n\t * until the head reference is released.\n\t */\n\thead = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\n\tif (!head) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn NULL;\n\t}\n\n\t/* holding inode lock, so always make a non-blocking call to try the\n\t * page group lock */\n\tret = nfs_page_group_lock(head, true);\n\tif (ret < 0) {\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (!nonblock && ret == -EAGAIN) {\n\t\t\tnfs_page_group_lock_wait(head);\n\t\t\tnfs_release_request(head);\n\t\t\tgoto try_again;\n\t\t}\n\n\t\tnfs_release_request(head);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/* lock each request in the page group */\n\tsubreq = head;\n\tdo {\n\t\t/*\n\t\t * Subrequests are always contiguous, non overlapping\n\t\t * and in order - but may be repeated (mirrored writes).\n\t\t */\n\t\tif (subreq->wb_offset == (head->wb_offset + total_bytes)) {\n\t\t\t/* keep track of how many bytes this group covers */\n\t\t\ttotal_bytes += subreq->wb_bytes;\n\t\t} else if (WARN_ON_ONCE(subreq->wb_offset < head->wb_offset ||\n\t\t\t    ((subreq->wb_offset + subreq->wb_bytes) >\n\t\t\t     (head->wb_offset + total_bytes)))) {\n\t\t\tnfs_page_group_unlock(head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\n\t\tif (!nfs_lock_request(subreq)) {\n\t\t\t/* releases page group bit lock and\n\t\t\t * inode spin lock and all references */\n\t\t\tret = nfs_unroll_locks_and_wait(inode, head,\n\t\t\t\tsubreq, nonblock);\n\n\t\t\tif (ret == 0)\n\t\t\t\tgoto try_again;\n\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* Now that all requests are locked, make sure they aren't on any list.\n\t * Commit list removal accounting is done after locks are dropped */\n\tsubreq = head;\n\tdo {\n\t\tnfs_clear_request_commit(subreq);\n\t\tsubreq = subreq->wb_this_page;\n\t} while (subreq != head);\n\n\t/* unlink subrequests from head, destroy them later */\n\tif (head->wb_this_page != head) {\n\t\t/* destroy list will be terminated by head */\n\t\tdestroy_list = head->wb_this_page;\n\t\thead->wb_this_page = head;\n\n\t\t/* change head request to cover whole range that\n\t\t * the former page group covered */\n\t\thead->wb_bytes = total_bytes;\n\t}\n\n\t/*\n\t * prepare head request to be added to new pgio descriptor\n\t */\n\tnfs_page_group_clear_bits(head);\n\n\t/*\n\t * some part of the group was still on the inode list - otherwise\n\t * the group wouldn't be involved in async write.\n\t * grab a reference for the head request, iff it needs one.\n\t */\n\tif (!test_and_set_bit(PG_INODE_REF, &head->wb_flags))\n\t\tkref_get(&head->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\n\t/* drop lock to clean uprequests on destroy list */\n\tspin_unlock(&inode->i_lock);\n\n\tnfs_destroy_unlinked_subrequests(destroy_list, head);\n\n\t/* still holds ref on head from nfs_page_find_head_request_locked\n\t * and still has lock on head from lock loop */\n\treturn head;\n}"
  },
  {
    "function_name": "nfs_destroy_unlinked_subrequests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "365-406",
    "snippet": "static void\nnfs_destroy_unlinked_subrequests(struct nfs_page *destroy_list,\n\t\t\t\t struct nfs_page *old_head)\n{\n\twhile (destroy_list) {\n\t\tstruct nfs_page *subreq = destroy_list;\n\n\t\tdestroy_list = (subreq->wb_this_page == old_head) ?\n\t\t\t\t   NULL : subreq->wb_this_page;\n\n\t\tWARN_ON_ONCE(old_head != subreq->wb_head);\n\n\t\t/* make sure old group is not used */\n\t\tsubreq->wb_head = subreq;\n\t\tsubreq->wb_this_page = subreq;\n\n\t\t/* subreq is now totally disconnected from page group or any\n\t\t * write / commit lists. last chance to wake any waiters */\n\t\tnfs_unlock_request(subreq);\n\n\t\tif (!test_bit(PG_TEARDOWN, &subreq->wb_flags)) {\n\t\t\t/* release ref on old head request */\n\t\t\tnfs_release_request(old_head);\n\n\t\t\tnfs_page_group_clear_bits(subreq);\n\n\t\t\t/* release the PG_INODE_REF reference */\n\t\t\tif (test_and_clear_bit(PG_INODE_REF, &subreq->wb_flags))\n\t\t\t\tnfs_release_request(subreq);\n\t\t\telse\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(test_bit(PG_CLEAN, &subreq->wb_flags));\n\t\t\t/* zombie requests have already released the last\n\t\t\t * reference and were waiting on the rest of the\n\t\t\t * group to complete. Since it's no longer part of a\n\t\t\t * group, simply free the request */\n\t\t\tnfs_page_group_clear_bits(subreq);\n\t\t\tnfs_free_request(subreq);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_free_request",
          "args": [
            "subreq"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_free_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "450-464",
          "snippet": "void nfs_free_request(struct nfs_page *req)\n{\n\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t/* extra debug: make sure no sync bits are still set */\n\tWARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));\n\tWARN_ON_ONCE(test_bit(PG_UNLOCKPAGE, &req->wb_flags));\n\tWARN_ON_ONCE(test_bit(PG_UPTODATE, &req->wb_flags));\n\tWARN_ON_ONCE(test_bit(PG_WB_END, &req->wb_flags));\n\tWARN_ON_ONCE(test_bit(PG_REMOVE, &req->wb_flags));\n\n\t/* Release struct file and open context */\n\tnfs_clear_request(req);\n\tnfs_page_free(req);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_free_request(struct nfs_page *req)\n{\n\tWARN_ON_ONCE(req->wb_this_page != req);\n\n\t/* extra debug: make sure no sync bits are still set */\n\tWARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));\n\tWARN_ON_ONCE(test_bit(PG_UNLOCKPAGE, &req->wb_flags));\n\tWARN_ON_ONCE(test_bit(PG_UPTODATE, &req->wb_flags));\n\tWARN_ON_ONCE(test_bit(PG_WB_END, &req->wb_flags));\n\tWARN_ON_ONCE(test_bit(PG_REMOVE, &req->wb_flags));\n\n\t/* Release struct file and open context */\n\tnfs_clear_request(req);\n\tnfs_page_free(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_group_clear_bits",
          "args": [
            "subreq"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "297-305",
          "snippet": "static void\nnfs_page_group_clear_bits(struct nfs_page *req)\n{\n\tclear_bit(PG_TEARDOWN, &req->wb_flags);\n\tclear_bit(PG_UNLOCKPAGE, &req->wb_flags);\n\tclear_bit(PG_UPTODATE, &req->wb_flags);\n\tclear_bit(PG_WB_END, &req->wb_flags);\n\tclear_bit(PG_REMOVE, &req->wb_flags);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void\nnfs_page_group_clear_bits(struct nfs_page *req)\n{\n\tclear_bit(PG_TEARDOWN, &req->wb_flags);\n\tclear_bit(PG_UNLOCKPAGE, &req->wb_flags);\n\tclear_bit(PG_UPTODATE, &req->wb_flags);\n\tclear_bit(PG_WB_END, &req->wb_flags);\n\tclear_bit(PG_REMOVE, &req->wb_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_bit(PG_CLEAN, &subreq->wb_flags)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PG_CLEAN",
            "&subreq->wb_flags"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "subreq"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "PG_INODE_REF",
            "&subreq->wb_flags"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_unlock_request",
          "args": [
            "subreq"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unlock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "394-404",
          "snippet": "void nfs_unlock_request(struct nfs_page *req)\n{\n\tif (!NFS_WBACK_BUSY(req)) {\n\t\tprintk(KERN_ERR \"NFS: Invalid unlock attempted\\n\");\n\t\tBUG();\n\t}\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_BUSY, &req->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&req->wb_flags, PG_BUSY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_unlock_request(struct nfs_page *req)\n{\n\tif (!NFS_WBACK_BUSY(req)) {\n\t\tprintk(KERN_ERR \"NFS: Invalid unlock attempted\\n\");\n\t\tBUG();\n\t}\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_BUSY, &req->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&req->wb_flags, PG_BUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "old_head != subreq->wb_head"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void\nnfs_destroy_unlinked_subrequests(struct nfs_page *destroy_list,\n\t\t\t\t struct nfs_page *old_head)\n{\n\twhile (destroy_list) {\n\t\tstruct nfs_page *subreq = destroy_list;\n\n\t\tdestroy_list = (subreq->wb_this_page == old_head) ?\n\t\t\t\t   NULL : subreq->wb_this_page;\n\n\t\tWARN_ON_ONCE(old_head != subreq->wb_head);\n\n\t\t/* make sure old group is not used */\n\t\tsubreq->wb_head = subreq;\n\t\tsubreq->wb_this_page = subreq;\n\n\t\t/* subreq is now totally disconnected from page group or any\n\t\t * write / commit lists. last chance to wake any waiters */\n\t\tnfs_unlock_request(subreq);\n\n\t\tif (!test_bit(PG_TEARDOWN, &subreq->wb_flags)) {\n\t\t\t/* release ref on old head request */\n\t\t\tnfs_release_request(old_head);\n\n\t\t\tnfs_page_group_clear_bits(subreq);\n\n\t\t\t/* release the PG_INODE_REF reference */\n\t\t\tif (test_and_clear_bit(PG_INODE_REF, &subreq->wb_flags))\n\t\t\t\tnfs_release_request(subreq);\n\t\t\telse\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(test_bit(PG_CLEAN, &subreq->wb_flags));\n\t\t\t/* zombie requests have already released the last\n\t\t\t * reference and were waiting on the rest of the\n\t\t\t * group to complete. Since it's no longer part of a\n\t\t\t * group, simply free the request */\n\t\t\tnfs_page_group_clear_bits(subreq);\n\t\t\tnfs_free_request(subreq);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "nfs_unroll_locks_and_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "323-353",
    "snippet": "static int\nnfs_unroll_locks_and_wait(struct inode *inode, struct nfs_page *head,\n\t\t\t  struct nfs_page *req, bool nonblock)\n\t__releases(&inode->i_lock)\n{\n\tstruct nfs_page *tmp;\n\tint ret;\n\n\t/* relinquish all the locks successfully grabbed this run */\n\tfor (tmp = head ; tmp != req; tmp = tmp->wb_this_page)\n\t\tnfs_unlock_request(tmp);\n\n\tWARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));\n\n\t/* grab a ref on the request that will be waited on */\n\tkref_get(&req->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\tspin_unlock(&inode->i_lock);\n\n\t/* release ref from nfs_page_find_head_request_locked */\n\tnfs_release_request(head);\n\n\tif (!nonblock)\n\t\tret = nfs_wait_on_request(req);\n\telse\n\t\tret = -EAGAIN;\n\tnfs_release_request(req);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_release_request",
          "args": [
            "req"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_release_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "466-469",
          "snippet": "void nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_release_request(struct nfs_page *req)\n{\n\tkref_put(&req->wb_kref, nfs_page_group_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_wait_on_request",
          "args": [
            "req"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_wait_on_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "478-483",
          "snippet": "int\nnfs_wait_on_request(struct nfs_page *req)\n{\n\treturn wait_on_bit_io(&req->wb_flags, PG_BUSY,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint\nnfs_wait_on_request(struct nfs_page *req)\n{\n\treturn wait_on_bit_io(&req->wb_flags, PG_BUSY,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_group_unlock",
          "args": [
            "head"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "205-216",
          "snippet": "void\nnfs_page_group_unlock(struct nfs_page *req)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_HEADLOCK, &head->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&head->wb_flags, PG_HEADLOCK);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid\nnfs_page_group_unlock(struct nfs_page *req)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_HEADLOCK, &head->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&head->wb_flags, PG_HEADLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&req->wb_kref"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_bit(PG_TEARDOWN, &req->wb_flags)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PG_TEARDOWN",
            "&req->wb_flags"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_unlock_request",
          "args": [
            "tmp"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_unlock_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "394-404",
          "snippet": "void nfs_unlock_request(struct nfs_page *req)\n{\n\tif (!NFS_WBACK_BUSY(req)) {\n\t\tprintk(KERN_ERR \"NFS: Invalid unlock attempted\\n\");\n\t\tBUG();\n\t}\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_BUSY, &req->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&req->wb_flags, PG_BUSY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid nfs_unlock_request(struct nfs_page *req)\n{\n\tif (!NFS_WBACK_BUSY(req)) {\n\t\tprintk(KERN_ERR \"NFS: Invalid unlock attempted\\n\");\n\t\tBUG();\n\t}\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_BUSY, &req->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&req->wb_flags, PG_BUSY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&inode->i_lock"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic int\nnfs_unroll_locks_and_wait(struct inode *inode, struct nfs_page *head,\n\t\t\t  struct nfs_page *req, bool nonblock)\n\t__releases(&inode->i_lock)\n{\n\tstruct nfs_page *tmp;\n\tint ret;\n\n\t/* relinquish all the locks successfully grabbed this run */\n\tfor (tmp = head ; tmp != req; tmp = tmp->wb_this_page)\n\t\tnfs_unlock_request(tmp);\n\n\tWARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));\n\n\t/* grab a ref on the request that will be waited on */\n\tkref_get(&req->wb_kref);\n\n\tnfs_page_group_unlock(head);\n\tspin_unlock(&inode->i_lock);\n\n\t/* release ref from nfs_page_find_head_request_locked */\n\tnfs_release_request(head);\n\n\tif (!nonblock)\n\t\tret = nfs_wait_on_request(req);\n\telse\n\t\tret = -EAGAIN;\n\tnfs_release_request(req);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_page_group_clear_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "297-305",
    "snippet": "static void\nnfs_page_group_clear_bits(struct nfs_page *req)\n{\n\tclear_bit(PG_TEARDOWN, &req->wb_flags);\n\tclear_bit(PG_UNLOCKPAGE, &req->wb_flags);\n\tclear_bit(PG_UPTODATE, &req->wb_flags);\n\tclear_bit(PG_WB_END, &req->wb_flags);\n\tclear_bit(PG_REMOVE, &req->wb_flags);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "PG_REMOVE",
            "&req->wb_flags"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void\nnfs_page_group_clear_bits(struct nfs_page *req)\n{\n\tclear_bit(PG_TEARDOWN, &req->wb_flags);\n\tclear_bit(PG_UNLOCKPAGE, &req->wb_flags);\n\tclear_bit(PG_UPTODATE, &req->wb_flags);\n\tclear_bit(PG_WB_END, &req->wb_flags);\n\tclear_bit(PG_REMOVE, &req->wb_flags);\n}"
  },
  {
    "function_name": "nfs_end_page_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "279-290",
    "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
    ],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bdi_congested",
          "args": [
            "&nfss->backing_dev_info",
            "BLK_RW_ASYNC"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec_return",
          "args": [
            "&nfss->writeback"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "req->wb_page"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_group_sync_on_bit",
          "args": [
            "req",
            "PG_WB_END"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_sync_on_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "255-264",
          "snippet": "bool nfs_page_group_sync_on_bit(struct nfs_page *req, unsigned int bit)\n{\n\tbool ret;\n\n\tnfs_page_group_lock(req, false);\n\tret = nfs_page_group_sync_on_bit_locked(req, bit);\n\tnfs_page_group_unlock(req);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nbool nfs_page_group_sync_on_bit(struct nfs_page *req, unsigned int bit)\n{\n\tbool ret;\n\n\tnfs_page_group_lock(req, false);\n\tret = nfs_page_group_sync_on_bit_locked(req, bit);\n\tnfs_page_group_unlock(req);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "req->wb_page"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
  },
  {
    "function_name": "nfs_set_page_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "265-277",
    "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
    ],
    "globals_used": [
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bdi_congested",
          "args": [
            "&nfss->backing_dev_info",
            "BLK_RW_ASYNC"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_return",
          "args": [
            "&nfss->writeback"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret != 0"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_set_page_writeback",
          "args": [
            "page"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "page_file_mapping(page)->host"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
  },
  {
    "function_name": "wb_priority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "243-253",
    "snippet": "static int wb_priority(struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tif (wbc->for_reclaim)\n\t\treturn FLUSH_HIGHPRI | FLUSH_STABLE;\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tret = FLUSH_COND_STABLE;\n\tif (wbc->for_kupdate || wbc->for_background)\n\t\tret |= FLUSH_LOWPRI;\n\treturn ret;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int wb_priority(struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tif (wbc->for_reclaim)\n\t\treturn FLUSH_HIGHPRI | FLUSH_STABLE;\n\tif (wbc->sync_mode == WB_SYNC_ALL)\n\t\tret = FLUSH_COND_STABLE;\n\tif (wbc->for_kupdate || wbc->for_background)\n\t\tret |= FLUSH_LOWPRI;\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs_mark_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "234-241",
    "snippet": "static void nfs_mark_uptodate(struct nfs_page *req)\n{\n\tif (PageUptodate(req->wb_page))\n\t\treturn;\n\tif (!nfs_page_group_covers_page(req))\n\t\treturn;\n\tSetPageUptodate(req->wb_page);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "req->wb_page"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_group_covers_page",
          "args": [
            "req"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_covers_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "209-229",
          "snippet": "static bool nfs_page_group_covers_page(struct nfs_page *req)\n{\n\tstruct nfs_page *tmp;\n\tunsigned int pos = 0;\n\tunsigned int len = nfs_page_length(req->wb_page);\n\n\tnfs_page_group_lock(req, false);\n\n\tdo {\n\t\ttmp = nfs_page_group_search_locked(req->wb_head, pos);\n\t\tif (tmp) {\n\t\t\t/* no way this should happen */\n\t\t\tWARN_ON_ONCE(tmp->wb_pgbase != pos);\n\t\t\tpos += tmp->wb_bytes - (pos - tmp->wb_pgbase);\n\t\t}\n\t} while (tmp && pos < len);\n\n\tnfs_page_group_unlock(req);\n\tWARN_ON_ONCE(pos > len);\n\treturn pos == len;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic bool nfs_page_group_covers_page(struct nfs_page *req)\n{\n\tstruct nfs_page *tmp;\n\tunsigned int pos = 0;\n\tunsigned int len = nfs_page_length(req->wb_page);\n\n\tnfs_page_group_lock(req, false);\n\n\tdo {\n\t\ttmp = nfs_page_group_search_locked(req->wb_head, pos);\n\t\tif (tmp) {\n\t\t\t/* no way this should happen */\n\t\t\tWARN_ON_ONCE(tmp->wb_pgbase != pos);\n\t\t\tpos += tmp->wb_bytes - (pos - tmp->wb_pgbase);\n\t\t}\n\t} while (tmp && pos < len);\n\n\tnfs_page_group_unlock(req);\n\tWARN_ON_ONCE(pos > len);\n\treturn pos == len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "req->wb_page"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic void nfs_mark_uptodate(struct nfs_page *req)\n{\n\tif (PageUptodate(req->wb_page))\n\t\treturn;\n\tif (!nfs_page_group_covers_page(req))\n\t\treturn;\n\tSetPageUptodate(req->wb_page);\n}"
  },
  {
    "function_name": "nfs_page_group_covers_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "209-229",
    "snippet": "static bool nfs_page_group_covers_page(struct nfs_page *req)\n{\n\tstruct nfs_page *tmp;\n\tunsigned int pos = 0;\n\tunsigned int len = nfs_page_length(req->wb_page);\n\n\tnfs_page_group_lock(req, false);\n\n\tdo {\n\t\ttmp = nfs_page_group_search_locked(req->wb_head, pos);\n\t\tif (tmp) {\n\t\t\t/* no way this should happen */\n\t\t\tWARN_ON_ONCE(tmp->wb_pgbase != pos);\n\t\t\tpos += tmp->wb_bytes - (pos - tmp->wb_pgbase);\n\t\t}\n\t} while (tmp && pos < len);\n\n\tnfs_page_group_unlock(req);\n\tWARN_ON_ONCE(pos > len);\n\treturn pos == len;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "pos > len"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_group_unlock",
          "args": [
            "req"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "205-216",
          "snippet": "void\nnfs_page_group_unlock(struct nfs_page *req)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_HEADLOCK, &head->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&head->wb_flags, PG_HEADLOCK);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid\nnfs_page_group_unlock(struct nfs_page *req)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tsmp_mb__before_atomic();\n\tclear_bit(PG_HEADLOCK, &head->wb_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&head->wb_flags, PG_HEADLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tmp->wb_pgbase != pos"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_group_search_locked",
          "args": [
            "req->wb_head",
            "pos"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_search_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "182-200",
          "snippet": "static struct nfs_page *\nnfs_page_group_search_locked(struct nfs_page *head, unsigned int page_offset)\n{\n\tstruct nfs_page *req;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\tWARN_ON_ONCE(!test_bit(PG_HEADLOCK, &head->wb_head->wb_flags));\n\n\treq = head;\n\tdo {\n\t\tif (page_offset >= req->wb_pgbase &&\n\t\t    page_offset < (req->wb_pgbase + req->wb_bytes))\n\t\t\treturn req;\n\n\t\treq = req->wb_this_page;\n\t} while (req != head);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic struct nfs_page *\nnfs_page_group_search_locked(struct nfs_page *head, unsigned int page_offset)\n{\n\tstruct nfs_page *req;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\tWARN_ON_ONCE(!test_bit(PG_HEADLOCK, &head->wb_head->wb_flags));\n\n\treq = head;\n\tdo {\n\t\tif (page_offset >= req->wb_pgbase &&\n\t\t    page_offset < (req->wb_pgbase + req->wb_bytes))\n\t\t\treturn req;\n\n\t\treq = req->wb_this_page;\n\t} while (req != head);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_group_lock",
          "args": [
            "req",
            "false"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_group_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "167-182",
          "snippet": "int\nnfs_page_group_lock(struct nfs_page *req, bool nonblock)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tif (!test_and_set_bit(PG_HEADLOCK, &head->wb_flags))\n\t\treturn 0;\n\n\tif (!nonblock)\n\t\treturn wait_on_bit_lock(&head->wb_flags, PG_HEADLOCK,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint\nnfs_page_group_lock(struct nfs_page *req, bool nonblock)\n{\n\tstruct nfs_page *head = req->wb_head;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\n\tif (!test_and_set_bit(PG_HEADLOCK, &head->wb_flags))\n\t\treturn 0;\n\n\tif (!nonblock)\n\t\treturn wait_on_bit_lock(&head->wb_flags, PG_HEADLOCK,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_length",
          "args": [
            "req->wb_page"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "617-631",
          "snippet": "static inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
            "loff_t nfs_file_llseek(struct file *, loff_t, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\n\nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic bool nfs_page_group_covers_page(struct nfs_page *req)\n{\n\tstruct nfs_page *tmp;\n\tunsigned int pos = 0;\n\tunsigned int len = nfs_page_length(req->wb_page);\n\n\tnfs_page_group_lock(req, false);\n\n\tdo {\n\t\ttmp = nfs_page_group_search_locked(req->wb_head, pos);\n\t\tif (tmp) {\n\t\t\t/* no way this should happen */\n\t\t\tWARN_ON_ONCE(tmp->wb_pgbase != pos);\n\t\t\tpos += tmp->wb_bytes - (pos - tmp->wb_pgbase);\n\t\t}\n\t} while (tmp && pos < len);\n\n\tnfs_page_group_unlock(req);\n\tWARN_ON_ONCE(pos > len);\n\treturn pos == len;\n}"
  },
  {
    "function_name": "nfs_page_group_search_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "182-200",
    "snippet": "static struct nfs_page *\nnfs_page_group_search_locked(struct nfs_page *head, unsigned int page_offset)\n{\n\tstruct nfs_page *req;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\tWARN_ON_ONCE(!test_bit(PG_HEADLOCK, &head->wb_head->wb_flags));\n\n\treq = head;\n\tdo {\n\t\tif (page_offset >= req->wb_pgbase &&\n\t\t    page_offset < (req->wb_pgbase + req->wb_bytes))\n\t\t\treturn req;\n\n\t\treq = req->wb_this_page;\n\t} while (req != head);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!test_bit(PG_HEADLOCK, &head->wb_head->wb_flags)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "PG_HEADLOCK",
            "&head->wb_head->wb_flags"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "head != head->wb_head"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\n\nstatic struct nfs_page *\nnfs_page_group_search_locked(struct nfs_page *head, unsigned int page_offset)\n{\n\tstruct nfs_page *req;\n\n\tWARN_ON_ONCE(head != head->wb_head);\n\tWARN_ON_ONCE(!test_bit(PG_HEADLOCK, &head->wb_head->wb_flags));\n\n\treq = head;\n\tdo {\n\t\tif (page_offset >= req->wb_pgbase &&\n\t\t    page_offset < (req->wb_pgbase + req->wb_bytes))\n\t\t\treturn req;\n\n\t\treq = req->wb_this_page;\n\t} while (req != head);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs_set_pageerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "164-167",
    "snippet": "static void nfs_set_pageerror(struct page *page)\n{\n\tnfs_zap_mapping(page_file_mapping(page)->host, page_file_mapping(page));\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_zap_mapping",
          "args": [
            "page_file_mapping(page)->host",
            "page_file_mapping(page)"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_zap_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/inode.c",
          "lines": "197-204",
          "snippet": "void nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"netns.h\"",
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_invalidate_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"netns.h\"\n#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/nfs_xdr.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void nfs_invalidate_inode(struct inode *);\n\nvoid nfs_zap_mapping(struct inode *inode, struct address_space *mapping)\n{\n\tif (mapping->nrpages != 0) {\n\t\tspin_lock(&inode->i_lock);\n\t\tnfs_set_cache_invalid(inode, NFS_INO_INVALID_DATA);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_pageerror(struct page *page)\n{\n\tnfs_zap_mapping(page_file_mapping(page)->host, page_file_mapping(page));\n}"
  },
  {
    "function_name": "nfs_grow_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "143-161",
    "snippet": "static void nfs_grow_file(struct page *page, unsigned int offset, unsigned int count)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tloff_t end, i_size;\n\tpgoff_t end_index;\n\n\tspin_lock(&inode->i_lock);\n\ti_size = i_size_read(inode);\n\tend_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\tif (i_size > 0 && page_file_index(page) < end_index)\n\t\tgoto out;\n\tend = page_file_offset(page) + ((loff_t)offset+count);\n\tif (i_size >= end)\n\t\tgoto out;\n\ti_size_write(inode, end);\n\tnfs_inc_stats(inode, NFSIOS_EXTENDWRITE);\nout:\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_inc_stats",
          "args": [
            "inode",
            "NFSIOS_EXTENDWRITE"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inc_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/iostat.h",
          "lines": "31-35",
          "snippet": "static inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}",
          "includes": [
            "#include <linux/nfs_iostat.h>",
            "#include <linux/cache.h>",
            "#include <linux/percpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_iostat.h>\n#include <linux/cache.h>\n#include <linux/percpu.h>\n\nstatic inline void nfs_inc_stats(const struct inode *inode,\n\t\t\t\t enum nfs_stat_eventcounters stat)\n{\n\tnfs_inc_server_stats(NFS_SERVER(inode), stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "end"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_offset",
          "args": [
            "page"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_index",
          "args": [
            "page"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_grow_file(struct page *page, unsigned int offset, unsigned int count)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tloff_t end, i_size;\n\tpgoff_t end_index;\n\n\tspin_lock(&inode->i_lock);\n\ti_size = i_size_read(inode);\n\tend_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\tif (i_size > 0 && page_file_index(page) < end_index)\n\t\tgoto out;\n\tend = page_file_offset(page) + ((loff_t)offset+count);\n\tif (i_size >= end)\n\t\tgoto out;\n\ti_size_write(inode, end);\n\tnfs_inc_stats(inode, NFSIOS_EXTENDWRITE);\nout:\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "nfs_page_find_head_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "131-140",
    "snippet": "static struct nfs_page *nfs_page_find_head_request(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *req = NULL;\n\n\tspin_lock(&inode->i_lock);\n\treq = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\tspin_unlock(&inode->i_lock);\n\treturn req;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_page_find_head_request_locked",
          "args": [
            "NFS_I(inode)",
            "page"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_find_head_request_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "107-124",
          "snippet": "static struct nfs_page *\nnfs_page_find_head_request_locked(struct nfs_inode *nfsi, struct page *page)\n{\n\tstruct nfs_page *req = NULL;\n\n\tif (PagePrivate(page))\n\t\treq = (struct nfs_page *)page_private(page);\n\telse if (unlikely(PageSwapCache(page)))\n\t\treq = nfs_page_search_commits_for_head_request_locked(nfsi,\n\t\t\tpage);\n\n\tif (req) {\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tkref_get(&req->wb_kref);\n\t}\n\n\treturn req;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_page_find_head_request_locked(struct nfs_inode *nfsi, struct page *page)\n{\n\tstruct nfs_page *req = NULL;\n\n\tif (PagePrivate(page))\n\t\treq = (struct nfs_page *)page_private(page);\n\telse if (unlikely(PageSwapCache(page)))\n\t\treq = nfs_page_search_commits_for_head_request_locked(nfsi,\n\t\t\tpage);\n\n\tif (req) {\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tkref_get(&req->wb_kref);\n\t}\n\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "inode"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *nfs_page_find_head_request(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tstruct nfs_page *req = NULL;\n\n\tspin_lock(&inode->i_lock);\n\treq = nfs_page_find_head_request_locked(NFS_I(inode), page);\n\tspin_unlock(&inode->i_lock);\n\treturn req;\n}"
  },
  {
    "function_name": "nfs_page_find_head_request_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "107-124",
    "snippet": "static struct nfs_page *\nnfs_page_find_head_request_locked(struct nfs_inode *nfsi, struct page *page)\n{\n\tstruct nfs_page *req = NULL;\n\n\tif (PagePrivate(page))\n\t\treq = (struct nfs_page *)page_private(page);\n\telse if (unlikely(PageSwapCache(page)))\n\t\treq = nfs_page_search_commits_for_head_request_locked(nfsi,\n\t\t\tpage);\n\n\tif (req) {\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tkref_get(&req->wb_kref);\n\t}\n\n\treturn req;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs_redirty_request(struct nfs_page *req);",
      "static void nfs_clear_request_commit(struct nfs_page *req);",
      "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&req->wb_kref"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "req->wb_head != req"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_page_search_commits_for_head_request_locked",
          "args": [
            "nfsi",
            "page"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_page_search_commits_for_head_request_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "746-768",
          "snippet": "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct nfs_page *freq, *t;\n\tstruct nfs_commit_info cinfo;\n\tstruct inode *inode = &nfsi->vfs_inode;\n\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\n\t/* search through pnfs commit lists */\n\tfreq = pnfs_search_commit_reqs(inode, &cinfo, page);\n\tif (freq)\n\t\treturn freq->wb_head;\n\n\t/* Linearly search the commit list for the correct request */\n\tlist_for_each_entry_safe(freq, t, &cinfo.mds->list, wb_list) {\n\t\tif (freq->wb_page == page)\n\t\t\treturn freq->wb_head;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);",
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page)\n{\n\tstruct nfs_page *freq, *t;\n\tstruct nfs_commit_info cinfo;\n\tstruct inode *inode = &nfsi->vfs_inode;\n\n\tnfs_init_cinfo_from_inode(&cinfo, inode);\n\n\t/* search through pnfs commit lists */\n\tfreq = pnfs_search_commit_reqs(inode, &cinfo, page);\n\tif (freq)\n\t\treturn freq->wb_head;\n\n\t/* Linearly search the commit list for the correct request */\n\tlist_for_each_entry_safe(freq, t, &cinfo.mds->list, wb_list) {\n\t\tif (freq->wb_page == page)\n\t\t\treturn freq->wb_head;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageSwapCache(page)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageSwapCache",
          "args": [
            "page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic struct nfs_page *\nnfs_page_find_head_request_locked(struct nfs_inode *nfsi, struct page *page)\n{\n\tstruct nfs_page *req = NULL;\n\n\tif (PagePrivate(page))\n\t\treq = (struct nfs_page *)page_private(page);\n\telse if (unlikely(PageSwapCache(page)))\n\t\treq = nfs_page_search_commits_for_head_request_locked(nfsi,\n\t\t\tpage);\n\n\tif (req) {\n\t\tWARN_ON_ONCE(req->wb_head != req);\n\t\tkref_get(&req->wb_kref);\n\t}\n\n\treturn req;\n}"
  },
  {
    "function_name": "nfs_context_set_write_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "93-98",
    "snippet": "static void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)\n{\n\tctx->error = error;\n\tsmp_wmb();\n\tset_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFS_CONTEXT_ERROR_WRITE",
            "&ctx->flags"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)\n{\n\tctx->error = error;\n\tsmp_wmb();\n\tset_bit(NFS_CONTEXT_ERROR_WRITE, &ctx->flags);\n}"
  },
  {
    "function_name": "nfs_writehdr_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "88-91",
    "snippet": "static void nfs_writehdr_free(struct nfs_pgio_header *hdr)\n{\n\tmempool_free(hdr, nfs_wdata_mempool);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static mempool_t *nfs_wdata_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "hdr",
            "nfs_wdata_mempool"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic mempool_t *nfs_wdata_mempool;\n\nstatic void nfs_writehdr_free(struct nfs_pgio_header *hdr)\n{\n\tmempool_free(hdr, nfs_wdata_mempool);\n}"
  },
  {
    "function_name": "nfs_writehdr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "79-86",
    "snippet": "static struct nfs_pgio_header *nfs_writehdr_alloc(void)\n{\n\tstruct nfs_pgio_header *p = mempool_alloc(nfs_wdata_mempool, GFP_NOIO);\n\n\tif (p)\n\t\tmemset(p, 0, sizeof(*p));\n\treturn p;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static mempool_t *nfs_wdata_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(*p)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "nfs_wdata_mempool",
            "GFP_NOIO"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic mempool_t *nfs_wdata_mempool;\n\nstatic struct nfs_pgio_header *nfs_writehdr_alloc(void)\n{\n\tstruct nfs_pgio_header *p = mempool_alloc(nfs_wdata_mempool, GFP_NOIO);\n\n\tif (p)\n\t\tmemset(p, 0, sizeof(*p));\n\treturn p;\n}"
  },
  {
    "function_name": "nfs_commit_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "73-76",
    "snippet": "void nfs_commit_free(struct nfs_commit_data *p)\n{\n\tmempool_free(p, nfs_commit_mempool);\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static mempool_t *nfs_commit_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "p",
            "nfs_commit_mempool"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic mempool_t *nfs_commit_mempool;\n\nvoid nfs_commit_free(struct nfs_commit_data *p)\n{\n\tmempool_free(p, nfs_commit_mempool);\n}"
  },
  {
    "function_name": "nfs_commitdata_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
    "lines": "61-70",
    "snippet": "struct nfs_commit_data *nfs_commitdata_alloc(void)\n{\n\tstruct nfs_commit_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOIO);\n\n\tif (p) {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tINIT_LIST_HEAD(&p->pages);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include \"nfstrace.h\"",
      "#include \"pnfs.h\"",
      "#include \"fscache.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"iostat.h\"",
      "#include \"internal.h\"",
      "#include \"delegation.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/export.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/nfs_page.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/migrate.h>",
      "#include <linux/swap.h>",
      "#include <linux/writeback.h>",
      "#include <linux/file.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static mempool_t *nfs_commit_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&p->pages"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(*p)"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "nfs_commit_mempool",
            "GFP_NOIO"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic mempool_t *nfs_commit_mempool;\n\nstruct nfs_commit_data *nfs_commitdata_alloc(void)\n{\n\tstruct nfs_commit_data *p = mempool_alloc(nfs_commit_mempool, GFP_NOIO);\n\n\tif (p) {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tINIT_LIST_HEAD(&p->pages);\n\t}\n\treturn p;\n}"
  }
]