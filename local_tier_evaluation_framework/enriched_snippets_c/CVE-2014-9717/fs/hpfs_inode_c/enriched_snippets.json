[
  {
    "function_name": "hpfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
    "lines": "306-315",
    "snippet": "void hpfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (!inode->i_nlink) {\n\t\thpfs_lock(inode->i_sb);\n\t\thpfs_remove_fnode(inode->i_sb, inode->i_ino);\n\t\thpfs_unlock(inode->i_sb);\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_remove_fnode",
          "args": [
            "inode->i_sb",
            "inode->i_ino"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/anode.c",
          "lines": "480-496",
          "snippet": "void hpfs_remove_fnode(struct super_block *s, fnode_secno fno)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end;\n\tif (!(fnode = hpfs_map_fnode(s, fno, &bh))) return;\n\tif (!fnode_is_dir(fnode)) hpfs_remove_btree(s, &fnode->btree);\n\telse hpfs_remove_dtree(s, le32_to_cpu(fnode->u.external[0].disk_secno));\n\tea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (ea_indirect(ea))\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\thpfs_ea_ext_remove(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l));\n\tbrelse(bh);\n\thpfs_free_sectors(s, fno, 1);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_remove_fnode(struct super_block *s, fnode_secno fno)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end;\n\tif (!(fnode = hpfs_map_fnode(s, fno, &bh))) return;\n\tif (!fnode_is_dir(fnode)) hpfs_remove_btree(s, &fnode->btree);\n\telse hpfs_remove_dtree(s, le32_to_cpu(fnode->u.external[0].disk_secno));\n\tea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (ea_indirect(ea))\n\t\t\thpfs_ea_remove(s, ea_sec(ea), ea_in_anode(ea), ea_len(ea));\n\thpfs_ea_ext_remove(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l));\n\tbrelse(bh);\n\thpfs_free_sectors(s, fno, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (!inode->i_nlink) {\n\t\thpfs_lock(inode->i_sb);\n\t\thpfs_remove_fnode(inode->i_sb, inode->i_ino);\n\t\thpfs_unlock(inode->i_sb);\n\t}\n}"
  },
  {
    "function_name": "hpfs_write_if_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
    "lines": "298-304",
    "snippet": "void hpfs_write_if_changed(struct inode *inode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\n\tif (hpfs_inode->i_dirty)\n\t\thpfs_write_inode(inode);\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_write_inode",
          "args": [
            "inode"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "207-256",
          "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_if_changed(struct inode *inode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(inode);\n\n\tif (hpfs_inode->i_dirty)\n\t\thpfs_write_inode(inode);\n}"
  },
  {
    "function_name": "hpfs_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
    "lines": "258-296",
    "snippet": "int hpfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EINVAL;\n\n\thpfs_lock(inode->i_sb);\n\tif (inode->i_ino == hpfs_sb(inode->i_sb)->sb_root)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_UID) &&\n\t    from_kuid(&init_user_ns, attr->ia_uid) >= 0x10000)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_GID) &&\n\t    from_kgid(&init_user_ns, attr->ia_gid) >= 0x10000)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_SIZE) && attr->ia_size > inode->i_size)\n\t\tgoto out_unlock;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\n\thpfs_write_inode(inode);\n\n out_unlock:\n\thpfs_unlock(inode->i_sb);\n\treturn error;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "inode->i_sb"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_inode",
          "args": [
            "inode"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "207-256",
          "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_truncate",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/file.c",
          "lines": "63-74",
          "snippet": "void hpfs_truncate(struct inode *i)\n{\n\tif (IS_IMMUTABLE(i)) return /*-EPERM*/;\n\thpfs_lock_assert(i->i_sb);\n\n\thpfs_i(i)->i_n_secs = 0;\n\ti->i_blocks = 1 + ((i->i_size + 511) >> 9);\n\thpfs_i(i)->mmu_private = i->i_size;\n\thpfs_truncate_btree(i->i_sb, i->i_ino, 1, ((i->i_size + 511) >> 9));\n\thpfs_write_inode(i);\n\thpfs_i(i)->i_n_secs = 0;\n}",
          "includes": [
            "#include <linux/mpage.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mpage.h>\n#include \"hpfs_fn.h\"\n\nvoid hpfs_truncate(struct inode *i)\n{\n\tif (IS_IMMUTABLE(i)) return /*-EPERM*/;\n\thpfs_lock_assert(i->i_sb);\n\n\thpfs_i(i)->i_n_secs = 0;\n\ti->i_blocks = 1 + ((i->i_size + 511) >> 9);\n\thpfs_i(i)->mmu_private = i->i_size;\n\thpfs_truncate_btree(i->i_sb, i->i_ino, 1, ((i->i_size + 511) >> 9));\n\thpfs_write_inode(i);\n\thpfs_i(i)->i_n_secs = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/inode.c",
          "lines": "823-843",
          "snippet": "static int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/crypto.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/crypto.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n\nstatic int ecryptfs_inode_newsize_ok(struct inode *inode, loff_t offset)\n{\n\tstruct ecryptfs_crypt_stat *crypt_stat;\n\tloff_t lower_oldsize, lower_newsize;\n\n\tcrypt_stat = &ecryptfs_inode_to_private(inode)->crypt_stat;\n\tlower_oldsize = upper_size_to_lower_size(crypt_stat,\n\t\t\t\t\t\t i_size_read(inode));\n\tlower_newsize = upper_size_to_lower_size(crypt_stat, offset);\n\tif (lower_newsize > lower_oldsize) {\n\t\t/*\n\t\t * The eCryptfs inode and the new *lower* size are mixed here\n\t\t * because we may not have the lower i_mutex held and/or it may\n\t\t * not be appropriate to call inode_newsize_ok() with inodes\n\t\t * from other filesystems.\n\t\t */\n\t\treturn inode_newsize_ok(inode, lower_newsize);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "attr->ia_gid"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "attr->ia_uid"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "inode->i_sb"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nint hpfs_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EINVAL;\n\n\thpfs_lock(inode->i_sb);\n\tif (inode->i_ino == hpfs_sb(inode->i_sb)->sb_root)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_UID) &&\n\t    from_kuid(&init_user_ns, attr->ia_uid) >= 0x10000)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_GID) &&\n\t    from_kgid(&init_user_ns, attr->ia_gid) >= 0x10000)\n\t\tgoto out_unlock;\n\tif ((attr->ia_valid & ATTR_SIZE) && attr->ia_size > inode->i_size)\n\t\tgoto out_unlock;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\tgoto out_unlock;\n\n\tif ((attr->ia_valid & ATTR_SIZE) &&\n\t    attr->ia_size != i_size_read(inode)) {\n\t\terror = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\tgoto out_unlock;\n\n\t\ttruncate_setsize(inode, attr->ia_size);\n\t\thpfs_truncate(inode);\n\t}\n\n\tsetattr_copy(inode, attr);\n\n\thpfs_write_inode(inode);\n\n out_unlock:\n\thpfs_unlock(inode->i_sb);\n\treturn error;\n}"
  },
  {
    "function_name": "hpfs_write_inode_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
    "lines": "207-256",
    "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "i->i_sb",
            "\"directory %08lx doesn't have '.' entry\"",
            "(unsigned long)i->i_ino"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "/*hpfs_inode->i_ea_size*/0"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(i->i_sb, i->i_ctime.tv_sec)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmt_to_local",
          "args": [
            "i->i_sb",
            "i->i_ctime.tv_sec"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "gmt_to_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "332-336",
          "snippet": "static inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(i->i_sb, i->i_atime.tv_sec)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(i->i_sb, i->i_mtime.tv_sec)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_dirent",
          "args": [
            "i",
            "hpfs_inode->i_dno",
            "\"\\001\\001\"",
            "2",
            "NULL",
            "&qbh"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "map_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "907-940",
          "snippet": "struct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "i->i_mode"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hpfs_inode->i_ea_size"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(i->i_sb, i->i_ctime.tv_sec)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(i->i_sb, i->i_atime.tv_sec)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(i->i_sb, i->i_mtime.tv_sec)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_write_inode_ea",
          "args": [
            "i",
            "fnode"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "144-178",
          "snippet": "static void hpfs_write_inode_ea(struct inode *i, struct fnode *fnode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\t/*if (le32_to_cpu(fnode->acl_size_l) || le16_to_cpu(fnode->acl_size_s)) {\n\t\t   Some unknown structures like ACL may be in fnode,\n\t\t   we'd better not overwrite them\n\t\thpfs_error(i->i_sb, \"fnode %08x has some unknown HPFS386 structures\", i->i_ino);\n\t} else*/ if (hpfs_sb(i->i_sb)->sb_eas >= 2) {\n\t\t__le32 ea;\n\t\tif (!uid_eq(i->i_uid, hpfs_sb(i->i_sb)->sb_uid) || hpfs_inode->i_ea_uid) {\n\t\t\tea = cpu_to_le32(i_uid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"UID\", (char*)&ea, 2);\n\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t}\n\t\tif (!gid_eq(i->i_gid, hpfs_sb(i->i_sb)->sb_gid) || hpfs_inode->i_ea_gid) {\n\t\t\tea = cpu_to_le32(i_gid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"GID\", (char *)&ea, 2);\n\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t}\n\t\tif (!S_ISLNK(i->i_mode))\n\t\t\tif ((i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0 : 0111))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))\n\t\t\t  && i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0222 : 0333))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))) || hpfs_inode->i_ea_mode) {\n\t\t\t\tea = cpu_to_le32(i->i_mode);\n\t\t\t\t/* sick, but legal */\n\t\t\t\thpfs_set_ea(i, fnode, \"MODE\", (char *)&ea, 2);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\tif (S_ISBLK(i->i_mode) || S_ISCHR(i->i_mode)) {\n\t\t\tea = cpu_to_le32(new_encode_dev(i->i_rdev));\n\t\t\thpfs_set_ea(i, fnode, \"DEV\", (char *)&ea, 4);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nstatic void hpfs_write_inode_ea(struct inode *i, struct fnode *fnode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\t/*if (le32_to_cpu(fnode->acl_size_l) || le16_to_cpu(fnode->acl_size_s)) {\n\t\t   Some unknown structures like ACL may be in fnode,\n\t\t   we'd better not overwrite them\n\t\thpfs_error(i->i_sb, \"fnode %08x has some unknown HPFS386 structures\", i->i_ino);\n\t} else*/ if (hpfs_sb(i->i_sb)->sb_eas >= 2) {\n\t\t__le32 ea;\n\t\tif (!uid_eq(i->i_uid, hpfs_sb(i->i_sb)->sb_uid) || hpfs_inode->i_ea_uid) {\n\t\t\tea = cpu_to_le32(i_uid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"UID\", (char*)&ea, 2);\n\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t}\n\t\tif (!gid_eq(i->i_gid, hpfs_sb(i->i_sb)->sb_gid) || hpfs_inode->i_ea_gid) {\n\t\t\tea = cpu_to_le32(i_gid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"GID\", (char *)&ea, 2);\n\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t}\n\t\tif (!S_ISLNK(i->i_mode))\n\t\t\tif ((i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0 : 0111))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))\n\t\t\t  && i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0222 : 0333))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))) || hpfs_inode->i_ea_mode) {\n\t\t\t\tea = cpu_to_le32(i->i_mode);\n\t\t\t\t/* sick, but legal */\n\t\t\t\thpfs_set_ea(i, fnode, \"MODE\", (char *)&ea, 2);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\tif (S_ISBLK(i->i_mode) || S_ISCHR(i->i_mode)) {\n\t\t\tea = cpu_to_le32(new_encode_dev(i->i_rdev));\n\t\t\thpfs_set_ea(i, fnode, \"DEV\", (char *)&ea, 4);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "i->i_mode"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i->i_size"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i->i_size"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "i->i_mode"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_fnode_dirent",
          "args": [
            "i->i_sb",
            "i->i_ino",
            "fnode",
            "&qbh"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "map_fnode_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "996-1093",
          "snippet": "struct hpfs_dirent *map_fnode_dirent(struct super_block *s, fnode_secno fno,\n\t\t\t\t     struct fnode *f, struct quad_buffer_head *qbh)\n{\n\tunsigned char *name1;\n\tunsigned char *name2;\n\tint name1len, name2len;\n\tstruct dnode *d;\n\tdnode_secno dno, downd;\n\tstruct fnode *upf;\n\tstruct buffer_head *bh;\n\tstruct hpfs_dirent *de, *de_end;\n\tint c;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tname1 = f->name;\n\tif (!(name2 = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't map dirent\\n\");\n\t\treturn NULL;\n\t}\n\tif (f->len <= 15)\n\t\tmemcpy(name2, name1, name1len = name2len = f->len);\n\telse {\n\t\tmemcpy(name2, name1, 15);\n\t\tmemset(name2 + 15, 0xff, 256 - 15);\n\t\t/*name2[15] = 0xff;*/\n\t\tname1len = 15; name2len = 256;\n\t}\n\tif (!(upf = hpfs_map_fnode(s, le32_to_cpu(f->up), &bh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\t\n\tif (!fnode_is_dir(upf)) {\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"fnode %08x has non-directory parent %08x\", fno, le32_to_cpu(f->up));\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tdno = le32_to_cpu(upf->u.external[0].disk_secno);\n\tbrelse(bh);\n\tgo_down:\n\tdownd = 0;\n\tgo_up:\n\tif (!(d = hpfs_map_dnode(s, dno, qbh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tde_end = dnode_end_de(d);\n\tde = dnode_first_de(d);\n\tif (downd) {\n\t\twhile (de < de_end) {\n\t\t\tif (de->down) if (de_down_pointer(de) == downd) goto f;\n\t\t\tde = de_next_de(de);\n\t\t}\n\t\thpfs_error(s, \"pointer to dnode %08x not found in dnode %08x\", downd, dno);\n\t\thpfs_brelse4(qbh);\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tnext_de:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name1, name1len, de->name, de->namelen, de->last);\n\tif (c < 0 && de->down) {\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(qbh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"map_fnode_dirent #1\")) {\n\t\t\t\tkfree(name2);\n\t\t\t\treturn NULL;\n\t\t}\n\t\tgoto go_down;\n\t}\n\tf:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name2, name2len, de->name, de->namelen, de->last);\n\tif (c < 0 && !de->last) goto not_found;\n\tif ((de = de_next_de(de)) < de_end) goto next_de;\n\tif (d->root_dnode) goto not_found;\n\tdownd = dno;\n\tdno = le32_to_cpu(d->up);\n\thpfs_brelse4(qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, downd, &d1, &d2, \"map_fnode_dirent #2\")) {\n\t\t\tkfree(name2);\n\t\t\treturn NULL;\n\t\t}\n\tgoto go_up;\n\tnot_found:\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"dirent for fnode %08x not found\", fno);\n\tkfree(name2);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_fnode_dirent(struct super_block *s, fnode_secno fno,\n\t\t\t\t     struct fnode *f, struct quad_buffer_head *qbh)\n{\n\tunsigned char *name1;\n\tunsigned char *name2;\n\tint name1len, name2len;\n\tstruct dnode *d;\n\tdnode_secno dno, downd;\n\tstruct fnode *upf;\n\tstruct buffer_head *bh;\n\tstruct hpfs_dirent *de, *de_end;\n\tint c;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tname1 = f->name;\n\tif (!(name2 = kmalloc(256, GFP_NOFS))) {\n\t\tpr_err(\"out of memory, can't map dirent\\n\");\n\t\treturn NULL;\n\t}\n\tif (f->len <= 15)\n\t\tmemcpy(name2, name1, name1len = name2len = f->len);\n\telse {\n\t\tmemcpy(name2, name1, 15);\n\t\tmemset(name2 + 15, 0xff, 256 - 15);\n\t\t/*name2[15] = 0xff;*/\n\t\tname1len = 15; name2len = 256;\n\t}\n\tif (!(upf = hpfs_map_fnode(s, le32_to_cpu(f->up), &bh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\t\n\tif (!fnode_is_dir(upf)) {\n\t\tbrelse(bh);\n\t\thpfs_error(s, \"fnode %08x has non-directory parent %08x\", fno, le32_to_cpu(f->up));\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tdno = le32_to_cpu(upf->u.external[0].disk_secno);\n\tbrelse(bh);\n\tgo_down:\n\tdownd = 0;\n\tgo_up:\n\tif (!(d = hpfs_map_dnode(s, dno, qbh))) {\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tde_end = dnode_end_de(d);\n\tde = dnode_first_de(d);\n\tif (downd) {\n\t\twhile (de < de_end) {\n\t\t\tif (de->down) if (de_down_pointer(de) == downd) goto f;\n\t\t\tde = de_next_de(de);\n\t\t}\n\t\thpfs_error(s, \"pointer to dnode %08x not found in dnode %08x\", downd, dno);\n\t\thpfs_brelse4(qbh);\n\t\tkfree(name2);\n\t\treturn NULL;\n\t}\n\tnext_de:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name1, name1len, de->name, de->namelen, de->last);\n\tif (c < 0 && de->down) {\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(qbh);\n\t\tif (hpfs_sb(s)->sb_chk)\n\t\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"map_fnode_dirent #1\")) {\n\t\t\t\tkfree(name2);\n\t\t\t\treturn NULL;\n\t\t}\n\t\tgoto go_down;\n\t}\n\tf:\n\tif (le32_to_cpu(de->fnode) == fno) {\n\t\tkfree(name2);\n\t\treturn de;\n\t}\n\tc = hpfs_compare_names(s, name2, name2len, de->name, de->namelen, de->last);\n\tif (c < 0 && !de->last) goto not_found;\n\tif ((de = de_next_de(de)) < de_end) goto next_de;\n\tif (d->root_dnode) goto not_found;\n\tdownd = dno;\n\tdno = le32_to_cpu(d->up);\n\thpfs_brelse4(qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, downd, &d1, &d2, \"map_fnode_dirent #2\")) {\n\t\t\tkfree(name2);\n\t\t\treturn NULL;\n\t\t}\n\tgoto go_up;\n\tnot_found:\n\thpfs_brelse4(qbh);\n\thpfs_error(s, \"dirent for fnode %08x not found\", fno);\n\tkfree(name2);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "i->i_sb"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "i->i_sb",
            "i->i_ino",
            "&bh"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "hpfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
    "lines": "180-205",
    "snippet": "void hpfs_write_inode(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct inode *parent;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (hpfs_inode->i_rddir_off && !atomic_read(&i->i_count)) {\n\t\tif (*hpfs_inode->i_rddir_off)\n\t\t\tpr_err(\"write_inode: some position still there\\n\");\n\t\tkfree(hpfs_inode->i_rddir_off);\n\t\thpfs_inode->i_rddir_off = NULL;\n\t}\n\tif (!i->i_nlink) {\n\t\treturn;\n\t}\n\tparent = iget_locked(i->i_sb, hpfs_inode->i_parent_dir);\n\tif (parent) {\n\t\thpfs_inode->i_dirty = 0;\n\t\tif (parent->i_state & I_NEW) {\n\t\t\thpfs_init_inode(parent);\n\t\t\thpfs_read_inode(parent);\n\t\t\tunlock_new_inode(parent);\n\t\t}\n\t\thpfs_write_inode_nolock(i);\n\t\tiput(parent);\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "parent"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_inode_nolock",
          "args": [
            "i"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "207-256",
          "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "parent"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_read_inode",
          "args": [
            "parent"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "43-142",
          "snippet": "void hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_init_inode",
          "args": [
            "parent"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "i->i_sb",
            "hpfs_inode->i_parent_dir"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hpfs_inode->i_rddir_off"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"write_inode: some position still there\\n\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&i->i_count"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "i->i_sb"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct inode *parent;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (hpfs_inode->i_rddir_off && !atomic_read(&i->i_count)) {\n\t\tif (*hpfs_inode->i_rddir_off)\n\t\t\tpr_err(\"write_inode: some position still there\\n\");\n\t\tkfree(hpfs_inode->i_rddir_off);\n\t\thpfs_inode->i_rddir_off = NULL;\n\t}\n\tif (!i->i_nlink) {\n\t\treturn;\n\t}\n\tparent = iget_locked(i->i_sb, hpfs_inode->i_parent_dir);\n\tif (parent) {\n\t\thpfs_inode->i_dirty = 0;\n\t\tif (parent->i_state & I_NEW) {\n\t\t\thpfs_init_inode(parent);\n\t\t\thpfs_read_inode(parent);\n\t\t\tunlock_new_inode(parent);\n\t\t}\n\t\thpfs_write_inode_nolock(i);\n\t\tiput(parent);\n\t}\n}"
  },
  {
    "function_name": "hpfs_write_inode_ea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
    "lines": "144-178",
    "snippet": "static void hpfs_write_inode_ea(struct inode *i, struct fnode *fnode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\t/*if (le32_to_cpu(fnode->acl_size_l) || le16_to_cpu(fnode->acl_size_s)) {\n\t\t   Some unknown structures like ACL may be in fnode,\n\t\t   we'd better not overwrite them\n\t\thpfs_error(i->i_sb, \"fnode %08x has some unknown HPFS386 structures\", i->i_ino);\n\t} else*/ if (hpfs_sb(i->i_sb)->sb_eas >= 2) {\n\t\t__le32 ea;\n\t\tif (!uid_eq(i->i_uid, hpfs_sb(i->i_sb)->sb_uid) || hpfs_inode->i_ea_uid) {\n\t\t\tea = cpu_to_le32(i_uid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"UID\", (char*)&ea, 2);\n\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t}\n\t\tif (!gid_eq(i->i_gid, hpfs_sb(i->i_sb)->sb_gid) || hpfs_inode->i_ea_gid) {\n\t\t\tea = cpu_to_le32(i_gid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"GID\", (char *)&ea, 2);\n\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t}\n\t\tif (!S_ISLNK(i->i_mode))\n\t\t\tif ((i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0 : 0111))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))\n\t\t\t  && i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0222 : 0333))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))) || hpfs_inode->i_ea_mode) {\n\t\t\t\tea = cpu_to_le32(i->i_mode);\n\t\t\t\t/* sick, but legal */\n\t\t\t\thpfs_set_ea(i, fnode, \"MODE\", (char *)&ea, 2);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\tif (S_ISBLK(i->i_mode) || S_ISCHR(i->i_mode)) {\n\t\t\tea = cpu_to_le32(new_encode_dev(i->i_rdev));\n\t\t\thpfs_set_ea(i, fnode, \"DEV\", (char *)&ea, 4);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_set_ea",
          "args": [
            "i",
            "fnode",
            "\"DEV\"",
            "(char *)&ea",
            "4"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_set_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
          "lines": "189-366",
          "snippet": "void hpfs_set_ea(struct inode *inode, struct fnode *fnode, const char *key,\n\t\t const char *data, int size)\n{\n\tfnode_secno fno = inode->i_ino;\n\tstruct super_block *s = inode->i_sb;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tunsigned char h[4];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t} else if (ea_valuelen(ea) == size) {\n\t\t\t\tmemcpy(ea_data(ea), data, size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ea_valuelen(ea) == size)\n\t\t\t\t\thpfs_ea_write(s, a, ano, pos + 4 + ea->namelen + 1, size, data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!le16_to_cpu(fnode->ea_offs)) {\n\t\t/*if (le16_to_cpu(fnode->ea_size_s)) {\n\t\t\thpfs_error(s, \"fnode %08x: ea_size_s == %03x, ea_offs == 0\",\n\t\t\t\tinode->i_ino, le16_to_cpu(fnode->ea_size_s));\n\t\t\treturn;\n\t\t}*/\n\t\tfnode->ea_offs = cpu_to_le16(0xc4);\n\t}\n\tif (le16_to_cpu(fnode->ea_offs) < 0xc4 || le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200) {\n\t\thpfs_error(s, \"fnode %08lx: ea_offs == %03x, ea_size_s == %03x\",\n\t\t\t(unsigned long)inode->i_ino,\n\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\treturn;\n\t}\n\tif ((le16_to_cpu(fnode->ea_size_s) || !le32_to_cpu(fnode->ea_size_l)) &&\n\t     le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5 <= 0x200) {\n\t\tea = fnode_end_ea(fnode);\n\t\t*(char *)ea = 0;\n\t\tea->namelen = strlen(key);\n\t\tea->valuelen_lo = size;\n\t\tea->valuelen_hi = size >> 8;\n\t\tstrcpy(ea->name, key);\n\t\tmemcpy(ea_data(ea), data, size);\n\t\tfnode->ea_size_s = cpu_to_le16(le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5);\n\t\tgoto ret;\n\t}\n\t/* Most the code here is 99.9993422% unused. I hope there are no bugs.\n\t   But what .. HPFS.IFS has also bugs in ea management. */\n\tif (le16_to_cpu(fnode->ea_size_s) && !le32_to_cpu(fnode->ea_size_l)) {\n\t\tsecno n;\n\t\tstruct buffer_head *bh;\n\t\tchar *data;\n\t\tif (!(n = hpfs_alloc_sector(s, fno, 1, 0))) return;\n\t\tif (!(data = hpfs_get_sector(s, n, &bh))) {\n\t\t\thpfs_free_sectors(s, n, 1);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data, fnode_ea(fnode), le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_l = cpu_to_le32(le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_s = cpu_to_le16(0);\n\t\tfnode->ea_secno = cpu_to_le32(n);\n\t\tfnode->flags &= ~FNODE_anode;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tpos = le32_to_cpu(fnode->ea_size_l) + 5 + strlen(key) + size;\n\tlen = (le32_to_cpu(fnode->ea_size_l) + 511) >> 9;\n\tif (pos >= 30000) goto bail;\n\twhile (((pos + 511) >> 9) > len) {\n\t\tif (!len) {\n\t\t\tsecno q = hpfs_alloc_sector(s, fno, 1, 0);\n\t\t\tif (!q) goto bail;\n\t\t\tfnode->ea_secno = cpu_to_le32(q);\n\t\t\tfnode->flags &= ~FNODE_anode;\n\t\t\tlen++;\n\t\t} else if (!fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_alloc_if_possible(s, le32_to_cpu(fnode->ea_secno) + len)) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\t/* Aargh... don't know how to create ea anodes :-( */\n\t\t\t\t/*struct buffer_head *bh;\n\t\t\t\tstruct anode *anode;\n\t\t\t\tanode_secno a_s;\n\t\t\t\tif (!(anode = hpfs_alloc_anode(s, fno, &a_s, &bh)))\n\t\t\t\t\tgoto bail;\n\t\t\t\tanode->up = cpu_to_le32(fno);\n\t\t\t\tanode->btree.fnode_parent = 1;\n\t\t\t\tanode->btree.n_free_nodes--;\n\t\t\t\tanode->btree.n_used_nodes++;\n\t\t\t\tanode->btree.first_free = cpu_to_le16(le16_to_cpu(anode->btree.first_free) + 12);\n\t\t\t\tanode->u.external[0].disk_secno = cpu_to_le32(le32_to_cpu(fnode->ea_secno));\n\t\t\t\tanode->u.external[0].file_secno = cpu_to_le32(0);\n\t\t\t\tanode->u.external[0].length = cpu_to_le32(len);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tfnode->flags |= FNODE_anode;\n\t\t\t\tfnode->ea_secno = cpu_to_le32(a_s);*/\n\t\t\t\tsecno new_sec;\n\t\t\t\tint i;\n\t\t\t\tif (!(new_sec = hpfs_alloc_sector(s, fno, 1, 1 - ((pos + 511) >> 9))))\n\t\t\t\t\tgoto bail;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstruct buffer_head *bh1, *bh2;\n\t\t\t\t\tvoid *b1, *b2;\n\t\t\t\t\tif (!(b1 = hpfs_map_sector(s, le32_to_cpu(fnode->ea_secno) + i, &bh1, len - i - 1))) {\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(b2 = hpfs_get_sector(s, new_sec + i, &bh2))) {\n\t\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(b2, b1, 512);\n\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\tmark_buffer_dirty(bh2);\n\t\t\t\t\tbrelse(bh2);\n\t\t\t\t}\n\t\t\t\thpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno), len);\n\t\t\t\tfnode->ea_secno = cpu_to_le32(new_sec);\n\t\t\t\tlen = (pos + 511) >> 9;\n\t\t\t}\n\t\t}\n\t\tif (fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_add_sector_to_btree(s, le32_to_cpu(fnode->ea_secno),\n\t\t\t\t\t\t     0, len) != -1) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\th[0] = 0;\n\th[1] = strlen(key);\n\th[2] = size & 0xff;\n\th[3] = size >> 8;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l), 4, h)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 4, h[1] + 1, key)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 5 + h[1], size, data)) goto bail;\n\tfnode->ea_size_l = cpu_to_le32(pos);\n\tret:\n\thpfs_i(inode)->i_ea_size += 5 + strlen(key) + size;\n\treturn;\n\tbail:\n\tif (le32_to_cpu(fnode->ea_secno))\n\t\tif (fnode_in_anode(fnode)) hpfs_truncate_btree(s, le32_to_cpu(fnode->ea_secno), 1, (le32_to_cpu(fnode->ea_size_l) + 511) >> 9);\n\t\telse hpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9), len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9));\n\telse fnode->ea_secno = fnode->ea_size_l = cpu_to_le32(0);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_set_ea(struct inode *inode, struct fnode *fnode, const char *key,\n\t\t const char *data, int size)\n{\n\tfnode_secno fno = inode->i_ino;\n\tstruct super_block *s = inode->i_sb;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tunsigned char h[4];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t} else if (ea_valuelen(ea) == size) {\n\t\t\t\tmemcpy(ea_data(ea), data, size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ea_valuelen(ea) == size)\n\t\t\t\t\thpfs_ea_write(s, a, ano, pos + 4 + ea->namelen + 1, size, data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!le16_to_cpu(fnode->ea_offs)) {\n\t\t/*if (le16_to_cpu(fnode->ea_size_s)) {\n\t\t\thpfs_error(s, \"fnode %08x: ea_size_s == %03x, ea_offs == 0\",\n\t\t\t\tinode->i_ino, le16_to_cpu(fnode->ea_size_s));\n\t\t\treturn;\n\t\t}*/\n\t\tfnode->ea_offs = cpu_to_le16(0xc4);\n\t}\n\tif (le16_to_cpu(fnode->ea_offs) < 0xc4 || le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200) {\n\t\thpfs_error(s, \"fnode %08lx: ea_offs == %03x, ea_size_s == %03x\",\n\t\t\t(unsigned long)inode->i_ino,\n\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\treturn;\n\t}\n\tif ((le16_to_cpu(fnode->ea_size_s) || !le32_to_cpu(fnode->ea_size_l)) &&\n\t     le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5 <= 0x200) {\n\t\tea = fnode_end_ea(fnode);\n\t\t*(char *)ea = 0;\n\t\tea->namelen = strlen(key);\n\t\tea->valuelen_lo = size;\n\t\tea->valuelen_hi = size >> 8;\n\t\tstrcpy(ea->name, key);\n\t\tmemcpy(ea_data(ea), data, size);\n\t\tfnode->ea_size_s = cpu_to_le16(le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5);\n\t\tgoto ret;\n\t}\n\t/* Most the code here is 99.9993422% unused. I hope there are no bugs.\n\t   But what .. HPFS.IFS has also bugs in ea management. */\n\tif (le16_to_cpu(fnode->ea_size_s) && !le32_to_cpu(fnode->ea_size_l)) {\n\t\tsecno n;\n\t\tstruct buffer_head *bh;\n\t\tchar *data;\n\t\tif (!(n = hpfs_alloc_sector(s, fno, 1, 0))) return;\n\t\tif (!(data = hpfs_get_sector(s, n, &bh))) {\n\t\t\thpfs_free_sectors(s, n, 1);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data, fnode_ea(fnode), le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_l = cpu_to_le32(le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_s = cpu_to_le16(0);\n\t\tfnode->ea_secno = cpu_to_le32(n);\n\t\tfnode->flags &= ~FNODE_anode;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tpos = le32_to_cpu(fnode->ea_size_l) + 5 + strlen(key) + size;\n\tlen = (le32_to_cpu(fnode->ea_size_l) + 511) >> 9;\n\tif (pos >= 30000) goto bail;\n\twhile (((pos + 511) >> 9) > len) {\n\t\tif (!len) {\n\t\t\tsecno q = hpfs_alloc_sector(s, fno, 1, 0);\n\t\t\tif (!q) goto bail;\n\t\t\tfnode->ea_secno = cpu_to_le32(q);\n\t\t\tfnode->flags &= ~FNODE_anode;\n\t\t\tlen++;\n\t\t} else if (!fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_alloc_if_possible(s, le32_to_cpu(fnode->ea_secno) + len)) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\t/* Aargh... don't know how to create ea anodes :-( */\n\t\t\t\t/*struct buffer_head *bh;\n\t\t\t\tstruct anode *anode;\n\t\t\t\tanode_secno a_s;\n\t\t\t\tif (!(anode = hpfs_alloc_anode(s, fno, &a_s, &bh)))\n\t\t\t\t\tgoto bail;\n\t\t\t\tanode->up = cpu_to_le32(fno);\n\t\t\t\tanode->btree.fnode_parent = 1;\n\t\t\t\tanode->btree.n_free_nodes--;\n\t\t\t\tanode->btree.n_used_nodes++;\n\t\t\t\tanode->btree.first_free = cpu_to_le16(le16_to_cpu(anode->btree.first_free) + 12);\n\t\t\t\tanode->u.external[0].disk_secno = cpu_to_le32(le32_to_cpu(fnode->ea_secno));\n\t\t\t\tanode->u.external[0].file_secno = cpu_to_le32(0);\n\t\t\t\tanode->u.external[0].length = cpu_to_le32(len);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tfnode->flags |= FNODE_anode;\n\t\t\t\tfnode->ea_secno = cpu_to_le32(a_s);*/\n\t\t\t\tsecno new_sec;\n\t\t\t\tint i;\n\t\t\t\tif (!(new_sec = hpfs_alloc_sector(s, fno, 1, 1 - ((pos + 511) >> 9))))\n\t\t\t\t\tgoto bail;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstruct buffer_head *bh1, *bh2;\n\t\t\t\t\tvoid *b1, *b2;\n\t\t\t\t\tif (!(b1 = hpfs_map_sector(s, le32_to_cpu(fnode->ea_secno) + i, &bh1, len - i - 1))) {\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(b2 = hpfs_get_sector(s, new_sec + i, &bh2))) {\n\t\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(b2, b1, 512);\n\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\tmark_buffer_dirty(bh2);\n\t\t\t\t\tbrelse(bh2);\n\t\t\t\t}\n\t\t\t\thpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno), len);\n\t\t\t\tfnode->ea_secno = cpu_to_le32(new_sec);\n\t\t\t\tlen = (pos + 511) >> 9;\n\t\t\t}\n\t\t}\n\t\tif (fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_add_sector_to_btree(s, le32_to_cpu(fnode->ea_secno),\n\t\t\t\t\t\t     0, len) != -1) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\th[0] = 0;\n\th[1] = strlen(key);\n\th[2] = size & 0xff;\n\th[3] = size >> 8;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l), 4, h)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 4, h[1] + 1, key)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 5 + h[1], size, data)) goto bail;\n\tfnode->ea_size_l = cpu_to_le32(pos);\n\tret:\n\thpfs_i(inode)->i_ea_size += 5 + strlen(key) + size;\n\treturn;\n\tbail:\n\tif (le32_to_cpu(fnode->ea_secno))\n\t\tif (fnode_in_anode(fnode)) hpfs_truncate_btree(s, le32_to_cpu(fnode->ea_secno), 1, (le32_to_cpu(fnode->ea_size_l) + 511) >> 9);\n\t\telse hpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9), len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9));\n\telse fnode->ea_secno = fnode->ea_size_l = cpu_to_le32(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_encode_dev(i->i_rdev)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "i->i_rdev"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "i->i_mode"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "i->i_mode"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i->i_mode"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "i->i_mode"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "i->i_mode"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "i->i_sb"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "i->i_mode"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "i->i_mode"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "i->i_mode"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_gid_read(i)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "i"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "i->i_gid",
            "hpfs_sb(i->i_sb)->sb_gid"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i_uid_read(i)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "i"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "i->i_uid",
            "hpfs_sb(i->i_sb)->sb_uid"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nstatic void hpfs_write_inode_ea(struct inode *i, struct fnode *fnode)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\t/*if (le32_to_cpu(fnode->acl_size_l) || le16_to_cpu(fnode->acl_size_s)) {\n\t\t   Some unknown structures like ACL may be in fnode,\n\t\t   we'd better not overwrite them\n\t\thpfs_error(i->i_sb, \"fnode %08x has some unknown HPFS386 structures\", i->i_ino);\n\t} else*/ if (hpfs_sb(i->i_sb)->sb_eas >= 2) {\n\t\t__le32 ea;\n\t\tif (!uid_eq(i->i_uid, hpfs_sb(i->i_sb)->sb_uid) || hpfs_inode->i_ea_uid) {\n\t\t\tea = cpu_to_le32(i_uid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"UID\", (char*)&ea, 2);\n\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t}\n\t\tif (!gid_eq(i->i_gid, hpfs_sb(i->i_sb)->sb_gid) || hpfs_inode->i_ea_gid) {\n\t\t\tea = cpu_to_le32(i_gid_read(i));\n\t\t\thpfs_set_ea(i, fnode, \"GID\", (char *)&ea, 2);\n\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t}\n\t\tif (!S_ISLNK(i->i_mode))\n\t\t\tif ((i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0 : 0111))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))\n\t\t\t  && i->i_mode != ((hpfs_sb(i->i_sb)->sb_mode & ~(S_ISDIR(i->i_mode) ? 0222 : 0333))\n\t\t\t  | (S_ISDIR(i->i_mode) ? S_IFDIR : S_IFREG))) || hpfs_inode->i_ea_mode) {\n\t\t\t\tea = cpu_to_le32(i->i_mode);\n\t\t\t\t/* sick, but legal */\n\t\t\t\thpfs_set_ea(i, fnode, \"MODE\", (char *)&ea, 2);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\tif (S_ISBLK(i->i_mode) || S_ISCHR(i->i_mode)) {\n\t\t\tea = cpu_to_le32(new_encode_dev(i->i_rdev));\n\t\t\thpfs_set_ea(i, fnode, \"DEV\", (char *)&ea, 4);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hpfs_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
    "lines": "43-142",
    "snippet": "void hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fnode->file_size"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "i",
            "1"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_count_dnodes",
          "args": [
            "i->i_sb",
            "hpfs_inode->i_dno",
            "&n_dnodes",
            "&n_subdirs",
            "NULL"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_count_dnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "741-792",
          "snippet": "void hpfs_count_dnodes(struct super_block *s, dnode_secno dno, int *n_dnodes,\n\t\t       int *n_subdirs, int *n_items)\n{\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tdnode_secno ptr, odno = 0;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tgo_down:\n\tif (n_dnodes) (*n_dnodes)++;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"hpfs_count_dnodes #1\")) return;\n\tptr = 0;\n\tgo_up:\n\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\tif (hpfs_sb(s)->sb_chk) if (odno && odno != -1 && le32_to_cpu(dnode->up) != odno)\n\t\thpfs_error(s, \"hpfs_count_dnodes: bad up pointer; dnode %08x, down %08x points to %08x\", odno, dno, le32_to_cpu(dnode->up));\n\tde = dnode_first_de(dnode);\n\tif (ptr) while(1) {\n\t\tif (de->down) if (de_down_pointer(de) == ptr) goto process_de;\n\t\tif (de->last) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_error(s, \"hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x\",\n\t\t\t\tptr, dno, odno);\n\t\t\treturn;\n\t\t}\n\t\tde = de_next_de(de);\n\t}\n\tnext_de:\n\tif (de->down) {\n\t\todno = dno;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto go_down;\n\t}\n\tprocess_de:\n\tif (!de->first && !de->last && de->directory && n_subdirs) (*n_subdirs)++;\n\tif (!de->first && !de->last && n_items) (*n_items)++;\n\tif ((de = de_next_de(de)) < dnode_end_de(dnode)) goto next_de;\n\tptr = dno;\n\tdno = le32_to_cpu(dnode->up);\n\tif (dnode->root_dnode) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ptr, &d1, &d2, \"hpfs_count_dnodes #2\")) return;\n\todno = -1;\n\tgoto go_up;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_count_dnodes(struct super_block *s, dnode_secno dno, int *n_dnodes,\n\t\t       int *n_subdirs, int *n_items)\n{\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tdnode_secno ptr, odno = 0;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tgo_down:\n\tif (n_dnodes) (*n_dnodes)++;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"hpfs_count_dnodes #1\")) return;\n\tptr = 0;\n\tgo_up:\n\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\tif (hpfs_sb(s)->sb_chk) if (odno && odno != -1 && le32_to_cpu(dnode->up) != odno)\n\t\thpfs_error(s, \"hpfs_count_dnodes: bad up pointer; dnode %08x, down %08x points to %08x\", odno, dno, le32_to_cpu(dnode->up));\n\tde = dnode_first_de(dnode);\n\tif (ptr) while(1) {\n\t\tif (de->down) if (de_down_pointer(de) == ptr) goto process_de;\n\t\tif (de->last) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_error(s, \"hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x\",\n\t\t\t\tptr, dno, odno);\n\t\t\treturn;\n\t\t}\n\t\tde = de_next_de(de);\n\t}\n\tnext_de:\n\tif (de->down) {\n\t\todno = dno;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto go_down;\n\t}\n\tprocess_de:\n\tif (!de->first && !de->last && de->directory && n_subdirs) (*n_subdirs)++;\n\tif (!de->first && !de->last && n_items) (*n_items)++;\n\tif ((de = de_next_de(de)) < dnode_end_de(dnode)) goto next_de;\n\tptr = dno;\n\tdno = le32_to_cpu(dnode->up);\n\tif (dnode->root_dnode) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ptr, &d1, &d2, \"hpfs_count_dnodes #2\")) return;\n\todno = -1;\n\tgoto go_up;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "sb",
            "hpfs_inode->i_parent_dir",
            "&bh0"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "sb"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fnode_is_dir",
          "args": [
            "fnode"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "fnode_is_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs.h",
          "lines": "480-483",
          "snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool fnode_is_dir(struct fnode *p)\n{\n\treturn (p->flags & FNODE_dir) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "i",
            "mode",
            "new_decode_dev(rdev)"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "rdev"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ea"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_get_ea",
          "args": [
            "i->i_sb",
            "fnode",
            "\"DEV\"",
            "&ea_size"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_get_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
          "lines": "129-181",
          "snippet": "char *hpfs_get_ea(struct super_block *s, struct fnode *fnode, char *key, int *size)\n{\n\tchar *ret;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(ret, ea_data(ea), ea_valuelen(ea));\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return NULL;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn NULL;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), ret)) {\n\t\t\t\tkfree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nchar *hpfs_get_ea(struct super_block *s, struct fnode *fnode, char *key, int *size)\n{\n\tchar *ret;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(ret, ea_data(ea), ea_valuelen(ea));\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return NULL;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn NULL;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\treturn get_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), *size = ea_len(ea));\n\t\t\tif (!(ret = kmalloc((*size = ea_valuelen(ea)) + 1, GFP_NOFS))) {\n\t\t\t\tpr_err(\"out of memory for EA\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), ret)) {\n\t\t\t\tkfree(ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret[ea_valuelen(ea)] = 0;\n\t\t\treturn ret;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ea"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "*(__le16*)ea"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ea"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ea"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "i",
            "le16_to_cpu(*(__le16*)ea)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ea"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "i",
            "le16_to_cpu(*(__le16*)ea)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "i"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_read_inode(struct inode *i)\n{\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tvoid *ea;\n\tint ea_size;\n\n\tif (!(fnode = hpfs_map_fnode(sb, i->i_ino, &bh))) {\n\t\t/*i->i_mode |= S_IFREG;\n\t\ti->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tclear_nlink(i);*/\n\t\tmake_bad_inode(i);\n\t\treturn;\n\t}\n\tif (hpfs_sb(i->i_sb)->sb_eas) {\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"UID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_uid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_uid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"GID\", &ea_size))) {\n\t\t\tif (ea_size == 2) {\n\t\t\t\ti_gid_write(i, le16_to_cpu(*(__le16*)ea));\n\t\t\t\thpfs_inode->i_ea_gid = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"SYMLINK\", &ea_size))) {\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = S_IFLNK | 0777;\n\t\t\ti->i_op = &page_symlink_inode_operations;\n\t\t\ti->i_data.a_ops = &hpfs_symlink_aops;\n\t\t\tset_nlink(i, 1);\n\t\t\ti->i_size = ea_size;\n\t\t\ti->i_blocks = 1;\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"MODE\", &ea_size))) {\n\t\t\tint rdev = 0;\n\t\t\tumode_t mode = hpfs_sb(sb)->sb_mode;\n\t\t\tif (ea_size == 2) {\n\t\t\t\tmode = le16_to_cpu(*(__le16*)ea);\n\t\t\t\thpfs_inode->i_ea_mode = 1;\n\t\t\t}\n\t\t\tkfree(ea);\n\t\t\ti->i_mode = mode;\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode)) {\n\t\t\t\tif ((ea = hpfs_get_ea(i->i_sb, fnode, \"DEV\", &ea_size))) {\n\t\t\t\t\tif (ea_size == 4)\n\t\t\t\t\t\trdev = le32_to_cpu(*(__le32*)ea);\n\t\t\t\t\tkfree(ea);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (S_ISBLK(mode) || S_ISCHR(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tset_nlink(i, 1);\n\t\t\t\ti->i_size = 0;\n\t\t\t\ti->i_blocks = 1;\n\t\t\t\tinit_special_inode(i, mode,\n\t\t\t\t\tnew_decode_dev(rdev));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tif (fnode_is_dir(fnode)) {\n\t\tint n_dnodes, n_subdirs;\n\t\ti->i_mode |= S_IFDIR;\n\t\ti->i_op = &hpfs_dir_iops;\n\t\ti->i_fop = &hpfs_dir_ops;\n\t\thpfs_inode->i_parent_dir = le32_to_cpu(fnode->up);\n\t\thpfs_inode->i_dno = le32_to_cpu(fnode->u.external[0].disk_secno);\n\t\tif (hpfs_sb(sb)->sb_chk >= 2) {\n\t\t\tstruct buffer_head *bh0;\n\t\t\tif (hpfs_map_fnode(sb, hpfs_inode->i_parent_dir, &bh0)) brelse(bh0);\n\t\t}\n\t\tn_dnodes = 0; n_subdirs = 0;\n\t\thpfs_count_dnodes(i->i_sb, hpfs_inode->i_dno, &n_dnodes, &n_subdirs, NULL);\n\t\ti->i_blocks = 4 * n_dnodes;\n\t\ti->i_size = 2048 * n_dnodes;\n\t\tset_nlink(i, 2 + n_subdirs);\n\t} else {\n\t\ti->i_mode |= S_IFREG;\n\t\tif (!hpfs_inode->i_ea_mode) i->i_mode &= ~0111;\n\t\ti->i_op = &hpfs_file_iops;\n\t\ti->i_fop = &hpfs_file_ops;\n\t\tset_nlink(i, 1);\n\t\ti->i_size = le32_to_cpu(fnode->file_size);\n\t\ti->i_blocks = ((i->i_size + 511) >> 9) + 1;\n\t\ti->i_data.a_ops = &hpfs_aops;\n\t\thpfs_i(i)->mmu_private = i->i_size;\n\t}\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "hpfs_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
    "lines": "13-41",
    "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "sb"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
  }
]