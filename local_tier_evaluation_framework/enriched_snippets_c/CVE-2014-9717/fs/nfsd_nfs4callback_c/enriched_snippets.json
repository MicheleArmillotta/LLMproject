[
  {
    "function_name": "nfsd4_run_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "1105-1108",
    "snippet": "void nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *callback_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "callback_wq",
            "&cb->cb_work"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}"
  },
  {
    "function_name": "nfsd4_init_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "1092-1103",
    "snippet": "void nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tINIT_LIST_HEAD(&cb->cb_per_client);\n\tcb->cb_done = true;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cb->cb_per_client"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cb->cb_work",
            "nfsd4_run_cb_work"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};\n\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tstruct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tINIT_LIST_HEAD(&cb->cb_per_client);\n\tcb->cb_done = true;\n}"
  },
  {
    "function_name": "nfsd4_run_cb_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "1066-1090",
    "snippet": "static void\nnfsd4_run_cb_work(struct work_struct *work)\n{\n\tstruct nfsd4_callback *cb =\n\t\tcontainer_of(work, struct nfsd4_callback, cb_work);\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct rpc_clnt *clnt;\n\n\tif (cb->cb_ops && cb->cb_ops->prepare)\n\t\tcb->cb_ops->prepare(cb);\n\n\tif (clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK)\n\t\tnfsd4_process_cb_update(cb);\n\n\tclnt = clp->cl_cb_client;\n\tif (!clnt) {\n\t\t/* Callback channel broken, or client killed; give up: */\n\t\tif (cb->cb_ops && cb->cb_ops->release)\n\t\t\tcb->cb_ops->release(cb);\n\t\treturn;\n\t}\n\tcb->cb_msg.rpc_cred = clp->cl_cb_cred;\n\trpc_call_async(clnt, &cb->cb_msg, RPC_TASK_SOFT | RPC_TASK_SOFTCONN,\n\t\t\tcb->cb_ops ? &nfsd4_cb_ops : &nfsd4_cb_probe_ops, cb);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_call_ops nfsd4_cb_probe_ops = {\n\t/* XXX: release method to ensure we set the cb channel down if\n\t * necessary on early failure? */\n\t.rpc_call_done = nfsd4_cb_probe_done,\n};",
      "static const struct rpc_call_ops nfsd4_cb_ops = {\n\t.rpc_call_prepare = nfsd4_cb_prepare,\n\t.rpc_call_done = nfsd4_cb_done,\n\t.rpc_release = nfsd4_cb_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_call_async",
          "args": [
            "clnt",
            "&cb->cb_msg",
            "RPC_TASK_SOFT | RPC_TASK_SOFTCONN",
            "cb->cb_ops ? &nfsd4_cb_ops : &nfsd4_cb_probe_ops",
            "cb"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb->cb_ops->release",
          "args": [
            "cb"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_process_cb_update",
          "args": [
            "cb"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_process_cb_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1016-1064",
          "snippet": "static void nfsd4_process_cb_update(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_conn conn;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct nfsd4_session *ses = NULL;\n\tstruct nfsd4_conn *c;\n\tint err;\n\n\t/*\n\t * This is either an update, or the client dying; in either case,\n\t * kill the old client:\n\t */\n\tif (clp->cl_cb_client) {\n\t\trpc_shutdown_client(clp->cl_cb_client);\n\t\tclp->cl_cb_client = NULL;\n\t\tput_rpccred(clp->cl_cb_cred);\n\t\tclp->cl_cb_cred = NULL;\n\t}\n\tif (clp->cl_cb_conn.cb_xprt) {\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\t\tclp->cl_cb_conn.cb_xprt = NULL;\n\t}\n\tif (test_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags))\n\t\treturn;\n\tspin_lock(&clp->cl_lock);\n\t/*\n\t * Only serialized callback code is allowed to clear these\n\t * flags; main nfsd code can only set them:\n\t */\n\tBUG_ON(!(clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK));\n\tclear_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\n\tmemcpy(&conn, &cb->cb_clp->cl_cb_conn, sizeof(struct nfs4_cb_conn));\n\tc = __nfsd4_find_backchannel(clp);\n\tif (c) {\n\t\tsvc_xprt_get(c->cn_xprt);\n\t\tconn.cb_xprt = c->cn_xprt;\n\t\tses = c->cn_session;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\terr = setup_callback_client(clp, &conn, ses);\n\tif (err) {\n\t\tnfsd4_mark_cb_down(clp, err);\n\t\treturn;\n\t}\n\t/* Yay, the callback channel's back! Restart any callbacks: */\n\tlist_for_each_entry(cb, &clp->cl_callbacks, cb_per_client)\n\t\tqueue_work(callback_wq, &cb->cb_work);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nstatic void nfsd4_process_cb_update(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_conn conn;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct nfsd4_session *ses = NULL;\n\tstruct nfsd4_conn *c;\n\tint err;\n\n\t/*\n\t * This is either an update, or the client dying; in either case,\n\t * kill the old client:\n\t */\n\tif (clp->cl_cb_client) {\n\t\trpc_shutdown_client(clp->cl_cb_client);\n\t\tclp->cl_cb_client = NULL;\n\t\tput_rpccred(clp->cl_cb_cred);\n\t\tclp->cl_cb_cred = NULL;\n\t}\n\tif (clp->cl_cb_conn.cb_xprt) {\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\t\tclp->cl_cb_conn.cb_xprt = NULL;\n\t}\n\tif (test_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags))\n\t\treturn;\n\tspin_lock(&clp->cl_lock);\n\t/*\n\t * Only serialized callback code is allowed to clear these\n\t * flags; main nfsd code can only set them:\n\t */\n\tBUG_ON(!(clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK));\n\tclear_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\n\tmemcpy(&conn, &cb->cb_clp->cl_cb_conn, sizeof(struct nfs4_cb_conn));\n\tc = __nfsd4_find_backchannel(clp);\n\tif (c) {\n\t\tsvc_xprt_get(c->cn_xprt);\n\t\tconn.cb_xprt = c->cn_xprt;\n\t\tses = c->cn_session;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\terr = setup_callback_client(clp, &conn, ses);\n\tif (err) {\n\t\tnfsd4_mark_cb_down(clp, err);\n\t\treturn;\n\t}\n\t/* Yay, the callback channel's back! Restart any callbacks: */\n\tlist_for_each_entry(cb, &clp->cl_callbacks, cb_per_client)\n\t\tqueue_work(callback_wq, &cb->cb_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb->cb_ops->prepare",
          "args": [
            "cb"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structnfsd4_callback",
            "cb_work"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic const struct rpc_call_ops nfsd4_cb_probe_ops = {\n\t/* XXX: release method to ensure we set the cb channel down if\n\t * necessary on early failure? */\n\t.rpc_call_done = nfsd4_cb_probe_done,\n};\nstatic const struct rpc_call_ops nfsd4_cb_ops = {\n\t.rpc_call_prepare = nfsd4_cb_prepare,\n\t.rpc_call_done = nfsd4_cb_done,\n\t.rpc_release = nfsd4_cb_release,\n};\n\nstatic void\nnfsd4_run_cb_work(struct work_struct *work)\n{\n\tstruct nfsd4_callback *cb =\n\t\tcontainer_of(work, struct nfsd4_callback, cb_work);\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct rpc_clnt *clnt;\n\n\tif (cb->cb_ops && cb->cb_ops->prepare)\n\t\tcb->cb_ops->prepare(cb);\n\n\tif (clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK)\n\t\tnfsd4_process_cb_update(cb);\n\n\tclnt = clp->cl_cb_client;\n\tif (!clnt) {\n\t\t/* Callback channel broken, or client killed; give up: */\n\t\tif (cb->cb_ops && cb->cb_ops->release)\n\t\t\tcb->cb_ops->release(cb);\n\t\treturn;\n\t}\n\tcb->cb_msg.rpc_cred = clp->cl_cb_cred;\n\trpc_call_async(clnt, &cb->cb_msg, RPC_TASK_SOFT | RPC_TASK_SOFTCONN,\n\t\t\tcb->cb_ops ? &nfsd4_cb_ops : &nfsd4_cb_probe_ops, cb);\n}"
  },
  {
    "function_name": "nfsd4_process_cb_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "1016-1064",
    "snippet": "static void nfsd4_process_cb_update(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_conn conn;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct nfsd4_session *ses = NULL;\n\tstruct nfsd4_conn *c;\n\tint err;\n\n\t/*\n\t * This is either an update, or the client dying; in either case,\n\t * kill the old client:\n\t */\n\tif (clp->cl_cb_client) {\n\t\trpc_shutdown_client(clp->cl_cb_client);\n\t\tclp->cl_cb_client = NULL;\n\t\tput_rpccred(clp->cl_cb_cred);\n\t\tclp->cl_cb_cred = NULL;\n\t}\n\tif (clp->cl_cb_conn.cb_xprt) {\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\t\tclp->cl_cb_conn.cb_xprt = NULL;\n\t}\n\tif (test_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags))\n\t\treturn;\n\tspin_lock(&clp->cl_lock);\n\t/*\n\t * Only serialized callback code is allowed to clear these\n\t * flags; main nfsd code can only set them:\n\t */\n\tBUG_ON(!(clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK));\n\tclear_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\n\tmemcpy(&conn, &cb->cb_clp->cl_cb_conn, sizeof(struct nfs4_cb_conn));\n\tc = __nfsd4_find_backchannel(clp);\n\tif (c) {\n\t\tsvc_xprt_get(c->cn_xprt);\n\t\tconn.cb_xprt = c->cn_xprt;\n\t\tses = c->cn_session;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\terr = setup_callback_client(clp, &conn, ses);\n\tif (err) {\n\t\tnfsd4_mark_cb_down(clp, err);\n\t\treturn;\n\t}\n\t/* Yay, the callback channel's back! Restart any callbacks: */\n\tlist_for_each_entry(cb, &clp->cl_callbacks, cb_per_client)\n\t\tqueue_work(callback_wq, &cb->cb_work);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *callback_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "callback_wq",
            "&cb->cb_work"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cb",
            "&clp->cl_callbacks",
            "cb_per_client"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_mark_cb_down",
          "args": [
            "clp",
            "err"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_mark_cb_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "812-816",
          "snippet": "static void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_DOWN;\n\twarn_no_callback_path(clp, reason);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_DOWN;\n\twarn_no_callback_path(clp, reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_callback_client",
          "args": [
            "clp",
            "&conn",
            "ses"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "setup_callback_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "748-804",
          "snippet": "static int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *conn, struct nfsd4_session *ses)\n{\n\tint maxtime = max_cb_time(clp->net);\n\tstruct rpc_timeout\ttimeparms = {\n\t\t.to_initval\t= maxtime,\n\t\t.to_retries\t= 0,\n\t\t.to_maxval\t= maxtime,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= clp->net,\n\t\t.address\t= (struct sockaddr *) &conn->cb_addr,\n\t\t.addrsize\t= conn->cb_addrlen,\n\t\t.saddress\t= (struct sockaddr *) &conn->cb_saddr,\n\t\t.timeout\t= &timeparms,\n\t\t.program\t= &cb_program,\n\t\t.version\t= 0,\n\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING | RPC_CLNT_CREATE_QUIET),\n\t};\n\tstruct rpc_clnt *client;\n\tstruct rpc_cred *cred;\n\n\tif (clp->cl_minorversion == 0) {\n\t\tif (!clp->cl_cred.cr_principal &&\n\t\t\t\t(clp->cl_cred.cr_flavor >= RPC_AUTH_GSS_KRB5))\n\t\t\treturn -EINVAL;\n\t\targs.client_name = clp->cl_cred.cr_principal;\n\t\targs.prognumber\t= conn->cb_prog;\n\t\targs.protocol = XPRT_TRANSPORT_TCP;\n\t\targs.authflavor = clp->cl_cred.cr_flavor;\n\t\tclp->cl_cb_ident = conn->cb_ident;\n\t} else {\n\t\tif (!conn->cb_xprt)\n\t\t\treturn -EINVAL;\n\t\tclp->cl_cb_conn.cb_xprt = conn->cb_xprt;\n\t\tclp->cl_cb_session = ses;\n\t\targs.bc_xprt = conn->cb_xprt;\n\t\targs.prognumber = clp->cl_cb_session->se_cb_prog;\n\t\targs.protocol = conn->cb_xprt->xpt_class->xcl_ident |\n\t\t\t\tXPRT_TRANSPORT_BC;\n\t\targs.authflavor = ses->se_cb_sec.flavor;\n\t}\n\t/* Create RPC client */\n\tclient = create_backchannel_client(&args);\n\tif (IS_ERR(client)) {\n\t\tdprintk(\"NFSD: couldn't create callback client: %ld\\n\",\n\t\t\tPTR_ERR(client));\n\t\treturn PTR_ERR(client);\n\t}\n\tcred = get_backchannel_cred(clp, client, ses);\n\tif (IS_ERR(cred)) {\n\t\trpc_shutdown_client(client);\n\t\treturn PTR_ERR(cred);\n\t}\n\tclp->cl_cb_client = client;\n\tclp->cl_cb_cred = cred;\n\treturn 0;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct rpc_program cb_program;",
            "static const struct rpc_program cb_program = {\n\t.name\t\t\t= \"nfs4_cb\",\n\t.number\t\t\t= NFS4_CALLBACK,\n\t.nrvers\t\t\t= ARRAY_SIZE(nfs_cb_version),\n\t.version\t\t= nfs_cb_version,\n\t.stats\t\t\t= &cb_stats,\n\t.pipe_dir_name\t\t= \"nfsd4_cb\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic const struct rpc_program cb_program;\nstatic const struct rpc_program cb_program = {\n\t.name\t\t\t= \"nfs4_cb\",\n\t.number\t\t\t= NFS4_CALLBACK,\n\t.nrvers\t\t\t= ARRAY_SIZE(nfs_cb_version),\n\t.version\t\t= nfs_cb_version,\n\t.stats\t\t\t= &cb_stats,\n\t.pipe_dir_name\t\t= \"nfsd4_cb\",\n};\n\nstatic int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *conn, struct nfsd4_session *ses)\n{\n\tint maxtime = max_cb_time(clp->net);\n\tstruct rpc_timeout\ttimeparms = {\n\t\t.to_initval\t= maxtime,\n\t\t.to_retries\t= 0,\n\t\t.to_maxval\t= maxtime,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= clp->net,\n\t\t.address\t= (struct sockaddr *) &conn->cb_addr,\n\t\t.addrsize\t= conn->cb_addrlen,\n\t\t.saddress\t= (struct sockaddr *) &conn->cb_saddr,\n\t\t.timeout\t= &timeparms,\n\t\t.program\t= &cb_program,\n\t\t.version\t= 0,\n\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING | RPC_CLNT_CREATE_QUIET),\n\t};\n\tstruct rpc_clnt *client;\n\tstruct rpc_cred *cred;\n\n\tif (clp->cl_minorversion == 0) {\n\t\tif (!clp->cl_cred.cr_principal &&\n\t\t\t\t(clp->cl_cred.cr_flavor >= RPC_AUTH_GSS_KRB5))\n\t\t\treturn -EINVAL;\n\t\targs.client_name = clp->cl_cred.cr_principal;\n\t\targs.prognumber\t= conn->cb_prog;\n\t\targs.protocol = XPRT_TRANSPORT_TCP;\n\t\targs.authflavor = clp->cl_cred.cr_flavor;\n\t\tclp->cl_cb_ident = conn->cb_ident;\n\t} else {\n\t\tif (!conn->cb_xprt)\n\t\t\treturn -EINVAL;\n\t\tclp->cl_cb_conn.cb_xprt = conn->cb_xprt;\n\t\tclp->cl_cb_session = ses;\n\t\targs.bc_xprt = conn->cb_xprt;\n\t\targs.prognumber = clp->cl_cb_session->se_cb_prog;\n\t\targs.protocol = conn->cb_xprt->xpt_class->xcl_ident |\n\t\t\t\tXPRT_TRANSPORT_BC;\n\t\targs.authflavor = ses->se_cb_sec.flavor;\n\t}\n\t/* Create RPC client */\n\tclient = create_backchannel_client(&args);\n\tif (IS_ERR(client)) {\n\t\tdprintk(\"NFSD: couldn't create callback client: %ld\\n\",\n\t\t\tPTR_ERR(client));\n\t\treturn PTR_ERR(client);\n\t}\n\tcred = get_backchannel_cred(clp, client, ses);\n\tif (IS_ERR(cred)) {\n\t\trpc_shutdown_client(client);\n\t\treturn PTR_ERR(cred);\n\t}\n\tclp->cl_cb_client = client;\n\tclp->cl_cb_cred = cred;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_xprt_get",
          "args": [
            "c->cn_xprt"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfsd4_find_backchannel",
          "args": [
            "clp"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "__nfsd4_find_backchannel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1002-1014",
          "snippet": "static struct nfsd4_conn * __nfsd4_find_backchannel(struct nfs4_client *clp)\n{\n\tstruct nfsd4_session *s;\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(s, &clp->cl_sessions, se_perclnt) {\n\t\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\t\tif (c->cn_flags & NFS4_CDFC4_BACK)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct nfsd4_conn * __nfsd4_find_backchannel(struct nfs4_client *clp)\n{\n\tstruct nfsd4_session *s;\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(s, &clp->cl_sessions, se_perclnt) {\n\t\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\t\tif (c->cn_flags & NFS4_CDFC4_BACK)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&conn",
            "&cb->cb_clp->cl_cb_conn",
            "sizeof(struct nfs4_cb_conn)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_CB_UPDATE",
            "&clp->cl_flags"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK)"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_CB_KILL",
            "&clp->cl_flags"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_xprt_put",
          "args": [
            "clp->cl_cb_conn.cb_xprt"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "clp->cl_cb_cred"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "clp->cl_cb_client"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nstatic void nfsd4_process_cb_update(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_conn conn;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tstruct nfsd4_session *ses = NULL;\n\tstruct nfsd4_conn *c;\n\tint err;\n\n\t/*\n\t * This is either an update, or the client dying; in either case,\n\t * kill the old client:\n\t */\n\tif (clp->cl_cb_client) {\n\t\trpc_shutdown_client(clp->cl_cb_client);\n\t\tclp->cl_cb_client = NULL;\n\t\tput_rpccred(clp->cl_cb_cred);\n\t\tclp->cl_cb_cred = NULL;\n\t}\n\tif (clp->cl_cb_conn.cb_xprt) {\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\t\tclp->cl_cb_conn.cb_xprt = NULL;\n\t}\n\tif (test_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags))\n\t\treturn;\n\tspin_lock(&clp->cl_lock);\n\t/*\n\t * Only serialized callback code is allowed to clear these\n\t * flags; main nfsd code can only set them:\n\t */\n\tBUG_ON(!(clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK));\n\tclear_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\n\tmemcpy(&conn, &cb->cb_clp->cl_cb_conn, sizeof(struct nfs4_cb_conn));\n\tc = __nfsd4_find_backchannel(clp);\n\tif (c) {\n\t\tsvc_xprt_get(c->cn_xprt);\n\t\tconn.cb_xprt = c->cn_xprt;\n\t\tses = c->cn_session;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\terr = setup_callback_client(clp, &conn, ses);\n\tif (err) {\n\t\tnfsd4_mark_cb_down(clp, err);\n\t\treturn;\n\t}\n\t/* Yay, the callback channel's back! Restart any callbacks: */\n\tlist_for_each_entry(cb, &clp->cl_callbacks, cb_per_client)\n\t\tqueue_work(callback_wq, &cb->cb_work);\n}"
  },
  {
    "function_name": "__nfsd4_find_backchannel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "1002-1014",
    "snippet": "static struct nfsd4_conn * __nfsd4_find_backchannel(struct nfs4_client *clp)\n{\n\tstruct nfsd4_session *s;\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(s, &clp->cl_sessions, se_perclnt) {\n\t\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\t\tif (c->cn_flags & NFS4_CDFC4_BACK)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "c",
            "&s->se_conns",
            "cn_persession"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&clp->cl_sessions",
            "se_perclnt"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct nfsd4_conn * __nfsd4_find_backchannel(struct nfs4_client *clp)\n{\n\tstruct nfsd4_session *s;\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(s, &clp->cl_sessions, se_perclnt) {\n\t\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\t\tif (c->cn_flags & NFS4_CDFC4_BACK)\n\t\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfsd4_shutdown_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "989-999",
    "snippet": "void nfsd4_shutdown_callback(struct nfs4_client *clp)\n{\n\tset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\n\t/*\n\t * Note this won't actually result in a null callback;\n\t * instead, nfsd4_run_cb_null() will detect the killed\n\t * client, destroy the rpc client, and stop:\n\t */\n\tnfsd4_run_cb(&clp->cl_cb_null);\n\tflush_workqueue(callback_wq);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *callback_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "callback_wq"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_run_cb",
          "args": [
            "&clp->cl_cb_null"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_run_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1105-1108",
          "snippet": "void nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_CB_KILL",
            "&clp->cl_flags"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_shutdown_callback(struct nfs4_client *clp)\n{\n\tset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\n\t/*\n\t * Note this won't actually result in a null callback;\n\t * instead, nfsd4_run_cb_null() will detect the killed\n\t * client, destroy the rpc client, and stop:\n\t */\n\tnfsd4_run_cb(&clp->cl_cb_null);\n\tflush_workqueue(callback_wq);\n}"
  },
  {
    "function_name": "nfsd4_destroy_callback_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "983-986",
    "snippet": "void nfsd4_destroy_callback_queue(void)\n{\n\tdestroy_workqueue(callback_wq);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *callback_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "callback_wq"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_destroy_callback_queue(void)\n{\n\tdestroy_workqueue(callback_wq);\n}"
  },
  {
    "function_name": "nfsd4_create_callback_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "975-981",
    "snippet": "int nfsd4_create_callback_queue(void)\n{\n\tcallback_wq = create_singlethread_workqueue(\"nfsd4_callbacks\");\n\tif (!callback_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *callback_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_singlethread_workqueue",
          "args": [
            "\"nfsd4_callbacks\""
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nint nfsd4_create_callback_queue(void)\n{\n\tcallback_wq = create_singlethread_workqueue(\"nfsd4_callbacks\");\n\tif (!callback_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_cb_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "955-967",
    "snippet": "static void nfsd4_cb_release(void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\n\tif (cb->cb_done) {\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del(&cb->cb_per_client);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tcb->cb_ops->release(cb);\n\t}\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cb->cb_ops->release",
          "args": [
            "cb"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cb->cb_per_client"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_cb_release(void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\n\tif (cb->cb_done) {\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_del(&cb->cb_per_client);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tcb->cb_ops->release(cb);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cb_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "911-953",
    "snippet": "static void nfsd4_cb_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\n\tdprintk(\"%s: minorversion=%d\\n\", __func__,\n\t\tclp->cl_minorversion);\n\n\tif (clp->cl_minorversion) {\n\t\t/* No need for lock, access serialized in nfsd4_cb_prepare */\n\t\t++clp->cl_cb_session->se_cb_seq_nr;\n\t\tclear_bit(0, &clp->cl_cb_slot_busy);\n\t\trpc_wake_up_next(&clp->cl_cb_waitq);\n\t\tdprintk(\"%s: freed slot, new seqid=%d\\n\", __func__,\n\t\t\tclp->cl_cb_session->se_cb_seq_nr);\n\t}\n\n\tif (clp->cl_cb_client != task->tk_client) {\n\t\t/* We're shutting down or changing cl_cb_client; leave\n\t\t * it to nfsd4_process_cb_update to restart the call if\n\t\t * necessary. */\n\t\treturn;\n\t}\n\n\tif (cb->cb_done)\n\t\treturn;\n\n\tswitch (cb->cb_ops->done(cb, task)) {\n\tcase 0:\n\t\ttask->tk_status = 0;\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\tcase 1:\n\t\tbreak;\n\tcase -1:\n\t\t/* Network partition? */\n\t\tnfsd4_mark_cb_down(clp, task->tk_status);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tcb->cb_done = true;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_mark_cb_down",
          "args": [
            "clp",
            "task->tk_status"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_mark_cb_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "812-816",
          "snippet": "static void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_DOWN;\n\twarn_no_callback_path(clp, reason);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_DOWN;\n\twarn_no_callback_path(clp, reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_restart_call_prepare",
          "args": [
            "task"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb->cb_ops->done",
          "args": [
            "cb",
            "task"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: freed slot, new seqid=%d\\n\"",
            "__func__",
            "clp->cl_cb_session->se_cb_seq_nr"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_wake_up_next",
          "args": [
            "&clp->cl_cb_waitq"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "0",
            "&clp->cl_cb_slot_busy"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: minorversion=%d\\n\"",
            "__func__",
            "clp->cl_minorversion"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_cb_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\n\tdprintk(\"%s: minorversion=%d\\n\", __func__,\n\t\tclp->cl_minorversion);\n\n\tif (clp->cl_minorversion) {\n\t\t/* No need for lock, access serialized in nfsd4_cb_prepare */\n\t\t++clp->cl_cb_session->se_cb_seq_nr;\n\t\tclear_bit(0, &clp->cl_cb_slot_busy);\n\t\trpc_wake_up_next(&clp->cl_cb_waitq);\n\t\tdprintk(\"%s: freed slot, new seqid=%d\\n\", __func__,\n\t\t\tclp->cl_cb_session->se_cb_seq_nr);\n\t}\n\n\tif (clp->cl_cb_client != task->tk_client) {\n\t\t/* We're shutting down or changing cl_cb_client; leave\n\t\t * it to nfsd4_process_cb_update to restart the call if\n\t\t * necessary. */\n\t\treturn;\n\t}\n\n\tif (cb->cb_done)\n\t\treturn;\n\n\tswitch (cb->cb_ops->done(cb, task)) {\n\tcase 0:\n\t\ttask->tk_status = 0;\n\t\trpc_restart_call_prepare(task);\n\t\treturn;\n\tcase 1:\n\t\tbreak;\n\tcase -1:\n\t\t/* Network partition? */\n\t\tnfsd4_mark_cb_down(clp, task->tk_status);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tcb->cb_done = true;\n}"
  },
  {
    "function_name": "nfsd4_cb_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "890-909",
    "snippet": "static void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tu32 minorversion = clp->cl_minorversion;\n\n\tcb->cb_minorversion = minorversion;\n\tif (minorversion) {\n\t\tif (!nfsd41_cb_get_slot(clp, task))\n\t\t\treturn;\n\t}\n\tspin_lock(&clp->cl_lock);\n\tif (list_empty(&cb->cb_per_client)) {\n\t\t/* This is the first call, not a restart */\n\t\tcb->cb_done = false;\n\t\tlist_add(&cb->cb_per_client, &clp->cl_callbacks);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\trpc_call_start(task);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_call_start",
          "args": [
            "task"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&cb->cb_per_client",
            "&clp->cl_callbacks"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cb->cb_per_client"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd41_cb_get_slot",
          "args": [
            "clp",
            "task"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd41_cb_get_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "872-884",
          "snippet": "static bool nfsd41_cb_get_slot(struct nfs4_client *clp, struct rpc_task *task)\n{\n\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\trpc_sleep_on(&clp->cl_cb_waitq, task, NULL);\n\t\t/* Race breaker */\n\t\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\t\tdprintk(\"%s slot is busy\\n\", __func__);\n\t\t\treturn false;\n\t\t}\n\t\trpc_wake_up_queued_task(&clp->cl_cb_waitq, task);\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic bool nfsd41_cb_get_slot(struct nfs4_client *clp, struct rpc_task *task)\n{\n\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\trpc_sleep_on(&clp->cl_cb_waitq, task, NULL);\n\t\t/* Race breaker */\n\t\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\t\tdprintk(\"%s slot is busy\\n\", __func__);\n\t\t\treturn false;\n\t\t}\n\t\trpc_wake_up_queued_task(&clp->cl_cb_waitq, task);\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfsd4_callback *cb = calldata;\n\tstruct nfs4_client *clp = cb->cb_clp;\n\tu32 minorversion = clp->cl_minorversion;\n\n\tcb->cb_minorversion = minorversion;\n\tif (minorversion) {\n\t\tif (!nfsd41_cb_get_slot(clp, task))\n\t\t\treturn;\n\t}\n\tspin_lock(&clp->cl_lock);\n\tif (list_empty(&cb->cb_per_client)) {\n\t\t/* This is the first call, not a restart */\n\t\tcb->cb_done = false;\n\t\tlist_add(&cb->cb_per_client, &clp->cl_callbacks);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\trpc_call_start(task);\n}"
  },
  {
    "function_name": "nfsd41_cb_get_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "872-884",
    "snippet": "static bool nfsd41_cb_get_slot(struct nfs4_client *clp, struct rpc_task *task)\n{\n\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\trpc_sleep_on(&clp->cl_cb_waitq, task, NULL);\n\t\t/* Race breaker */\n\t\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\t\tdprintk(\"%s slot is busy\\n\", __func__);\n\t\t\treturn false;\n\t\t}\n\t\trpc_wake_up_queued_task(&clp->cl_cb_waitq, task);\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_wake_up_queued_task",
          "args": [
            "&clp->cl_cb_waitq",
            "task"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s slot is busy\\n\"",
            "__func__"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&clp->cl_cb_slot_busy"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_sleep_on",
          "args": [
            "&clp->cl_cb_waitq",
            "task",
            "NULL"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic bool nfsd41_cb_get_slot(struct nfs4_client *clp, struct rpc_task *task)\n{\n\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\trpc_sleep_on(&clp->cl_cb_waitq, task, NULL);\n\t\t/* Race breaker */\n\t\tif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\n\t\t\tdprintk(\"%s slot is busy\\n\", __func__);\n\t\t\treturn false;\n\t\t}\n\t\trpc_wake_up_queued_task(&clp->cl_cb_waitq, task);\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "nfsd4_change_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "859-865",
    "snippet": "void nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\n{\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tspin_lock(&clp->cl_lock);\n\tmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&clp->cl_cb_conn",
            "conn",
            "sizeof(struct nfs4_cb_conn)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nvoid nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\n{\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tspin_lock(&clp->cl_lock);\n\tmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "nfsd4_probe_callback_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "853-857",
    "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *callback_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "callback_wq"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_probe_callback",
          "args": [
            "clp"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "853-857",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
  },
  {
    "function_name": "nfsd4_probe_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "846-851",
    "snippet": "void nfsd4_probe_callback(struct nfs4_client *clp)\n{\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tset_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\n\tnfsd4_run_cb(&clp->cl_cb_null);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_run_cb",
          "args": [
            "&clp->cl_cb_null"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_run_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "1105-1108",
          "snippet": "void nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_CB_UPDATE",
            "&clp->cl_flags"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nvoid nfsd4_probe_callback(struct nfs4_client *clp)\n{\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tset_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\n\tnfsd4_run_cb(&clp->cl_cb_null);\n}"
  },
  {
    "function_name": "nfsd4_cb_probe_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "824-832",
    "snippet": "static void nfsd4_cb_probe_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_client *clp = container_of(calldata, struct nfs4_client, cl_cb_null);\n\n\tif (task->tk_status)\n\t\tnfsd4_mark_cb_down(clp, task->tk_status);\n\telse\n\t\tclp->cl_cb_state = NFSD4_CB_UP;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_mark_cb_down",
          "args": [
            "clp",
            "task->tk_status"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_mark_cb_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "812-816",
          "snippet": "static void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_DOWN;\n\twarn_no_callback_path(clp, reason);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_DOWN;\n\twarn_no_callback_path(clp, reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "calldata",
            "structnfs4_client",
            "cl_cb_null"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_cb_probe_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_client *clp = container_of(calldata, struct nfs4_client, cl_cb_null);\n\n\tif (task->tk_status)\n\t\tnfsd4_mark_cb_down(clp, task->tk_status);\n\telse\n\t\tclp->cl_cb_state = NFSD4_CB_UP;\n}"
  },
  {
    "function_name": "nfsd4_mark_cb_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "818-822",
    "snippet": "static void nfsd4_mark_cb_fault(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_FAULT;\n\twarn_no_callback_path(clp, reason);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "warn_no_callback_path",
          "args": [
            "clp",
            "reason"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "warn_no_callback_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "806-810",
          "snippet": "static void warn_no_callback_path(struct nfs4_client *clp, int reason)\n{\n\tdprintk(\"NFSD: warning: no callback path to client %.*s: error %d\\n\",\n\t\t(int)clp->cl_name.len, clp->cl_name.data, reason);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void warn_no_callback_path(struct nfs4_client *clp, int reason)\n{\n\tdprintk(\"NFSD: warning: no callback path to client %.*s: error %d\\n\",\n\t\t(int)clp->cl_name.len, clp->cl_name.data, reason);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_FAULT;\n\twarn_no_callback_path(clp, reason);\n}"
  },
  {
    "function_name": "nfsd4_mark_cb_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "812-816",
    "snippet": "static void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_DOWN;\n\twarn_no_callback_path(clp, reason);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "warn_no_callback_path",
          "args": [
            "clp",
            "reason"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "warn_no_callback_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "806-810",
          "snippet": "static void warn_no_callback_path(struct nfs4_client *clp, int reason)\n{\n\tdprintk(\"NFSD: warning: no callback path to client %.*s: error %d\\n\",\n\t\t(int)clp->cl_name.len, clp->cl_name.data, reason);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void warn_no_callback_path(struct nfs4_client *clp, int reason)\n{\n\tdprintk(\"NFSD: warning: no callback path to client %.*s: error %d\\n\",\n\t\t(int)clp->cl_name.len, clp->cl_name.data, reason);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_DOWN;\n\twarn_no_callback_path(clp, reason);\n}"
  },
  {
    "function_name": "warn_no_callback_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "806-810",
    "snippet": "static void warn_no_callback_path(struct nfs4_client *clp, int reason)\n{\n\tdprintk(\"NFSD: warning: no callback path to client %.*s: error %d\\n\",\n\t\t(int)clp->cl_name.len, clp->cl_name.data, reason);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: warning: no callback path to client %.*s: error %d\\n\"",
            "(int)clp->cl_name.len",
            "clp->cl_name.data",
            "reason"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void warn_no_callback_path(struct nfs4_client *clp, int reason)\n{\n\tdprintk(\"NFSD: warning: no callback path to client %.*s: error %d\\n\",\n\t\t(int)clp->cl_name.len, clp->cl_name.data, reason);\n}"
  },
  {
    "function_name": "setup_callback_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "748-804",
    "snippet": "static int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *conn, struct nfsd4_session *ses)\n{\n\tint maxtime = max_cb_time(clp->net);\n\tstruct rpc_timeout\ttimeparms = {\n\t\t.to_initval\t= maxtime,\n\t\t.to_retries\t= 0,\n\t\t.to_maxval\t= maxtime,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= clp->net,\n\t\t.address\t= (struct sockaddr *) &conn->cb_addr,\n\t\t.addrsize\t= conn->cb_addrlen,\n\t\t.saddress\t= (struct sockaddr *) &conn->cb_saddr,\n\t\t.timeout\t= &timeparms,\n\t\t.program\t= &cb_program,\n\t\t.version\t= 0,\n\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING | RPC_CLNT_CREATE_QUIET),\n\t};\n\tstruct rpc_clnt *client;\n\tstruct rpc_cred *cred;\n\n\tif (clp->cl_minorversion == 0) {\n\t\tif (!clp->cl_cred.cr_principal &&\n\t\t\t\t(clp->cl_cred.cr_flavor >= RPC_AUTH_GSS_KRB5))\n\t\t\treturn -EINVAL;\n\t\targs.client_name = clp->cl_cred.cr_principal;\n\t\targs.prognumber\t= conn->cb_prog;\n\t\targs.protocol = XPRT_TRANSPORT_TCP;\n\t\targs.authflavor = clp->cl_cred.cr_flavor;\n\t\tclp->cl_cb_ident = conn->cb_ident;\n\t} else {\n\t\tif (!conn->cb_xprt)\n\t\t\treturn -EINVAL;\n\t\tclp->cl_cb_conn.cb_xprt = conn->cb_xprt;\n\t\tclp->cl_cb_session = ses;\n\t\targs.bc_xprt = conn->cb_xprt;\n\t\targs.prognumber = clp->cl_cb_session->se_cb_prog;\n\t\targs.protocol = conn->cb_xprt->xpt_class->xcl_ident |\n\t\t\t\tXPRT_TRANSPORT_BC;\n\t\targs.authflavor = ses->se_cb_sec.flavor;\n\t}\n\t/* Create RPC client */\n\tclient = create_backchannel_client(&args);\n\tif (IS_ERR(client)) {\n\t\tdprintk(\"NFSD: couldn't create callback client: %ld\\n\",\n\t\t\tPTR_ERR(client));\n\t\treturn PTR_ERR(client);\n\t}\n\tcred = get_backchannel_cred(clp, client, ses);\n\tif (IS_ERR(cred)) {\n\t\trpc_shutdown_client(client);\n\t\treturn PTR_ERR(cred);\n\t}\n\tclp->cl_cb_client = client;\n\tclp->cl_cb_cred = cred;\n\treturn 0;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_program cb_program;",
      "static const struct rpc_program cb_program = {\n\t.name\t\t\t= \"nfs4_cb\",\n\t.number\t\t\t= NFS4_CALLBACK,\n\t.nrvers\t\t\t= ARRAY_SIZE(nfs_cb_version),\n\t.version\t\t= nfs_cb_version,\n\t.stats\t\t\t= &cb_stats,\n\t.pipe_dir_name\t\t= \"nfsd4_cb\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cred"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "client"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cred"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_backchannel_cred",
          "args": [
            "clp",
            "client",
            "ses"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "get_backchannel_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "718-730",
          "snippet": "static struct rpc_cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)\n{\n\tif (clp->cl_minorversion == 0) {\n\t\treturn get_rpccred(callback_cred);\n\t} else {\n\t\tstruct rpc_auth *auth = client->cl_auth;\n\t\tstruct auth_cred acred = {};\n\n\t\tacred.uid = ses->se_cb_sec.uid;\n\t\tacred.gid = ses->se_cb_sec.gid;\n\t\treturn auth->au_ops->lookup_cred(client->cl_auth, &acred, 0);\n\t}\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_cred *callback_cred;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_cred *callback_cred;\n\nstatic struct rpc_cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)\n{\n\tif (clp->cl_minorversion == 0) {\n\t\treturn get_rpccred(callback_cred);\n\t} else {\n\t\tstruct rpc_auth *auth = client->cl_auth;\n\t\tstruct auth_cred acred = {};\n\n\t\tacred.uid = ses->se_cb_sec.uid;\n\t\tacred.gid = ses->se_cb_sec.gid;\n\t\treturn auth->au_ops->lookup_cred(client->cl_auth, &acred, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "client"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: couldn't create callback client: %ld\\n\"",
            "PTR_ERR(client)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "client"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "client"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_backchannel_client",
          "args": [
            "&args"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "create_backchannel_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "732-746",
          "snippet": "static struct rpc_clnt *create_backchannel_client(struct rpc_create_args *args)\n{\n\tstruct rpc_xprt *xprt;\n\n\tif (args->protocol != XPRT_TRANSPORT_BC_TCP)\n\t\treturn rpc_create(args);\n\n\txprt = args->bc_xprt->xpt_bc_xprt;\n\tif (xprt) {\n\t\txprt_get(xprt);\n\t\treturn rpc_create_xprt(args, xprt);\n\t}\n\n\treturn rpc_create(args);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_clnt *create_backchannel_client(struct rpc_create_args *args)\n{\n\tstruct rpc_xprt *xprt;\n\n\tif (args->protocol != XPRT_TRANSPORT_BC_TCP)\n\t\treturn rpc_create(args);\n\n\txprt = args->bc_xprt->xpt_bc_xprt;\n\tif (xprt) {\n\t\txprt_get(xprt);\n\t\treturn rpc_create_xprt(args, xprt);\n\t}\n\n\treturn rpc_create(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_cb_time",
          "args": [
            "clp->net"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "max_cb_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "700-704",
          "snippet": "static int max_cb_time(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\treturn max(nn->nfsd4_lease/10, (time_t)1) * HZ;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int max_cb_time(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\treturn max(nn->nfsd4_lease/10, (time_t)1) * HZ;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic const struct rpc_program cb_program;\nstatic const struct rpc_program cb_program = {\n\t.name\t\t\t= \"nfs4_cb\",\n\t.number\t\t\t= NFS4_CALLBACK,\n\t.nrvers\t\t\t= ARRAY_SIZE(nfs_cb_version),\n\t.version\t\t= nfs_cb_version,\n\t.stats\t\t\t= &cb_stats,\n\t.pipe_dir_name\t\t= \"nfsd4_cb\",\n};\n\nstatic int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *conn, struct nfsd4_session *ses)\n{\n\tint maxtime = max_cb_time(clp->net);\n\tstruct rpc_timeout\ttimeparms = {\n\t\t.to_initval\t= maxtime,\n\t\t.to_retries\t= 0,\n\t\t.to_maxval\t= maxtime,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= clp->net,\n\t\t.address\t= (struct sockaddr *) &conn->cb_addr,\n\t\t.addrsize\t= conn->cb_addrlen,\n\t\t.saddress\t= (struct sockaddr *) &conn->cb_saddr,\n\t\t.timeout\t= &timeparms,\n\t\t.program\t= &cb_program,\n\t\t.version\t= 0,\n\t\t.flags\t\t= (RPC_CLNT_CREATE_NOPING | RPC_CLNT_CREATE_QUIET),\n\t};\n\tstruct rpc_clnt *client;\n\tstruct rpc_cred *cred;\n\n\tif (clp->cl_minorversion == 0) {\n\t\tif (!clp->cl_cred.cr_principal &&\n\t\t\t\t(clp->cl_cred.cr_flavor >= RPC_AUTH_GSS_KRB5))\n\t\t\treturn -EINVAL;\n\t\targs.client_name = clp->cl_cred.cr_principal;\n\t\targs.prognumber\t= conn->cb_prog;\n\t\targs.protocol = XPRT_TRANSPORT_TCP;\n\t\targs.authflavor = clp->cl_cred.cr_flavor;\n\t\tclp->cl_cb_ident = conn->cb_ident;\n\t} else {\n\t\tif (!conn->cb_xprt)\n\t\t\treturn -EINVAL;\n\t\tclp->cl_cb_conn.cb_xprt = conn->cb_xprt;\n\t\tclp->cl_cb_session = ses;\n\t\targs.bc_xprt = conn->cb_xprt;\n\t\targs.prognumber = clp->cl_cb_session->se_cb_prog;\n\t\targs.protocol = conn->cb_xprt->xpt_class->xcl_ident |\n\t\t\t\tXPRT_TRANSPORT_BC;\n\t\targs.authflavor = ses->se_cb_sec.flavor;\n\t}\n\t/* Create RPC client */\n\tclient = create_backchannel_client(&args);\n\tif (IS_ERR(client)) {\n\t\tdprintk(\"NFSD: couldn't create callback client: %ld\\n\",\n\t\t\tPTR_ERR(client));\n\t\treturn PTR_ERR(client);\n\t}\n\tcred = get_backchannel_cred(clp, client, ses);\n\tif (IS_ERR(cred)) {\n\t\trpc_shutdown_client(client);\n\t\treturn PTR_ERR(cred);\n\t}\n\tclp->cl_cb_client = client;\n\tclp->cl_cb_cred = cred;\n\treturn 0;\n}"
  },
  {
    "function_name": "create_backchannel_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "732-746",
    "snippet": "static struct rpc_clnt *create_backchannel_client(struct rpc_create_args *args)\n{\n\tstruct rpc_xprt *xprt;\n\n\tif (args->protocol != XPRT_TRANSPORT_BC_TCP)\n\t\treturn rpc_create(args);\n\n\txprt = args->bc_xprt->xpt_bc_xprt;\n\tif (xprt) {\n\t\txprt_get(xprt);\n\t\treturn rpc_create_xprt(args, xprt);\n\t}\n\n\treturn rpc_create(args);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_create",
          "args": [
            "args"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_create_xprt",
          "args": [
            "args",
            "xprt"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xprt_get",
          "args": [
            "xprt"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_create",
          "args": [
            "args"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_clnt *create_backchannel_client(struct rpc_create_args *args)\n{\n\tstruct rpc_xprt *xprt;\n\n\tif (args->protocol != XPRT_TRANSPORT_BC_TCP)\n\t\treturn rpc_create(args);\n\n\txprt = args->bc_xprt->xpt_bc_xprt;\n\tif (xprt) {\n\t\txprt_get(xprt);\n\t\treturn rpc_create_xprt(args, xprt);\n\t}\n\n\treturn rpc_create(args);\n}"
  },
  {
    "function_name": "get_backchannel_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "718-730",
    "snippet": "static struct rpc_cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)\n{\n\tif (clp->cl_minorversion == 0) {\n\t\treturn get_rpccred(callback_cred);\n\t} else {\n\t\tstruct rpc_auth *auth = client->cl_auth;\n\t\tstruct auth_cred acred = {};\n\n\t\tacred.uid = ses->se_cb_sec.uid;\n\t\tacred.gid = ses->se_cb_sec.gid;\n\t\treturn auth->au_ops->lookup_cred(client->cl_auth, &acred, 0);\n\t}\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rpc_cred *callback_cred;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "auth->au_ops->lookup_cred",
          "args": [
            "client->cl_auth",
            "&acred",
            "0"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rpccred",
          "args": [
            "callback_cred"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_cred *callback_cred;\n\nstatic struct rpc_cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)\n{\n\tif (clp->cl_minorversion == 0) {\n\t\treturn get_rpccred(callback_cred);\n\t} else {\n\t\tstruct rpc_auth *auth = client->cl_auth;\n\t\tstruct auth_cred acred = {};\n\n\t\tacred.uid = ses->se_cb_sec.uid;\n\t\tacred.gid = ses->se_cb_sec.gid;\n\t\treturn auth->au_ops->lookup_cred(client->cl_auth, &acred, 0);\n\t}\n}"
  },
  {
    "function_name": "set_callback_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "708-716",
    "snippet": "int set_callback_cred(void)\n{\n\tif (callback_cred)\n\t\treturn 0;\n\tcallback_cred = rpc_lookup_machine_cred(\"nfs\");\n\tif (!callback_cred)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rpc_cred *callback_cred;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_lookup_machine_cred",
          "args": [
            "\"nfs\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_cred *callback_cred;\n\nint set_callback_cred(void)\n{\n\tif (callback_cred)\n\t\treturn 0;\n\tcallback_cred = rpc_lookup_machine_cred(\"nfs\");\n\tif (!callback_cred)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "max_cb_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "700-704",
    "snippet": "static int max_cb_time(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\treturn max(nn->nfsd4_lease/10, (time_t)1) * HZ;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nn->nfsd4_lease/10",
            "(time_t)1"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_max_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4proc.c",
          "lines": "2299-2309",
          "snippet": "int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define op_encode_hdr_size\t\t(2)"
          ],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int max_cb_time(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\treturn max(nn->nfsd4_lease/10, (time_t)1) * HZ;\n}"
  },
  {
    "function_name": "nfs4_xdr_dec_cb_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "619-642",
    "snippet": "static int nfs4_xdr_dec_cb_layout(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_compound_hdr hdr;\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (cb) {\n\t\tstatus = decode_cb_sequence4res(xdr, cb);\n\t\tif (unlikely(status))\n\t\t\tgoto out;\n\t}\n\tstatus = decode_cb_op_status(xdr, OP_CB_LAYOUTRECALL, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tstatus = nfs_cb_stat_to_errno(nfserr);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_cb_stat_to_errno",
          "args": [
            "nfserr"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_cb_stat_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "213-224",
          "snippet": "static int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\nstatic int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nfserr != NFS4_OK"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cb_op_status",
          "args": [
            "xdr",
            "OP_CB_LAYOUTRECALL",
            "&nfserr"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cb_op_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "226-247",
          "snippet": "static int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\t\t       enum nfsstat4 *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\t\t       enum nfsstat4 *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cb_sequence4res",
          "args": [
            "xdr",
            "cb"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cb_sequence4res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "446-465",
          "snippet": "static int decode_cb_sequence4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tif (cb->cb_minorversion == 0)\n\t\treturn 0;\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tgoto out_default;\n\tstatus = decode_cb_sequence4resok(xdr, cb);\nout:\n\treturn status;\nout_default:\n\treturn nfs_cb_stat_to_errno(nfserr);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_sequence4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tif (cb->cb_minorversion == 0)\n\t\treturn 0;\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tgoto out_default;\n\tstatus = decode_cb_sequence4resok(xdr, cb);\nout:\n\treturn status;\nout_default:\n\treturn nfs_cb_stat_to_errno(nfserr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cb_compound4res",
          "args": [
            "xdr",
            "&hdr"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cb_compound4res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "291-311",
          "snippet": "static int decode_cb_compound4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->status = be32_to_cpup(p++);\n\t/* Ignore the tag */\n\tlength = be32_to_cpup(p++);\n\tp = xdr_inline_decode(xdr, length + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->nops = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_compound4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->status = be32_to_cpup(p++);\n\t/* Ignore the tag */\n\tlength = be32_to_cpup(p++);\n\tp = xdr_inline_decode(xdr, length + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->nops = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int nfs4_xdr_dec_cb_layout(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_compound_hdr hdr;\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (cb) {\n\t\tstatus = decode_cb_sequence4res(xdr, cb);\n\t\tif (unlikely(status))\n\t\t\tgoto out;\n\t}\n\tstatus = decode_cb_op_status(xdr, OP_CB_LAYOUTRECALL, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tstatus = nfs_cb_stat_to_errno(nfserr);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_xdr_enc_cb_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "602-617",
    "snippet": "static void nfs4_xdr_enc_cb_layout(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const struct nfsd4_callback *cb)\n{\n\tconst struct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = 0,\n\t\t.minorversion = cb->cb_minorversion,\n\t};\n\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\tencode_cb_layout4args(xdr, ls, &hdr);\n\tencode_cb_nops(&hdr);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_cb_nops",
          "args": [
            "&hdr"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cb_nops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "276-280",
          "snippet": "static void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\n{\n\tBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\n\t*hdr->nops_p = cpu_to_be32(hdr->nops);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\n{\n\tBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\n\t*hdr->nops_p = cpu_to_be32(hdr->nops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cb_layout4args",
          "args": [
            "xdr",
            "ls",
            "&hdr"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cb_layout4args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "576-600",
          "snippet": "static void encode_cb_layout4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layout_stateid *ls,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tBUG_ON(hdr->minorversion == 0);\n\n\tp = xdr_reserve_space(xdr, 5 * 4);\n\t*p++ = cpu_to_be32(OP_CB_LAYOUTRECALL);\n\t*p++ = cpu_to_be32(ls->ls_layout_type);\n\t*p++ = cpu_to_be32(IOMODE_ANY);\n\t*p++ = cpu_to_be32(1);\n\t*p = cpu_to_be32(RETURN_FILE);\n\n\tencode_nfs_fh4(xdr, &ls->ls_stid.sc_file->fi_fhandle);\n\n\tp = xdr_reserve_space(xdr, 2 * 8);\n\tp = xdr_encode_hyper(p, 0);\n\txdr_encode_hyper(p, NFS4_MAX_UINT64);\n\n\tencode_stateid4(xdr, &ls->ls_recall_sid);\n\n\thdr->nops++;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_layout4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layout_stateid *ls,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tBUG_ON(hdr->minorversion == 0);\n\n\tp = xdr_reserve_space(xdr, 5 * 4);\n\t*p++ = cpu_to_be32(OP_CB_LAYOUTRECALL);\n\t*p++ = cpu_to_be32(ls->ls_layout_type);\n\t*p++ = cpu_to_be32(IOMODE_ANY);\n\t*p++ = cpu_to_be32(1);\n\t*p = cpu_to_be32(RETURN_FILE);\n\n\tencode_nfs_fh4(xdr, &ls->ls_stid.sc_file->fi_fhandle);\n\n\tp = xdr_reserve_space(xdr, 2 * 8);\n\tp = xdr_encode_hyper(p, 0);\n\txdr_encode_hyper(p, NFS4_MAX_UINT64);\n\n\tencode_stateid4(xdr, &ls->ls_recall_sid);\n\n\thdr->nops++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cb_sequence4args",
          "args": [
            "xdr",
            "cb",
            "&hdr"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cb_sequence4args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "351-372",
          "snippet": "static void encode_cb_sequence4args(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfsd4_callback *cb,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\t__be32 *p;\n\n\tif (hdr->minorversion == 0)\n\t\treturn;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\n\tencode_sessionid4(xdr, session);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\n\t*p++ = cpu_to_be32(session->se_cb_seq_nr);\t/* csa_sequenceid */\n\t*p++ = xdr_zero;\t\t\t/* csa_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_highest_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_cachethis */\n\txdr_encode_empty_array(p);\t\t/* csa_referring_call_lists */\n\n\thdr->nops++;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_sequence4args(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfsd4_callback *cb,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\t__be32 *p;\n\n\tif (hdr->minorversion == 0)\n\t\treturn;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\n\tencode_sessionid4(xdr, session);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\n\t*p++ = cpu_to_be32(session->se_cb_seq_nr);\t/* csa_sequenceid */\n\t*p++ = xdr_zero;\t\t\t/* csa_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_highest_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_cachethis */\n\txdr_encode_empty_array(p);\t\t/* csa_referring_call_lists */\n\n\thdr->nops++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cb_compound4args",
          "args": [
            "xdr",
            "&hdr"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cb_compound4args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "259-271",
          "snippet": "static void encode_cb_compound4args(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 * p;\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\n\tp = xdr_encode_empty_array(p);\t\t/* empty tag */\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\t*p++ = cpu_to_be32(hdr->ident);\n\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\t\t/* argarray element count */\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_compound4args(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 * p;\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\n\tp = xdr_encode_empty_array(p);\t\t/* empty tag */\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\t*p++ = cpu_to_be32(hdr->ident);\n\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\t\t/* argarray element count */\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cb",
            "structnfs4_layout_stateid",
            "ls_recall"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfs4_xdr_enc_cb_layout(struct rpc_rqst *req,\n\t\t\t\t   struct xdr_stream *xdr,\n\t\t\t\t   const struct nfsd4_callback *cb)\n{\n\tconst struct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = 0,\n\t\t.minorversion = cb->cb_minorversion,\n\t};\n\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\tencode_cb_layout4args(xdr, ls, &hdr);\n\tencode_cb_nops(&hdr);\n}"
  },
  {
    "function_name": "encode_cb_layout4args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "576-600",
    "snippet": "static void encode_cb_layout4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layout_stateid *ls,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tBUG_ON(hdr->minorversion == 0);\n\n\tp = xdr_reserve_space(xdr, 5 * 4);\n\t*p++ = cpu_to_be32(OP_CB_LAYOUTRECALL);\n\t*p++ = cpu_to_be32(ls->ls_layout_type);\n\t*p++ = cpu_to_be32(IOMODE_ANY);\n\t*p++ = cpu_to_be32(1);\n\t*p = cpu_to_be32(RETURN_FILE);\n\n\tencode_nfs_fh4(xdr, &ls->ls_stid.sc_file->fi_fhandle);\n\n\tp = xdr_reserve_space(xdr, 2 * 8);\n\tp = xdr_encode_hyper(p, 0);\n\txdr_encode_hyper(p, NFS4_MAX_UINT64);\n\n\tencode_stateid4(xdr, &ls->ls_recall_sid);\n\n\thdr->nops++;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_stateid4",
          "args": [
            "xdr",
            "&ls->ls_recall_sid"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "encode_stateid4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "142-149",
          "snippet": "static void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\n\t*p++ = cpu_to_be32(sid->si_generation);\n\txdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\n\t*p++ = cpu_to_be32(sid->si_generation);\n\txdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "NFS4_MAX_UINT64"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "0"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "2 * 8"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_nfs_fh4",
          "args": [
            "xdr",
            "&ls->ls_stid.sc_file->fi_fhandle"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nfs_fh4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "124-132",
          "snippet": "static void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\n{\n\tu32 length = fh->fh_size;\n\t__be32 *p;\n\n\tBUG_ON(length > NFS4_FHSIZE);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, &fh->fh_base, length);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\n{\n\tu32 length = fh->fh_size;\n\t__be32 *p;\n\n\tBUG_ON(length > NFS4_FHSIZE);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, &fh->fh_base, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "RETURN_FILE"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "IOMODE_ANY"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ls->ls_layout_type"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "OP_CB_LAYOUTRECALL"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "5 * 4"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "hdr->minorversion == 0"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_layout4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_layout_stateid *ls,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tBUG_ON(hdr->minorversion == 0);\n\n\tp = xdr_reserve_space(xdr, 5 * 4);\n\t*p++ = cpu_to_be32(OP_CB_LAYOUTRECALL);\n\t*p++ = cpu_to_be32(ls->ls_layout_type);\n\t*p++ = cpu_to_be32(IOMODE_ANY);\n\t*p++ = cpu_to_be32(1);\n\t*p = cpu_to_be32(RETURN_FILE);\n\n\tencode_nfs_fh4(xdr, &ls->ls_stid.sc_file->fi_fhandle);\n\n\tp = xdr_reserve_space(xdr, 2 * 8);\n\tp = xdr_encode_hyper(p, 0);\n\txdr_encode_hyper(p, NFS4_MAX_UINT64);\n\n\tencode_stateid4(xdr, &ls->ls_recall_sid);\n\n\thdr->nops++;\n}"
  },
  {
    "function_name": "nfs4_xdr_dec_cb_recall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "522-547",
    "snippet": "static int nfs4_xdr_dec_cb_recall(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_compound_hdr hdr;\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\tgoto out;\n\n\tif (cb != NULL) {\n\t\tstatus = decode_cb_sequence4res(xdr, cb);\n\t\tif (unlikely(status))\n\t\t\tgoto out;\n\t}\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_RECALL, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tstatus = nfs_cb_stat_to_errno(nfserr);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_cb_stat_to_errno",
          "args": [
            "nfserr"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_cb_stat_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "213-224",
          "snippet": "static int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\nstatic int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nfserr != NFS4_OK"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cb_op_status",
          "args": [
            "xdr",
            "OP_CB_RECALL",
            "&nfserr"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cb_op_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "226-247",
          "snippet": "static int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\t\t       enum nfsstat4 *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\t\t       enum nfsstat4 *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cb_sequence4res",
          "args": [
            "xdr",
            "cb"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cb_sequence4res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "446-465",
          "snippet": "static int decode_cb_sequence4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tif (cb->cb_minorversion == 0)\n\t\treturn 0;\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tgoto out_default;\n\tstatus = decode_cb_sequence4resok(xdr, cb);\nout:\n\treturn status;\nout_default:\n\treturn nfs_cb_stat_to_errno(nfserr);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_sequence4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tif (cb->cb_minorversion == 0)\n\t\treturn 0;\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tgoto out_default;\n\tstatus = decode_cb_sequence4resok(xdr, cb);\nout:\n\treturn status;\nout_default:\n\treturn nfs_cb_stat_to_errno(nfserr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cb_compound4res",
          "args": [
            "xdr",
            "&hdr"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cb_compound4res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "291-311",
          "snippet": "static int decode_cb_compound4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->status = be32_to_cpup(p++);\n\t/* Ignore the tag */\n\tlength = be32_to_cpup(p++);\n\tp = xdr_inline_decode(xdr, length + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->nops = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_compound4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->status = be32_to_cpup(p++);\n\t/* Ignore the tag */\n\tlength = be32_to_cpup(p++);\n\tp = xdr_inline_decode(xdr, length + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->nops = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int nfs4_xdr_dec_cb_recall(struct rpc_rqst *rqstp,\n\t\t\t\t  struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tstruct nfs4_cb_compound_hdr hdr;\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tstatus = decode_cb_compound4res(xdr, &hdr);\n\tif (unlikely(status))\n\t\tgoto out;\n\n\tif (cb != NULL) {\n\t\tstatus = decode_cb_sequence4res(xdr, cb);\n\t\tif (unlikely(status))\n\t\t\tgoto out;\n\t}\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_RECALL, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tstatus = nfs_cb_stat_to_errno(nfserr);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_xdr_dec_cb_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "513-517",
    "snippet": "static int nfs4_xdr_dec_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tvoid *__unused)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int nfs4_xdr_dec_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tvoid *__unused)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_xdr_enc_cb_recall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "488-501",
    "snippet": "static void nfs4_xdr_enc_cb_recall(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t   const struct nfsd4_callback *cb)\n{\n\tconst struct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = cb->cb_clp->cl_cb_ident,\n\t\t.minorversion = cb->cb_minorversion,\n\t};\n\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\tencode_cb_recall4args(xdr, dp, &hdr);\n\tencode_cb_nops(&hdr);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_cb_nops",
          "args": [
            "&hdr"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cb_nops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "276-280",
          "snippet": "static void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\n{\n\tBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\n\t*hdr->nops_p = cpu_to_be32(hdr->nops);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\n{\n\tBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\n\t*hdr->nops_p = cpu_to_be32(hdr->nops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cb_recall4args",
          "args": [
            "xdr",
            "dp",
            "&hdr"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cb_recall4args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "322-337",
          "snippet": "static void encode_cb_recall4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_delegation *dp,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_RECALL);\n\tencode_stateid4(xdr, &dp->dl_stid.sc_stateid);\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p++ = xdr_zero;\t\t\t/* truncate */\n\n\tencode_nfs_fh4(xdr, &dp->dl_stid.sc_file->fi_fhandle);\n\n\thdr->nops++;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_recall4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_delegation *dp,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_RECALL);\n\tencode_stateid4(xdr, &dp->dl_stid.sc_stateid);\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p++ = xdr_zero;\t\t\t/* truncate */\n\n\tencode_nfs_fh4(xdr, &dp->dl_stid.sc_file->fi_fhandle);\n\n\thdr->nops++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cb_sequence4args",
          "args": [
            "xdr",
            "cb",
            "&hdr"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cb_sequence4args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "351-372",
          "snippet": "static void encode_cb_sequence4args(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfsd4_callback *cb,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\t__be32 *p;\n\n\tif (hdr->minorversion == 0)\n\t\treturn;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\n\tencode_sessionid4(xdr, session);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\n\t*p++ = cpu_to_be32(session->se_cb_seq_nr);\t/* csa_sequenceid */\n\t*p++ = xdr_zero;\t\t\t/* csa_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_highest_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_cachethis */\n\txdr_encode_empty_array(p);\t\t/* csa_referring_call_lists */\n\n\thdr->nops++;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_sequence4args(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfsd4_callback *cb,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\t__be32 *p;\n\n\tif (hdr->minorversion == 0)\n\t\treturn;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\n\tencode_sessionid4(xdr, session);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\n\t*p++ = cpu_to_be32(session->se_cb_seq_nr);\t/* csa_sequenceid */\n\t*p++ = xdr_zero;\t\t\t/* csa_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_highest_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_cachethis */\n\txdr_encode_empty_array(p);\t\t/* csa_referring_call_lists */\n\n\thdr->nops++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cb_compound4args",
          "args": [
            "xdr",
            "&hdr"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cb_compound4args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "259-271",
          "snippet": "static void encode_cb_compound4args(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 * p;\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\n\tp = xdr_encode_empty_array(p);\t\t/* empty tag */\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\t*p++ = cpu_to_be32(hdr->ident);\n\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\t\t/* argarray element count */\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_compound4args(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 * p;\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\n\tp = xdr_encode_empty_array(p);\t\t/* empty tag */\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\t*p++ = cpu_to_be32(hdr->ident);\n\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\t\t/* argarray element count */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb_to_delegation",
          "args": [
            "cb"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfs4_xdr_enc_cb_recall(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t   const struct nfsd4_callback *cb)\n{\n\tconst struct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfs4_cb_compound_hdr hdr = {\n\t\t.ident = cb->cb_clp->cl_cb_ident,\n\t\t.minorversion = cb->cb_minorversion,\n\t};\n\n\tencode_cb_compound4args(xdr, &hdr);\n\tencode_cb_sequence4args(xdr, cb, &hdr);\n\tencode_cb_recall4args(xdr, dp, &hdr);\n\tencode_cb_nops(&hdr);\n}"
  },
  {
    "function_name": "nfs4_xdr_enc_cb_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "479-483",
    "snippet": "static void nfs4_xdr_enc_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *__unused)\n{\n\txdr_reserve_space(xdr, 0);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "0"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfs4_xdr_enc_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t void *__unused)\n{\n\txdr_reserve_space(xdr, 0);\n}"
  },
  {
    "function_name": "decode_cb_sequence4res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "446-465",
    "snippet": "static int decode_cb_sequence4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tif (cb->cb_minorversion == 0)\n\t\treturn 0;\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tgoto out_default;\n\tstatus = decode_cb_sequence4resok(xdr, cb);\nout:\n\treturn status;\nout_default:\n\treturn nfs_cb_stat_to_errno(nfserr);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_cb_stat_to_errno",
          "args": [
            "nfserr"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_cb_stat_to_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "213-224",
          "snippet": "static int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\nstatic int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_cb_sequence4resok",
          "args": [
            "xdr",
            "cb"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cb_sequence4resok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "395-444",
          "snippet": "static int decode_cb_sequence4resok(struct xdr_stream *xdr,\n\t\t\t\t    struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\tstruct nfs4_sessionid id;\n\tint status;\n\t__be32 *p;\n\tu32 dummy;\n\n\tstatus = -ESERVERFAULT;\n\n\t/*\n\t * If the server returns different values for sessionID, slotID or\n\t * sequence number, the server is looney tunes.\n\t */\n\tp = xdr_inline_decode(xdr, NFS4_MAX_SESSIONID_LEN + 4 + 4 + 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tmemcpy(id.data, p, NFS4_MAX_SESSIONID_LEN);\n\tif (memcmp(id.data, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN) != 0) {\n\t\tdprintk(\"NFS: %s Invalid session id\\n\", __func__);\n\t\tgoto out;\n\t}\n\tp += XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN);\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != session->se_cb_seq_nr) {\n\t\tdprintk(\"NFS: %s Invalid sequence number\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != 0) {\n\t\tdprintk(\"NFS: %s Invalid slotid\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * FIXME: process highest slotid and target highest slotid\n\t */\n\tstatus = 0;\nout:\n\tif (status)\n\t\tnfsd4_mark_cb_fault(cb->cb_clp, status);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_sequence4resok(struct xdr_stream *xdr,\n\t\t\t\t    struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\tstruct nfs4_sessionid id;\n\tint status;\n\t__be32 *p;\n\tu32 dummy;\n\n\tstatus = -ESERVERFAULT;\n\n\t/*\n\t * If the server returns different values for sessionID, slotID or\n\t * sequence number, the server is looney tunes.\n\t */\n\tp = xdr_inline_decode(xdr, NFS4_MAX_SESSIONID_LEN + 4 + 4 + 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tmemcpy(id.data, p, NFS4_MAX_SESSIONID_LEN);\n\tif (memcmp(id.data, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN) != 0) {\n\t\tdprintk(\"NFS: %s Invalid session id\\n\", __func__);\n\t\tgoto out;\n\t}\n\tp += XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN);\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != session->se_cb_seq_nr) {\n\t\tdprintk(\"NFS: %s Invalid sequence number\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != 0) {\n\t\tdprintk(\"NFS: %s Invalid slotid\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * FIXME: process highest slotid and target highest slotid\n\t */\n\tstatus = 0;\nout:\n\tif (status)\n\t\tnfsd4_mark_cb_fault(cb->cb_clp, status);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nfserr != NFS4_OK"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_cb_op_status",
          "args": [
            "xdr",
            "OP_CB_SEQUENCE",
            "&nfserr"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "decode_cb_op_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "226-247",
          "snippet": "static int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\t\t       enum nfsstat4 *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\t\t       enum nfsstat4 *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_sequence4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfsd4_callback *cb)\n{\n\tenum nfsstat4 nfserr;\n\tint status;\n\n\tif (cb->cb_minorversion == 0)\n\t\treturn 0;\n\n\tstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &nfserr);\n\tif (unlikely(status))\n\t\tgoto out;\n\tif (unlikely(nfserr != NFS4_OK))\n\t\tgoto out_default;\n\tstatus = decode_cb_sequence4resok(xdr, cb);\nout:\n\treturn status;\nout_default:\n\treturn nfs_cb_stat_to_errno(nfserr);\n}"
  },
  {
    "function_name": "decode_cb_sequence4resok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "395-444",
    "snippet": "static int decode_cb_sequence4resok(struct xdr_stream *xdr,\n\t\t\t\t    struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\tstruct nfs4_sessionid id;\n\tint status;\n\t__be32 *p;\n\tu32 dummy;\n\n\tstatus = -ESERVERFAULT;\n\n\t/*\n\t * If the server returns different values for sessionID, slotID or\n\t * sequence number, the server is looney tunes.\n\t */\n\tp = xdr_inline_decode(xdr, NFS4_MAX_SESSIONID_LEN + 4 + 4 + 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tmemcpy(id.data, p, NFS4_MAX_SESSIONID_LEN);\n\tif (memcmp(id.data, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN) != 0) {\n\t\tdprintk(\"NFS: %s Invalid session id\\n\", __func__);\n\t\tgoto out;\n\t}\n\tp += XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN);\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != session->se_cb_seq_nr) {\n\t\tdprintk(\"NFS: %s Invalid sequence number\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != 0) {\n\t\tdprintk(\"NFS: %s Invalid slotid\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * FIXME: process highest slotid and target highest slotid\n\t */\n\tstatus = 0;\nout:\n\tif (status)\n\t\tnfsd4_mark_cb_fault(cb->cb_clp, status);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_overflow_msg",
          "args": [
            "__func__",
            "xdr"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "print_overflow_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "65-70",
          "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_mark_cb_fault",
          "args": [
            "cb->cb_clp",
            "status"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_mark_cb_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "818-822",
          "snippet": "static void nfsd4_mark_cb_fault(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_FAULT;\n\twarn_no_callback_path(clp, reason);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *, int reason);\n\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *clp, int reason)\n{\n\tclp->cl_cb_state = NFSD4_CB_FAULT;\n\twarn_no_callback_path(clp, reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s Invalid slotid\\n\"",
            "__func__"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s Invalid sequence number\\n\"",
            "__func__"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s Invalid session id\\n\"",
            "__func__"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "id.data",
            "session->se_sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "id.data",
            "p",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "NFS4_MAX_SESSIONID_LEN + 4 + 4 + 4 + 4"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_sequence4resok(struct xdr_stream *xdr,\n\t\t\t\t    struct nfsd4_callback *cb)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\tstruct nfs4_sessionid id;\n\tint status;\n\t__be32 *p;\n\tu32 dummy;\n\n\tstatus = -ESERVERFAULT;\n\n\t/*\n\t * If the server returns different values for sessionID, slotID or\n\t * sequence number, the server is looney tunes.\n\t */\n\tp = xdr_inline_decode(xdr, NFS4_MAX_SESSIONID_LEN + 4 + 4 + 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\tmemcpy(id.data, p, NFS4_MAX_SESSIONID_LEN);\n\tif (memcmp(id.data, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN) != 0) {\n\t\tdprintk(\"NFS: %s Invalid session id\\n\", __func__);\n\t\tgoto out;\n\t}\n\tp += XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN);\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != session->se_cb_seq_nr) {\n\t\tdprintk(\"NFS: %s Invalid sequence number\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tdummy = be32_to_cpup(p++);\n\tif (dummy != 0) {\n\t\tdprintk(\"NFS: %s Invalid slotid\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * FIXME: process highest slotid and target highest slotid\n\t */\n\tstatus = 0;\nout:\n\tif (status)\n\t\tnfsd4_mark_cb_fault(cb->cb_clp, status);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "encode_cb_sequence4args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "351-372",
    "snippet": "static void encode_cb_sequence4args(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfsd4_callback *cb,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\t__be32 *p;\n\n\tif (hdr->minorversion == 0)\n\t\treturn;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\n\tencode_sessionid4(xdr, session);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\n\t*p++ = cpu_to_be32(session->se_cb_seq_nr);\t/* csa_sequenceid */\n\t*p++ = xdr_zero;\t\t\t/* csa_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_highest_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_cachethis */\n\txdr_encode_empty_array(p);\t\t/* csa_referring_call_lists */\n\n\thdr->nops++;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_empty_array",
          "args": [
            "p"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_encode_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "72-76",
          "snippet": "static __be32 *xdr_encode_empty_array(__be32 *p)\n{\n\t*p++ = xdr_zero;\n\treturn p;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic __be32 *xdr_encode_empty_array(__be32 *p)\n{\n\t*p++ = xdr_zero;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "session->se_cb_seq_nr"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + 4 + 4 + 4 + 4"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_sessionid4",
          "args": [
            "xdr",
            "session"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "encode_sessionid4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "156-164",
          "snippet": "static void encode_sessionid4(struct xdr_stream *xdr,\n\t\t\t      const struct nfsd4_session *session)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN);\n\txdr_encode_opaque_fixed(p, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_sessionid4(struct xdr_stream *xdr,\n\t\t\t      const struct nfsd4_session *session)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN);\n\txdr_encode_opaque_fixed(p, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_nfs_cb_opnum4",
          "args": [
            "xdr",
            "OP_CB_SEQUENCE"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nfs_cb_opnum4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "111-117",
          "snippet": "static void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(op);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(op);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_sequence4args(struct xdr_stream *xdr,\n\t\t\t\t    const struct nfsd4_callback *cb,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\tstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\n\t__be32 *p;\n\n\tif (hdr->minorversion == 0)\n\t\treturn;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\n\tencode_sessionid4(xdr, session);\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\n\t*p++ = cpu_to_be32(session->se_cb_seq_nr);\t/* csa_sequenceid */\n\t*p++ = xdr_zero;\t\t\t/* csa_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_highest_slotid */\n\t*p++ = xdr_zero;\t\t\t/* csa_cachethis */\n\txdr_encode_empty_array(p);\t\t/* csa_referring_call_lists */\n\n\thdr->nops++;\n}"
  },
  {
    "function_name": "encode_cb_recall4args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "322-337",
    "snippet": "static void encode_cb_recall4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_delegation *dp,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_RECALL);\n\tencode_stateid4(xdr, &dp->dl_stid.sc_stateid);\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p++ = xdr_zero;\t\t\t/* truncate */\n\n\tencode_nfs_fh4(xdr, &dp->dl_stid.sc_file->fi_fhandle);\n\n\thdr->nops++;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_nfs_fh4",
          "args": [
            "xdr",
            "&dp->dl_stid.sc_file->fi_fhandle"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nfs_fh4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "124-132",
          "snippet": "static void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\n{\n\tu32 length = fh->fh_size;\n\t__be32 *p;\n\n\tBUG_ON(length > NFS4_FHSIZE);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, &fh->fh_base, length);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\n{\n\tu32 length = fh->fh_size;\n\t__be32 *p;\n\n\tBUG_ON(length > NFS4_FHSIZE);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, &fh->fh_base, length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_stateid4",
          "args": [
            "xdr",
            "&dp->dl_stid.sc_stateid"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "encode_stateid4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "142-149",
          "snippet": "static void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\n\t*p++ = cpu_to_be32(sid->si_generation);\n\txdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\n\t*p++ = cpu_to_be32(sid->si_generation);\n\txdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_nfs_cb_opnum4",
          "args": [
            "xdr",
            "OP_CB_RECALL"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "encode_nfs_cb_opnum4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "111-117",
          "snippet": "static void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(op);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(op);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_recall4args(struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_delegation *dp,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tencode_nfs_cb_opnum4(xdr, OP_CB_RECALL);\n\tencode_stateid4(xdr, &dp->dl_stid.sc_stateid);\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p++ = xdr_zero;\t\t\t/* truncate */\n\n\tencode_nfs_fh4(xdr, &dp->dl_stid.sc_file->fi_fhandle);\n\n\thdr->nops++;\n}"
  },
  {
    "function_name": "decode_cb_compound4res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "291-311",
    "snippet": "static int decode_cb_compound4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->status = be32_to_cpup(p++);\n\t/* Ignore the tag */\n\tlength = be32_to_cpup(p++);\n\tp = xdr_inline_decode(xdr, length + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->nops = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_overflow_msg",
          "args": [
            "__func__",
            "xdr"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "print_overflow_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "65-70",
          "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "length + 4"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4 + 4"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_compound4res(struct xdr_stream *xdr,\n\t\t\t\t  struct nfs4_cb_compound_hdr *hdr)\n{\n\tu32 length;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->status = be32_to_cpup(p++);\n\t/* Ignore the tag */\n\tlength = be32_to_cpup(p++);\n\tp = xdr_inline_decode(xdr, length + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\thdr->nops = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "encode_cb_nops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "276-280",
    "snippet": "static void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\n{\n\tBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\n\t*hdr->nops_p = cpu_to_be32(hdr->nops);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "hdr->nops"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\n{\n\tBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\n\t*hdr->nops_p = cpu_to_be32(hdr->nops);\n}"
  },
  {
    "function_name": "encode_cb_compound4args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "259-271",
    "snippet": "static void encode_cb_compound4args(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 * p;\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\n\tp = xdr_encode_empty_array(p);\t\t/* empty tag */\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\t*p++ = cpu_to_be32(hdr->ident);\n\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\t\t/* argarray element count */\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "hdr->nops"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "hdr->ident"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "hdr->minorversion"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_empty_array",
          "args": [
            "p"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_encode_empty_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "72-76",
          "snippet": "static __be32 *xdr_encode_empty_array(__be32 *p)\n{\n\t*p++ = xdr_zero;\n\treturn p;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic __be32 *xdr_encode_empty_array(__be32 *p)\n{\n\t*p++ = xdr_zero;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + 4 + 4 + 4"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_cb_compound4args(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs4_cb_compound_hdr *hdr)\n{\n\t__be32 * p;\n\n\tp = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\n\tp = xdr_encode_empty_array(p);\t\t/* empty tag */\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\t*p++ = cpu_to_be32(hdr->ident);\n\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\t\t/* argarray element count */\n}"
  },
  {
    "function_name": "decode_cb_op_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "226-247",
    "snippet": "static int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\t\t       enum nfsstat4 *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\"",
            "op",
            "expected"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_overflow_msg",
          "args": [
            "__func__",
            "xdr"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "print_overflow_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
          "lines": "65-70",
          "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "op != expected"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4 + 4"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\n\t\t\t       enum nfsstat4 *status)\n{\n\t__be32 *p;\n\tu32 op;\n\n\tp = xdr_inline_decode(xdr, 4 + 4);\n\tif (unlikely(p == NULL))\n\t\tgoto out_overflow;\n\top = be32_to_cpup(p++);\n\tif (unlikely(op != expected))\n\t\tgoto out_unexpected;\n\t*status = be32_to_cpup(p);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\nout_unexpected:\n\tdprintk(\"NFSD: Callback server returned operation %d but \"\n\t\t\"we issued a request for %d\\n\", op, expected);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "nfs_cb_stat_to_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "213-224",
    "snippet": "static int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: Unrecognized NFS CB status value: %u\\n\"",
            "status"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic const struct {\n\tint stat;\n\tint errno;\n} nfs_cb_errtbl[] = {\n\t{ NFS4_OK,\t\t0\t\t},\n\t{ NFS4ERR_PERM,\t\t-EPERM\t\t},\n\t{ NFS4ERR_NOENT,\t-ENOENT\t\t},\n\t{ NFS4ERR_IO,\t\t-EIO\t\t},\n\t{ NFS4ERR_NXIO,\t\t-ENXIO\t\t},\n\t{ NFS4ERR_ACCESS,\t-EACCES\t\t},\n\t{ NFS4ERR_EXIST,\t-EEXIST\t\t},\n\t{ NFS4ERR_XDEV,\t\t-EXDEV\t\t},\n\t{ NFS4ERR_NOTDIR,\t-ENOTDIR\t},\n\t{ NFS4ERR_ISDIR,\t-EISDIR\t\t},\n\t{ NFS4ERR_INVAL,\t-EINVAL\t\t},\n\t{ NFS4ERR_FBIG,\t\t-EFBIG\t\t},\n\t{ NFS4ERR_NOSPC,\t-ENOSPC\t\t},\n\t{ NFS4ERR_ROFS,\t\t-EROFS\t\t},\n\t{ NFS4ERR_MLINK,\t-EMLINK\t\t},\n\t{ NFS4ERR_NAMETOOLONG,\t-ENAMETOOLONG\t},\n\t{ NFS4ERR_NOTEMPTY,\t-ENOTEMPTY\t},\n\t{ NFS4ERR_DQUOT,\t-EDQUOT\t\t},\n\t{ NFS4ERR_STALE,\t-ESTALE\t\t},\n\t{ NFS4ERR_BADHANDLE,\t-EBADHANDLE\t},\n\t{ NFS4ERR_BAD_COOKIE,\t-EBADCOOKIE\t},\n\t{ NFS4ERR_NOTSUPP,\t-ENOTSUPP\t},\n\t{ NFS4ERR_TOOSMALL,\t-ETOOSMALL\t},\n\t{ NFS4ERR_SERVERFAULT,\t-ESERVERFAULT\t},\n\t{ NFS4ERR_BADTYPE,\t-EBADTYPE\t},\n\t{ NFS4ERR_LOCKED,\t-EAGAIN\t\t},\n\t{ NFS4ERR_RESOURCE,\t-EREMOTEIO\t},\n\t{ NFS4ERR_SYMLINK,\t-ELOOP\t\t},\n\t{ NFS4ERR_OP_ILLEGAL,\t-EOPNOTSUPP\t},\n\t{ NFS4ERR_DEADLOCK,\t-EDEADLK\t},\n\t{ -1,\t\t\t-EIO\t\t}\n};\n\nstatic int nfs_cb_stat_to_errno(int status)\n{\n\tint i;\n\n\tfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\n\t\tif (nfs_cb_errtbl[i].stat == status)\n\t\t\treturn nfs_cb_errtbl[i].errno;\n\t}\n\n\tdprintk(\"NFSD: Unrecognized NFS CB status value: %u\\n\", status);\n\treturn -status;\n}"
  },
  {
    "function_name": "encode_sessionid4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "156-164",
    "snippet": "static void encode_sessionid4(struct xdr_stream *xdr,\n\t\t\t      const struct nfsd4_session *session)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN);\n\txdr_encode_opaque_fixed(p, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "session->se_sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_sessionid4(struct xdr_stream *xdr,\n\t\t\t      const struct nfsd4_session *session)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN);\n\txdr_encode_opaque_fixed(p, session->se_sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n}"
  },
  {
    "function_name": "encode_stateid4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "142-149",
    "snippet": "static void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\n\t*p++ = cpu_to_be32(sid->si_generation);\n\txdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&sid->si_opaque",
            "NFS4_STATEID_OTHER_SIZE"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sid->si_generation"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_STATEID_SIZE"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\n\t*p++ = cpu_to_be32(sid->si_generation);\n\txdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\n}"
  },
  {
    "function_name": "encode_nfs_fh4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "124-132",
    "snippet": "static void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\n{\n\tu32 length = fh->fh_size;\n\t__be32 *p;\n\n\tBUG_ON(length > NFS4_FHSIZE);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, &fh->fh_base, length);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "&fh->fh_base",
            "length"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + length"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "length > NFS4_FHSIZE"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\n{\n\tu32 length = fh->fh_size;\n\t__be32 *p;\n\n\tBUG_ON(length > NFS4_FHSIZE);\n\tp = xdr_reserve_space(xdr, 4 + length);\n\txdr_encode_opaque(p, &fh->fh_base, length);\n}"
  },
  {
    "function_name": "encode_nfs_cb_opnum4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "111-117",
    "snippet": "static void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(op);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "op"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4);\n\t*p = cpu_to_be32(op);\n}"
  },
  {
    "function_name": "xdr_encode_empty_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "72-76",
    "snippet": "static __be32 *xdr_encode_empty_array(__be32 *p)\n{\n\t*p++ = xdr_zero;\n\treturn p;\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic __be32 *xdr_encode_empty_array(__be32 *p)\n{\n\t*p++ = xdr_zero;\n\treturn p;\n}"
  },
  {
    "function_name": "print_overflow_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4callback.c",
    "lines": "65-70",
    "snippet": "static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}",
    "includes": [
      "#include \"xdr4cb.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/xprt.h>",
      "#include <linux/sunrpc/clnt.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\"",
            "func",
            "xdr->end - xdr->p"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\n{\n\tdprintk(\"NFS: %s prematurely hit the end of our receive buffer. \"\n\t\t\"Remaining buffer length is %tu words.\\n\",\n\t\tfunc, xdr->end - xdr->p);\n}"
  }
]