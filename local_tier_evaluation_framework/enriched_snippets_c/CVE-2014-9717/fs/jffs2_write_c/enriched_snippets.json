[
  {
    "function_name": "ffs2_do_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
    "lines": "668-722",
    "snippet": "nt jffs2_do_link (struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, uint32_t ino, uint8_t type, const char *name, int namelen, uint32_t time)\n{\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t alloclen;\n\tint ret;\n\n\trd = jffs2_alloc_raw_dirent();\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,\n\t\t\t\tALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\tif (ret) {\n\t\tjffs2_free_raw_dirent(rd);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&dir_f->sem);\n\n\t/* Build a deletion node */\n\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd->totlen = cpu_to_je32(sizeof(*rd) + namelen);\n\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd->pino = cpu_to_je32(dir_f->inocache->ino);\n\trd->version = cpu_to_je32(++dir_f->highest_version);\n\trd->ino = cpu_to_je32(ino);\n\trd->mctime = cpu_to_je32(time);\n\trd->nsize = namelen;\n\n\trd->type = type;\n\n\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\trd->name_crc = cpu_to_je32(crc32(0, name, namelen));\n\n\tfd = jffs2_write_dirent(c, dir_f, rd, name, namelen, ALLOC_NORMAL);\n\n\tjffs2_free_raw_dirent(rd);\n\n\tif (IS_ERR(fd)) {\n\t\tjffs2_complete_reservation(c);\n\t\tmutex_unlock(&dir_f->sem);\n\t\treturn PTR_ERR(fd);\n\t}\n\n\t/* File it. This will mark the old one obsolete. */\n\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\n\tjffs2_complete_reservation(c);\n\tmutex_unlock(&dir_f->sem);\n\n\treturn 0;\n}",
    "includes": [
      "include \"compr.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_complete_reservation(",
          "args": [
            ")"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_complete_reservation(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "556-563",
          "snippet": "oid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_add_fd_to_list(",
          "args": [
            ",",
            "d,",
            "dir_f->dents)"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_fd_to_list(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "26-57",
          "snippet": "oid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "d)"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "d)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_raw_dirent(",
          "args": [
            "d)"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_raw_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "158-162",
          "snippet": "oid jffs2_free_raw_dirent(struct jffs2_raw_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(raw_dirent_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *raw_dirent_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *raw_dirent_slab;\n\noid jffs2_free_raw_dirent(struct jffs2_raw_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(raw_dirent_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_write_dirent(",
          "args": [
            ",",
            "ir_f,",
            "d,",
            "ame,",
            "amelen,",
            "LLOC_NORMAL)"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_write_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
          "lines": "205-335",
          "snippet": "truct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode)\n{\n\tstruct jffs2_full_dirent *fd;\n\tsize_t retlen;\n\tstruct kvec vecs[2];\n\tuint32_t flash_ofs;\n\tint retried = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",\n\t\t  __func__,\n\t\t  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t  je32_to_cpu(rd->name_crc));\n\n\tD1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   });\n\n\tif (strnlen(name, namelen) != namelen) {\n\t\t/* This should never happen, but seems to have done on at least one\n\t\t   occasion: https://dev.laptop.org/ticket/4184 */\n\t\tpr_crit(\"Error in jffs2_write_dirent() -- name contains zero bytes!\\n\");\n\t\tpr_crit(\"Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",\n\t\t\tje32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t\tje32_to_cpu(rd->name_crc));\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tvecs[0].iov_base = rd;\n\tvecs[0].iov_len = sizeof(*rd);\n\tvecs[1].iov_base = (unsigned char *)name;\n\tvecs[1].iov_len = namelen;\n\n\tfd = jffs2_alloc_full_dirent(namelen+1);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(name, namelen);\n\tfd->type = rd->type;\n\tmemcpy(fd->name, name, namelen);\n\tfd->name[namelen]=0;\n\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dirent_version %d, highest version %d -> updating dirent\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(rd->version), f->highest_version);\n\t\trd->version = cpu_to_je32(++f->highest_version);\n\t\tfd->version = je32_to_cpu(rd->version);\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));\n\tif (ret || (retlen != sizeof(*rd) + namelen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*rd) + namelen, flash_ofs, ret, retlen);\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*rd)+namelen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write\\n\",\n\t\t\t\t\t  flash_ofs);\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\tfd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),\n\t\t\t\t\t      PAD(sizeof(*rd)+namelen), f->inocache);\n\tif (IS_ERR(fd->raw)) {\n\t\tvoid *hold_err = fd->raw;\n\t\t/* Release the full_dirent which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "include \"compr.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode)\n{\n\tstruct jffs2_full_dirent *fd;\n\tsize_t retlen;\n\tstruct kvec vecs[2];\n\tuint32_t flash_ofs;\n\tint retried = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",\n\t\t  __func__,\n\t\t  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t  je32_to_cpu(rd->name_crc));\n\n\tD1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   });\n\n\tif (strnlen(name, namelen) != namelen) {\n\t\t/* This should never happen, but seems to have done on at least one\n\t\t   occasion: https://dev.laptop.org/ticket/4184 */\n\t\tpr_crit(\"Error in jffs2_write_dirent() -- name contains zero bytes!\\n\");\n\t\tpr_crit(\"Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",\n\t\t\tje32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t\tje32_to_cpu(rd->name_crc));\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tvecs[0].iov_base = rd;\n\tvecs[0].iov_len = sizeof(*rd);\n\tvecs[1].iov_base = (unsigned char *)name;\n\tvecs[1].iov_len = namelen;\n\n\tfd = jffs2_alloc_full_dirent(namelen+1);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(name, namelen);\n\tfd->type = rd->type;\n\tmemcpy(fd->name, name, namelen);\n\tfd->name[namelen]=0;\n\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dirent_version %d, highest version %d -> updating dirent\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(rd->version), f->highest_version);\n\t\trd->version = cpu_to_je32(++f->highest_version);\n\t\tfd->version = je32_to_cpu(rd->version);\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));\n\tif (ret || (retlen != sizeof(*rd) + namelen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*rd) + namelen, flash_ofs, ret, retlen);\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*rd)+namelen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write\\n\",\n\t\t\t\t\t  flash_ofs);\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\tfd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),\n\t\t\t\t\t      PAD(sizeof(*rd)+namelen), f->inocache);\n\tif (IS_ERR(fd->raw)) {\n\t\tvoid *hold_err = fd->raw;\n\t\t/* Release the full_dirent which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, name, namelen))"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "ame,",
            "amelen)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, rd, sizeof(*rd)-8))"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(*rd)-8)"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ime)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "no)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "+dir_f->highest_version)"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ir_f->inocache->ino)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, rd, sizeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(struct jffs2_unknown_node)-4)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "izeof(*rd) + namelen)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_NODETYPE_DIRENT)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_MAGIC_BITMASK)"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space(",
          "args": [
            ",",
            "izeof(*rd)+namelen,",
            "alloclen,",
            "LLOC_NORMAL,",
            "FFS2_SUMMARY_DIRENT_SIZE(namelen))"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "74-210",
          "snippet": "nt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_SUMMARY_DIRENT_SIZE(",
          "args": [
            "amelen)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_raw_dirent(",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_do_link (struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f, uint32_t ino, uint8_t type, const char *name, int namelen, uint32_t time)\n{\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t alloclen;\n\tint ret;\n\n\trd = jffs2_alloc_raw_dirent();\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,\n\t\t\t\tALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\tif (ret) {\n\t\tjffs2_free_raw_dirent(rd);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&dir_f->sem);\n\n\t/* Build a deletion node */\n\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd->totlen = cpu_to_je32(sizeof(*rd) + namelen);\n\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd->pino = cpu_to_je32(dir_f->inocache->ino);\n\trd->version = cpu_to_je32(++dir_f->highest_version);\n\trd->ino = cpu_to_je32(ino);\n\trd->mctime = cpu_to_je32(time);\n\trd->nsize = namelen;\n\n\trd->type = type;\n\n\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\trd->name_crc = cpu_to_je32(crc32(0, name, namelen));\n\n\tfd = jffs2_write_dirent(c, dir_f, rd, name, namelen, ALLOC_NORMAL);\n\n\tjffs2_free_raw_dirent(rd);\n\n\tif (IS_ERR(fd)) {\n\t\tjffs2_complete_reservation(c);\n\t\tmutex_unlock(&dir_f->sem);\n\t\treturn PTR_ERR(fd);\n\t}\n\n\t/* File it. This will mark the old one obsolete. */\n\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\n\tjffs2_complete_reservation(c);\n\tmutex_unlock(&dir_f->sem);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_do_unlink(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
    "lines": "546-665",
    "snippet": "nt jffs2_do_unlink(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f,\n\t\t    const char *name, int namelen, struct jffs2_inode_info *dead_f,\n\t\t    uint32_t time)\n{\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t alloclen;\n\tint ret;\n\n\tif (!jffs2_can_mark_obsolete(c)) {\n\t\t/* We can't mark stuff obsolete on the medium. We need to write a deletion dirent */\n\n\t\trd = jffs2_alloc_raw_dirent();\n\t\tif (!rd)\n\t\t\treturn -ENOMEM;\n\n\t\tret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,\n\t\t\t\t\tALLOC_DELETION, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\tif (ret) {\n\t\t\tjffs2_free_raw_dirent(rd);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmutex_lock(&dir_f->sem);\n\n\t\t/* Build a deletion node */\n\t\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\t\trd->totlen = cpu_to_je32(sizeof(*rd) + namelen);\n\t\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\t\trd->pino = cpu_to_je32(dir_f->inocache->ino);\n\t\trd->version = cpu_to_je32(++dir_f->highest_version);\n\t\trd->ino = cpu_to_je32(0);\n\t\trd->mctime = cpu_to_je32(time);\n\t\trd->nsize = namelen;\n\t\trd->type = DT_UNKNOWN;\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t\trd->name_crc = cpu_to_je32(crc32(0, name, namelen));\n\n\t\tfd = jffs2_write_dirent(c, dir_f, rd, name, namelen, ALLOC_DELETION);\n\n\t\tjffs2_free_raw_dirent(rd);\n\n\t\tif (IS_ERR(fd)) {\n\t\t\tjffs2_complete_reservation(c);\n\t\t\tmutex_unlock(&dir_f->sem);\n\t\t\treturn PTR_ERR(fd);\n\t\t}\n\n\t\t/* File it. This will mark the old one obsolete. */\n\t\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\t\tmutex_unlock(&dir_f->sem);\n\t} else {\n\t\tuint32_t nhash = full_name_hash(name, namelen);\n\n\t\tfd = dir_f->dents;\n\t\t/* We don't actually want to reserve any space, but we do\n\t\t   want to be holding the alloc_sem when we write to flash */\n\t\tmutex_lock(&c->alloc_sem);\n\t\tmutex_lock(&dir_f->sem);\n\n\t\tfor (fd = dir_f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->nhash == nhash &&\n\t\t\t    !memcmp(fd->name, name, namelen) &&\n\t\t\t    !fd->name[namelen]) {\n\n\t\t\t\tjffs2_dbg(1, \"Marking old dirent node (ino #%u) @%08x obsolete\\n\",\n\t\t\t\t\t  fd->ino, ref_offset(fd->raw));\n\t\t\t\tjffs2_mark_node_obsolete(c, fd->raw);\n\t\t\t\t/* We don't want to remove it from the list immediately,\n\t\t\t\t   because that screws up getdents()/seek() semantics even\n\t\t\t\t   more than they're screwed already. Turn it into a\n\t\t\t\t   node-less deletion dirent instead -- a placeholder */\n\t\t\t\tfd->raw = NULL;\n\t\t\t\tfd->ino = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&dir_f->sem);\n\t}\n\n\t/* dead_f is NULL if this was a rename not a real unlink */\n\t/* Also catch the !f->inocache case, where there was a dirent\n\t   pointing to an inode which didn't exist. */\n\tif (dead_f && dead_f->inocache) {\n\n\t\tmutex_lock(&dead_f->sem);\n\n\t\tif (S_ISDIR(OFNI_EDONI_2SFFJ(dead_f)->i_mode)) {\n\t\t\twhile (dead_f->dents) {\n\t\t\t\t/* There can be only deleted ones */\n\t\t\t\tfd = dead_f->dents;\n\n\t\t\t\tdead_f->dents = fd->next;\n\n\t\t\t\tif (fd->ino) {\n\t\t\t\t\tpr_warn(\"Deleting inode #%u with active dentry \\\"%s\\\"->ino #%u\\n\",\n\t\t\t\t\t\tdead_f->inocache->ino,\n\t\t\t\t\t\tfd->name, fd->ino);\n\t\t\t\t} else {\n\t\t\t\t\tjffs2_dbg(1, \"Removing deletion dirent for \\\"%s\\\" from dir ino #%u\\n\",\n\t\t\t\t\t\t  fd->name,\n\t\t\t\t\t\t  dead_f->inocache->ino);\n\t\t\t\t}\n\t\t\t\tif (fd->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, fd->raw);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t}\n\t\t\tdead_f->inocache->pino_nlink = 0;\n\t\t} else\n\t\t\tdead_f->inocache->pino_nlink--;\n\t\t/* NB: Caller must set inode nlink if appropriate */\n\t\tmutex_unlock(&dead_f->sem);\n\t}\n\n\tjffs2_complete_reservation(c);\n\n\treturn 0;\n}",
    "includes": [
      "include \"compr.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_complete_reservation(",
          "args": [
            ")"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_complete_reservation(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "556-563",
          "snippet": "oid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "dead_f->sem)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_full_dirent(",
          "args": [
            "d)"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "130-134",
          "snippet": "oid jffs2_free_full_dirent(struct jffs2_full_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkfree(x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_full_dirent(struct jffs2_full_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "d->raw)"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Removing deletion dirent for \\\"%s\\\" from dir ino #%u\\n\",",
            "d->name,",
            "ead_f->inocache->ino)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Deleting inode #%u with active dentry \\\"%s\\\"->ino #%u\\n\",",
            "ead_f->inocache->ino,",
            "d->name,",
            "d->ino)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ISDIR(",
          "args": [
            "FNI_EDONI_2SFFJ(dead_f)->i_mode)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FNI_EDONI_2SFFJ(",
          "args": [
            "ead_f)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "dead_f->sem)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Marking old dirent node (ino #%u) @%08x obsolete\\n\",",
            "d->ino,",
            "ef_offset(fd->raw))"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_offset(",
          "args": [
            "d->raw)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcmp(",
          "args": [
            "d->name,",
            "ame,",
            "amelen)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "c->alloc_sem)"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull_name_hash(",
          "args": [
            "ame,",
            "amelen)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_fd_to_list(",
          "args": [
            ",",
            "d,",
            "dir_f->dents)"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_fd_to_list(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "26-57",
          "snippet": "oid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "d)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "d)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_raw_dirent(",
          "args": [
            "d)"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_raw_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "158-162",
          "snippet": "oid jffs2_free_raw_dirent(struct jffs2_raw_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(raw_dirent_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *raw_dirent_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *raw_dirent_slab;\n\noid jffs2_free_raw_dirent(struct jffs2_raw_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(raw_dirent_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_write_dirent(",
          "args": [
            ",",
            "ir_f,",
            "d,",
            "ame,",
            "amelen,",
            "LLOC_DELETION)"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_write_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
          "lines": "205-335",
          "snippet": "truct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode)\n{\n\tstruct jffs2_full_dirent *fd;\n\tsize_t retlen;\n\tstruct kvec vecs[2];\n\tuint32_t flash_ofs;\n\tint retried = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",\n\t\t  __func__,\n\t\t  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t  je32_to_cpu(rd->name_crc));\n\n\tD1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   });\n\n\tif (strnlen(name, namelen) != namelen) {\n\t\t/* This should never happen, but seems to have done on at least one\n\t\t   occasion: https://dev.laptop.org/ticket/4184 */\n\t\tpr_crit(\"Error in jffs2_write_dirent() -- name contains zero bytes!\\n\");\n\t\tpr_crit(\"Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",\n\t\t\tje32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t\tje32_to_cpu(rd->name_crc));\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tvecs[0].iov_base = rd;\n\tvecs[0].iov_len = sizeof(*rd);\n\tvecs[1].iov_base = (unsigned char *)name;\n\tvecs[1].iov_len = namelen;\n\n\tfd = jffs2_alloc_full_dirent(namelen+1);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(name, namelen);\n\tfd->type = rd->type;\n\tmemcpy(fd->name, name, namelen);\n\tfd->name[namelen]=0;\n\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dirent_version %d, highest version %d -> updating dirent\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(rd->version), f->highest_version);\n\t\trd->version = cpu_to_je32(++f->highest_version);\n\t\tfd->version = je32_to_cpu(rd->version);\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));\n\tif (ret || (retlen != sizeof(*rd) + namelen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*rd) + namelen, flash_ofs, ret, retlen);\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*rd)+namelen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write\\n\",\n\t\t\t\t\t  flash_ofs);\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\tfd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),\n\t\t\t\t\t      PAD(sizeof(*rd)+namelen), f->inocache);\n\tif (IS_ERR(fd->raw)) {\n\t\tvoid *hold_err = fd->raw;\n\t\t/* Release the full_dirent which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "include \"compr.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode)\n{\n\tstruct jffs2_full_dirent *fd;\n\tsize_t retlen;\n\tstruct kvec vecs[2];\n\tuint32_t flash_ofs;\n\tint retried = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",\n\t\t  __func__,\n\t\t  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t  je32_to_cpu(rd->name_crc));\n\n\tD1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   });\n\n\tif (strnlen(name, namelen) != namelen) {\n\t\t/* This should never happen, but seems to have done on at least one\n\t\t   occasion: https://dev.laptop.org/ticket/4184 */\n\t\tpr_crit(\"Error in jffs2_write_dirent() -- name contains zero bytes!\\n\");\n\t\tpr_crit(\"Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",\n\t\t\tje32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t\tje32_to_cpu(rd->name_crc));\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tvecs[0].iov_base = rd;\n\tvecs[0].iov_len = sizeof(*rd);\n\tvecs[1].iov_base = (unsigned char *)name;\n\tvecs[1].iov_len = namelen;\n\n\tfd = jffs2_alloc_full_dirent(namelen+1);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(name, namelen);\n\tfd->type = rd->type;\n\tmemcpy(fd->name, name, namelen);\n\tfd->name[namelen]=0;\n\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dirent_version %d, highest version %d -> updating dirent\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(rd->version), f->highest_version);\n\t\trd->version = cpu_to_je32(++f->highest_version);\n\t\tfd->version = je32_to_cpu(rd->version);\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));\n\tif (ret || (retlen != sizeof(*rd) + namelen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*rd) + namelen, flash_ofs, ret, retlen);\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*rd)+namelen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write\\n\",\n\t\t\t\t\t  flash_ofs);\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\tfd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),\n\t\t\t\t\t      PAD(sizeof(*rd)+namelen), f->inocache);\n\tif (IS_ERR(fd->raw)) {\n\t\tvoid *hold_err = fd->raw;\n\t\t/* Release the full_dirent which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, name, namelen))"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "ame,",
            "amelen)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, rd, sizeof(*rd)-8))"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(*rd)-8)"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ime)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            ")"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "+dir_f->highest_version)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ir_f->inocache->ino)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, rd, sizeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(struct jffs2_unknown_node)-4)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "izeof(*rd) + namelen)"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_NODETYPE_DIRENT)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_MAGIC_BITMASK)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space(",
          "args": [
            ",",
            "izeof(*rd)+namelen,",
            "alloclen,",
            "LLOC_DELETION,",
            "FFS2_SUMMARY_DIRENT_SIZE(namelen))"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "74-210",
          "snippet": "nt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_SUMMARY_DIRENT_SIZE(",
          "args": [
            "amelen)"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_raw_dirent(",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_can_mark_obsolete(",
          "args": [
            ")"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_do_unlink(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f,\n\t\t    const char *name, int namelen, struct jffs2_inode_info *dead_f,\n\t\t    uint32_t time)\n{\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t alloclen;\n\tint ret;\n\n\tif (!jffs2_can_mark_obsolete(c)) {\n\t\t/* We can't mark stuff obsolete on the medium. We need to write a deletion dirent */\n\n\t\trd = jffs2_alloc_raw_dirent();\n\t\tif (!rd)\n\t\t\treturn -ENOMEM;\n\n\t\tret = jffs2_reserve_space(c, sizeof(*rd)+namelen, &alloclen,\n\t\t\t\t\tALLOC_DELETION, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\tif (ret) {\n\t\t\tjffs2_free_raw_dirent(rd);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmutex_lock(&dir_f->sem);\n\n\t\t/* Build a deletion node */\n\t\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\t\trd->totlen = cpu_to_je32(sizeof(*rd) + namelen);\n\t\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\t\trd->pino = cpu_to_je32(dir_f->inocache->ino);\n\t\trd->version = cpu_to_je32(++dir_f->highest_version);\n\t\trd->ino = cpu_to_je32(0);\n\t\trd->mctime = cpu_to_je32(time);\n\t\trd->nsize = namelen;\n\t\trd->type = DT_UNKNOWN;\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t\trd->name_crc = cpu_to_je32(crc32(0, name, namelen));\n\n\t\tfd = jffs2_write_dirent(c, dir_f, rd, name, namelen, ALLOC_DELETION);\n\n\t\tjffs2_free_raw_dirent(rd);\n\n\t\tif (IS_ERR(fd)) {\n\t\t\tjffs2_complete_reservation(c);\n\t\t\tmutex_unlock(&dir_f->sem);\n\t\t\treturn PTR_ERR(fd);\n\t\t}\n\n\t\t/* File it. This will mark the old one obsolete. */\n\t\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\t\tmutex_unlock(&dir_f->sem);\n\t} else {\n\t\tuint32_t nhash = full_name_hash(name, namelen);\n\n\t\tfd = dir_f->dents;\n\t\t/* We don't actually want to reserve any space, but we do\n\t\t   want to be holding the alloc_sem when we write to flash */\n\t\tmutex_lock(&c->alloc_sem);\n\t\tmutex_lock(&dir_f->sem);\n\n\t\tfor (fd = dir_f->dents; fd; fd = fd->next) {\n\t\t\tif (fd->nhash == nhash &&\n\t\t\t    !memcmp(fd->name, name, namelen) &&\n\t\t\t    !fd->name[namelen]) {\n\n\t\t\t\tjffs2_dbg(1, \"Marking old dirent node (ino #%u) @%08x obsolete\\n\",\n\t\t\t\t\t  fd->ino, ref_offset(fd->raw));\n\t\t\t\tjffs2_mark_node_obsolete(c, fd->raw);\n\t\t\t\t/* We don't want to remove it from the list immediately,\n\t\t\t\t   because that screws up getdents()/seek() semantics even\n\t\t\t\t   more than they're screwed already. Turn it into a\n\t\t\t\t   node-less deletion dirent instead -- a placeholder */\n\t\t\t\tfd->raw = NULL;\n\t\t\t\tfd->ino = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&dir_f->sem);\n\t}\n\n\t/* dead_f is NULL if this was a rename not a real unlink */\n\t/* Also catch the !f->inocache case, where there was a dirent\n\t   pointing to an inode which didn't exist. */\n\tif (dead_f && dead_f->inocache) {\n\n\t\tmutex_lock(&dead_f->sem);\n\n\t\tif (S_ISDIR(OFNI_EDONI_2SFFJ(dead_f)->i_mode)) {\n\t\t\twhile (dead_f->dents) {\n\t\t\t\t/* There can be only deleted ones */\n\t\t\t\tfd = dead_f->dents;\n\n\t\t\t\tdead_f->dents = fd->next;\n\n\t\t\t\tif (fd->ino) {\n\t\t\t\t\tpr_warn(\"Deleting inode #%u with active dentry \\\"%s\\\"->ino #%u\\n\",\n\t\t\t\t\t\tdead_f->inocache->ino,\n\t\t\t\t\t\tfd->name, fd->ino);\n\t\t\t\t} else {\n\t\t\t\t\tjffs2_dbg(1, \"Removing deletion dirent for \\\"%s\\\" from dir ino #%u\\n\",\n\t\t\t\t\t\t  fd->name,\n\t\t\t\t\t\t  dead_f->inocache->ino);\n\t\t\t\t}\n\t\t\t\tif (fd->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, fd->raw);\n\t\t\t\tjffs2_free_full_dirent(fd);\n\t\t\t}\n\t\t\tdead_f->inocache->pino_nlink = 0;\n\t\t} else\n\t\t\tdead_f->inocache->pino_nlink--;\n\t\t/* NB: Caller must set inode nlink if appropriate */\n\t\tmutex_unlock(&dead_f->sem);\n\t}\n\n\tjffs2_complete_reservation(c);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_do_create(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
    "lines": "440-543",
    "snippet": "nt jffs2_do_create(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f,\n\t\t    struct jffs2_inode_info *f, struct jffs2_raw_inode *ri,\n\t\t    const struct qstr *qstr)\n{\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dnode *fn;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t alloclen;\n\tint ret;\n\n\t/* Try to reserve enough space for both node and dirent.\n\t * Just the node will do for now, though\n\t */\n\tret = jffs2_reserve_space(c, sizeof(*ri), &alloclen, ALLOC_NORMAL,\n\t\t\t\tJFFS2_SUMMARY_INODE_SIZE);\n\tjffs2_dbg(1, \"%s(): reserved 0x%x bytes\\n\", __func__, alloclen);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&f->sem);\n\n\tri->data_crc = cpu_to_je32(0);\n\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\n\tfn = jffs2_write_dnode(c, f, ri, NULL, 0, ALLOC_NORMAL);\n\n\tjffs2_dbg(1, \"jffs2_do_create created file with mode 0x%x\\n\",\n\t\t  jemode_to_cpu(ri->mode));\n\n\tif (IS_ERR(fn)) {\n\t\tjffs2_dbg(1, \"jffs2_write_dnode() failed\\n\");\n\t\t/* Eeek. Wave bye bye */\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_complete_reservation(c);\n\t\treturn PTR_ERR(fn);\n\t}\n\t/* No data here. Only a metadata node, which will be\n\t   obsoleted by the first data write\n\t*/\n\tf->metadata = fn;\n\n\tmutex_unlock(&f->sem);\n\tjffs2_complete_reservation(c);\n\n\tret = jffs2_init_security(&f->vfs_inode, &dir_f->vfs_inode, qstr);\n\tif (ret)\n\t\treturn ret;\n\tret = jffs2_init_acl_post(&f->vfs_inode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = jffs2_reserve_space(c, sizeof(*rd)+qstr->len, &alloclen,\n\t\t\t\tALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(qstr->len));\n\n\tif (ret) {\n\t\t/* Eep. */\n\t\tjffs2_dbg(1, \"jffs2_reserve_space() for dirent failed\\n\");\n\t\treturn ret;\n\t}\n\n\trd = jffs2_alloc_raw_dirent();\n\tif (!rd) {\n\t\t/* Argh. Now we treat it like a normal delete */\n\t\tjffs2_complete_reservation(c);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&dir_f->sem);\n\n\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd->totlen = cpu_to_je32(sizeof(*rd) + qstr->len);\n\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd->pino = cpu_to_je32(dir_f->inocache->ino);\n\trd->version = cpu_to_je32(++dir_f->highest_version);\n\trd->ino = ri->ino;\n\trd->mctime = ri->ctime;\n\trd->nsize = qstr->len;\n\trd->type = DT_REG;\n\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\trd->name_crc = cpu_to_je32(crc32(0, qstr->name, qstr->len));\n\n\tfd = jffs2_write_dirent(c, dir_f, rd, qstr->name, qstr->len, ALLOC_NORMAL);\n\n\tjffs2_free_raw_dirent(rd);\n\n\tif (IS_ERR(fd)) {\n\t\t/* dirent failed to write. Delete the inode normally\n\t\t   as if it were the final unlink() */\n\t\tjffs2_complete_reservation(c);\n\t\tmutex_unlock(&dir_f->sem);\n\t\treturn PTR_ERR(fd);\n\t}\n\n\t/* Link the fd into the inode's list, obsoleting an old\n\t   one if necessary. */\n\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\n\tjffs2_complete_reservation(c);\n\tmutex_unlock(&dir_f->sem);\n\n\treturn 0;\n}",
    "includes": [
      "include \"compr.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_complete_reservation(",
          "args": [
            ")"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_complete_reservation(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "556-563",
          "snippet": "oid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_add_fd_to_list(",
          "args": [
            ",",
            "d,",
            "dir_f->dents)"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_fd_to_list(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "26-57",
          "snippet": "oid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "d)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "d)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_raw_dirent(",
          "args": [
            "d)"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_raw_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "158-162",
          "snippet": "oid jffs2_free_raw_dirent(struct jffs2_raw_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(raw_dirent_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *raw_dirent_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *raw_dirent_slab;\n\noid jffs2_free_raw_dirent(struct jffs2_raw_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(raw_dirent_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_write_dirent(",
          "args": [
            ",",
            "ir_f,",
            "d,",
            "str->name,",
            "str->len,",
            "LLOC_NORMAL)"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_write_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
          "lines": "205-335",
          "snippet": "truct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode)\n{\n\tstruct jffs2_full_dirent *fd;\n\tsize_t retlen;\n\tstruct kvec vecs[2];\n\tuint32_t flash_ofs;\n\tint retried = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",\n\t\t  __func__,\n\t\t  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t  je32_to_cpu(rd->name_crc));\n\n\tD1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   });\n\n\tif (strnlen(name, namelen) != namelen) {\n\t\t/* This should never happen, but seems to have done on at least one\n\t\t   occasion: https://dev.laptop.org/ticket/4184 */\n\t\tpr_crit(\"Error in jffs2_write_dirent() -- name contains zero bytes!\\n\");\n\t\tpr_crit(\"Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",\n\t\t\tje32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t\tje32_to_cpu(rd->name_crc));\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tvecs[0].iov_base = rd;\n\tvecs[0].iov_len = sizeof(*rd);\n\tvecs[1].iov_base = (unsigned char *)name;\n\tvecs[1].iov_len = namelen;\n\n\tfd = jffs2_alloc_full_dirent(namelen+1);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(name, namelen);\n\tfd->type = rd->type;\n\tmemcpy(fd->name, name, namelen);\n\tfd->name[namelen]=0;\n\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dirent_version %d, highest version %d -> updating dirent\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(rd->version), f->highest_version);\n\t\trd->version = cpu_to_je32(++f->highest_version);\n\t\tfd->version = je32_to_cpu(rd->version);\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));\n\tif (ret || (retlen != sizeof(*rd) + namelen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*rd) + namelen, flash_ofs, ret, retlen);\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*rd)+namelen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write\\n\",\n\t\t\t\t\t  flash_ofs);\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\tfd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),\n\t\t\t\t\t      PAD(sizeof(*rd)+namelen), f->inocache);\n\tif (IS_ERR(fd->raw)) {\n\t\tvoid *hold_err = fd->raw;\n\t\t/* Release the full_dirent which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "include \"compr.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode)\n{\n\tstruct jffs2_full_dirent *fd;\n\tsize_t retlen;\n\tstruct kvec vecs[2];\n\tuint32_t flash_ofs;\n\tint retried = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",\n\t\t  __func__,\n\t\t  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t  je32_to_cpu(rd->name_crc));\n\n\tD1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   });\n\n\tif (strnlen(name, namelen) != namelen) {\n\t\t/* This should never happen, but seems to have done on at least one\n\t\t   occasion: https://dev.laptop.org/ticket/4184 */\n\t\tpr_crit(\"Error in jffs2_write_dirent() -- name contains zero bytes!\\n\");\n\t\tpr_crit(\"Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",\n\t\t\tje32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t\tje32_to_cpu(rd->name_crc));\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tvecs[0].iov_base = rd;\n\tvecs[0].iov_len = sizeof(*rd);\n\tvecs[1].iov_base = (unsigned char *)name;\n\tvecs[1].iov_len = namelen;\n\n\tfd = jffs2_alloc_full_dirent(namelen+1);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(name, namelen);\n\tfd->type = rd->type;\n\tmemcpy(fd->name, name, namelen);\n\tfd->name[namelen]=0;\n\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dirent_version %d, highest version %d -> updating dirent\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(rd->version), f->highest_version);\n\t\trd->version = cpu_to_je32(++f->highest_version);\n\t\tfd->version = je32_to_cpu(rd->version);\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));\n\tif (ret || (retlen != sizeof(*rd) + namelen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*rd) + namelen, flash_ofs, ret, retlen);\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*rd)+namelen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write\\n\",\n\t\t\t\t\t  flash_ofs);\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\tfd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),\n\t\t\t\t\t      PAD(sizeof(*rd)+namelen), f->inocache);\n\tif (IS_ERR(fd->raw)) {\n\t\tvoid *hold_err = fd->raw;\n\t\t/* Release the full_dirent which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, qstr->name, qstr->len))"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "str->name,",
            "str->len)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, rd, sizeof(*rd)-8))"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(*rd)-8)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "+dir_f->highest_version)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ir_f->inocache->ino)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, rd, sizeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(struct jffs2_unknown_node)-4)"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "izeof(*rd) + qstr->len)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_NODETYPE_DIRENT)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_MAGIC_BITMASK)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "dir_f->sem)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_raw_dirent(",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_reserve_space() for dirent failed\\n\")"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space(",
          "args": [
            ",",
            "izeof(*rd)+qstr->len,",
            "alloclen,",
            "LLOC_NORMAL,",
            "FFS2_SUMMARY_DIRENT_SIZE(qstr->len))"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "74-210",
          "snippet": "nt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_SUMMARY_DIRENT_SIZE(",
          "args": [
            "str->len)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_init_acl_post(",
          "args": [
            "f->vfs_inode)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_init_acl_post(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/acl.c",
          "lines": "292-309",
          "snippet": "nt jffs2_init_acl_post(struct inode *inode)\n{\n\tint rc;\n\n\tif (inode->i_default_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_DEFAULT, inode->i_default_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (inode->i_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_ACCESS, inode->i_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_init_acl_post(struct inode *inode)\n{\n\tint rc;\n\n\tif (inode->i_default_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_DEFAULT, inode->i_default_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (inode->i_acl) {\n\t\trc = __jffs2_set_acl(inode, JFFS2_XPREFIX_ACL_ACCESS, inode->i_acl);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_init_security(",
          "args": [
            "f->vfs_inode,",
            "dir_f->vfs_inode,",
            "str)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_init_security(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/security.c",
          "lines": "43-48",
          "snippet": "nt jffs2_init_security(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &jffs2_initxattrs, NULL);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/security.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/security.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_init_security(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &jffs2_initxattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "f->sem)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "n)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "f->sem)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_write_dnode() failed\\n\")"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "n)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_do_create created file with mode 0x%x\\n\",",
            "emode_to_cpu(ri->mode))"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emode_to_cpu(",
          "args": [
            "i->mode)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_write_dnode(",
          "args": [
            ",",
            ",",
            "i,",
            "ULL,",
            ",",
            "LLOC_NORMAL)"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_write_dnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
          "lines": "59-203",
          "snippet": "truct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t   struct jffs2_raw_inode *ri, const unsigned char *data,\n\t\t\t\t\t   uint32_t datalen, int alloc_mode)\n\n{\n\tstruct jffs2_full_dnode *fn;\n\tsize_t retlen;\n\tuint32_t flash_ofs;\n\tstruct kvec vecs[2];\n\tint ret;\n\tint retried = 0;\n\tunsigned long cnt = 2;\n\n\tD1(if(je32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dnode()\\n\");\n\t\tBUG();\n\t}\n\t   );\n\tvecs[0].iov_base = ri;\n\tvecs[0].iov_len = sizeof(*ri);\n\tvecs[1].iov_base = (unsigned char *)data;\n\tvecs[1].iov_len = datalen;\n\n\tif (je32_to_cpu(ri->totlen) != sizeof(*ri) + datalen) {\n\t\tpr_warn(\"%s(): ri->totlen (0x%08x) != sizeof(*ri) (0x%08zx) + datalen (0x%08x)\\n\",\n\t\t\t__func__, je32_to_cpu(ri->totlen),\n\t\t\tsizeof(*ri), datalen);\n\t}\n\n\tfn = jffs2_alloc_full_dnode();\n\tif (!fn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* check number of valid vecs */\n\tif (!datalen || !data)\n\t\tcnt = 1;\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(ri->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dnode_version %d, highest version %d -> updating dnode\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(ri->version), f->highest_version);\n\t\tri->version = cpu_to_je32(++f->highest_version);\n\t\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, cnt, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:f->inocache->ino);\n\n\tif (ret || (retlen != sizeof(*ri) + datalen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*ri) + datalen, flash_ofs, ret, retlen);\n\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\t/* Don't change raw->size to match retlen. We may have\n\t\t\t   written the node header already, and only the data will\n\t\t\t   seem corrupted, in which case the scan would skip over\n\t\t\t   any node we write before the original intended end of\n\t\t\t   this node */\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*ri)+datalen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried && alloc_mode != ALLOC_NORETRY) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  flash_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\t/* If node covers at least a whole page, or if it starts at the\n\t   beginning of a page and runs to the end of the file, or if\n\t   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL.\n\t*/\n\tif ((je32_to_cpu(ri->dsize) >= PAGE_CACHE_SIZE) ||\n\t    ( ((je32_to_cpu(ri->offset)&(PAGE_CACHE_SIZE-1))==0) &&\n\t      (je32_to_cpu(ri->dsize)+je32_to_cpu(ri->offset) ==  je32_to_cpu(ri->isize)))) {\n\t\tflash_ofs |= REF_PRISTINE;\n\t} else {\n\t\tflash_ofs |= REF_NORMAL;\n\t}\n\tfn->raw = jffs2_add_physical_node_ref(c, flash_ofs, PAD(sizeof(*ri)+datalen), f->inocache);\n\tif (IS_ERR(fn->raw)) {\n\t\tvoid *hold_err = fn->raw;\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\tfn->ofs = je32_to_cpu(ri->offset);\n\tfn->size = je32_to_cpu(ri->dsize);\n\tfn->frags = 0;\n\n\tjffs2_dbg(1, \"jffs2_write_dnode wrote node at 0x%08x(%d) with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\\n\",\n\t\t  flash_ofs & ~3, flash_ofs & 3, je32_to_cpu(ri->dsize),\n\t\t  je32_to_cpu(ri->csize), je32_to_cpu(ri->node_crc),\n\t\t  je32_to_cpu(ri->data_crc), je32_to_cpu(ri->totlen));\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fn;\n}",
          "includes": [
            "include \"compr.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t   struct jffs2_raw_inode *ri, const unsigned char *data,\n\t\t\t\t\t   uint32_t datalen, int alloc_mode)\n\n{\n\tstruct jffs2_full_dnode *fn;\n\tsize_t retlen;\n\tuint32_t flash_ofs;\n\tstruct kvec vecs[2];\n\tint ret;\n\tint retried = 0;\n\tunsigned long cnt = 2;\n\n\tD1(if(je32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dnode()\\n\");\n\t\tBUG();\n\t}\n\t   );\n\tvecs[0].iov_base = ri;\n\tvecs[0].iov_len = sizeof(*ri);\n\tvecs[1].iov_base = (unsigned char *)data;\n\tvecs[1].iov_len = datalen;\n\n\tif (je32_to_cpu(ri->totlen) != sizeof(*ri) + datalen) {\n\t\tpr_warn(\"%s(): ri->totlen (0x%08x) != sizeof(*ri) (0x%08zx) + datalen (0x%08x)\\n\",\n\t\t\t__func__, je32_to_cpu(ri->totlen),\n\t\t\tsizeof(*ri), datalen);\n\t}\n\n\tfn = jffs2_alloc_full_dnode();\n\tif (!fn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* check number of valid vecs */\n\tif (!datalen || !data)\n\t\tcnt = 1;\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(ri->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dnode_version %d, highest version %d -> updating dnode\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(ri->version), f->highest_version);\n\t\tri->version = cpu_to_je32(++f->highest_version);\n\t\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, cnt, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:f->inocache->ino);\n\n\tif (ret || (retlen != sizeof(*ri) + datalen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*ri) + datalen, flash_ofs, ret, retlen);\n\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\t/* Don't change raw->size to match retlen. We may have\n\t\t\t   written the node header already, and only the data will\n\t\t\t   seem corrupted, in which case the scan would skip over\n\t\t\t   any node we write before the original intended end of\n\t\t\t   this node */\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*ri)+datalen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried && alloc_mode != ALLOC_NORETRY) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  flash_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\t/* If node covers at least a whole page, or if it starts at the\n\t   beginning of a page and runs to the end of the file, or if\n\t   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL.\n\t*/\n\tif ((je32_to_cpu(ri->dsize) >= PAGE_CACHE_SIZE) ||\n\t    ( ((je32_to_cpu(ri->offset)&(PAGE_CACHE_SIZE-1))==0) &&\n\t      (je32_to_cpu(ri->dsize)+je32_to_cpu(ri->offset) ==  je32_to_cpu(ri->isize)))) {\n\t\tflash_ofs |= REF_PRISTINE;\n\t} else {\n\t\tflash_ofs |= REF_NORMAL;\n\t}\n\tfn->raw = jffs2_add_physical_node_ref(c, flash_ofs, PAD(sizeof(*ri)+datalen), f->inocache);\n\tif (IS_ERR(fn->raw)) {\n\t\tvoid *hold_err = fn->raw;\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\tfn->ofs = je32_to_cpu(ri->offset);\n\tfn->size = je32_to_cpu(ri->dsize);\n\tfn->frags = 0;\n\n\tjffs2_dbg(1, \"jffs2_write_dnode wrote node at 0x%08x(%d) with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\\n\",\n\t\t  flash_ofs & ~3, flash_ofs & 3, je32_to_cpu(ri->dsize),\n\t\t  je32_to_cpu(ri->csize), je32_to_cpu(ri->node_crc),\n\t\t  je32_to_cpu(ri->data_crc), je32_to_cpu(ri->totlen));\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, ri, sizeof(*ri)-8))"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "i,",
            "izeof(*ri)-8)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            ")"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "f->sem)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): reserved 0x%x bytes\\n\",",
            "_func__,",
            "lloclen)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_do_create(struct jffs2_sb_info *c, struct jffs2_inode_info *dir_f,\n\t\t    struct jffs2_inode_info *f, struct jffs2_raw_inode *ri,\n\t\t    const struct qstr *qstr)\n{\n\tstruct jffs2_raw_dirent *rd;\n\tstruct jffs2_full_dnode *fn;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t alloclen;\n\tint ret;\n\n\t/* Try to reserve enough space for both node and dirent.\n\t * Just the node will do for now, though\n\t */\n\tret = jffs2_reserve_space(c, sizeof(*ri), &alloclen, ALLOC_NORMAL,\n\t\t\t\tJFFS2_SUMMARY_INODE_SIZE);\n\tjffs2_dbg(1, \"%s(): reserved 0x%x bytes\\n\", __func__, alloclen);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&f->sem);\n\n\tri->data_crc = cpu_to_je32(0);\n\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\n\tfn = jffs2_write_dnode(c, f, ri, NULL, 0, ALLOC_NORMAL);\n\n\tjffs2_dbg(1, \"jffs2_do_create created file with mode 0x%x\\n\",\n\t\t  jemode_to_cpu(ri->mode));\n\n\tif (IS_ERR(fn)) {\n\t\tjffs2_dbg(1, \"jffs2_write_dnode() failed\\n\");\n\t\t/* Eeek. Wave bye bye */\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_complete_reservation(c);\n\t\treturn PTR_ERR(fn);\n\t}\n\t/* No data here. Only a metadata node, which will be\n\t   obsoleted by the first data write\n\t*/\n\tf->metadata = fn;\n\n\tmutex_unlock(&f->sem);\n\tjffs2_complete_reservation(c);\n\n\tret = jffs2_init_security(&f->vfs_inode, &dir_f->vfs_inode, qstr);\n\tif (ret)\n\t\treturn ret;\n\tret = jffs2_init_acl_post(&f->vfs_inode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = jffs2_reserve_space(c, sizeof(*rd)+qstr->len, &alloclen,\n\t\t\t\tALLOC_NORMAL, JFFS2_SUMMARY_DIRENT_SIZE(qstr->len));\n\n\tif (ret) {\n\t\t/* Eep. */\n\t\tjffs2_dbg(1, \"jffs2_reserve_space() for dirent failed\\n\");\n\t\treturn ret;\n\t}\n\n\trd = jffs2_alloc_raw_dirent();\n\tif (!rd) {\n\t\t/* Argh. Now we treat it like a normal delete */\n\t\tjffs2_complete_reservation(c);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&dir_f->sem);\n\n\trd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd->totlen = cpu_to_je32(sizeof(*rd) + qstr->len);\n\trd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd->pino = cpu_to_je32(dir_f->inocache->ino);\n\trd->version = cpu_to_je32(++dir_f->highest_version);\n\trd->ino = ri->ino;\n\trd->mctime = ri->ctime;\n\trd->nsize = qstr->len;\n\trd->type = DT_REG;\n\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\trd->name_crc = cpu_to_je32(crc32(0, qstr->name, qstr->len));\n\n\tfd = jffs2_write_dirent(c, dir_f, rd, qstr->name, qstr->len, ALLOC_NORMAL);\n\n\tjffs2_free_raw_dirent(rd);\n\n\tif (IS_ERR(fd)) {\n\t\t/* dirent failed to write. Delete the inode normally\n\t\t   as if it were the final unlink() */\n\t\tjffs2_complete_reservation(c);\n\t\tmutex_unlock(&dir_f->sem);\n\t\treturn PTR_ERR(fd);\n\t}\n\n\t/* Link the fd into the inode's list, obsoleting an old\n\t   one if necessary. */\n\tjffs2_add_fd_to_list(c, fd, &dir_f->dents);\n\n\tjffs2_complete_reservation(c);\n\tmutex_unlock(&dir_f->sem);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_write_inode_range(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
    "lines": "340-438",
    "snippet": "nt jffs2_write_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t    struct jffs2_raw_inode *ri, unsigned char *buf,\n\t\t\t    uint32_t offset, uint32_t writelen, uint32_t *retlen)\n{\n\tint ret = 0;\n\tuint32_t writtenlen = 0;\n\n\tjffs2_dbg(1, \"%s(): Ino #%u, ofs 0x%x, len 0x%x\\n\",\n\t\t  __func__, f->inocache->ino, offset, writelen);\n\n\twhile(writelen) {\n\t\tstruct jffs2_full_dnode *fn;\n\t\tunsigned char *comprbuf = NULL;\n\t\tuint16_t comprtype = JFFS2_COMPR_NONE;\n\t\tuint32_t alloclen;\n\t\tuint32_t datalen, cdatalen;\n\t\tint retried = 0;\n\n\tretry:\n\t\tjffs2_dbg(2, \"jffs2_commit_write() loop: 0x%x to write to 0x%x\\n\",\n\t\t\t  writelen, offset);\n\n\t\tret = jffs2_reserve_space(c, sizeof(*ri) + JFFS2_MIN_DATA_LEN,\n\t\t\t\t\t&alloclen, ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"jffs2_reserve_space returned %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_lock(&f->sem);\n\t\tdatalen = min_t(uint32_t, writelen, PAGE_CACHE_SIZE - (offset & (PAGE_CACHE_SIZE-1)));\n\t\tcdatalen = min_t(uint32_t, alloclen - sizeof(*ri), datalen);\n\n\t\tcomprtype = jffs2_compress(c, f, buf, &comprbuf, &datalen, &cdatalen);\n\n\t\tri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri->totlen = cpu_to_je32(sizeof(*ri) + cdatalen);\n\t\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri->ino = cpu_to_je32(f->inocache->ino);\n\t\tri->version = cpu_to_je32(++f->highest_version);\n\t\tri->isize = cpu_to_je32(max(je32_to_cpu(ri->isize), offset + datalen));\n\t\tri->offset = cpu_to_je32(offset);\n\t\tri->csize = cpu_to_je32(cdatalen);\n\t\tri->dsize = cpu_to_je32(datalen);\n\t\tri->compr = comprtype & 0xff;\n\t\tri->usercompr = (comprtype >> 8 ) & 0xff;\n\t\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\t\tri->data_crc = cpu_to_je32(crc32(0, comprbuf, cdatalen));\n\n\t\tfn = jffs2_write_dnode(c, f, ri, comprbuf, cdatalen, ALLOC_NORETRY);\n\n\t\tjffs2_free_comprbuf(comprbuf, buf);\n\n\t\tif (IS_ERR(fn)) {\n\t\t\tret = PTR_ERR(fn);\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_complete_reservation(c);\n\t\t\tif (!retried) {\n\t\t\t\t/* Write error to be retried */\n\t\t\t\tretried = 1;\n\t\t\t\tjffs2_dbg(1, \"Retrying node write in jffs2_write_inode_range()\\n\");\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tret = jffs2_add_full_dnode_to_inode(c, f, fn);\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t\tif (ret) {\n\t\t\t/* Eep */\n\t\t\tjffs2_dbg(1, \"Eep. add_full_dnode_to_inode() failed in commit_write, returned %d\\n\",\n\t\t\t\t  ret);\n\t\t\tjffs2_mark_node_obsolete(c, fn->raw);\n\t\t\tjffs2_free_full_dnode(fn);\n\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_complete_reservation(c);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_complete_reservation(c);\n\t\tif (!datalen) {\n\t\t\tpr_warn(\"Eep. We didn't actually write any data in jffs2_write_inode_range()\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tjffs2_dbg(1, \"increasing writtenlen by %d\\n\", datalen);\n\t\twrittenlen += datalen;\n\t\toffset += datalen;\n\t\twritelen -= datalen;\n\t\tbuf += datalen;\n\t}\n\t*retlen = writtenlen;\n\treturn ret;\n}",
    "includes": [
      "include \"compr.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "increasing writtenlen by %d\\n\",",
            "atalen)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Eep. We didn't actually write any data in jffs2_write_inode_range()\\n\")"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_complete_reservation(",
          "args": [
            ")"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_complete_reservation(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "556-563",
          "snippet": "oid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "f->sem)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "f->sem)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_full_dnode(",
          "args": [
            "n)"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "144-148",
          "snippet": "oid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *full_dnode_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *full_dnode_slab;\n\noid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_mark_node_obsolete(",
          "args": [
            ",",
            "n->raw)"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_mark_node_obsolete(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "579-835",
          "snippet": "oid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint blocknr;\n\tstruct jffs2_unknown_node n;\n\tint ret, addedsize;\n\tsize_t retlen;\n\tuint32_t freed_len;\n\n\tif(unlikely(!ref)) {\n\t\tpr_notice(\"EEEEEK. jffs2_mark_node_obsolete called with NULL node\\n\");\n\t\treturn;\n\t}\n\tif (ref_obsolete(ref)) {\n\t\tjffs2_dbg(1, \"%s(): called with already obsolete node at 0x%08x\\n\",\n\t\t\t  __func__, ref_offset(ref));\n\t\treturn;\n\t}\n\tblocknr = ref->flash_offset / c->sector_size;\n\tif (blocknr >= c->nr_blocks) {\n\t\tpr_notice(\"raw node at 0x%08x is off the end of device!\\n\",\n\t\t\t  ref->flash_offset);\n\t\tBUG();\n\t}\n\tjeb = &c->blocks[blocknr];\n\n\tif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\n\t    !(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\n\t\t/* Hm. This may confuse static lock analysis. If any of the above\n\t\t   three conditions is false, we're going to return from this\n\t\t   function without actually obliterating any nodes or freeing\n\t\t   any jffs2_raw_node_refs. So we don't need to stop erases from\n\t\t   happening, or protect against people holding an obsolete\n\t\t   jffs2_raw_node_ref without the erase_completion_lock. */\n\t\tmutex_lock(&c->erase_free_sem);\n\t}\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tfreed_len = ref_totlen(c, jeb, ref);\n\n\tif (ref_flags(ref) == REF_UNCHECKED) {\n\t\tD1(if (unlikely(jeb->unchecked_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting previously unchecked node at 0x%08x of len %x\\n\",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->unchecked_size -= freed_len;\n\t\tc->unchecked_size -= freed_len;\n\t} else {\n\t\tD1(if (unlikely(jeb->used_size < freed_len)) {\n\t\t\t\tpr_notice(\"raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\\n\",\n\t\t\t\t\t  freed_len, blocknr,\n\t\t\t\t\t  ref->flash_offset, jeb->used_size);\n\t\t\tBUG();\n\t\t})\n\t\t\tjffs2_dbg(1, \"Obsoleting node at 0x%08x of len %#x: \",\n\t\t\t\t  ref_offset(ref), freed_len);\n\t\tjeb->used_size -= freed_len;\n\t\tc->used_size -= freed_len;\n\t}\n\n\t// Take care, that wasted size is taken into concern\n\tif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\n\t\tjffs2_dbg(1, \"Dirtying\\n\");\n\t\taddedsize = freed_len;\n\t\tjeb->dirty_size += freed_len;\n\t\tc->dirty_size += freed_len;\n\n\t\t/* Convert wasted space to dirty, if not a bad block */\n\t\tif (jeb->wasted_size) {\n\t\t\tif (on_list(&jeb->list, &c->bad_used_list)) {\n\t\t\t\tjffs2_dbg(1, \"Leaving block at %08x on the bad_used_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\taddedsize = 0; /* To fool the refiling code later */\n\t\t\t} else {\n\t\t\t\tjffs2_dbg(1, \"Converting %d bytes of wasted space to dirty in block at %08x\\n\",\n\t\t\t\t\t  jeb->wasted_size, jeb->offset);\n\t\t\t\taddedsize += jeb->wasted_size;\n\t\t\t\tjeb->dirty_size += jeb->wasted_size;\n\t\t\t\tc->dirty_size += jeb->wasted_size;\n\t\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\t\tjeb->wasted_size = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tjffs2_dbg(1, \"Wasting\\n\");\n\t\taddedsize = 0;\n\t\tjeb->wasted_size += freed_len;\n\t\tc->wasted_size += freed_len;\n\t}\n\tref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tif (c->flags & JFFS2_SB_FLAG_SCANNING) {\n\t\t/* Flash scanning is in progress. Don't muck about with the block\n\t\t   lists because they're not ready yet, and don't actually\n\t\t   obliterate nodes that look obsolete. If they weren't\n\t\t   marked obsolete on the flash at the time they _became_\n\t\t   obsolete, there was probably a reason for that. */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\tif (jeb == c->nextblock) {\n\t\tjffs2_dbg(2, \"Not moving nextblock 0x%08x to dirty/erase_pending list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (!jeb->used_size && !jeb->unchecked_size) {\n\t\tif (jeb == c->gcblock) {\n\t\t\tjffs2_dbg(1, \"gcblock at 0x%08x completely dirtied. Clearing gcblock...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tc->gcblock = NULL;\n\t\t} else {\n\t\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t}\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\tjffs2_dbg(1, \"...and adding to erasable_pending_wbuf_list\\n\");\n\t\t\tlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\n\t\t} else {\n\t\t\tif (jiffies & 127) {\n\t\t\t\t/* Most of the time, we just erase it immediately. Otherwise we\n\t\t\t\t   spend ages scanning it on mount, etc. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erase_pending_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t\tjffs2_garbage_collect_trigger(c);\n\t\t\t} else {\n\t\t\t\t/* Sometimes, however, we leave it elsewhere so it doesn't get\n\t\t\t\t   immediately reused, and we spread the load a bit. */\n\t\t\t\tjffs2_dbg(1, \"...and adding to erasable_list\\n\");\n\t\t\t\tlist_add_tail(&jeb->list, &c->erasable_list);\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Done OK\\n\");\n\t} else if (jeb == c->gcblock) {\n\t\tjffs2_dbg(2, \"Not moving gcblock 0x%08x to dirty_list\\n\",\n\t\t\t  jeb->offset);\n\t} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->dirty_list);\n\t} else if (VERYDIRTY(c, jeb->dirty_size) &&\n\t\t   !VERYDIRTY(c, jeb->dirty_size - addedsize)) {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\\n\",\n\t\t\t  jeb->offset);\n\t\tlist_del(&jeb->list);\n\t\tjffs2_dbg(1, \"...and adding to very_dirty_list\\n\");\n\t\tlist_add_tail(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tjffs2_dbg(1, \"Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\n\t\t(c->flags & JFFS2_SB_FLAG_BUILDING)) {\n\t\t/* We didn't lock the erase_free_sem */\n\t\treturn;\n\t}\n\n\t/* The erase_free_sem is locked, and has been since before we marked the node obsolete\n\t   and potentially put its eraseblock onto the erase_pending_list. Thus, we know that\n\t   the block hasn't _already_ been erased, and that 'ref' itself hasn't been freed yet\n\t   by jffs2_free_jeb_node_refs() in erase.c. Which is nice. */\n\n\tjffs2_dbg(1, \"obliterating obsoleted node at 0x%08x\\n\",\n\t\t  ref_offset(ref));\n\tret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Read error reading from obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short read from obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\tif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\n\t\tpr_warn(\"Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\\n\",\n\t\t\tje32_to_cpu(n.totlen), freed_len);\n\t\tgoto out_erase_sem;\n\t}\n\tif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\\n\",\n\t\t\t  ref_offset(ref), je16_to_cpu(n.nodetype));\n\t\tgoto out_erase_sem;\n\t}\n\t/* XXX FIXME: This is ugly now */\n\tn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\n\tret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\n\tif (ret) {\n\t\tpr_warn(\"Write error in obliterating obsoleted node at 0x%08x: %d\\n\",\n\t\t\tref_offset(ref), ret);\n\t\tgoto out_erase_sem;\n\t}\n\tif (retlen != sizeof(n)) {\n\t\tpr_warn(\"Short write in obliterating obsoleted node at 0x%08x: %zd\\n\",\n\t\t\tref_offset(ref), retlen);\n\t\tgoto out_erase_sem;\n\t}\n\n\t/* Nodes which have been marked obsolete no longer need to be\n\t   associated with any inode. Remove them from the per-inode list.\n\n\t   Note we can't do this for NAND at the moment because we need\n\t   obsolete dirent nodes to stay on the lists, because of the\n\t   horridness in jffs2_garbage_collect_deletion_dirent(). Also\n\t   because we delete the inocache, and on NAND we need that to\n\t   stay around until all the nodes are actually erased, in order\n\t   to stop us from giving the same inode number to another newly\n\t   created inode. */\n\tif (ref->next_in_ino) {\n\t\tstruct jffs2_inode_cache *ic;\n\t\tstruct jffs2_raw_node_ref **p;\n\n\t\tspin_lock(&c->erase_completion_lock);\n\n\t\tic = jffs2_raw_ref_to_ic(ref);\n\t\tfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\n\t\t\t;\n\n\t\t*p = ref->next_in_ino;\n\t\tref->next_in_ino = NULL;\n\n\t\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\t\tbreak;\n\t\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\n out_erase_sem:\n\tmutex_unlock(&c->erase_free_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Eep. add_full_dnode_to_inode() failed in commit_write, returned %d\\n\",",
            "et)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_full_dnode_to_inode(",
          "args": [
            ",",
            ",",
            "n)"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_full_dnode_to_inode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "363-406",
          "snippet": "nt jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\n{\n\tint ret;\n\tstruct jffs2_node_frag *newfrag;\n\n\tif (unlikely(!fn->size))\n\t\treturn 0;\n\n\tnewfrag = new_fragment(fn, fn->ofs, fn->size);\n\tif (unlikely(!newfrag))\n\t\treturn -ENOMEM;\n\tnewfrag->node->frags = 1;\n\n\tdbg_fragtree(\"adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\\n\",\n\t\t  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);\n\n\tret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/* If we now share a page with other nodes, mark either previous\n\t   or next node REF_NORMAL, as appropriate.  */\n\tif (newfrag->ofs & (PAGE_CACHE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *prev = frag_prev(newfrag);\n\n\t\tmark_ref_normal(fn->raw);\n\t\t/* If we don't start at zero there's _always_ a previous */\n\t\tif (prev->node)\n\t\t\tmark_ref_normal(prev->node->raw);\n\t}\n\n\tif ((newfrag->ofs+newfrag->size) & (PAGE_CACHE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *next = frag_next(newfrag);\n\n\t\tif (next) {\n\t\t\tmark_ref_normal(fn->raw);\n\t\t\tif (next->node)\n\t\t\t\tmark_ref_normal(next->node->raw);\n\t\t}\n\t}\n\tjffs2_dbg_fragtree_paranoia_check_nolock(f);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\n{\n\tint ret;\n\tstruct jffs2_node_frag *newfrag;\n\n\tif (unlikely(!fn->size))\n\t\treturn 0;\n\n\tnewfrag = new_fragment(fn, fn->ofs, fn->size);\n\tif (unlikely(!newfrag))\n\t\treturn -ENOMEM;\n\tnewfrag->node->frags = 1;\n\n\tdbg_fragtree(\"adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\\n\",\n\t\t  fn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);\n\n\tret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t/* If we now share a page with other nodes, mark either previous\n\t   or next node REF_NORMAL, as appropriate.  */\n\tif (newfrag->ofs & (PAGE_CACHE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *prev = frag_prev(newfrag);\n\n\t\tmark_ref_normal(fn->raw);\n\t\t/* If we don't start at zero there's _always_ a previous */\n\t\tif (prev->node)\n\t\t\tmark_ref_normal(prev->node->raw);\n\t}\n\n\tif ((newfrag->ofs+newfrag->size) & (PAGE_CACHE_SIZE-1)) {\n\t\tstruct jffs2_node_frag *next = frag_next(newfrag);\n\n\t\tif (next) {\n\t\t\tmark_ref_normal(fn->raw);\n\t\t\tif (next->node)\n\t\t\t\tmark_ref_normal(next->node->raw);\n\t\t}\n\t}\n\tjffs2_dbg_fragtree_paranoia_check_nolock(f);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Retrying node write in jffs2_write_inode_range()\\n\")"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "f->sem)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "n)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "n)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_comprbuf(",
          "args": [
            "omprbuf,",
            "uf)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_write_dnode(",
          "args": [
            ",",
            ",",
            "i,",
            "omprbuf,",
            "datalen,",
            "LLOC_NORETRY)"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_write_dnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
          "lines": "59-203",
          "snippet": "truct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t   struct jffs2_raw_inode *ri, const unsigned char *data,\n\t\t\t\t\t   uint32_t datalen, int alloc_mode)\n\n{\n\tstruct jffs2_full_dnode *fn;\n\tsize_t retlen;\n\tuint32_t flash_ofs;\n\tstruct kvec vecs[2];\n\tint ret;\n\tint retried = 0;\n\tunsigned long cnt = 2;\n\n\tD1(if(je32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dnode()\\n\");\n\t\tBUG();\n\t}\n\t   );\n\tvecs[0].iov_base = ri;\n\tvecs[0].iov_len = sizeof(*ri);\n\tvecs[1].iov_base = (unsigned char *)data;\n\tvecs[1].iov_len = datalen;\n\n\tif (je32_to_cpu(ri->totlen) != sizeof(*ri) + datalen) {\n\t\tpr_warn(\"%s(): ri->totlen (0x%08x) != sizeof(*ri) (0x%08zx) + datalen (0x%08x)\\n\",\n\t\t\t__func__, je32_to_cpu(ri->totlen),\n\t\t\tsizeof(*ri), datalen);\n\t}\n\n\tfn = jffs2_alloc_full_dnode();\n\tif (!fn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* check number of valid vecs */\n\tif (!datalen || !data)\n\t\tcnt = 1;\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(ri->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dnode_version %d, highest version %d -> updating dnode\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(ri->version), f->highest_version);\n\t\tri->version = cpu_to_je32(++f->highest_version);\n\t\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, cnt, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:f->inocache->ino);\n\n\tif (ret || (retlen != sizeof(*ri) + datalen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*ri) + datalen, flash_ofs, ret, retlen);\n\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\t/* Don't change raw->size to match retlen. We may have\n\t\t\t   written the node header already, and only the data will\n\t\t\t   seem corrupted, in which case the scan would skip over\n\t\t\t   any node we write before the original intended end of\n\t\t\t   this node */\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*ri)+datalen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried && alloc_mode != ALLOC_NORETRY) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  flash_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\t/* If node covers at least a whole page, or if it starts at the\n\t   beginning of a page and runs to the end of the file, or if\n\t   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL.\n\t*/\n\tif ((je32_to_cpu(ri->dsize) >= PAGE_CACHE_SIZE) ||\n\t    ( ((je32_to_cpu(ri->offset)&(PAGE_CACHE_SIZE-1))==0) &&\n\t      (je32_to_cpu(ri->dsize)+je32_to_cpu(ri->offset) ==  je32_to_cpu(ri->isize)))) {\n\t\tflash_ofs |= REF_PRISTINE;\n\t} else {\n\t\tflash_ofs |= REF_NORMAL;\n\t}\n\tfn->raw = jffs2_add_physical_node_ref(c, flash_ofs, PAD(sizeof(*ri)+datalen), f->inocache);\n\tif (IS_ERR(fn->raw)) {\n\t\tvoid *hold_err = fn->raw;\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\tfn->ofs = je32_to_cpu(ri->offset);\n\tfn->size = je32_to_cpu(ri->dsize);\n\tfn->frags = 0;\n\n\tjffs2_dbg(1, \"jffs2_write_dnode wrote node at 0x%08x(%d) with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\\n\",\n\t\t  flash_ofs & ~3, flash_ofs & 3, je32_to_cpu(ri->dsize),\n\t\t  je32_to_cpu(ri->csize), je32_to_cpu(ri->node_crc),\n\t\t  je32_to_cpu(ri->data_crc), je32_to_cpu(ri->totlen));\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fn;\n}",
          "includes": [
            "include \"compr.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t   struct jffs2_raw_inode *ri, const unsigned char *data,\n\t\t\t\t\t   uint32_t datalen, int alloc_mode)\n\n{\n\tstruct jffs2_full_dnode *fn;\n\tsize_t retlen;\n\tuint32_t flash_ofs;\n\tstruct kvec vecs[2];\n\tint ret;\n\tint retried = 0;\n\tunsigned long cnt = 2;\n\n\tD1(if(je32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dnode()\\n\");\n\t\tBUG();\n\t}\n\t   );\n\tvecs[0].iov_base = ri;\n\tvecs[0].iov_len = sizeof(*ri);\n\tvecs[1].iov_base = (unsigned char *)data;\n\tvecs[1].iov_len = datalen;\n\n\tif (je32_to_cpu(ri->totlen) != sizeof(*ri) + datalen) {\n\t\tpr_warn(\"%s(): ri->totlen (0x%08x) != sizeof(*ri) (0x%08zx) + datalen (0x%08x)\\n\",\n\t\t\t__func__, je32_to_cpu(ri->totlen),\n\t\t\tsizeof(*ri), datalen);\n\t}\n\n\tfn = jffs2_alloc_full_dnode();\n\tif (!fn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* check number of valid vecs */\n\tif (!datalen || !data)\n\t\tcnt = 1;\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(ri->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dnode_version %d, highest version %d -> updating dnode\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(ri->version), f->highest_version);\n\t\tri->version = cpu_to_je32(++f->highest_version);\n\t\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, cnt, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:f->inocache->ino);\n\n\tif (ret || (retlen != sizeof(*ri) + datalen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*ri) + datalen, flash_ofs, ret, retlen);\n\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\t/* Don't change raw->size to match retlen. We may have\n\t\t\t   written the node header already, and only the data will\n\t\t\t   seem corrupted, in which case the scan would skip over\n\t\t\t   any node we write before the original intended end of\n\t\t\t   this node */\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*ri)+datalen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried && alloc_mode != ALLOC_NORETRY) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  flash_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\t/* If node covers at least a whole page, or if it starts at the\n\t   beginning of a page and runs to the end of the file, or if\n\t   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL.\n\t*/\n\tif ((je32_to_cpu(ri->dsize) >= PAGE_CACHE_SIZE) ||\n\t    ( ((je32_to_cpu(ri->offset)&(PAGE_CACHE_SIZE-1))==0) &&\n\t      (je32_to_cpu(ri->dsize)+je32_to_cpu(ri->offset) ==  je32_to_cpu(ri->isize)))) {\n\t\tflash_ofs |= REF_PRISTINE;\n\t} else {\n\t\tflash_ofs |= REF_NORMAL;\n\t}\n\tfn->raw = jffs2_add_physical_node_ref(c, flash_ofs, PAD(sizeof(*ri)+datalen), f->inocache);\n\tif (IS_ERR(fn->raw)) {\n\t\tvoid *hold_err = fn->raw;\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\tfn->ofs = je32_to_cpu(ri->offset);\n\tfn->size = je32_to_cpu(ri->dsize);\n\tfn->frags = 0;\n\n\tjffs2_dbg(1, \"jffs2_write_dnode wrote node at 0x%08x(%d) with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\\n\",\n\t\t  flash_ofs & ~3, flash_ofs & 3, je32_to_cpu(ri->dsize),\n\t\t  je32_to_cpu(ri->csize), je32_to_cpu(ri->node_crc),\n\t\t  je32_to_cpu(ri->data_crc), je32_to_cpu(ri->totlen));\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, comprbuf, cdatalen))"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "omprbuf,",
            "datalen)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, ri, sizeof(*ri)-8))"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "i,",
            "izeof(*ri)-8)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "atalen)"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "datalen)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ffset)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "ax(je32_to_cpu(ri->isize), offset + datalen))"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ax(",
          "args": [
            "e32_to_cpu(ri->isize),",
            "ffset + datalen)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->isize)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "+f->highest_version)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "->inocache->ino)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, ri, sizeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "i,",
            "izeof(struct jffs2_unknown_node)-4)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "izeof(*ri) + cdatalen)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_NODETYPE_INODE)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_MAGIC_BITMASK)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_compress(",
          "args": [
            ",",
            ",",
            "uf,",
            "comprbuf,",
            "datalen,",
            "cdatalen)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "lloclen - sizeof(*ri),",
            "atalen)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "ritelen,",
            "AGE_CACHE_SIZE - (offset & (PAGE_CACHE_SIZE-1)))"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "f->sem)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_reserve_space returned %d\\n\",",
            "et)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space(",
          "args": [
            ",",
            "izeof(*ri) + JFFS2_MIN_DATA_LEN,",
            "alloclen,",
            "LLOC_NORMAL,",
            "FFS2_SUMMARY_INODE_SIZE)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "74-210",
          "snippet": "nt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_commit_write() loop: 0x%x to write to 0x%x\\n\",",
            "ritelen,",
            "ffset)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Ino #%u, ofs 0x%x, len 0x%x\\n\",",
            "_func__,",
            "->inocache->ino,",
            "ffset,",
            "ritelen)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_write_inode_range(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t    struct jffs2_raw_inode *ri, unsigned char *buf,\n\t\t\t    uint32_t offset, uint32_t writelen, uint32_t *retlen)\n{\n\tint ret = 0;\n\tuint32_t writtenlen = 0;\n\n\tjffs2_dbg(1, \"%s(): Ino #%u, ofs 0x%x, len 0x%x\\n\",\n\t\t  __func__, f->inocache->ino, offset, writelen);\n\n\twhile(writelen) {\n\t\tstruct jffs2_full_dnode *fn;\n\t\tunsigned char *comprbuf = NULL;\n\t\tuint16_t comprtype = JFFS2_COMPR_NONE;\n\t\tuint32_t alloclen;\n\t\tuint32_t datalen, cdatalen;\n\t\tint retried = 0;\n\n\tretry:\n\t\tjffs2_dbg(2, \"jffs2_commit_write() loop: 0x%x to write to 0x%x\\n\",\n\t\t\t  writelen, offset);\n\n\t\tret = jffs2_reserve_space(c, sizeof(*ri) + JFFS2_MIN_DATA_LEN,\n\t\t\t\t\t&alloclen, ALLOC_NORMAL, JFFS2_SUMMARY_INODE_SIZE);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"jffs2_reserve_space returned %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_lock(&f->sem);\n\t\tdatalen = min_t(uint32_t, writelen, PAGE_CACHE_SIZE - (offset & (PAGE_CACHE_SIZE-1)));\n\t\tcdatalen = min_t(uint32_t, alloclen - sizeof(*ri), datalen);\n\n\t\tcomprtype = jffs2_compress(c, f, buf, &comprbuf, &datalen, &cdatalen);\n\n\t\tri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri->totlen = cpu_to_je32(sizeof(*ri) + cdatalen);\n\t\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri->ino = cpu_to_je32(f->inocache->ino);\n\t\tri->version = cpu_to_je32(++f->highest_version);\n\t\tri->isize = cpu_to_je32(max(je32_to_cpu(ri->isize), offset + datalen));\n\t\tri->offset = cpu_to_je32(offset);\n\t\tri->csize = cpu_to_je32(cdatalen);\n\t\tri->dsize = cpu_to_je32(datalen);\n\t\tri->compr = comprtype & 0xff;\n\t\tri->usercompr = (comprtype >> 8 ) & 0xff;\n\t\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\t\tri->data_crc = cpu_to_je32(crc32(0, comprbuf, cdatalen));\n\n\t\tfn = jffs2_write_dnode(c, f, ri, comprbuf, cdatalen, ALLOC_NORETRY);\n\n\t\tjffs2_free_comprbuf(comprbuf, buf);\n\n\t\tif (IS_ERR(fn)) {\n\t\t\tret = PTR_ERR(fn);\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_complete_reservation(c);\n\t\t\tif (!retried) {\n\t\t\t\t/* Write error to be retried */\n\t\t\t\tretried = 1;\n\t\t\t\tjffs2_dbg(1, \"Retrying node write in jffs2_write_inode_range()\\n\");\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tret = jffs2_add_full_dnode_to_inode(c, f, fn);\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t\tif (ret) {\n\t\t\t/* Eep */\n\t\t\tjffs2_dbg(1, \"Eep. add_full_dnode_to_inode() failed in commit_write, returned %d\\n\",\n\t\t\t\t  ret);\n\t\t\tjffs2_mark_node_obsolete(c, fn->raw);\n\t\t\tjffs2_free_full_dnode(fn);\n\n\t\t\tmutex_unlock(&f->sem);\n\t\t\tjffs2_complete_reservation(c);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&f->sem);\n\t\tjffs2_complete_reservation(c);\n\t\tif (!datalen) {\n\t\t\tpr_warn(\"Eep. We didn't actually write any data in jffs2_write_inode_range()\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tjffs2_dbg(1, \"increasing writtenlen by %d\\n\", datalen);\n\t\twrittenlen += datalen;\n\t\toffset += datalen;\n\t\twritelen -= datalen;\n\t\tbuf += datalen;\n\t}\n\t*retlen = writtenlen;\n\treturn ret;\n}"
  },
  {
    "function_name": "ffs2_write_dirent(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
    "lines": "205-335",
    "snippet": "truct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode)\n{\n\tstruct jffs2_full_dirent *fd;\n\tsize_t retlen;\n\tstruct kvec vecs[2];\n\tuint32_t flash_ofs;\n\tint retried = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",\n\t\t  __func__,\n\t\t  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t  je32_to_cpu(rd->name_crc));\n\n\tD1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   });\n\n\tif (strnlen(name, namelen) != namelen) {\n\t\t/* This should never happen, but seems to have done on at least one\n\t\t   occasion: https://dev.laptop.org/ticket/4184 */\n\t\tpr_crit(\"Error in jffs2_write_dirent() -- name contains zero bytes!\\n\");\n\t\tpr_crit(\"Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",\n\t\t\tje32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t\tje32_to_cpu(rd->name_crc));\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tvecs[0].iov_base = rd;\n\tvecs[0].iov_len = sizeof(*rd);\n\tvecs[1].iov_base = (unsigned char *)name;\n\tvecs[1].iov_len = namelen;\n\n\tfd = jffs2_alloc_full_dirent(namelen+1);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(name, namelen);\n\tfd->type = rd->type;\n\tmemcpy(fd->name, name, namelen);\n\tfd->name[namelen]=0;\n\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dirent_version %d, highest version %d -> updating dirent\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(rd->version), f->highest_version);\n\t\trd->version = cpu_to_je32(++f->highest_version);\n\t\tfd->version = je32_to_cpu(rd->version);\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));\n\tif (ret || (retlen != sizeof(*rd) + namelen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*rd) + namelen, flash_ofs, ret, retlen);\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*rd)+namelen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write\\n\",\n\t\t\t\t\t  flash_ofs);\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\tfd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),\n\t\t\t\t\t      PAD(sizeof(*rd)+namelen), f->inocache);\n\tif (IS_ERR(fd->raw)) {\n\t\tvoid *hold_err = fd->raw;\n\t\t/* Release the full_dirent which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fd;\n}",
    "includes": [
      "include \"compr.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_sanity_check(",
          "args": [
            ",",
            "ULL)"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_sanity_check(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "51-58",
          "snippet": "id\n__jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RR_CAST(",
          "args": [
            "old_err)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_full_dirent(",
          "args": [
            "d)"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "130-134",
          "snippet": "oid jffs2_free_full_dirent(struct jffs2_full_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkfree(x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_full_dirent(struct jffs2_full_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "d->raw)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_physical_node_ref(",
          "args": [
            ",",
            "lash_ofs | dirent_node_state(rd),",
            "AD(sizeof(*rd)+namelen),",
            "->inocache)"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_physical_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "500-553",
          "snippet": "truct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(*rd)+namelen)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irent_node_state(",
          "args": [
            "d)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "et?ret:-EIO)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Failed to allocate space to retry failed write: %d!\\n\",",
            "et)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_paranoia_check(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_paranoia_check(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "300-307",
          "snippet": "id\n__jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\tstruct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\t__jffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\tstruct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\t__jffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Allocated space at 0x%08x to retry failed write\\n\",",
            "lash_ofs)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_ofs(",
          "args": [
            ")"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "f->sem)"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space(",
          "args": [
            ",",
            "izeof(*rd) + namelen,",
            "dummy,",
            "lloc_mode,",
            "FFS2_SUMMARY_DIRENT_SIZE(namelen))"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "74-210",
          "snippet": "nt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_SUMMARY_DIRENT_SIZE(",
          "args": [
            "amelen)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_complete_reservation(",
          "args": [
            ")"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_complete_reservation(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "556-563",
          "snippet": "oid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "f->sem)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space_gc(",
          "args": [
            ",",
            "izeof(*rd) + namelen,",
            "dummy,",
            "FFS2_SUMMARY_DIRENT_SIZE(namelen))"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space_gc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "212-238",
          "snippet": "nt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FFS2_SUMMARY_DIRENT_SIZE(",
          "args": [
            "amelen)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Retrying failed write.\\n\")"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",",
            "lash_ofs)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(*rd)+namelen)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",",
            "izeof(*rd) + namelen,",
            "lash_ofs,",
            "et,",
            "etlen)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_writev(",
          "args": [
            ",",
            "ecs,",
            ",",
            "lash_ofs,",
            "retlen,",
            "alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino))"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->pino)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, rd, sizeof(*rd)-8))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(*rd)-8)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->version)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "+f->highest_version)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): dirent_version %d, highest version %d -> updating dirent\\n\",",
            "_func__,",
            "e32_to_cpu(rd->version),",
            "->highest_version)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->version)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "retried)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->version)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_prewrite_paranoia_check(",
          "args": [
            ",",
            "lash_ofs,",
            "ecs[0].iov_len + vecs[1].iov_len)"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_prewrite_paranoia_check(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "124-158",
          "snippet": "id\n__jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\t    uint32_t ofs, int len)\n{\n\tsize_t retlen;\n\tint ret, i;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_WARNING(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\t\tlen, ret, retlen);\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tret = 0;\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != 0xff)\n\t\t\tret = 1;\n\n\tif (ret) {\n\t\tJFFS2_ERROR(\"argh, about to write node to %#08x on flash, but there are data already there. The first corrupted byte is at %#08x offset.\\n\",\n\t\t\tofs, ofs + i);\n\t\t__jffs2_dbg_dump_buffer(buf, len, ofs);\n\t\tkfree(buf);\n\t\tBUG();\n\t}\n\n\tkfree(buf);\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\t    uint32_t ofs, int len)\n{\n\tsize_t retlen;\n\tint ret, i;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_WARNING(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\t\tlen, ret, retlen);\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tret = 0;\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != 0xff)\n\t\t\tret = 1;\n\n\tif (ret) {\n\t\tJFFS2_ERROR(\"argh, about to write node to %#08x on flash, but there are data already there. The first corrupted byte is at %#08x offset.\\n\",\n\t\t\tofs, ofs + i);\n\t\t__jffs2_dbg_dump_buffer(buf, len, ofs);\n\t\tkfree(buf);\n\t\tBUG();\n\t}\n\n\tkfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rite_ofs(",
          "args": [
            ")"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "d->name,",
            "ame,",
            "amelen)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ull_name_hash(",
          "args": [
            "ame,",
            "amelen)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->ino)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->version)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "ENOMEM)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_full_dirent(",
          "args": [
            "amelen+1)"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_alloc_full_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "122-128",
          "snippet": "truct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize)\n{\n\tstruct jffs2_full_dirent *ret;\n\tret = kmalloc(sizeof(struct jffs2_full_dirent) + namesize, GFP_KERNEL);\n\tdbg_memalloc(\"%p\\n\", ret);\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize)\n{\n\tstruct jffs2_full_dirent *ret;\n\tret = kmalloc(sizeof(struct jffs2_full_dirent) + namesize, GFP_KERNEL);\n\tdbg_memalloc(\"%p\\n\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "EIO)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARN_ON(",
          "args": [
            ")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",",
            "e32_to_cpu(rd->pino),",
            "ame,",
            "ame,",
            "e32_to_cpu(rd->ino),",
            "e32_to_cpu(rd->name_crc))"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->name_crc)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->ino)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->pino)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "Error in jffs2_write_dirent() -- name contains zero bytes!\\n\")"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trnlen(",
          "args": [
            "ame,",
            "amelen)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1(",
          "args": [
            "f(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) \n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   })"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "Eep. CRC not correct in jffs2_write_dirent()\\n\")"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(",
          "args": [
            "e32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "319-323",
          "snippet": "oid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(struct jffs2_unknown_node)-4)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->hdr_crc)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",",
            "_func__,",
            "e32_to_cpu(rd->pino),",
            "ame,",
            "ame,",
            "e32_to_cpu(rd->ino),",
            "e32_to_cpu(rd->name_crc))"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->name_crc)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->ino)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->pino)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dirent *jffs2_write_dirent(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t     struct jffs2_raw_dirent *rd, const unsigned char *name,\n\t\t\t\t\t     uint32_t namelen, int alloc_mode)\n{\n\tstruct jffs2_full_dirent *fd;\n\tsize_t retlen;\n\tstruct kvec vecs[2];\n\tuint32_t flash_ofs;\n\tint retried = 0;\n\tint ret;\n\n\tjffs2_dbg(1, \"%s(ino #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x)\\n\",\n\t\t  __func__,\n\t\t  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t  je32_to_cpu(rd->name_crc));\n\n\tD1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dirent()\\n\");\n\t\tBUG();\n\t   });\n\n\tif (strnlen(name, namelen) != namelen) {\n\t\t/* This should never happen, but seems to have done on at least one\n\t\t   occasion: https://dev.laptop.org/ticket/4184 */\n\t\tpr_crit(\"Error in jffs2_write_dirent() -- name contains zero bytes!\\n\");\n\t\tpr_crit(\"Directory inode #%u, name at *0x%p \\\"%s\\\"->ino #%u, name_crc 0x%08x\\n\",\n\t\t\tje32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),\n\t\t\tje32_to_cpu(rd->name_crc));\n\t\tWARN_ON(1);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tvecs[0].iov_base = rd;\n\tvecs[0].iov_len = sizeof(*rd);\n\tvecs[1].iov_base = (unsigned char *)name;\n\tvecs[1].iov_len = namelen;\n\n\tfd = jffs2_alloc_full_dirent(namelen+1);\n\tif (!fd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(name, namelen);\n\tfd->type = rd->type;\n\tmemcpy(fd->name, name, namelen);\n\tfd->name[namelen]=0;\n\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dirent_version %d, highest version %d -> updating dirent\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(rd->version), f->highest_version);\n\t\trd->version = cpu_to_je32(++f->highest_version);\n\t\tfd->version = je32_to_cpu(rd->version);\n\t\trd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, 2, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));\n\tif (ret || (retlen != sizeof(*rd) + namelen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*rd) + namelen, flash_ofs, ret, retlen);\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*rd)+namelen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*rd) + namelen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_DIRENT_SIZE(namelen));\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write\\n\",\n\t\t\t\t\t  flash_ofs);\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\tfd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),\n\t\t\t\t\t      PAD(sizeof(*rd)+namelen), f->inocache);\n\tif (IS_ERR(fd->raw)) {\n\t\tvoid *hold_err = fd->raw;\n\t\t/* Release the full_dirent which is now useless, and return */\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fd;\n}"
  },
  {
    "function_name": "ffs2_write_dnode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
    "lines": "59-203",
    "snippet": "truct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t   struct jffs2_raw_inode *ri, const unsigned char *data,\n\t\t\t\t\t   uint32_t datalen, int alloc_mode)\n\n{\n\tstruct jffs2_full_dnode *fn;\n\tsize_t retlen;\n\tuint32_t flash_ofs;\n\tstruct kvec vecs[2];\n\tint ret;\n\tint retried = 0;\n\tunsigned long cnt = 2;\n\n\tD1(if(je32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dnode()\\n\");\n\t\tBUG();\n\t}\n\t   );\n\tvecs[0].iov_base = ri;\n\tvecs[0].iov_len = sizeof(*ri);\n\tvecs[1].iov_base = (unsigned char *)data;\n\tvecs[1].iov_len = datalen;\n\n\tif (je32_to_cpu(ri->totlen) != sizeof(*ri) + datalen) {\n\t\tpr_warn(\"%s(): ri->totlen (0x%08x) != sizeof(*ri) (0x%08zx) + datalen (0x%08x)\\n\",\n\t\t\t__func__, je32_to_cpu(ri->totlen),\n\t\t\tsizeof(*ri), datalen);\n\t}\n\n\tfn = jffs2_alloc_full_dnode();\n\tif (!fn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* check number of valid vecs */\n\tif (!datalen || !data)\n\t\tcnt = 1;\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(ri->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dnode_version %d, highest version %d -> updating dnode\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(ri->version), f->highest_version);\n\t\tri->version = cpu_to_je32(++f->highest_version);\n\t\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, cnt, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:f->inocache->ino);\n\n\tif (ret || (retlen != sizeof(*ri) + datalen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*ri) + datalen, flash_ofs, ret, retlen);\n\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\t/* Don't change raw->size to match retlen. We may have\n\t\t\t   written the node header already, and only the data will\n\t\t\t   seem corrupted, in which case the scan would skip over\n\t\t\t   any node we write before the original intended end of\n\t\t\t   this node */\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*ri)+datalen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried && alloc_mode != ALLOC_NORETRY) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  flash_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\t/* If node covers at least a whole page, or if it starts at the\n\t   beginning of a page and runs to the end of the file, or if\n\t   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL.\n\t*/\n\tif ((je32_to_cpu(ri->dsize) >= PAGE_CACHE_SIZE) ||\n\t    ( ((je32_to_cpu(ri->offset)&(PAGE_CACHE_SIZE-1))==0) &&\n\t      (je32_to_cpu(ri->dsize)+je32_to_cpu(ri->offset) ==  je32_to_cpu(ri->isize)))) {\n\t\tflash_ofs |= REF_PRISTINE;\n\t} else {\n\t\tflash_ofs |= REF_NORMAL;\n\t}\n\tfn->raw = jffs2_add_physical_node_ref(c, flash_ofs, PAD(sizeof(*ri)+datalen), f->inocache);\n\tif (IS_ERR(fn->raw)) {\n\t\tvoid *hold_err = fn->raw;\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\tfn->ofs = je32_to_cpu(ri->offset);\n\tfn->size = je32_to_cpu(ri->dsize);\n\tfn->frags = 0;\n\n\tjffs2_dbg(1, \"jffs2_write_dnode wrote node at 0x%08x(%d) with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\\n\",\n\t\t  flash_ofs & ~3, flash_ofs & 3, je32_to_cpu(ri->dsize),\n\t\t  je32_to_cpu(ri->csize), je32_to_cpu(ri->node_crc),\n\t\t  je32_to_cpu(ri->data_crc), je32_to_cpu(ri->totlen));\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fn;\n}",
    "includes": [
      "include \"compr.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_sanity_check(",
          "args": [
            ",",
            "ULL)"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_sanity_check(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "51-58",
          "snippet": "id\n__jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_sanity_check(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_write_dnode wrote node at 0x%08x(%d) with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\\n\",",
            "lash_ofs & ~3,",
            "lash_ofs & 3,",
            "e32_to_cpu(ri->dsize),",
            "e32_to_cpu(ri->csize),",
            "e32_to_cpu(ri->node_crc),",
            "e32_to_cpu(ri->data_crc),",
            "e32_to_cpu(ri->totlen))"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->totlen)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->data_crc)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->node_crc)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->csize)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->dsize)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->dsize)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->offset)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_CAST(",
          "args": [
            "old_err)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_full_dnode(",
          "args": [
            "n)"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "144-148",
          "snippet": "oid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic struct kmem_cache *full_dnode_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic struct kmem_cache *full_dnode_slab;\n\noid jffs2_free_full_dnode(struct jffs2_full_dnode *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkmem_cache_free(full_dnode_slab, x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "n->raw)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_physical_node_ref(",
          "args": [
            ",",
            "lash_ofs,",
            "AD(sizeof(*ri)+datalen),",
            "->inocache)"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_physical_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "500-553",
          "snippet": "truct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *new;\n\n\tjeb = &c->blocks[ofs / c->sector_size];\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%x(%d), size 0x%x\\n\",\n\t\t  __func__, ofs & ~3, ofs & 3, len);\n#if 1\n\t/* Allow non-obsolete nodes only to be added at the end of c->nextblock, \n\t   if c->nextblock is set. Note that wbuf.c will file obsolete nodes\n\t   even after refiling c->nextblock */\n\tif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\n\t    && (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\n\t\tpr_warn(\"argh. node added in wrong place at 0x%08x(%d)\\n\",\n\t\t\tofs & ~3, ofs & 3);\n\t\tif (c->nextblock)\n\t\t\tpr_warn(\"nextblock 0x%08x\", c->nextblock->offset);\n\t\telse\n\t\t\tpr_warn(\"No nextblock\");\n\t\tpr_cont(\", expected at %08x\\n\",\n\t\t\tjeb->offset + (c->sector_size - jeb->free_size));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n#endif\n\tspin_lock(&c->erase_completion_lock);\n\n\tnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\n\n\tif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\n\t\t/* If it lives on the dirty_list, jffs2_reserve_space will put it there */\n\t\tjffs2_dbg(1, \"Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\\n\",\n\t\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t\t  jeb->used_size);\n\t\tif (jffs2_wbuf_dirty(c)) {\n\t\t\t/* Flush the last write in the block if it's outstanding */\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tjffs2_flush_wbuf_pad(c);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tlist_add_tail(&jeb->list, &c->clean_list);\n\t\tc->nextblock = NULL;\n\t}\n\tjffs2_dbg_acct_sanity_check_nolock(c,jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(*ri)+datalen)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->isize)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->offset)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->dsize)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->offset)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->dsize)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "et?ret:-EIO)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Failed to allocate space to retry failed write: %d!\\n\",",
            "et)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_paranoia_check(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_paranoia_check(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "300-307",
          "snippet": "id\n__jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\tstruct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\t__jffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\tstruct jffs2_eraseblock *jeb)\n{\n\tspin_lock(&c->erase_completion_lock);\n\t__jffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\tspin_unlock(&c->erase_completion_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Allocated space at 0x%08x to retry failed write.\\n\",",
            "lash_ofs)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_ofs(",
          "args": [
            ")"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "f->sem)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space(",
          "args": [
            ",",
            "izeof(*ri) + datalen,",
            "dummy,",
            "lloc_mode,",
            "FFS2_SUMMARY_INODE_SIZE)"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "74-210",
          "snippet": "nt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\tuint32_t *len, int prio, uint32_t sumsize)\n{\n\tint ret = -EAGAIN;\n\tint blocksneeded = c->resv_blocks_write;\n\t/* align it */\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\tmutex_lock(&c->alloc_sem);\n\n\tjffs2_dbg(1, \"%s(): alloc sem got\\n\", __func__);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\t/*\n\t * Check if the free space is greater then size of the reserved pool.\n\t * If not, only allow root to proceed with writing.\n\t */\n\tif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/* this needs a little more thought (true <tglx> :)) */\n\twhile(ret == -EAGAIN) {\n\t\twhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\n\t\t\tuint32_t dirty, avail;\n\n\t\t\t/* calculate real dirty size\n\t\t\t * dirty_size contains blocks on erase_pending_list\n\t\t\t * those blocks are counted in c->nr_erasing_blocks.\n\t\t\t * If one block is actually erased, it is not longer counted as dirty_space\n\t\t\t * but it is counted in c->nr_erasing_blocks, so we add it and subtract it\n\t\t\t * with c->nr_erasing_blocks * c->sector_size again.\n\t\t\t * Blocks on erasable_list are counted as dirty_size, but not in c->nr_erasing_blocks\n\t\t\t * This helps us to force gc and pick eventually a clean block to spread the load.\n\t\t\t * We add unchecked_size here, as we hopefully will find some space to use.\n\t\t\t * This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t */\n\t\t\tdirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\n\t\t\tif (dirty < c->nospc_dirty_size) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on dirty space to GC, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjffs2_dbg(1, \"dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  dirty, c->unchecked_size,\n\t\t\t\t\t  c->sector_size);\n\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\t/* Calc possibly available space. Possibly available means that we\n\t\t\t * don't know, if unchecked size contains obsoleted nodes, which could give us some\n\t\t\t * more usable space. This will affect the sum only once, as gc first finishes checking\n\t\t\t * of nodes.\n\t\t\t + Return -ENOSPC, if the maximum possibly available space is less or equal than\n\t\t\t * blocksneeded * sector_size.\n\t\t\t * This blocks endless gc looping on a filesystem, which is nearly full, even if\n\t\t\t * the check above passes.\n\t\t\t */\n\t\t\tavail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\n\t\t\tif ( (avail / c->sector_size) <= blocksneeded) {\n\t\t\t\tif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\n\t\t\t\t\tjffs2_dbg(1, \"%s(): Low on possibly available space, but it's a deletion. Allowing...\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"max. available size 0x%08x  < blocksneeded * sector_size 0x%08x, returning -ENOSPC\\n\",\n\t\t\t\t\t  avail, blocksneeded * c->sector_size);\n\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\n\t\t\tjffs2_dbg(1, \"Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\\n\",\n\t\t\t\t  c->nr_free_blocks, c->nr_erasing_blocks,\n\t\t\t\t  c->free_size, c->dirty_size, c->wasted_size,\n\t\t\t\t  c->used_size, c->erasing_size, c->bad_size,\n\t\t\t\t  c->free_size + c->dirty_size +\n\t\t\t\t  c->wasted_size + c->used_size +\n\t\t\t\t  c->erasing_size + c->bad_size,\n\t\t\t\t  c->flash_size);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\tret = jffs2_garbage_collect_pass(c);\n\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\t\tif (c->nr_erasing_blocks &&\n\t\t\t\t    list_empty(&c->erase_pending_list) &&\n\t\t\t\t    list_empty(&c->erase_complete_list)) {\n\t\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\t\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\t\tadd_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t\tjffs2_dbg(1, \"%s waiting for erase to complete\\n\",\n\t\t\t\t\t\t  __func__);\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\t\t\t\tschedule();\n\t\t\t\t\tremove_wait_queue(&c->erase_wait, &wait);\n\t\t\t\t} else\n\t\t\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\t} else if (ret)\n\t\t\t\treturn ret;\n\n\t\t\tcond_resched();\n\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\n\t\t\tmutex_lock(&c->alloc_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t}\n\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): ret is %d\\n\", __func__, ret);\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&c->erase_completion_lock);\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\tif (ret)\n\t\tmutex_unlock(&c->alloc_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_complete_reservation(",
          "args": [
            ")"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_complete_reservation(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "556-563",
          "snippet": "oid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_complete_reservation(struct jffs2_sb_info *c)\n{\n\tjffs2_dbg(1, \"jffs2_complete_reservation()\\n\");\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->alloc_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "f->sem)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_reserve_space_gc(",
          "args": [
            ",",
            "izeof(*ri) + datalen,",
            "dummy,",
            "FFS2_SUMMARY_INODE_SIZE)"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_reserve_space_gc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodemgmt.c",
          "lines": "212-238",
          "snippet": "nt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/sched.h> /* For cond_resched() */\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/sched.h> /* For cond_resched() */\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_do_reserve_space(struct jffs2_sb_info *c,  uint32_t minsize,\n\t\t\t\t  uint32_t *len, uint32_t sumsize);\n\nnt jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\n\t\t\t   uint32_t *len, uint32_t sumsize)\n{\n\tint ret;\n\tminsize = PAD(minsize);\n\n\tjffs2_dbg(1, \"%s(): Requested 0x%x bytes\\n\", __func__, minsize);\n\n\twhile (true) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tret = jffs2_do_reserve_space(c, minsize, len, sumsize);\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"%s(): looping, ret is %d\\n\",\n\t\t\t\t  __func__, ret);\n\t\t}\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ret == -EAGAIN)\n\t\t\tcond_resched();\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!ret)\n\t\tret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Retrying failed write.\\n\")"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",",
            "lash_ofs)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(*ri)+datalen)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",",
            "izeof(*ri) + datalen,",
            "lash_ofs,",
            "et,",
            "etlen)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_writev(",
          "args": [
            ",",
            "ecs,",
            "nt,",
            "lash_ofs,",
            "retlen,",
            "alloc_mode==ALLOC_GC)?0:f->inocache->ino)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, ri, sizeof(*ri)-8))"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "i,",
            "izeof(*ri)-8)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "+f->highest_version)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): dnode_version %d, highest version %d -> updating dnode\\n\",",
            "_func__,",
            "e32_to_cpu(ri->version),",
            "->highest_version)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->version)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG_ON(",
          "args": [
            "retried)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->version)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_prewrite_paranoia_check(",
          "args": [
            ",",
            "lash_ofs,",
            "ecs[0].iov_len + vecs[1].iov_len)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_prewrite_paranoia_check(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "124-158",
          "snippet": "id\n__jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\t    uint32_t ofs, int len)\n{\n\tsize_t retlen;\n\tint ret, i;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_WARNING(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\t\tlen, ret, retlen);\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tret = 0;\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != 0xff)\n\t\t\tret = 1;\n\n\tif (ret) {\n\t\tJFFS2_ERROR(\"argh, about to write node to %#08x on flash, but there are data already there. The first corrupted byte is at %#08x offset.\\n\",\n\t\t\tofs, ofs + i);\n\t\t__jffs2_dbg_dump_buffer(buf, len, ofs);\n\t\tkfree(buf);\n\t\tBUG();\n\t}\n\n\tkfree(buf);\n}",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_prewrite_paranoia_check(struct jffs2_sb_info *c,\n\t\t\t\t    uint32_t ofs, int len)\n{\n\tsize_t retlen;\n\tint ret, i;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len)) {\n\t\tJFFS2_WARNING(\"read %d bytes failed or short. ret %d, retlen %zd.\\n\",\n\t\t\t\tlen, ret, retlen);\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tret = 0;\n\tfor (i = 0; i < len; i++)\n\t\tif (buf[i] != 0xff)\n\t\t\tret = 1;\n\n\tif (ret) {\n\t\tJFFS2_ERROR(\"argh, about to write node to %#08x on flash, but there are data already there. The first corrupted byte is at %#08x offset.\\n\",\n\t\t\tofs, ofs + i);\n\t\t__jffs2_dbg_dump_buffer(buf, len, ofs);\n\t\tkfree(buf);\n\t\tBUG();\n\t}\n\n\tkfree(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rite_ofs(",
          "args": [
            ")"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "ENOMEM)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_full_dnode(",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "%s(): ri->totlen (0x%08x) != sizeof(*ri) (0x%08zx) + datalen (0x%08x)\\n\",",
            "_func__,",
            "e32_to_cpu(ri->totlen),",
            "izeof(*ri),",
            "atalen)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->totlen)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->totlen)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1(",
          "args": [
            "f(je32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) \n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dnode()\\n\");\n\t\tBUG();\n\t}"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_crit(",
          "args": [
            "Eep. CRC not correct in jffs2_write_dnode()\\n\")"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(",
          "args": [
            "e32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_xattr_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "319-323",
          "snippet": "oid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_xattr_ref(struct jffs2_xattr_ref *ref)\n{\n\tdbg_memalloc(\"%p\\n\", ref);\n\tkmem_cache_free(xattr_ref_cache, ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "i,",
            "izeof(struct jffs2_unknown_node)-4)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->hdr_crc)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dnode *jffs2_write_dnode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t\t\t\t   struct jffs2_raw_inode *ri, const unsigned char *data,\n\t\t\t\t\t   uint32_t datalen, int alloc_mode)\n\n{\n\tstruct jffs2_full_dnode *fn;\n\tsize_t retlen;\n\tuint32_t flash_ofs;\n\tstruct kvec vecs[2];\n\tint ret;\n\tint retried = 0;\n\tunsigned long cnt = 2;\n\n\tD1(if(je32_to_cpu(ri->hdr_crc) != crc32(0, ri, sizeof(struct jffs2_unknown_node)-4)) {\n\t\tpr_crit(\"Eep. CRC not correct in jffs2_write_dnode()\\n\");\n\t\tBUG();\n\t}\n\t   );\n\tvecs[0].iov_base = ri;\n\tvecs[0].iov_len = sizeof(*ri);\n\tvecs[1].iov_base = (unsigned char *)data;\n\tvecs[1].iov_len = datalen;\n\n\tif (je32_to_cpu(ri->totlen) != sizeof(*ri) + datalen) {\n\t\tpr_warn(\"%s(): ri->totlen (0x%08x) != sizeof(*ri) (0x%08zx) + datalen (0x%08x)\\n\",\n\t\t\t__func__, je32_to_cpu(ri->totlen),\n\t\t\tsizeof(*ri), datalen);\n\t}\n\n\tfn = jffs2_alloc_full_dnode();\n\tif (!fn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* check number of valid vecs */\n\tif (!datalen || !data)\n\t\tcnt = 1;\n retry:\n\tflash_ofs = write_ofs(c);\n\n\tjffs2_dbg_prewrite_paranoia_check(c, flash_ofs, vecs[0].iov_len + vecs[1].iov_len);\n\n\tif ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(ri->version) < f->highest_version)) {\n\t\tBUG_ON(!retried);\n\t\tjffs2_dbg(1, \"%s(): dnode_version %d, highest version %d -> updating dnode\\n\",\n\t\t\t  __func__,\n\t\t\t  je32_to_cpu(ri->version), f->highest_version);\n\t\tri->version = cpu_to_je32(++f->highest_version);\n\t\tri->node_crc = cpu_to_je32(crc32(0, ri, sizeof(*ri)-8));\n\t}\n\n\tret = jffs2_flash_writev(c, vecs, cnt, flash_ofs, &retlen,\n\t\t\t\t (alloc_mode==ALLOC_GC)?0:f->inocache->ino);\n\n\tif (ret || (retlen != sizeof(*ri) + datalen)) {\n\t\tpr_notice(\"Write of %zd bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  sizeof(*ri) + datalen, flash_ofs, ret, retlen);\n\n\t\t/* Mark the space as dirtied */\n\t\tif (retlen) {\n\t\t\t/* Don't change raw->size to match retlen. We may have\n\t\t\t   written the node header already, and only the data will\n\t\t\t   seem corrupted, in which case the scan would skip over\n\t\t\t   any node we write before the original intended end of\n\t\t\t   this node */\n\t\t\tjffs2_add_physical_node_ref(c, flash_ofs | REF_OBSOLETE, PAD(sizeof(*ri)+datalen), NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  flash_ofs);\n\t\t}\n\t\tif (!retried && alloc_mode != ALLOC_NORETRY) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[flash_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tif (alloc_mode == ALLOC_GC) {\n\t\t\t\tret = jffs2_reserve_space_gc(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t} else {\n\t\t\t\t/* Locking pain */\n\t\t\t\tmutex_unlock(&f->sem);\n\t\t\t\tjffs2_complete_reservation(c);\n\n\t\t\t\tret = jffs2_reserve_space(c, sizeof(*ri) + datalen, &dummy,\n\t\t\t\t\t\t\t  alloc_mode, JFFS2_SUMMARY_INODE_SIZE);\n\t\t\t\tmutex_lock(&f->sem);\n\t\t\t}\n\n\t\t\tif (!ret) {\n\t\t\t\tflash_ofs = write_ofs(c);\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  flash_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_PTR(ret?ret:-EIO);\n\t}\n\t/* Mark the space used */\n\t/* If node covers at least a whole page, or if it starts at the\n\t   beginning of a page and runs to the end of the file, or if\n\t   it's a hole node, mark it REF_PRISTINE, else REF_NORMAL.\n\t*/\n\tif ((je32_to_cpu(ri->dsize) >= PAGE_CACHE_SIZE) ||\n\t    ( ((je32_to_cpu(ri->offset)&(PAGE_CACHE_SIZE-1))==0) &&\n\t      (je32_to_cpu(ri->dsize)+je32_to_cpu(ri->offset) ==  je32_to_cpu(ri->isize)))) {\n\t\tflash_ofs |= REF_PRISTINE;\n\t} else {\n\t\tflash_ofs |= REF_NORMAL;\n\t}\n\tfn->raw = jffs2_add_physical_node_ref(c, flash_ofs, PAD(sizeof(*ri)+datalen), f->inocache);\n\tif (IS_ERR(fn->raw)) {\n\t\tvoid *hold_err = fn->raw;\n\t\t/* Release the full_dnode which is now useless, and return */\n\t\tjffs2_free_full_dnode(fn);\n\t\treturn ERR_CAST(hold_err);\n\t}\n\tfn->ofs = je32_to_cpu(ri->offset);\n\tfn->size = je32_to_cpu(ri->dsize);\n\tfn->frags = 0;\n\n\tjffs2_dbg(1, \"jffs2_write_dnode wrote node at 0x%08x(%d) with dsize 0x%x, csize 0x%x, node_crc 0x%08x, data_crc 0x%08x, totlen 0x%08x\\n\",\n\t\t  flash_ofs & ~3, flash_ofs & 3, je32_to_cpu(ri->dsize),\n\t\t  je32_to_cpu(ri->csize), je32_to_cpu(ri->node_crc),\n\t\t  je32_to_cpu(ri->data_crc), je32_to_cpu(ri->totlen));\n\n\tif (retried) {\n\t\tjffs2_dbg_acct_sanity_check(c,NULL);\n\t}\n\n\treturn fn;\n}"
  },
  {
    "function_name": "ffs2_do_new_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/write.c",
    "lines": "23-54",
    "snippet": "nt jffs2_do_new_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t       uint32_t mode, struct jffs2_raw_inode *ri)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ic, 0, sizeof(*ic));\n\n\tf->inocache = ic;\n\tf->inocache->pino_nlink = 1; /* Will be overwritten shortly for directories */\n\tf->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;\n\tf->inocache->state = INO_STATE_PRESENT;\n\n\tjffs2_add_ino_cache(c, f->inocache);\n\tjffs2_dbg(1, \"%s(): Assigned ino# %d\\n\", __func__, f->inocache->ino);\n\tri->ino = cpu_to_je32(f->inocache->ino);\n\n\tri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\tri->totlen = cpu_to_je32(PAD(sizeof(*ri)));\n\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\tri->mode = cpu_to_jemode(mode);\n\n\tf->highest_version = 1;\n\tri->version = cpu_to_je32(f->highest_version);\n\n\treturn 0;\n}",
    "includes": [
      "include \"compr.h\"",
      "include \"nodelist.h\"\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/fs.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "->highest_version)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_jemode(",
          "args": [
            "ode)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "rc32(0, ri, sizeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "i,",
            "izeof(struct jffs2_unknown_node)-4)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "AD(sizeof(*ri)))"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(*ri))"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_NODETYPE_INODE)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "FFS2_MAGIC_BITMASK)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je32(",
          "args": [
            "->inocache->ino)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Assigned ino# %d\\n\",",
            "_func__,",
            "->inocache->ino)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_ino_cache(",
          "args": [
            ",",
            "->inocache)"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "c,",
            ",",
            "izeof(*ic))"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_inode_cache(",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"compr.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_do_new_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f,\n\t\t       uint32_t mode, struct jffs2_raw_inode *ri)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ic, 0, sizeof(*ic));\n\n\tf->inocache = ic;\n\tf->inocache->pino_nlink = 1; /* Will be overwritten shortly for directories */\n\tf->inocache->nodes = (struct jffs2_raw_node_ref *)f->inocache;\n\tf->inocache->state = INO_STATE_PRESENT;\n\n\tjffs2_add_ino_cache(c, f->inocache);\n\tjffs2_dbg(1, \"%s(): Assigned ino# %d\\n\", __func__, f->inocache->ino);\n\tri->ino = cpu_to_je32(f->inocache->ino);\n\n\tri->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tri->nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\tri->totlen = cpu_to_je32(PAD(sizeof(*ri)));\n\tri->hdr_crc = cpu_to_je32(crc32(0, ri, sizeof(struct jffs2_unknown_node)-4));\n\tri->mode = cpu_to_jemode(mode);\n\n\tf->highest_version = 1;\n\tri->version = cpu_to_je32(f->highest_version);\n\n\treturn 0;\n}"
  }
]