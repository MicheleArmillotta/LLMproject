[
  {
    "function_name": "exit_coda",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "420-433",
    "snippet": "static void __exit exit_coda(void)\n{\n        int err, i;\n\n\terr = unregister_filesystem(&coda_fs_type);\n\tif (err != 0)\n\t\tpr_warn(\"failed to unregister filesystem\\n\");\n\tfor (i = 0; i < MAX_CODADEVS; i++)\n\t\tdevice_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));\n\tclass_destroy(coda_psdev_class);\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\n\tcoda_sysctl_clean();\n\tcoda_destroy_inodecache();\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct class *coda_psdev_class;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_destroy_inodecache",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "coda_destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/inode.c",
          "lines": "85-93",
          "snippet": "void coda_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(coda_inode_cachep);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/file.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * coda_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/file.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * coda_inode_cachep;\n\nvoid coda_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(coda_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_sysctl_clean",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "coda_sysctl_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/sysctl.c",
          "lines": "70-72",
          "snippet": "void coda_sysctl_clean(void)\n{\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include <linux/sysctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include <linux/sysctl.h>\n\nvoid coda_sysctl_clean(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_chrdev",
          "args": [
            "CODA_PSDEV_MAJOR",
            "\"coda\""
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "285-296",
          "snippet": "void unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "class_destroy",
          "args": [
            "coda_psdev_class"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_destroy",
          "args": [
            "coda_psdev_class",
            "MKDEV(CODA_PSDEV_MAJOR, i)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "CODA_PSDEV_MAJOR",
            "i"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to unregister filesystem\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&coda_fs_type"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct class *coda_psdev_class;\n\nstatic void __exit exit_coda(void)\n{\n        int err, i;\n\n\terr = unregister_filesystem(&coda_fs_type);\n\tif (err != 0)\n\t\tpr_warn(\"failed to unregister filesystem\\n\");\n\tfor (i = 0; i < MAX_CODADEVS; i++)\n\t\tdevice_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));\n\tclass_destroy(coda_psdev_class);\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\n\tcoda_sysctl_clean();\n\tcoda_destroy_inodecache();\n}"
  },
  {
    "function_name": "init_coda",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "388-418",
    "snippet": "static int __init init_coda(void)\n{\n\tint status;\n\tint i;\n\n\tstatus = coda_init_inodecache();\n\tif (status)\n\t\tgoto out2;\n\tstatus = init_coda_psdev();\n\tif ( status ) {\n\t\tpr_warn(\"Problem (%d) in init_coda_psdev\\n\", status);\n\t\tgoto out1;\n\t}\n\t\n\tstatus = register_filesystem(&coda_fs_type);\n\tif (status) {\n\t\tpr_warn(\"failed to register filesystem!\\n\");\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\tfor (i = 0; i < MAX_CODADEVS; i++)\n\t\tdevice_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));\n\tclass_destroy(coda_psdev_class);\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\n\tcoda_sysctl_clean();\nout1:\n\tcoda_destroy_inodecache();\nout2:\n\treturn status;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct class *coda_psdev_class;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_destroy_inodecache",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "coda_destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/inode.c",
          "lines": "85-93",
          "snippet": "void coda_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(coda_inode_cachep);\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/file.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * coda_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/file.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * coda_inode_cachep;\n\nvoid coda_destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(coda_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_sysctl_clean",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "coda_sysctl_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/sysctl.c",
          "lines": "70-72",
          "snippet": "void coda_sysctl_clean(void)\n{\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include <linux/sysctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include <linux/sysctl.h>\n\nvoid coda_sysctl_clean(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_chrdev",
          "args": [
            "CODA_PSDEV_MAJOR",
            "\"coda\""
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "285-296",
          "snippet": "void unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "class_destroy",
          "args": [
            "coda_psdev_class"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_destroy",
          "args": [
            "coda_psdev_class",
            "MKDEV(CODA_PSDEV_MAJOR, i)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "CODA_PSDEV_MAJOR",
            "i"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to register filesystem!\\n\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&coda_fs_type"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Problem (%d) in init_coda_psdev\\n\"",
            "status"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_coda_psdev",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "init_coda_psdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
          "lines": "355-380",
          "snippet": "static int init_coda_psdev(void)\n{\n\tint i, err = 0;\n\tif (register_chrdev(CODA_PSDEV_MAJOR, \"coda\", &coda_psdev_fops)) {\n\t\tpr_err(\"%s: unable to get major %d\\n\",\n\t\t       __func__, CODA_PSDEV_MAJOR);\n              return -EIO;\n\t}\n\tcoda_psdev_class = class_create(THIS_MODULE, \"coda\");\n\tif (IS_ERR(coda_psdev_class)) {\n\t\terr = PTR_ERR(coda_psdev_class);\n\t\tgoto out_chrdev;\n\t}\t\t\n\tfor (i = 0; i < MAX_CODADEVS; i++) {\n\t\tmutex_init(&(&coda_comms[i])->vc_mutex);\n\t\tdevice_create(coda_psdev_class, NULL,\n\t\t\t      MKDEV(CODA_PSDEV_MAJOR, i), NULL, \"cfs%d\", i);\n\t}\n\tcoda_sysctl_init();\n\tgoto out;\n\nout_chrdev:\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/poll.h>",
            "#include <asm/io.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/delay.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/ioport.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/major.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct venus_comm coda_comms[MAX_CODADEVS];",
            "static struct class *coda_psdev_class;",
            "static const struct file_operations coda_psdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= coda_psdev_read,\n\t.write\t\t= coda_psdev_write,\n\t.poll\t\t= coda_psdev_poll,\n\t.unlocked_ioctl\t= coda_psdev_ioctl,\n\t.open\t\t= coda_psdev_open,\n\t.release\t= coda_psdev_release,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct venus_comm coda_comms[MAX_CODADEVS];\nstatic struct class *coda_psdev_class;\nstatic const struct file_operations coda_psdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= coda_psdev_read,\n\t.write\t\t= coda_psdev_write,\n\t.poll\t\t= coda_psdev_poll,\n\t.unlocked_ioctl\t= coda_psdev_ioctl,\n\t.open\t\t= coda_psdev_open,\n\t.release\t= coda_psdev_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int init_coda_psdev(void)\n{\n\tint i, err = 0;\n\tif (register_chrdev(CODA_PSDEV_MAJOR, \"coda\", &coda_psdev_fops)) {\n\t\tpr_err(\"%s: unable to get major %d\\n\",\n\t\t       __func__, CODA_PSDEV_MAJOR);\n              return -EIO;\n\t}\n\tcoda_psdev_class = class_create(THIS_MODULE, \"coda\");\n\tif (IS_ERR(coda_psdev_class)) {\n\t\terr = PTR_ERR(coda_psdev_class);\n\t\tgoto out_chrdev;\n\t}\t\t\n\tfor (i = 0; i < MAX_CODADEVS; i++) {\n\t\tmutex_init(&(&coda_comms[i])->vc_mutex);\n\t\tdevice_create(coda_psdev_class, NULL,\n\t\t\t      MKDEV(CODA_PSDEV_MAJOR, i), NULL, \"cfs%d\", i);\n\t}\n\tcoda_sysctl_init();\n\tgoto out;\n\nout_chrdev:\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_init_inodecache",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "coda_init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/inode.c",
          "lines": "74-83",
          "snippet": "int __init coda_init_inodecache(void)\n{\n\tcoda_inode_cachep = kmem_cache_create(\"coda_inode_cache\",\n\t\t\t\tsizeof(struct coda_inode_info),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (coda_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/file.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * coda_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/pid_namespace.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/file.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * coda_inode_cachep;\n\nint __init coda_init_inodecache(void)\n{\n\tcoda_inode_cachep = kmem_cache_create(\"coda_inode_cache\",\n\t\t\t\tsizeof(struct coda_inode_info),\n\t\t\t\t0, SLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD,\n\t\t\t\tinit_once);\n\tif (coda_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct class *coda_psdev_class;\n\nstatic int __init init_coda(void)\n{\n\tint status;\n\tint i;\n\n\tstatus = coda_init_inodecache();\n\tif (status)\n\t\tgoto out2;\n\tstatus = init_coda_psdev();\n\tif ( status ) {\n\t\tpr_warn(\"Problem (%d) in init_coda_psdev\\n\", status);\n\t\tgoto out1;\n\t}\n\t\n\tstatus = register_filesystem(&coda_fs_type);\n\tif (status) {\n\t\tpr_warn(\"failed to register filesystem!\\n\");\n\t\tgoto out;\n\t}\n\treturn 0;\nout:\n\tfor (i = 0; i < MAX_CODADEVS; i++)\n\t\tdevice_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));\n\tclass_destroy(coda_psdev_class);\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\n\tcoda_sysctl_clean();\nout1:\n\tcoda_destroy_inodecache();\nout2:\n\treturn status;\n}"
  },
  {
    "function_name": "init_coda_psdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "355-380",
    "snippet": "static int init_coda_psdev(void)\n{\n\tint i, err = 0;\n\tif (register_chrdev(CODA_PSDEV_MAJOR, \"coda\", &coda_psdev_fops)) {\n\t\tpr_err(\"%s: unable to get major %d\\n\",\n\t\t       __func__, CODA_PSDEV_MAJOR);\n              return -EIO;\n\t}\n\tcoda_psdev_class = class_create(THIS_MODULE, \"coda\");\n\tif (IS_ERR(coda_psdev_class)) {\n\t\terr = PTR_ERR(coda_psdev_class);\n\t\tgoto out_chrdev;\n\t}\t\t\n\tfor (i = 0; i < MAX_CODADEVS; i++) {\n\t\tmutex_init(&(&coda_comms[i])->vc_mutex);\n\t\tdevice_create(coda_psdev_class, NULL,\n\t\t\t      MKDEV(CODA_PSDEV_MAJOR, i), NULL, \"cfs%d\", i);\n\t}\n\tcoda_sysctl_init();\n\tgoto out;\n\nout_chrdev:\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct venus_comm coda_comms[MAX_CODADEVS];",
      "static struct class *coda_psdev_class;",
      "static const struct file_operations coda_psdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= coda_psdev_read,\n\t.write\t\t= coda_psdev_write,\n\t.poll\t\t= coda_psdev_poll,\n\t.unlocked_ioctl\t= coda_psdev_ioctl,\n\t.open\t\t= coda_psdev_open,\n\t.release\t= coda_psdev_release,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_chrdev",
          "args": [
            "CODA_PSDEV_MAJOR",
            "\"coda\""
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "285-296",
          "snippet": "void unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid unregister_chrdev_region(dev_t from, unsigned count)\n{\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_sysctl_init",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "coda_sysctl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/sysctl.c",
          "lines": "66-68",
          "snippet": "void coda_sysctl_init(void)\n{\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include <linux/sysctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include <linux/sysctl.h>\n\nvoid coda_sysctl_init(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_create",
          "args": [
            "coda_psdev_class",
            "NULL",
            "MKDEV(CODA_PSDEV_MAJOR, i)",
            "NULL",
            "\"cfs%d\"",
            "i"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "CODA_PSDEV_MAJOR",
            "i"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&(&coda_comms[i])->vc_mutex"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "coda_psdev_class"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "coda_psdev_class"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "class_create",
          "args": [
            "THIS_MODULE",
            "\"coda\""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: unable to get major %d\\n\"",
            "__func__",
            "CODA_PSDEV_MAJOR"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_chrdev",
          "args": [
            "CODA_PSDEV_MAJOR",
            "\"coda\"",
            "&coda_psdev_fops"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "register_chrdev_region",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/char_dev.c",
          "lines": "174-197",
          "snippet": "int register_chrdev_region(dev_t from, unsigned count, const char *name)\n{\n\tstruct char_device_struct *cd;\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tcd = __register_chrdev_region(MAJOR(n), MINOR(n),\n\t\t\t       next - n, name);\n\t\tif (IS_ERR(cd))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tto = n;\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n\treturn PTR_ERR(cd);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic struct char_device_struct {\n\tstruct char_device_struct *next;\n\tunsigned int major;\n\tunsigned int baseminor;\n\tint minorct;\n\tchar name[64];\n\tstruct cdev *cdev;\t\t/* will die */\n} *chrdevs[CHRDEV_MAJOR_HASH_SIZE];\n\nint register_chrdev_region(dev_t from, unsigned count, const char *name)\n{\n\tstruct char_device_struct *cd;\n\tdev_t to = from + count;\n\tdev_t n, next;\n\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tif (next > to)\n\t\t\tnext = to;\n\t\tcd = __register_chrdev_region(MAJOR(n), MINOR(n),\n\t\t\t       next - n, name);\n\t\tif (IS_ERR(cd))\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tto = n;\n\tfor (n = from; n < to; n = next) {\n\t\tnext = MKDEV(MAJOR(n)+1, 0);\n\t\tkfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n));\n\t}\n\treturn PTR_ERR(cd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct venus_comm coda_comms[MAX_CODADEVS];\nstatic struct class *coda_psdev_class;\nstatic const struct file_operations coda_psdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= coda_psdev_read,\n\t.write\t\t= coda_psdev_write,\n\t.poll\t\t= coda_psdev_poll,\n\t.unlocked_ioctl\t= coda_psdev_ioctl,\n\t.open\t\t= coda_psdev_open,\n\t.release\t= coda_psdev_release,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int init_coda_psdev(void)\n{\n\tint i, err = 0;\n\tif (register_chrdev(CODA_PSDEV_MAJOR, \"coda\", &coda_psdev_fops)) {\n\t\tpr_err(\"%s: unable to get major %d\\n\",\n\t\t       __func__, CODA_PSDEV_MAJOR);\n              return -EIO;\n\t}\n\tcoda_psdev_class = class_create(THIS_MODULE, \"coda\");\n\tif (IS_ERR(coda_psdev_class)) {\n\t\terr = PTR_ERR(coda_psdev_class);\n\t\tgoto out_chrdev;\n\t}\t\t\n\tfor (i = 0; i < MAX_CODADEVS; i++) {\n\t\tmutex_init(&(&coda_comms[i])->vc_mutex);\n\t\tdevice_create(coda_psdev_class, NULL,\n\t\t\t      MKDEV(CODA_PSDEV_MAJOR, i), NULL, \"cfs%d\", i);\n\t}\n\tcoda_sysctl_init();\n\tgoto out;\n\nout_chrdev:\n\tunregister_chrdev(CODA_PSDEV_MAJOR, \"coda\");\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "coda_psdev_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "304-341",
    "snippet": "static int coda_psdev_release(struct inode * inode, struct file * file)\n{\n\tstruct venus_comm *vcp = (struct venus_comm *) file->private_data;\n\tstruct upc_req *req, *tmp;\n\n\tif (!vcp || !vcp->vc_inuse ) {\n\t\tpr_warn(\"%s: Not open.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\t/* Wakeup clients so they can return. */\n\tlist_for_each_entry_safe(req, tmp, &vcp->vc_pending, uc_chain) {\n\t\tlist_del(&req->uc_chain);\n\n\t\t/* Async requests need to be freed here */\n\t\tif (req->uc_flags & CODA_REQ_ASYNC) {\n\t\t\tCODA_FREE(req->uc_data, sizeof(struct coda_in_hdr));\n\t\t\tkfree(req);\n\t\t\tcontinue;\n\t\t}\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t}\n\n\tlist_for_each_entry_safe(req, tmp, &vcp->vc_processing, uc_chain) {\n\t\tlist_del(&req->uc_chain);\n\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t}\n\n\tfile->private_data = NULL;\n\tvcp->vc_inuse--;\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&req->uc_sleep"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->uc_chain"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "req",
            "tmp",
            "&vcp->vc_processing",
            "uc_chain"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "req->uc_data",
            "sizeof(struct coda_in_hdr)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "req",
            "tmp",
            "&vcp->vc_pending",
            "uc_chain"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Not open.\\n\"",
            "__func__"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int coda_psdev_release(struct inode * inode, struct file * file)\n{\n\tstruct venus_comm *vcp = (struct venus_comm *) file->private_data;\n\tstruct upc_req *req, *tmp;\n\n\tif (!vcp || !vcp->vc_inuse ) {\n\t\tpr_warn(\"%s: Not open.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\t/* Wakeup clients so they can return. */\n\tlist_for_each_entry_safe(req, tmp, &vcp->vc_pending, uc_chain) {\n\t\tlist_del(&req->uc_chain);\n\n\t\t/* Async requests need to be freed here */\n\t\tif (req->uc_flags & CODA_REQ_ASYNC) {\n\t\t\tCODA_FREE(req->uc_data, sizeof(struct coda_in_hdr));\n\t\t\tkfree(req);\n\t\t\tcontinue;\n\t\t}\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t}\n\n\tlist_for_each_entry_safe(req, tmp, &vcp->vc_processing, uc_chain) {\n\t\tlist_del(&req->uc_chain);\n\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t}\n\n\tfile->private_data = NULL;\n\tvcp->vc_inuse--;\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_psdev_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "267-301",
    "snippet": "static int coda_psdev_open(struct inode * inode, struct file * file)\n{\n\tstruct venus_comm *vcp;\n\tint idx, err;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tidx = iminor(inode);\n\tif (idx < 0 || idx >= MAX_CODADEVS)\n\t\treturn -ENODEV;\n\n\terr = -EBUSY;\n\tvcp = &coda_comms[idx];\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tvcp->vc_inuse++;\n\n\t\tINIT_LIST_HEAD(&vcp->vc_pending);\n\t\tINIT_LIST_HEAD(&vcp->vc_processing);\n\t\tinit_waitqueue_head(&vcp->vc_waitq);\n\t\tvcp->vc_sb = NULL;\n\t\tvcp->vc_seq = 0;\n\n\t\tfile->private_data = vcp;\n\t\terr = 0;\n\t}\n\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn err;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct venus_comm coda_comms[MAX_CODADEVS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&vcp->vc_waitq"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vcp->vc_processing"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vcp->vc_pending"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iminor",
          "args": [
            "inode"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct venus_comm coda_comms[MAX_CODADEVS];\n\nstatic int coda_psdev_open(struct inode * inode, struct file * file)\n{\n\tstruct venus_comm *vcp;\n\tint idx, err;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tidx = iminor(inode);\n\tif (idx < 0 || idx >= MAX_CODADEVS)\n\t\treturn -ENODEV;\n\n\terr = -EBUSY;\n\tvcp = &coda_comms[idx];\n\tmutex_lock(&vcp->vc_mutex);\n\n\tif (!vcp->vc_inuse) {\n\t\tvcp->vc_inuse++;\n\n\t\tINIT_LIST_HEAD(&vcp->vc_pending);\n\t\tINIT_LIST_HEAD(&vcp->vc_processing);\n\t\tinit_waitqueue_head(&vcp->vc_waitq);\n\t\tvcp->vc_sb = NULL;\n\t\tvcp->vc_seq = 0;\n\n\t\tfile->private_data = vcp;\n\t\terr = 0;\n\t}\n\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "coda_psdev_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "203-265",
    "snippet": "static ssize_t coda_psdev_read(struct file * file, char __user * buf, \n\t\t\t       size_t nbytes, loff_t *off)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n        struct upc_req *req;\n\tssize_t retval = 0, count = 0;\n\n\tif (nbytes == 0)\n\t\treturn 0;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tadd_wait_queue(&vcp->vc_waitq, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (list_empty(&vcp->vc_pending)) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\tschedule();\n\t\tmutex_lock(&vcp->vc_mutex);\n\t}\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&vcp->vc_waitq, &wait);\n\n\tif (retval)\n\t\tgoto out;\n\n\treq = list_entry(vcp->vc_pending.next, struct upc_req,uc_chain);\n\tlist_del(&req->uc_chain);\n\n\t/* Move the input args into userspace */\n\tcount = req->uc_inSize;\n\tif (nbytes < req->uc_inSize) {\n\t\tpr_warn(\"%s: Venus read %ld bytes of %d in message\\n\",\n\t\t\t__func__, (long)nbytes, req->uc_inSize);\n\t\tcount = nbytes;\n        }\n\n\tif (copy_to_user(buf, req->uc_data, count))\n\t        retval = -EFAULT;\n        \n\t/* If request was not a signal, enqueue and don't free */\n\tif (!(req->uc_flags & CODA_REQ_ASYNC)) {\n\t\treq->uc_flags |= CODA_REQ_READ;\n\t\tlist_add_tail(&(req->uc_chain), &vcp->vc_processing);\n\t\tgoto out;\n\t}\n\n\tCODA_FREE(req->uc_data, sizeof(struct coda_in_hdr));\n\tkfree(req);\nout:\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn (count ? count : retval);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "req"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "req->uc_data",
            "sizeof(struct coda_in_hdr)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&(req->uc_chain)",
            "&vcp->vc_processing"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "req->uc_data",
            "count"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Venus read %ld bytes of %d in message\\n\"",
            "__func__",
            "(long)nbytes",
            "req->uc_inSize"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->uc_chain"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "vcp->vc_pending.next",
            "structupc_req",
            "uc_chain"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&vcp->vc_waitq",
            "&wait"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vcp->vc_pending"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&vcp->vc_waitq",
            "&wait"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t coda_psdev_read(struct file * file, char __user * buf, \n\t\t\t       size_t nbytes, loff_t *off)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n        struct upc_req *req;\n\tssize_t retval = 0, count = 0;\n\n\tif (nbytes == 0)\n\t\treturn 0;\n\n\tmutex_lock(&vcp->vc_mutex);\n\n\tadd_wait_queue(&vcp->vc_waitq, &wait);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\twhile (list_empty(&vcp->vc_pending)) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&vcp->vc_mutex);\n\t\tschedule();\n\t\tmutex_lock(&vcp->vc_mutex);\n\t}\n\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&vcp->vc_waitq, &wait);\n\n\tif (retval)\n\t\tgoto out;\n\n\treq = list_entry(vcp->vc_pending.next, struct upc_req,uc_chain);\n\tlist_del(&req->uc_chain);\n\n\t/* Move the input args into userspace */\n\tcount = req->uc_inSize;\n\tif (nbytes < req->uc_inSize) {\n\t\tpr_warn(\"%s: Venus read %ld bytes of %d in message\\n\",\n\t\t\t__func__, (long)nbytes, req->uc_inSize);\n\t\tcount = nbytes;\n        }\n\n\tif (copy_to_user(buf, req->uc_data, count))\n\t        retval = -EFAULT;\n        \n\t/* If request was not a signal, enqueue and don't free */\n\tif (!(req->uc_flags & CODA_REQ_ASYNC)) {\n\t\treq->uc_flags |= CODA_REQ_READ;\n\t\tlist_add_tail(&(req->uc_chain), &vcp->vc_processing);\n\t\tgoto out;\n\t}\n\n\tCODA_FREE(req->uc_data, sizeof(struct coda_in_hdr));\n\tkfree(req);\nout:\n\tmutex_unlock(&vcp->vc_mutex);\n\treturn (count ? count : retval);\n}"
  },
  {
    "function_name": "coda_psdev_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "97-197",
    "snippet": "static ssize_t coda_psdev_write(struct file *file, const char __user *buf, \n\t\t\t\tsize_t nbytes, loff_t *off)\n{\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n        struct upc_req *req = NULL;\n        struct upc_req *tmp;\n\tstruct list_head *lh;\n\tstruct coda_in_hdr hdr;\n\tssize_t retval = 0, count = 0;\n\tint error;\n\n        /* Peek at the opcode, uniquefier */\n\tif (copy_from_user(&hdr, buf, 2 * sizeof(u_long)))\n\t        return -EFAULT;\n\n        if (DOWNCALL(hdr.opcode)) {\n\t\tunion outputArgs *dcbuf;\n\t\tint size = sizeof(*dcbuf);\n\n\t\tif  ( nbytes < sizeof(struct coda_out_hdr) ) {\n\t\t\tpr_warn(\"coda_downcall opc %d uniq %d, not enough!\\n\",\n\t\t\t\thdr.opcode, hdr.unique);\n\t\t\tcount = nbytes;\n\t\t\tgoto out;\n\t\t}\n\t\tif ( nbytes > size ) {\n\t\t\tpr_warn(\"downcall opc %d, uniq %d, too much!\",\n\t\t\t\thdr.opcode, hdr.unique);\n\t\t        nbytes = size;\n\t\t}\n\t\tCODA_ALLOC(dcbuf, union outputArgs *, nbytes);\n\t\tif (copy_from_user(dcbuf, buf, nbytes)) {\n\t\t\tCODA_FREE(dcbuf, nbytes);\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* what downcall errors does Venus handle ? */\n\t\terror = coda_downcall(vcp, hdr.opcode, dcbuf);\n\n\t\tCODA_FREE(dcbuf, nbytes);\n\t\tif (error) {\n\t\t\tpr_warn(\"%s: coda_downcall error: %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\tretval = error;\n\t\t\tgoto out;\n\t\t}\n\t\tcount = nbytes;\n\t\tgoto out;\n\t}\n        \n\t/* Look for the message on the processing queue. */\n\tmutex_lock(&vcp->vc_mutex);\n\tlist_for_each(lh, &vcp->vc_processing) {\n\t\ttmp = list_entry(lh, struct upc_req , uc_chain);\n\t\tif (tmp->uc_unique == hdr.unique) {\n\t\t\treq = tmp;\n\t\t\tlist_del(&req->uc_chain);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcp->vc_mutex);\n\n\tif (!req) {\n\t\tpr_warn(\"%s: msg (%d, %d) not found\\n\",\n\t\t\t__func__, hdr.opcode, hdr.unique);\n\t\tretval = -ESRCH;\n\t\tgoto out;\n\t}\n\n        /* move data into response buffer. */\n\tif (req->uc_outSize < nbytes) {\n\t\tpr_warn(\"%s: too much cnt: %d, cnt: %ld, opc: %d, uniq: %d.\\n\",\n\t\t\t__func__, req->uc_outSize, (long)nbytes,\n\t\t\thdr.opcode, hdr.unique);\n\t\tnbytes = req->uc_outSize; /* don't have more space! */\n\t}\n        if (copy_from_user(req->uc_data, buf, nbytes)) {\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* adjust outsize. is this useful ?? */\n\treq->uc_outSize = nbytes;\n\treq->uc_flags |= CODA_REQ_WRITE;\n\tcount = nbytes;\n\n\t/* Convert filedescriptor into a file handle */\n\tif (req->uc_opcode == CODA_OPEN_BY_FD) {\n\t\tstruct coda_open_by_fd_out *outp =\n\t\t\t(struct coda_open_by_fd_out *)req->uc_data;\n\t\tif (!outp->oh.result)\n\t\t\toutp->fh = fget(outp->fd);\n\t}\n\n        wake_up(&req->uc_sleep);\nout:\n        return(count ? count : retval);  \n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&req->uc_sleep"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget",
          "args": [
            "outp->fd"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "656-659",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "req->uc_data",
            "buf",
            "nbytes"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: too much cnt: %d, cnt: %ld, opc: %d, uniq: %d.\\n\"",
            "__func__",
            "req->uc_outSize",
            "(long)nbytes",
            "hdr.opcode",
            "hdr.unique"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: msg (%d, %d) not found\\n\"",
            "__func__",
            "hdr.opcode",
            "hdr.unique"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&req->uc_chain"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "lh",
            "structupc_req",
            "uc_chain"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "lh",
            "&vcp->vc_processing"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: coda_downcall error: %d\\n\"",
            "__func__",
            "error"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "dcbuf",
            "nbytes"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_downcall",
          "args": [
            "vcp",
            "hdr.opcode",
            "dcbuf"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "coda_downcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "807-881",
          "snippet": "int coda_downcall(struct venus_comm *vcp, int opcode, union outputArgs *out)\n{\n\tstruct inode *inode = NULL;\n\tstruct CodaFid *fid = NULL, *newfid;\n\tstruct super_block *sb;\n\n\t/* Handle invalidation requests. */\n\tmutex_lock(&vcp->vc_mutex);\n\tsb = vcp->vc_sb;\n\tif (!sb || !sb->s_root)\n\t\tgoto unlock_out;\n\n\tswitch (opcode) {\n\tcase CODA_FLUSH:\n\t\tcoda_cache_clear_all(sb);\n\t\tshrink_dcache_sb(sb);\n\t\tif (sb->s_root->d_inode)\n\t\t\tcoda_flag_inode(sb->s_root->d_inode, C_FLUSH);\n\t\tbreak;\n\n\tcase CODA_PURGEUSER:\n\t\tcoda_cache_clear_all(sb);\n\t\tbreak;\n\n\tcase CODA_ZAPDIR:\n\t\tfid = &out->coda_zapdir.CodaFid;\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tfid = &out->coda_zapfile.CodaFid;\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tfid = &out->coda_purgefid.CodaFid;\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tfid = &out->coda_replace.OldFid;\n\t\tbreak;\n\t}\n\tif (fid)\n\t\tinode = coda_fid_to_inode(fid, sb);\n\nunlock_out:\n\tmutex_unlock(&vcp->vc_mutex);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tswitch (opcode) {\n\tcase CODA_ZAPDIR:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\n\t\t/* catch the dentries later if some are still busy */\n\t\tcoda_flag_inode(inode, C_PURGE);\n\t\td_prune_aliases(inode);\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tnewfid = &out->coda_replace.NewFid;\n\t\tcoda_replace_fid(inode, fid, newfid);\n\t\tbreak;\n\t}\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint coda_downcall(struct venus_comm *vcp, int opcode, union outputArgs *out)\n{\n\tstruct inode *inode = NULL;\n\tstruct CodaFid *fid = NULL, *newfid;\n\tstruct super_block *sb;\n\n\t/* Handle invalidation requests. */\n\tmutex_lock(&vcp->vc_mutex);\n\tsb = vcp->vc_sb;\n\tif (!sb || !sb->s_root)\n\t\tgoto unlock_out;\n\n\tswitch (opcode) {\n\tcase CODA_FLUSH:\n\t\tcoda_cache_clear_all(sb);\n\t\tshrink_dcache_sb(sb);\n\t\tif (sb->s_root->d_inode)\n\t\t\tcoda_flag_inode(sb->s_root->d_inode, C_FLUSH);\n\t\tbreak;\n\n\tcase CODA_PURGEUSER:\n\t\tcoda_cache_clear_all(sb);\n\t\tbreak;\n\n\tcase CODA_ZAPDIR:\n\t\tfid = &out->coda_zapdir.CodaFid;\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tfid = &out->coda_zapfile.CodaFid;\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tfid = &out->coda_purgefid.CodaFid;\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tfid = &out->coda_replace.OldFid;\n\t\tbreak;\n\t}\n\tif (fid)\n\t\tinode = coda_fid_to_inode(fid, sb);\n\nunlock_out:\n\tmutex_unlock(&vcp->vc_mutex);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tswitch (opcode) {\n\tcase CODA_ZAPDIR:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_ZAPFILE:\n\t\tcoda_flag_inode(inode, C_VATTR);\n\t\tbreak;\n\n\tcase CODA_PURGEFID:\n\t\tcoda_flag_inode_children(inode, C_PURGE);\n\n\t\t/* catch the dentries later if some are still busy */\n\t\tcoda_flag_inode(inode, C_PURGE);\n\t\td_prune_aliases(inode);\n\t\tbreak;\n\n\tcase CODA_REPLACE:\n\t\tnewfid = &out->coda_replace.NewFid;\n\t\tcoda_replace_fid(inode, fid, newfid);\n\t\tbreak;\n\t}\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CODA_FREE",
          "args": [
            "dcbuf",
            "nbytes"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_ALLOC",
          "args": [
            "dcbuf",
            "unionoutputArgs*",
            "nbytes"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"downcall opc %d, uniq %d, too much!\"",
            "hdr.opcode",
            "hdr.unique"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"coda_downcall opc %d uniq %d, not enough!\\n\"",
            "hdr.opcode",
            "hdr.unique"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DOWNCALL",
          "args": [
            "hdr.opcode"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic ssize_t coda_psdev_write(struct file *file, const char __user *buf, \n\t\t\t\tsize_t nbytes, loff_t *off)\n{\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n        struct upc_req *req = NULL;\n        struct upc_req *tmp;\n\tstruct list_head *lh;\n\tstruct coda_in_hdr hdr;\n\tssize_t retval = 0, count = 0;\n\tint error;\n\n        /* Peek at the opcode, uniquefier */\n\tif (copy_from_user(&hdr, buf, 2 * sizeof(u_long)))\n\t        return -EFAULT;\n\n        if (DOWNCALL(hdr.opcode)) {\n\t\tunion outputArgs *dcbuf;\n\t\tint size = sizeof(*dcbuf);\n\n\t\tif  ( nbytes < sizeof(struct coda_out_hdr) ) {\n\t\t\tpr_warn(\"coda_downcall opc %d uniq %d, not enough!\\n\",\n\t\t\t\thdr.opcode, hdr.unique);\n\t\t\tcount = nbytes;\n\t\t\tgoto out;\n\t\t}\n\t\tif ( nbytes > size ) {\n\t\t\tpr_warn(\"downcall opc %d, uniq %d, too much!\",\n\t\t\t\thdr.opcode, hdr.unique);\n\t\t        nbytes = size;\n\t\t}\n\t\tCODA_ALLOC(dcbuf, union outputArgs *, nbytes);\n\t\tif (copy_from_user(dcbuf, buf, nbytes)) {\n\t\t\tCODA_FREE(dcbuf, nbytes);\n\t\t\tretval = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* what downcall errors does Venus handle ? */\n\t\terror = coda_downcall(vcp, hdr.opcode, dcbuf);\n\n\t\tCODA_FREE(dcbuf, nbytes);\n\t\tif (error) {\n\t\t\tpr_warn(\"%s: coda_downcall error: %d\\n\",\n\t\t\t\t__func__, error);\n\t\t\tretval = error;\n\t\t\tgoto out;\n\t\t}\n\t\tcount = nbytes;\n\t\tgoto out;\n\t}\n        \n\t/* Look for the message on the processing queue. */\n\tmutex_lock(&vcp->vc_mutex);\n\tlist_for_each(lh, &vcp->vc_processing) {\n\t\ttmp = list_entry(lh, struct upc_req , uc_chain);\n\t\tif (tmp->uc_unique == hdr.unique) {\n\t\t\treq = tmp;\n\t\t\tlist_del(&req->uc_chain);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcp->vc_mutex);\n\n\tif (!req) {\n\t\tpr_warn(\"%s: msg (%d, %d) not found\\n\",\n\t\t\t__func__, hdr.opcode, hdr.unique);\n\t\tretval = -ESRCH;\n\t\tgoto out;\n\t}\n\n        /* move data into response buffer. */\n\tif (req->uc_outSize < nbytes) {\n\t\tpr_warn(\"%s: too much cnt: %d, cnt: %ld, opc: %d, uniq: %d.\\n\",\n\t\t\t__func__, req->uc_outSize, (long)nbytes,\n\t\t\thdr.opcode, hdr.unique);\n\t\tnbytes = req->uc_outSize; /* don't have more space! */\n\t}\n        if (copy_from_user(req->uc_data, buf, nbytes)) {\n\t\treq->uc_flags |= CODA_REQ_ABORT;\n\t\twake_up(&req->uc_sleep);\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/* adjust outsize. is this useful ?? */\n\treq->uc_outSize = nbytes;\n\treq->uc_flags |= CODA_REQ_WRITE;\n\tcount = nbytes;\n\n\t/* Convert filedescriptor into a file handle */\n\tif (req->uc_opcode == CODA_OPEN_BY_FD) {\n\t\tstruct coda_open_by_fd_out *outp =\n\t\t\t(struct coda_open_by_fd_out *)req->uc_data;\n\t\tif (!outp->oh.result)\n\t\t\toutp->fh = fget(outp->fd);\n\t}\n\n        wake_up(&req->uc_sleep);\nout:\n        return(count ? count : retval);  \n}"
  },
  {
    "function_name": "coda_psdev_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "78-91",
    "snippet": "static long coda_psdev_ioctl(struct file * filp, unsigned int cmd, unsigned long arg)\n{\n\tunsigned int data;\n\n\tswitch(cmd) {\n\tcase CIOC_KERNEL_VERSION:\n\t\tdata = CODA_KERNEL_VERSION;\n\t\treturn put_user(data, (int __user *) arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "data",
            "(int __user *) arg"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic long coda_psdev_ioctl(struct file * filp, unsigned int cmd, unsigned long arg)\n{\n\tunsigned int data;\n\n\tswitch(cmd) {\n\tcase CIOC_KERNEL_VERSION:\n\t\tdata = CODA_KERNEL_VERSION;\n\t\treturn put_user(data, (int __user *) arg);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_psdev_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/psdev.c",
    "lines": "64-76",
    "snippet": "static unsigned int coda_psdev_poll(struct file *file, poll_table * wait)\n{\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n\tunsigned int mask = POLLOUT | POLLWRNORM;\n\n\tpoll_wait(file, &vcp->vc_waitq, wait);\n\tmutex_lock(&vcp->vc_mutex);\n\tif (!list_empty(&vcp->vc_pending))\n                mask |= POLLIN | POLLRDNORM;\n\tmutex_unlock(&vcp->vc_mutex);\n\n\treturn mask;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/poll.h>",
      "#include <asm/io.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/list.h>",
      "#include <linux/init.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/delay.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/ioport.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/time.h>",
      "#include <linux/major.h>",
      "#include <linux/kernel.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&vcp->vc_pending"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcp->vc_mutex"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&vcp->vc_waitq",
            "wait"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <asm/poll.h>\n#include <asm/io.h>\n#include <linux/pid_namespace.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/fcntl.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/major.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic unsigned int coda_psdev_poll(struct file *file, poll_table * wait)\n{\n        struct venus_comm *vcp = (struct venus_comm *) file->private_data;\n\tunsigned int mask = POLLOUT | POLLWRNORM;\n\n\tpoll_wait(file, &vcp->vc_waitq, wait);\n\tmutex_lock(&vcp->vc_mutex);\n\tif (!list_empty(&vcp->vc_pending))\n                mask |= POLLIN | POLLRDNORM;\n\tmutex_unlock(&vcp->vc_mutex);\n\n\treturn mask;\n}"
  }
]